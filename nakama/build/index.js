import require$$1 from 'http';
import require$$2 from 'https';
import require$$3 from 'zlib';
import require$$5, { createHmac } from 'crypto';
import require$$0$3 from 'events';
import require$$3$1 from 'net';
import require$$4 from 'tls';
import require$$0$2 from 'stream';
import require$$7 from 'url';
import require$$0$1 from 'buffer';

function _arrayLikeToArray(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
function _arrayWithHoles(r) {
  if (Array.isArray(r)) return r;
}
function _arrayWithoutHoles(r) {
  if (Array.isArray(r)) return _arrayLikeToArray(r);
}
function _assertClassBrand(e, t, n) {
  if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;
  throw new TypeError("Private element is not present on this object");
}
function _assertThisInitialized(e) {
  if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function asyncGeneratorStep(n, t, e, r, o, a, c) {
  try {
    var i = n[a](c),
      u = i.value;
  } catch (n) {
    return void e(n);
  }
  i.done ? t(u) : Promise.resolve(u).then(r, o);
}
function _asyncToGenerator(n) {
  return function () {
    var t = this,
      e = arguments;
    return new Promise(function (r, o) {
      var a = n.apply(t, e);
      function _next(n) {
        asyncGeneratorStep(a, r, o, _next, _throw, "next", n);
      }
      function _throw(n) {
        asyncGeneratorStep(a, r, o, _next, _throw, "throw", n);
      }
      _next(void 0);
    });
  };
}
function _callSuper(t, o, e) {
  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
}
function _checkPrivateRedeclaration(e, t) {
  if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object");
}
function _classCallCheck(a, n) {
  if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}
function _classPrivateFieldGet2(s, a) {
  return s.get(_assertClassBrand(s, a));
}
function _classPrivateFieldInitSpec(e, t, a) {
  _checkPrivateRedeclaration(e, t), t.set(e, a);
}
function _classPrivateFieldSet2(s, a, r) {
  return s.set(_assertClassBrand(s, a), r), r;
}
function _classPrivateMethodInitSpec(e, a) {
  _checkPrivateRedeclaration(e, a), a.add(e);
}
function _construct(t, e, r) {
  if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments);
  var o = [null];
  o.push.apply(o, e);
  var p = new (t.bind.apply(t, o))();
  return r && _setPrototypeOf(p, r.prototype), p;
}
function _defineProperties(e, r) {
  for (var t = 0; t < r.length; t++) {
    var o = r[t];
    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);
  }
}
function _createClass(e, r, t) {
  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}
function _createForOfIteratorHelper(r, e) {
  var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (!t) {
    if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e) {
      t && (r = t);
      var n = 0,
        F = function () {};
      return {
        s: F,
        n: function () {
          return n >= r.length ? {
            done: !0
          } : {
            done: !1,
            value: r[n++]
          };
        },
        e: function (r) {
          throw r;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var o,
    a = !0,
    u = !1;
  return {
    s: function () {
      t = t.call(r);
    },
    n: function () {
      var r = t.next();
      return a = r.done, r;
    },
    e: function (r) {
      u = !0, o = r;
    },
    f: function () {
      try {
        a || null == t.return || t.return();
      } finally {
        if (u) throw o;
      }
    }
  };
}
function _defineProperty(e, r, t) {
  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[r] = t, e;
}
function _get() {
  return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) {
    var p = _superPropBase(e, t);
    if (p) {
      var n = Object.getOwnPropertyDescriptor(p, t);
      return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value;
    }
  }, _get.apply(null, arguments);
}
function _getPrototypeOf(t) {
  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, _getPrototypeOf(t);
}
function _inherits(t, e) {
  if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
  t.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: t,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(t, "prototype", {
    writable: !1
  }), e && _setPrototypeOf(t, e);
}
function _isNativeFunction(t) {
  try {
    return -1 !== Function.toString.call(t).indexOf("[native code]");
  } catch (n) {
    return "function" == typeof t;
  }
}
function _isNativeReflectConstruct() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
  } catch (t) {}
  return (_isNativeReflectConstruct = function () {
    return !!t;
  })();
}
function _iterableToArray(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
function _iterableToArrayLimit(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e,
      n,
      i,
      u,
      a = [],
      f = !0,
      o = !1;
    try {
      if (i = (t = t.call(r)).next, 0 === l) {
        if (Object(t) !== t) return;
        f = !1;
      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);
    } catch (r) {
      o = !0, n = r;
    } finally {
      try {
        if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function (r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread2(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {
      _defineProperty(e, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return e;
}
function _possibleConstructorReturn(t, e) {
  if (e && ("object" == typeof e || "function" == typeof e)) return e;
  if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
  return _assertThisInitialized(t);
}
function _regeneratorRuntime() {
  _regeneratorRuntime = function () {
    return e;
  };
  var t,
    e = {},
    r = Object.prototype,
    n = r.hasOwnProperty,
    o = Object.defineProperty || function (t, e, r) {
      t[e] = r.value;
    },
    i = "function" == typeof Symbol ? Symbol : {},
    a = i.iterator || "@@iterator",
    c = i.asyncIterator || "@@asyncIterator",
    u = i.toStringTag || "@@toStringTag";
  function define(t, e, r) {
    return Object.defineProperty(t, e, {
      value: r,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), t[e];
  }
  try {
    define({}, "");
  } catch (t) {
    define = function (t, e, r) {
      return t[e] = r;
    };
  }
  function wrap(t, e, r, n) {
    var i = e && e.prototype instanceof Generator ? e : Generator,
      a = Object.create(i.prototype),
      c = new Context(n || []);
    return o(a, "_invoke", {
      value: makeInvokeMethod(t, r, c)
    }), a;
  }
  function tryCatch(t, e, r) {
    try {
      return {
        type: "normal",
        arg: t.call(e, r)
      };
    } catch (t) {
      return {
        type: "throw",
        arg: t
      };
    }
  }
  e.wrap = wrap;
  var h = "suspendedStart",
    l = "suspendedYield",
    f = "executing",
    s = "completed",
    y = {};
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  var p = {};
  define(p, a, function () {
    return this;
  });
  var d = Object.getPrototypeOf,
    v = d && d(d(values([])));
  v && v !== r && n.call(v, a) && (p = v);
  var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
  function defineIteratorMethods(t) {
    ["next", "throw", "return"].forEach(function (e) {
      define(t, e, function (t) {
        return this._invoke(e, t);
      });
    });
  }
  function AsyncIterator(t, e) {
    function invoke(r, o, i, a) {
      var c = tryCatch(t[r], t, o);
      if ("throw" !== c.type) {
        var u = c.arg,
          h = u.value;
        return h && "object" == typeof h && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) {
          invoke("next", t, i, a);
        }, function (t) {
          invoke("throw", t, i, a);
        }) : e.resolve(h).then(function (t) {
          u.value = t, i(u);
        }, function (t) {
          return invoke("throw", t, i, a);
        });
      }
      a(c.arg);
    }
    var r;
    o(this, "_invoke", {
      value: function (t, n) {
        function callInvokeWithMethodAndArg() {
          return new e(function (e, r) {
            invoke(t, n, e, r);
          });
        }
        return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(e, r, n) {
    var o = h;
    return function (i, a) {
      if (o === f) throw Error("Generator is already running");
      if (o === s) {
        if ("throw" === i) throw a;
        return {
          value: t,
          done: !0
        };
      }
      for (n.method = i, n.arg = a;;) {
        var c = n.delegate;
        if (c) {
          var u = maybeInvokeDelegate(c, n);
          if (u) {
            if (u === y) continue;
            return u;
          }
        }
        if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) {
          if (o === h) throw o = s, n.arg;
          n.dispatchException(n.arg);
        } else "return" === n.method && n.abrupt("return", n.arg);
        o = f;
        var p = tryCatch(e, r, n);
        if ("normal" === p.type) {
          if (o = n.done ? s : l, p.arg === y) continue;
          return {
            value: p.arg,
            done: n.done
          };
        }
        "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg);
      }
    };
  }
  function maybeInvokeDelegate(e, r) {
    var n = r.method,
      o = e.iterator[n];
    if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y;
    var i = tryCatch(o, e.iterator, r.arg);
    if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y;
    var a = i.arg;
    return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y);
  }
  function pushTryEntry(t) {
    var e = {
      tryLoc: t[0]
    };
    1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);
  }
  function resetTryEntry(t) {
    var e = t.completion || {};
    e.type = "normal", delete e.arg, t.completion = e;
  }
  function Context(t) {
    this.tryEntries = [{
      tryLoc: "root"
    }], t.forEach(pushTryEntry, this), this.reset(!0);
  }
  function values(e) {
    if (e || "" === e) {
      var r = e[a];
      if (r) return r.call(e);
      if ("function" == typeof e.next) return e;
      if (!isNaN(e.length)) {
        var o = -1,
          i = function next() {
            for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next;
            return next.value = t, next.done = !0, next;
          };
        return i.next = i;
      }
    }
    throw new TypeError(typeof e + " is not iterable");
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: !0
  }), o(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: !0
  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) {
    var e = "function" == typeof t && t.constructor;
    return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name));
  }, e.mark = function (t) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t;
  }, e.awrap = function (t) {
    return {
      __await: t
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () {
    return this;
  }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) {
    void 0 === i && (i = Promise);
    var a = new AsyncIterator(wrap(t, r, n, o), i);
    return e.isGeneratorFunction(r) ? a : a.next().then(function (t) {
      return t.done ? t.value : a.next();
    });
  }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () {
    return this;
  }), define(g, "toString", function () {
    return "[object Generator]";
  }), e.keys = function (t) {
    var e = Object(t),
      r = [];
    for (var n in e) r.push(n);
    return r.reverse(), function next() {
      for (; r.length;) {
        var t = r.pop();
        if (t in e) return next.value = t, next.done = !1, next;
      }
      return next.done = !0, next;
    };
  }, e.values = values, Context.prototype = {
    constructor: Context,
    reset: function (e) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t);
    },
    stop: function () {
      this.done = !0;
      var t = this.tryEntries[0].completion;
      if ("throw" === t.type) throw t.arg;
      return this.rval;
    },
    dispatchException: function (e) {
      if (this.done) throw e;
      var r = this;
      function handle(n, o) {
        return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o;
      }
      for (var o = this.tryEntries.length - 1; o >= 0; --o) {
        var i = this.tryEntries[o],
          a = i.completion;
        if ("root" === i.tryLoc) return handle("end");
        if (i.tryLoc <= this.prev) {
          var c = n.call(i, "catchLoc"),
            u = n.call(i, "finallyLoc");
          if (c && u) {
            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
          } else if (c) {
            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
          } else {
            if (!u) throw Error("try statement without catch or finally");
            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
          }
        }
      }
    },
    abrupt: function (t, e) {
      for (var r = this.tryEntries.length - 1; r >= 0; --r) {
        var o = this.tryEntries[r];
        if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) {
          var i = o;
          break;
        }
      }
      i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null);
      var a = i ? i.completion : {};
      return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a);
    },
    complete: function (t, e) {
      if ("throw" === t.type) throw t.arg;
      return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y;
    },
    finish: function (t) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var r = this.tryEntries[e];
        if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y;
      }
    },
    catch: function (t) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var r = this.tryEntries[e];
        if (r.tryLoc === t) {
          var n = r.completion;
          if ("throw" === n.type) {
            var o = n.arg;
            resetTryEntry(r);
          }
          return o;
        }
      }
      throw Error("illegal catch attempt");
    },
    delegateYield: function (e, r, n) {
      return this.delegate = {
        iterator: values(e),
        resultName: r,
        nextLoc: n
      }, "next" === this.method && (this.arg = t), y;
    }
  }, e;
}
function _setPrototypeOf(t, e) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
    return t.__proto__ = e, t;
  }, _setPrototypeOf(t, e);
}
function _slicedToArray(r, e) {
  return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();
}
function _superPropBase(t, o) {
  for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t)););
  return t;
}
function _superPropGet(t, o, e, r) {
  var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e);
  return 2 & r && "function" == typeof p ? function (t) {
    return p.apply(e, t);
  } : p;
}
function _toArray(r) {
  return _arrayWithHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableRest();
}
function _toConsumableArray(r) {
  return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();
}
function _toPrimitive(t, r) {
  if ("object" != typeof t || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}
function _unsupportedIterableToArray(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
  }
}
function _wrapNativeSuper(t) {
  var r = "function" == typeof Map ? new Map() : void 0;
  return _wrapNativeSuper = function (t) {
    if (null === t || !_isNativeFunction(t)) return t;
    if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function");
    if (void 0 !== r) {
      if (r.has(t)) return r.get(t);
      r.set(t, Wrapper);
    }
    function Wrapper() {
      return _construct(t, arguments, _getPrototypeOf(this).constructor);
    }
    return Wrapper.prototype = Object.create(t.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }), _setPrototypeOf(Wrapper, t);
  }, _wrapNativeSuper(t);
}

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function getAugmentedNamespace(n) {
  if (n.__esModule) return n;
  var f = n.default;
	if (typeof f == "function") {
		var a = function a () {
			if (this instanceof a) {
        return Reflect.construct(f, arguments, this.constructor);
			}
			return f.apply(this, arguments);
		};
		a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, '__esModule', {value: true});
	Object.keys(n).forEach(function (k) {
		var d = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d.get ? d : {
			enumerable: true,
			get: function () {
				return n[k];
			}
		});
	});
	return a;
}

var ethers = {};

var _version = {};

var hasRequired_version;
function require_version() {
  if (hasRequired_version) return _version;
  hasRequired_version = 1;
  /* Do NOT modify this file; see /src.ts/_admin/update-version.ts */
  Object.defineProperty(_version, "__esModule", {
    value: true
  });
  _version.version = void 0;
  /**
   *  The current version of Ethers.
   */
  _version.version = "6.13.4";
  return _version;
}

var abi = {};

var abiCoder = {};

var utils$3 = {};

var base58 = {};

var data = {};

var errors = {};

var properties = {};

var hasRequiredProperties;
function requireProperties() {
  if (hasRequiredProperties) return properties;
  hasRequiredProperties = 1;
  /**
   *  Property helper functions.
   *
   *  @_subsection api/utils:Properties  [about-properties]
   */
  Object.defineProperty(properties, "__esModule", {
    value: true
  });
  properties.defineProperties = properties.resolveProperties = void 0;
  function checkType(value, type, name) {
    var types = type.split("|").map(function (t) {
      return t.trim();
    });
    for (var i = 0; i < types.length; i++) {
      switch (type) {
        case "any":
          return;
        case "bigint":
        case "boolean":
        case "number":
        case "string":
          if (_typeof(value) === type) {
            return;
          }
      }
    }
    var error = new Error("invalid value for type ".concat(type));
    error.code = "INVALID_ARGUMENT";
    error.argument = "value.".concat(name);
    error.value = value;
    throw error;
  }
  /**
   *  Resolves to a new object that is a copy of %%value%%, but with all
   *  values resolved.
   */
  function resolveProperties(_x) {
    return _resolveProperties.apply(this, arguments);
  }
  function _resolveProperties() {
    _resolveProperties = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(value) {
      var keys, results;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            keys = Object.keys(value);
            _context.next = 3;
            return Promise.all(keys.map(function (k) {
              return Promise.resolve(value[k]);
            }));
          case 3:
            results = _context.sent;
            return _context.abrupt("return", results.reduce(function (accum, v, index) {
              accum[keys[index]] = v;
              return accum;
            }, {}));
          case 5:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    return _resolveProperties.apply(this, arguments);
  }
  properties.resolveProperties = resolveProperties;
  /**
   *  Assigns the %%values%% to %%target%% as read-only values.
   *
   *  It %%types%% is specified, the values are checked.
   */
  function defineProperties(target, values, types) {
    for (var key in values) {
      var value = values[key];
      var type = types ? types[key] : null;
      if (type) {
        checkType(value, type, key);
      }
      Object.defineProperty(target, key, {
        enumerable: true,
        value: value,
        writable: false
      });
    }
  }
  properties.defineProperties = defineProperties;
  return properties;
}

var hasRequiredErrors;
function requireErrors() {
  if (hasRequiredErrors) return errors;
  hasRequiredErrors = 1;
  /**
   *  All errors in ethers include properties to ensure they are both
   *  human-readable (i.e. ``.message``) and machine-readable (i.e. ``.code``).
   *
   *  The [[isError]] function can be used to check the error ``code`` and
   *  provide a type guard for the properties present on that error interface.
   *
   *  @_section: api/utils/errors:Errors  [about-errors]
   */
  Object.defineProperty(errors, "__esModule", {
    value: true
  });
  errors.assertPrivate = errors.assertNormalize = errors.assertArgumentCount = errors.assertArgument = errors.assert = errors.makeError = errors.isCallException = errors.isError = void 0;
  var _version_js_1 = /*@__PURE__*/require_version();
  var properties_js_1 = /*@__PURE__*/requireProperties();
  function stringify(value) {
    if (value == null) {
      return "null";
    }
    if (Array.isArray(value)) {
      return "[ " + value.map(stringify).join(", ") + " ]";
    }
    if (value instanceof Uint8Array) {
      var HEX = "0123456789abcdef";
      var result = "0x";
      for (var i = 0; i < value.length; i++) {
        result += HEX[value[i] >> 4];
        result += HEX[value[i] & 0xf];
      }
      return result;
    }
    if (_typeof(value) === "object" && typeof value.toJSON === "function") {
      return stringify(value.toJSON());
    }
    switch (_typeof(value)) {
      case "boolean":
      case "symbol":
        return value.toString();
      case "bigint":
        return BigInt(value).toString();
      case "number":
        return value.toString();
      case "string":
        return JSON.stringify(value);
      case "object":
        {
          var keys = Object.keys(value);
          keys.sort();
          return "{ " + keys.map(function (k) {
            return "".concat(stringify(k), ": ").concat(stringify(value[k]));
          }).join(", ") + " }";
        }
    }
    return "[ COULD NOT SERIALIZE ]";
  }
  /**
   *  Returns true if the %%error%% matches an error thrown by ethers
   *  that matches the error %%code%%.
   *
   *  In TypeScript environments, this can be used to check that %%error%%
   *  matches an EthersError type, which means the expected properties will
   *  be set.
   *
   *  @See [ErrorCodes](api:ErrorCode)
   *  @example
   *    try {
   *      // code....
   *    } catch (e) {
   *      if (isError(e, "CALL_EXCEPTION")) {
   *          // The Type Guard has validated this object
   *          console.log(e.data);
   *      }
   *    }
   */
  function isError(error, code) {
    return error && error.code === code;
  }
  errors.isError = isError;
  /**
   *  Returns true if %%error%% is a [[CallExceptionError].
   */
  function isCallException(error) {
    return isError(error, "CALL_EXCEPTION");
  }
  errors.isCallException = isCallException;
  /**
   *  Returns a new Error configured to the format ethers emits errors, with
   *  the %%message%%, [[api:ErrorCode]] %%code%% and additional properties
   *  for the corresponding EthersError.
   *
   *  Each error in ethers includes the version of ethers, a
   *  machine-readable [[ErrorCode]], and depending on %%code%%, additional
   *  required properties. The error message will also include the %%message%%,
   *  ethers version, %%code%% and all additional properties, serialized.
   */
  function makeError(message, code, info) {
    var shortMessage = message;
    {
      var details = [];
      if (info) {
        if ("message" in info || "code" in info || "name" in info) {
          throw new Error("value will overwrite populated values: ".concat(stringify(info)));
        }
        for (var key in info) {
          if (key === "shortMessage") {
            continue;
          }
          var value = info[key];
          //                try {
          details.push(key + "=" + stringify(value));
          //                } catch (error: any) {
          //                console.log("MMM", error.message);
          //                    details.push(key + "=[could not serialize object]");
          //                }
        }
      }
      details.push("code=".concat(code));
      details.push("version=".concat(_version_js_1.version));
      if (details.length) {
        message += " (" + details.join(", ") + ")";
      }
    }
    var error;
    switch (code) {
      case "INVALID_ARGUMENT":
        error = new TypeError(message);
        break;
      case "NUMERIC_FAULT":
      case "BUFFER_OVERRUN":
        error = new RangeError(message);
        break;
      default:
        error = new Error(message);
    }
    (0, properties_js_1.defineProperties)(error, {
      code: code
    });
    if (info) {
      Object.assign(error, info);
    }
    if (error.shortMessage == null) {
      (0, properties_js_1.defineProperties)(error, {
        shortMessage: shortMessage
      });
    }
    return error;
  }
  errors.makeError = makeError;
  /**
   *  Throws an EthersError with %%message%%, %%code%% and additional error
   *  %%info%% when %%check%% is falsish..
   *
   *  @see [[api:makeError]]
   */
  function assert(check, message, code, info) {
    if (!check) {
      throw makeError(message, code, info);
    }
  }
  errors.assert = assert;
  /**
   *  A simple helper to simply ensuring provided arguments match expected
   *  constraints, throwing if not.
   *
   *  In TypeScript environments, the %%check%% has been asserted true, so
   *  any further code does not need additional compile-time checks.
   */
  function assertArgument(check, message, name, value) {
    assert(check, message, "INVALID_ARGUMENT", {
      argument: name,
      value: value
    });
  }
  errors.assertArgument = assertArgument;
  function assertArgumentCount(count, expectedCount, message) {
    if (message == null) {
      message = "";
    }
    if (message) {
      message = ": " + message;
    }
    assert(count >= expectedCount, "missing arguemnt" + message, "MISSING_ARGUMENT", {
      count: count,
      expectedCount: expectedCount
    });
    assert(count <= expectedCount, "too many arguments" + message, "UNEXPECTED_ARGUMENT", {
      count: count,
      expectedCount: expectedCount
    });
  }
  errors.assertArgumentCount = assertArgumentCount;
  var _normalizeForms = ["NFD", "NFC", "NFKD", "NFKC"].reduce(function (accum, form) {
    try {
      // General test for normalize
      /* c8 ignore start */
      if ("test".normalize(form) !== "test") {
        throw new Error("bad");
      }
      ;
      /* c8 ignore stop */
      if (form === "NFD") {
        var check = String.fromCharCode(0xe9).normalize("NFD");
        var expected = String.fromCharCode(0x65, 0x0301);
        /* c8 ignore start */
        if (check !== expected) {
          throw new Error("broken");
        }
        /* c8 ignore stop */
      }
      accum.push(form);
    } catch (error) {}
    return accum;
  }, []);
  /**
   *  Throws if the normalization %%form%% is not supported.
   */
  function assertNormalize(form) {
    assert(_normalizeForms.indexOf(form) >= 0, "platform missing String.prototype.normalize", "UNSUPPORTED_OPERATION", {
      operation: "String.prototype.normalize",
      info: {
        form: form
      }
    });
  }
  errors.assertNormalize = assertNormalize;
  /**
   *  Many classes use file-scoped values to guard the constructor,
   *  making it effectively private. This facilitates that pattern
   *  by ensuring the %%givenGaurd%% matches the file-scoped %%guard%%,
   *  throwing if not, indicating the %%className%% if provided.
   */
  function assertPrivate(givenGuard, guard, className) {
    if (className == null) {
      className = "";
    }
    if (givenGuard !== guard) {
      var method = className,
        operation = "new";
      if (className) {
        method += ".";
        operation += " " + className;
      }
      assert(false, "private constructor; use ".concat(method, "from* methods"), "UNSUPPORTED_OPERATION", {
        operation: operation
      });
    }
  }
  errors.assertPrivate = assertPrivate;
  return errors;
}

var hasRequiredData;
function requireData() {
  if (hasRequiredData) return data;
  hasRequiredData = 1;
  Object.defineProperty(data, "__esModule", {
    value: true
  });
  data.zeroPadBytes = data.zeroPadValue = data.stripZerosLeft = data.dataSlice = data.dataLength = data.concat = data.hexlify = data.isBytesLike = data.isHexString = data.getBytesCopy = data.getBytes = void 0;
  /**
   *  Some data helpers.
   *
   *
   *  @_subsection api/utils:Data Helpers  [about-data]
   */
  var errors_js_1 = /*@__PURE__*/requireErrors();
  function _getBytes(value, name, copy) {
    if (value instanceof Uint8Array) {
      if (copy) {
        return new Uint8Array(value);
      }
      return value;
    }
    if (typeof value === "string" && value.match(/^0x(?:[0-9a-f][0-9a-f])*$/i)) {
      var result = new Uint8Array((value.length - 2) / 2);
      var offset = 2;
      for (var i = 0; i < result.length; i++) {
        result[i] = parseInt(value.substring(offset, offset + 2), 16);
        offset += 2;
      }
      return result;
    }
    (0, errors_js_1.assertArgument)(false, "invalid BytesLike value", name || "value", value);
  }
  /**
   *  Get a typed Uint8Array for %%value%%. If already a Uint8Array
   *  the original %%value%% is returned; if a copy is required use
   *  [[getBytesCopy]].
   *
   *  @see: getBytesCopy
   */
  function getBytes(value, name) {
    return _getBytes(value, name, false);
  }
  data.getBytes = getBytes;
  /**
   *  Get a typed Uint8Array for %%value%%, creating a copy if necessary
   *  to prevent any modifications of the returned value from being
   *  reflected elsewhere.
   *
   *  @see: getBytes
   */
  function getBytesCopy(value, name) {
    return _getBytes(value, name, true);
  }
  data.getBytesCopy = getBytesCopy;
  /**
   *  Returns true if %%value%% is a valid [[HexString]].
   *
   *  If %%length%% is ``true`` or a //number//, it also checks that
   *  %%value%% is a valid [[DataHexString]] of %%length%% (if a //number//)
   *  bytes of data (e.g. ``0x1234`` is 2 bytes).
   */
  function isHexString(value, length) {
    if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
      return false;
    }
    if (typeof length === "number" && value.length !== 2 + 2 * length) {
      return false;
    }
    if (length === true && value.length % 2 !== 0) {
      return false;
    }
    return true;
  }
  data.isHexString = isHexString;
  /**
   *  Returns true if %%value%% is a valid representation of arbitrary
   *  data (i.e. a valid [[DataHexString]] or a Uint8Array).
   */
  function isBytesLike(value) {
    return isHexString(value, true) || value instanceof Uint8Array;
  }
  data.isBytesLike = isBytesLike;
  var HexCharacters = "0123456789abcdef";
  /**
   *  Returns a [[DataHexString]] representation of %%data%%.
   */
  function hexlify(data) {
    var bytes = getBytes(data);
    var result = "0x";
    for (var i = 0; i < bytes.length; i++) {
      var v = bytes[i];
      result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];
    }
    return result;
  }
  data.hexlify = hexlify;
  /**
   *  Returns a [[DataHexString]] by concatenating all values
   *  within %%data%%.
   */
  function concat(datas) {
    return "0x" + datas.map(function (d) {
      return hexlify(d).substring(2);
    }).join("");
  }
  data.concat = concat;
  /**
   *  Returns the length of %%data%%, in bytes.
   */
  function dataLength(data) {
    if (isHexString(data, true)) {
      return (data.length - 2) / 2;
    }
    return getBytes(data).length;
  }
  data.dataLength = dataLength;
  /**
   *  Returns a [[DataHexString]] by slicing %%data%% from the %%start%%
   *  offset to the %%end%% offset.
   *
   *  By default %%start%% is 0 and %%end%% is the length of %%data%%.
   */
  function dataSlice(data, start, end) {
    var bytes = getBytes(data);
    if (end != null && end > bytes.length) {
      (0, errors_js_1.assert)(false, "cannot slice beyond data bounds", "BUFFER_OVERRUN", {
        buffer: bytes,
        length: bytes.length,
        offset: end
      });
    }
    return hexlify(bytes.slice(start == null ? 0 : start, end == null ? bytes.length : end));
  }
  data.dataSlice = dataSlice;
  /**
   *  Return the [[DataHexString]] result by stripping all **leading**
   ** zero bytes from %%data%%.
   */
  function stripZerosLeft(data) {
    var bytes = hexlify(data).substring(2);
    while (bytes.startsWith("00")) {
      bytes = bytes.substring(2);
    }
    return "0x" + bytes;
  }
  data.stripZerosLeft = stripZerosLeft;
  function zeroPad(data, length, left) {
    var bytes = getBytes(data);
    (0, errors_js_1.assert)(length >= bytes.length, "padding exceeds data length", "BUFFER_OVERRUN", {
      buffer: new Uint8Array(bytes),
      length: length,
      offset: length + 1
    });
    var result = new Uint8Array(length);
    result.fill(0);
    if (left) {
      result.set(bytes, length - bytes.length);
    } else {
      result.set(bytes, 0);
    }
    return hexlify(result);
  }
  /**
   *  Return the [[DataHexString]] of %%data%% padded on the **left**
   *  to %%length%% bytes.
   *
   *  If %%data%% already exceeds %%length%%, a [[BufferOverrunError]] is
   *  thrown.
   *
   *  This pads data the same as **values** are in Solidity
   *  (e.g. ``uint128``).
   */
  function zeroPadValue(data, length) {
    return zeroPad(data, length, true);
  }
  data.zeroPadValue = zeroPadValue;
  /**
   *  Return the [[DataHexString]] of %%data%% padded on the **right**
   *  to %%length%% bytes.
   *
   *  If %%data%% already exceeds %%length%%, a [[BufferOverrunError]] is
   *  thrown.
   *
   *  This pads data the same as **bytes** are in Solidity
   *  (e.g. ``bytes16``).
   */
  function zeroPadBytes(data, length) {
    return zeroPad(data, length, false);
  }
  data.zeroPadBytes = zeroPadBytes;
  return data;
}

var maths = {};

var hasRequiredMaths;
function requireMaths() {
  if (hasRequiredMaths) return maths;
  hasRequiredMaths = 1;
  Object.defineProperty(maths, "__esModule", {
    value: true
  });
  maths.toQuantity = maths.toBeArray = maths.toBeHex = maths.toNumber = maths.getNumber = maths.toBigInt = maths.getUint = maths.getBigInt = maths.mask = maths.toTwos = maths.fromTwos = void 0;
  /**
   *  Some mathematic operations.
   *
   *  @_subsection: api/utils:Math Helpers  [about-maths]
   */
  var data_js_1 = /*@__PURE__*/requireData();
  var errors_js_1 = /*@__PURE__*/requireErrors();
  var BN_0 = BigInt(0);
  var BN_1 = BigInt(1);
  //const BN_Max256 = (BN_1 << BigInt(256)) - BN_1;
  // IEEE 754 support 53-bits of mantissa
  var maxValue = 0x1fffffffffffff;
  /**
   *  Convert %%value%% from a twos-compliment representation of %%width%%
   *  bits to its value.
   *
   *  If the highest bit is ``1``, the result will be negative.
   */
  function fromTwos(_value, _width) {
    var value = getUint(_value, "value");
    var width = BigInt(getNumber(_width, "width"));
    (0, errors_js_1.assert)(value >> width === BN_0, "overflow", "NUMERIC_FAULT", {
      operation: "fromTwos",
      fault: "overflow",
      value: _value
    });
    // Top bit set; treat as a negative value
    if (value >> width - BN_1) {
      var _mask = (BN_1 << width) - BN_1;
      return -((~value & _mask) + BN_1);
    }
    return value;
  }
  maths.fromTwos = fromTwos;
  /**
   *  Convert %%value%% to a twos-compliment representation of
   *  %%width%% bits.
   *
   *  The result will always be positive.
   */
  function toTwos(_value, _width) {
    var value = getBigInt(_value, "value");
    var width = BigInt(getNumber(_width, "width"));
    var limit = BN_1 << width - BN_1;
    if (value < BN_0) {
      value = -value;
      (0, errors_js_1.assert)(value <= limit, "too low", "NUMERIC_FAULT", {
        operation: "toTwos",
        fault: "overflow",
        value: _value
      });
      var _mask2 = (BN_1 << width) - BN_1;
      return (~value & _mask2) + BN_1;
    } else {
      (0, errors_js_1.assert)(value < limit, "too high", "NUMERIC_FAULT", {
        operation: "toTwos",
        fault: "overflow",
        value: _value
      });
    }
    return value;
  }
  maths.toTwos = toTwos;
  /**
   *  Mask %%value%% with a bitmask of %%bits%% ones.
   */
  function mask(_value, _bits) {
    var value = getUint(_value, "value");
    var bits = BigInt(getNumber(_bits, "bits"));
    return value & (BN_1 << bits) - BN_1;
  }
  maths.mask = mask;
  /**
   *  Gets a BigInt from %%value%%. If it is an invalid value for
   *  a BigInt, then an ArgumentError will be thrown for %%name%%.
   */
  function getBigInt(value, name) {
    switch (_typeof(value)) {
      case "bigint":
        return value;
      case "number":
        (0, errors_js_1.assertArgument)(Number.isInteger(value), "underflow", name || "value", value);
        (0, errors_js_1.assertArgument)(value >= -maxValue && value <= maxValue, "overflow", name || "value", value);
        return BigInt(value);
      case "string":
        try {
          if (value === "") {
            throw new Error("empty string");
          }
          if (value[0] === "-" && value[1] !== "-") {
            return -BigInt(value.substring(1));
          }
          return BigInt(value);
        } catch (e) {
          (0, errors_js_1.assertArgument)(false, "invalid BigNumberish string: ".concat(e.message), name || "value", value);
        }
    }
    (0, errors_js_1.assertArgument)(false, "invalid BigNumberish value", name || "value", value);
  }
  maths.getBigInt = getBigInt;
  /**
   *  Returns %%value%% as a bigint, validating it is valid as a bigint
   *  value and that it is positive.
   */
  function getUint(value, name) {
    var result = getBigInt(value, name);
    (0, errors_js_1.assert)(result >= BN_0, "unsigned value cannot be negative", "NUMERIC_FAULT", {
      fault: "overflow",
      operation: "getUint",
      value: value
    });
    return result;
  }
  maths.getUint = getUint;
  var Nibbles = "0123456789abcdef";
  /*
   * Converts %%value%% to a BigInt. If %%value%% is a Uint8Array, it
   * is treated as Big Endian data.
   */
  function toBigInt(value) {
    if (value instanceof Uint8Array) {
      var result = "0x0";
      var _iterator = _createForOfIteratorHelper(value),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var v = _step.value;
          result += Nibbles[v >> 4];
          result += Nibbles[v & 0x0f];
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return BigInt(result);
    }
    return getBigInt(value);
  }
  maths.toBigInt = toBigInt;
  /**
   *  Gets a //number// from %%value%%. If it is an invalid value for
   *  a //number//, then an ArgumentError will be thrown for %%name%%.
   */
  function getNumber(value, name) {
    switch (_typeof(value)) {
      case "bigint":
        (0, errors_js_1.assertArgument)(value >= -maxValue && value <= maxValue, "overflow", name || "value", value);
        return Number(value);
      case "number":
        (0, errors_js_1.assertArgument)(Number.isInteger(value), "underflow", name || "value", value);
        (0, errors_js_1.assertArgument)(value >= -maxValue && value <= maxValue, "overflow", name || "value", value);
        return value;
      case "string":
        try {
          if (value === "") {
            throw new Error("empty string");
          }
          return getNumber(BigInt(value), name);
        } catch (e) {
          (0, errors_js_1.assertArgument)(false, "invalid numeric string: ".concat(e.message), name || "value", value);
        }
    }
    (0, errors_js_1.assertArgument)(false, "invalid numeric value", name || "value", value);
  }
  maths.getNumber = getNumber;
  /**
   *  Converts %%value%% to a number. If %%value%% is a Uint8Array, it
   *  is treated as Big Endian data. Throws if the value is not safe.
   */
  function toNumber(value) {
    return getNumber(toBigInt(value));
  }
  maths.toNumber = toNumber;
  /**
   *  Converts %%value%% to a Big Endian hexstring, optionally padded to
   *  %%width%% bytes.
   */
  function toBeHex(_value, _width) {
    var value = getUint(_value, "value");
    var result = value.toString(16);
    if (_width == null) {
      // Ensure the value is of even length
      if (result.length % 2) {
        result = "0" + result;
      }
    } else {
      var width = getNumber(_width, "width");
      (0, errors_js_1.assert)(width * 2 >= result.length, "value exceeds width (".concat(width, " bytes)"), "NUMERIC_FAULT", {
        operation: "toBeHex",
        fault: "overflow",
        value: _value
      });
      // Pad the value to the required width
      while (result.length < width * 2) {
        result = "0" + result;
      }
    }
    return "0x" + result;
  }
  maths.toBeHex = toBeHex;
  /**
   *  Converts %%value%% to a Big Endian Uint8Array.
   */
  function toBeArray(_value) {
    var value = getUint(_value, "value");
    if (value === BN_0) {
      return new Uint8Array([]);
    }
    var hex = value.toString(16);
    if (hex.length % 2) {
      hex = "0" + hex;
    }
    var result = new Uint8Array(hex.length / 2);
    for (var i = 0; i < result.length; i++) {
      var offset = i * 2;
      result[i] = parseInt(hex.substring(offset, offset + 2), 16);
    }
    return result;
  }
  maths.toBeArray = toBeArray;
  /**
   *  Returns a [[HexString]] for %%value%% safe to use as a //Quantity//.
   *
   *  A //Quantity// does not have and leading 0 values unless the value is
   *  the literal value `0x0`. This is most commonly used for JSSON-RPC
   *  numeric values.
   */
  function toQuantity(value) {
    var result = (0, data_js_1.hexlify)((0, data_js_1.isBytesLike)(value) ? value : toBeArray(value)).substring(2);
    while (result.startsWith("0")) {
      result = result.substring(1);
    }
    if (result === "") {
      result = "0";
    }
    return "0x" + result;
  }
  maths.toQuantity = toQuantity;
  return maths;
}

var hasRequiredBase58;
function requireBase58() {
  if (hasRequiredBase58) return base58;
  hasRequiredBase58 = 1;
  /**
   *  The [Base58 Encoding](link-base58) scheme allows a **numeric** value
   *  to be encoded as a compact string using a radix of 58 using only
   *  alpha-numeric characters. Confusingly similar characters are omitted
   *  (i.e. ``"l0O"``).
   *
   *  Note that Base58 encodes a **numeric** value, not arbitrary bytes,
   *  since any zero-bytes on the left would get removed. To mitigate this
   *  issue most schemes that use Base58 choose specific high-order values
   *  to ensure non-zero prefixes.
   *
   *  @_subsection: api/utils:Base58 Encoding [about-base58]
   */
  Object.defineProperty(base58, "__esModule", {
    value: true
  });
  base58.decodeBase58 = base58.encodeBase58 = void 0;
  var data_js_1 = /*@__PURE__*/requireData();
  var errors_js_1 = /*@__PURE__*/requireErrors();
  var maths_js_1 = /*@__PURE__*/requireMaths();
  var Alphabet = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
  var Lookup = null;
  function getAlpha(letter) {
    if (Lookup == null) {
      Lookup = {};
      for (var i = 0; i < Alphabet.length; i++) {
        Lookup[Alphabet[i]] = BigInt(i);
      }
    }
    var result = Lookup[letter];
    (0, errors_js_1.assertArgument)(result != null, "invalid base58 value", "letter", letter);
    return result;
  }
  var BN_0 = BigInt(0);
  var BN_58 = BigInt(58);
  /**
   *  Encode %%value%% as a Base58-encoded string.
   */
  function encodeBase58(_value) {
    var bytes = (0, data_js_1.getBytes)(_value);
    var value = (0, maths_js_1.toBigInt)(bytes);
    var result = "";
    while (value) {
      result = Alphabet[Number(value % BN_58)] + result;
      value /= BN_58;
    }
    // Account for leading padding zeros
    for (var i = 0; i < bytes.length; i++) {
      if (bytes[i]) {
        break;
      }
      result = Alphabet[0] + result;
    }
    return result;
  }
  base58.encodeBase58 = encodeBase58;
  /**
   *  Decode the Base58-encoded %%value%%.
   */
  function decodeBase58(value) {
    var result = BN_0;
    for (var i = 0; i < value.length; i++) {
      result *= BN_58;
      result += getAlpha(value[i]);
    }
    return result;
  }
  base58.decodeBase58 = decodeBase58;
  return base58;
}

var base64 = {};

var hasRequiredBase64;
function requireBase64() {
  if (hasRequiredBase64) return base64;
  hasRequiredBase64 = 1;
  Object.defineProperty(base64, "__esModule", {
    value: true
  });
  base64.encodeBase64 = base64.decodeBase64 = void 0;
  /**
   *  [Base64 encoding](link-wiki-base64) using 6-bit words to encode
   *  arbitrary bytes into a string using 65 printable symbols, the
   *  upper-case and lower-case alphabet, the digits ``0`` through ``9``,
   *  ``"+"`` and ``"/"`` with the ``"="`` used for padding.
   *
   *  @_subsection: api/utils:Base64 Encoding  [about-base64]
   */
  var data_js_1 = /*@__PURE__*/requireData();
  /**
   *  Decodes the base-64 encoded %%value%%.
   *
   *  @example:
   *    // The decoded value is always binary data...
   *    result = decodeBase64("SGVsbG8gV29ybGQhIQ==")
   *    //_result:
   *
   *    // ...use toUtf8String to convert it to a string.
   *    toUtf8String(result)
   *    //_result:
   *
   *    // Decoding binary data
   *    decodeBase64("EjQ=")
   *    //_result:
   */
  function decodeBase64(value) {
    return (0, data_js_1.getBytesCopy)(Buffer.from(value, "base64"));
  }
  base64.decodeBase64 = decodeBase64;
  /**
   *  Encodes %%data%% as a base-64 encoded string.
   *
   *  @example:
   *    // Encoding binary data as a hexstring
   *    encodeBase64("0x1234")
   *    //_result:
   *
   *    // Encoding binary data as a Uint8Array
   *    encodeBase64(new Uint8Array([ 0x12, 0x34 ]))
   *    //_result:
   *
   *    // The input MUST be data...
   *    encodeBase64("Hello World!!")
   *    //_error:
   *
   *    // ...use toUtf8Bytes for this.
   *    encodeBase64(toUtf8Bytes("Hello World!!"))
   *    //_result:
   */
  function encodeBase64(data) {
    return Buffer.from((0, data_js_1.getBytes)(data)).toString("base64");
  }
  base64.encodeBase64 = encodeBase64;
  return base64;
}

var events = {};

var hasRequiredEvents;
function requireEvents() {
  if (hasRequiredEvents) return events;
  hasRequiredEvents = 1;
  Object.defineProperty(events, "__esModule", {
    value: true
  });
  events.EventPayload = void 0;
  /**
   *  Events allow for applications to use the observer pattern, which
   *  allows subscribing and publishing events, outside the normal
   *  execution paths.
   *
   *  @_section api/utils/events:Events  [about-events]
   */
  var properties_js_1 = /*@__PURE__*/requireProperties();
  /**
   *  When an [[EventEmitterable]] triggers a [[Listener]], the
   *  callback always ahas one additional argument passed, which is
   *  an **EventPayload**.
   */
  var _listener = /*#__PURE__*/new WeakMap();
  var EventPayload = /*#__PURE__*/function () {
    /**
     *  Create a new **EventPayload** for %%emitter%% with
     *  the %%listener%% and for %%filter%%.
     */
    function EventPayload(emitter, listener, filter) {
      _classCallCheck(this, EventPayload);
      /**
       *  The event filter.
       */
      _defineProperty(this, "filter", void 0);
      /**
       *  The **EventEmitterable**.
       */
      _defineProperty(this, "emitter", void 0);
      _classPrivateFieldInitSpec(this, _listener, void 0);
      _classPrivateFieldSet2(_listener, this, listener);
      (0, properties_js_1.defineProperties)(this, {
        emitter: emitter,
        filter: filter
      });
    }
    /**
     *  Unregister the triggered listener for future events.
     */
    return _createClass(EventPayload, [{
      key: "removeListener",
      value: (function () {
        var _removeListener = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                if (!(_classPrivateFieldGet2(_listener, this) == null)) {
                  _context.next = 2;
                  break;
                }
                return _context.abrupt("return");
              case 2:
                _context.next = 4;
                return this.emitter.off(this.filter, _classPrivateFieldGet2(_listener, this));
              case 4:
              case "end":
                return _context.stop();
            }
          }, _callee, this);
        }));
        function removeListener() {
          return _removeListener.apply(this, arguments);
        }
        return removeListener;
      }())
    }]);
  }();
  events.EventPayload = EventPayload;
  return events;
}

var fetch = {};

var utf8 = {};

var hasRequiredUtf8;
function requireUtf8() {
  if (hasRequiredUtf8) return utf8;
  hasRequiredUtf8 = 1;
  (function (exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.toUtf8CodePoints = exports.toUtf8String = exports.toUtf8Bytes = exports.Utf8ErrorFuncs = void 0;
    /**
     *  Using strings in Ethereum (or any security-basd system) requires
     *  additional care. These utilities attempt to mitigate some of the
     *  safety issues as well as provide the ability to recover and analyse
     *  strings.
     *
     *  @_subsection api/utils:Strings and UTF-8  [about-strings]
     */
    var data_js_1 = /*@__PURE__*/requireData();
    var errors_js_1 = /*@__PURE__*/requireErrors();
    function errorFunc(reason, offset, bytes, output, badCodepoint) {
      (0, errors_js_1.assertArgument)(false, "invalid codepoint at offset ".concat(offset, "; ").concat(reason), "bytes", bytes);
    }
    function ignoreFunc(reason, offset, bytes, output, badCodepoint) {
      // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes
      if (reason === "BAD_PREFIX" || reason === "UNEXPECTED_CONTINUE") {
        var i = 0;
        for (var o = offset + 1; o < bytes.length; o++) {
          if (bytes[o] >> 6 !== 0x02) {
            break;
          }
          i++;
        }
        return i;
      }
      // This byte runs us past the end of the string, so just jump to the end
      // (but the first byte was read already read and therefore skipped)
      if (reason === "OVERRUN") {
        return bytes.length - offset - 1;
      }
      // Nothing to skip
      return 0;
    }
    function replaceFunc(reason, offset, bytes, output, badCodepoint) {
      // Overlong representations are otherwise "valid" code points; just non-deistingtished
      if (reason === "OVERLONG") {
        (0, errors_js_1.assertArgument)(typeof badCodepoint === "number", "invalid bad code point for replacement", "badCodepoint", badCodepoint);
        output.push(badCodepoint);
        return 0;
      }
      // Put the replacement character into the output
      output.push(0xfffd);
      // Otherwise, process as if ignoring errors
      return ignoreFunc(reason, offset, bytes);
    }
    /**
     *  A handful of popular, built-in UTF-8 error handling strategies.
     *
     *  **``"error"``** - throws on ANY illegal UTF-8 sequence or
     *  non-canonical (overlong) codepoints (this is the default)
     *
     *  **``"ignore"``** - silently drops any illegal UTF-8 sequence
     *  and accepts non-canonical (overlong) codepoints
     *
     *  **``"replace"``** - replace any illegal UTF-8 sequence with the
     *  UTF-8 replacement character (i.e. ``"\\ufffd"``) and accepts
     *  non-canonical (overlong) codepoints
     *
     *  @returns: Record<"error" | "ignore" | "replace", Utf8ErrorFunc>
     */
    exports.Utf8ErrorFuncs = Object.freeze({
      error: errorFunc,
      ignore: ignoreFunc,
      replace: replaceFunc
    });
    // http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499
    function getUtf8CodePoints(_bytes, onError) {
      if (onError == null) {
        onError = exports.Utf8ErrorFuncs.error;
      }
      var bytes = (0, data_js_1.getBytes)(_bytes, "bytes");
      var result = [];
      var i = 0;
      // Invalid bytes are ignored
      while (i < bytes.length) {
        var c = bytes[i++];
        // 0xxx xxxx
        if (c >> 7 === 0) {
          result.push(c);
          continue;
        }
        // Multibyte; how many bytes left for this character?
        var extraLength = null;
        var overlongMask = null;
        // 110x xxxx 10xx xxxx
        if ((c & 0xe0) === 0xc0) {
          extraLength = 1;
          overlongMask = 0x7f;
          // 1110 xxxx 10xx xxxx 10xx xxxx
        } else if ((c & 0xf0) === 0xe0) {
          extraLength = 2;
          overlongMask = 0x7ff;
          // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx
        } else if ((c & 0xf8) === 0xf0) {
          extraLength = 3;
          overlongMask = 0xffff;
        } else {
          if ((c & 0xc0) === 0x80) {
            i += onError("UNEXPECTED_CONTINUE", i - 1, bytes, result);
          } else {
            i += onError("BAD_PREFIX", i - 1, bytes, result);
          }
          continue;
        }
        // Do we have enough bytes in our data?
        if (i - 1 + extraLength >= bytes.length) {
          i += onError("OVERRUN", i - 1, bytes, result);
          continue;
        }
        // Remove the length prefix from the char
        var res = c & (1 << 8 - extraLength - 1) - 1;
        for (var j = 0; j < extraLength; j++) {
          var nextChar = bytes[i];
          // Invalid continuation byte
          if ((nextChar & 0xc0) != 0x80) {
            i += onError("MISSING_CONTINUE", i, bytes, result);
            res = null;
            break;
          }
          res = res << 6 | nextChar & 0x3f;
          i++;
        }
        // See above loop for invalid continuation byte
        if (res === null) {
          continue;
        }
        // Maximum code point
        if (res > 0x10ffff) {
          i += onError("OUT_OF_RANGE", i - 1 - extraLength, bytes, result, res);
          continue;
        }
        // Reserved for UTF-16 surrogate halves
        if (res >= 0xd800 && res <= 0xdfff) {
          i += onError("UTF16_SURROGATE", i - 1 - extraLength, bytes, result, res);
          continue;
        }
        // Check for overlong sequences (more bytes than needed)
        if (res <= overlongMask) {
          i += onError("OVERLONG", i - 1 - extraLength, bytes, result, res);
          continue;
        }
        result.push(res);
      }
      return result;
    }
    // http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array
    /**
     *  Returns the UTF-8 byte representation of %%str%%.
     *
     *  If %%form%% is specified, the string is normalized.
     */
    function toUtf8Bytes(str, form) {
      (0, errors_js_1.assertArgument)(typeof str === "string", "invalid string value", "str", str);
      if (form != null) {
        (0, errors_js_1.assertNormalize)(form);
        str = str.normalize(form);
      }
      var result = [];
      for (var i = 0; i < str.length; i++) {
        var c = str.charCodeAt(i);
        if (c < 0x80) {
          result.push(c);
        } else if (c < 0x800) {
          result.push(c >> 6 | 0xc0);
          result.push(c & 0x3f | 0x80);
        } else if ((c & 0xfc00) == 0xd800) {
          i++;
          var c2 = str.charCodeAt(i);
          (0, errors_js_1.assertArgument)(i < str.length && (c2 & 0xfc00) === 0xdc00, "invalid surrogate pair", "str", str);
          // Surrogate Pair
          var pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);
          result.push(pair >> 18 | 0xf0);
          result.push(pair >> 12 & 0x3f | 0x80);
          result.push(pair >> 6 & 0x3f | 0x80);
          result.push(pair & 0x3f | 0x80);
        } else {
          result.push(c >> 12 | 0xe0);
          result.push(c >> 6 & 0x3f | 0x80);
          result.push(c & 0x3f | 0x80);
        }
      }
      return new Uint8Array(result);
    }
    exports.toUtf8Bytes = toUtf8Bytes;
    //export 
    function _toUtf8String(codePoints) {
      return codePoints.map(function (codePoint) {
        if (codePoint <= 0xffff) {
          return String.fromCharCode(codePoint);
        }
        codePoint -= 0x10000;
        return String.fromCharCode((codePoint >> 10 & 0x3ff) + 0xd800, (codePoint & 0x3ff) + 0xdc00);
      }).join("");
    }
    /**
     *  Returns the string represented by the UTF-8 data %%bytes%%.
     *
     *  When %%onError%% function is specified, it is called on UTF-8
     *  errors allowing recovery using the [[Utf8ErrorFunc]] API.
     *  (default: [error](Utf8ErrorFuncs))
     */
    function toUtf8String(bytes, onError) {
      return _toUtf8String(getUtf8CodePoints(bytes, onError));
    }
    exports.toUtf8String = toUtf8String;
    /**
     *  Returns the UTF-8 code-points for %%str%%.
     *
     *  If %%form%% is specified, the string is normalized.
     */
    function toUtf8CodePoints(str, form) {
      return getUtf8CodePoints(toUtf8Bytes(str, form));
    }
    exports.toUtf8CodePoints = toUtf8CodePoints;
  })(utf8);
  return utf8;
}

var geturl = {};

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol, Iterator */

var _extendStatics = function extendStatics(d, b) {
  _extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
  };
  return _extendStatics(d, b);
};
function __extends(d, b) {
  if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  _extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var _assign = function __assign() {
  _assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return _assign.apply(this, arguments);
};
function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
}
function __decorate(decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __param(paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
}
function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
    return f;
  }
  var kind = contextIn.kind,
    key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _,
    done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context = {};
    for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
    for (var p in contextIn.access) context.access[p] = contextIn.access[p];
    context.addInitializer = function (f) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? {
      get: descriptor.get,
      set: descriptor.set
    } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || _typeof(result) !== "object") throw new TypeError("Object expected");
      if (_ = accept(result.get)) descriptor.get = _;
      if (_ = accept(result.set)) descriptor.set = _;
      if (_ = accept(result.init)) initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field") initializers.unshift(_);else descriptor[key] = _;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
}
function __runInitializers(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
}
function __propKey(x) {
  return _typeof(x) === "symbol" ? x : "".concat(x);
}
function __setFunctionName(f, name, prefix) {
  if (_typeof(name) === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
  return Object.defineProperty(f, "name", {
    configurable: true,
    value: prefix ? "".concat(prefix, " ", name) : name
  });
}
function __metadata(metadataKey, metadataValue) {
  if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = {
      label: 0,
      sent: function sent() {
        if (t[0] & 1) throw t[1];
        return t[1];
      },
      trys: [],
      ops: []
    },
    f,
    y,
    t,
    g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;
  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return {
            value: op[1],
            done: false
          };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
}
var __createBinding = Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
};
function __exportStar(m, o) {
  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator,
    m = s && o[s],
    i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function next() {
      if (o && i >= o.length) o = void 0;
      return {
        value: o && o[i++],
        done: !o
      };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o),
    r,
    ar = [],
    e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = {
      error: error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
}

/** @deprecated */
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
  return ar;
}

/** @deprecated */
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];
  return r;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []),
    i,
    q = [];
  return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function () {
    return this;
  }, i;
  function awaitReturn(f) {
    return function (v) {
      return Promise.resolve(v).then(f, reject);
    };
  }
  function verb(n, f) {
    if (g[n]) {
      i[n] = function (v) {
        return new Promise(function (a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
      if (f) i[n] = f(i[n]);
    }
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
}
function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function (e) {
    throw e;
  }), verb("return"), i[Symbol.iterator] = function () {
    return this;
  }, i;
  function verb(n, f) {
    i[n] = o[n] ? function (v) {
      return (p = !p) ? {
        value: __await(o[n](v)),
        done: false
      } : f ? f(v) : v;
    } : f;
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator],
    i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function (v) {
      return new Promise(function (resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function (v) {
      resolve({
        value: v,
        done: d
      });
    }, reject);
  }
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", {
      value: raw
    });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
var __setModuleDefault = Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
};
function __importStar(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
}
function __importDefault(mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
}
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
function __classPrivateFieldIn(state, receiver) {
  if (receiver === null || _typeof(receiver) !== "object" && typeof receiver !== "function") throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state === "function" ? receiver === state : state.has(receiver);
}
function __addDisposableResource(env, value, async) {
  if (value !== null && value !== void 0) {
    if (_typeof(value) !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
    var dispose, inner;
    if (async) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
      if (async) inner = dispose;
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    if (inner) dispose = function dispose() {
      try {
        inner.call(this);
      } catch (e) {
        return Promise.reject(e);
      }
    };
    env.stack.push({
      value: value,
      dispose: dispose,
      async: async
    });
  } else if (async) {
    env.stack.push({
      async: true
    });
  }
  return value;
}
var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};
function __disposeResources(env) {
  function fail(e) {
    env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
    env.hasError = true;
  }
  var r,
    s = 0;
  function next() {
    while (r = env.stack.pop()) {
      try {
        if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
        if (r.dispose) {
          var result = r.dispose.call(r.value);
          if (r.async) return s |= 2, Promise.resolve(result).then(next, function (e) {
            fail(e);
            return next();
          });
        } else s |= 1;
      } catch (e) {
        fail(e);
      }
    }
    if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
    if (env.hasError) throw env.error;
  }
  return next();
}
function __rewriteRelativeImportExtension(path, preserveJsx) {
  if (typeof path === "string" && /^\.\.?\//.test(path)) {
    return path.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function (m, tsx, d, ext, cm) {
      return tsx ? preserveJsx ? ".jsx" : ".js" : d && (!ext || !cm) ? m : d + ext + "." + cm.toLowerCase() + "js";
    });
  }
  return path;
}
var tslib_es6 = {
  __extends: __extends,
  __assign: _assign,
  __rest: __rest,
  __decorate: __decorate,
  __param: __param,
  __esDecorate: __esDecorate,
  __runInitializers: __runInitializers,
  __propKey: __propKey,
  __setFunctionName: __setFunctionName,
  __metadata: __metadata,
  __awaiter: __awaiter,
  __generator: __generator,
  __createBinding: __createBinding,
  __exportStar: __exportStar,
  __values: __values,
  __read: __read,
  __spread: __spread,
  __spreadArrays: __spreadArrays,
  __spreadArray: __spreadArray,
  __await: __await,
  __asyncGenerator: __asyncGenerator,
  __asyncDelegator: __asyncDelegator,
  __asyncValues: __asyncValues,
  __makeTemplateObject: __makeTemplateObject,
  __importStar: __importStar,
  __importDefault: __importDefault,
  __classPrivateFieldGet: __classPrivateFieldGet,
  __classPrivateFieldSet: __classPrivateFieldSet,
  __classPrivateFieldIn: __classPrivateFieldIn,
  __addDisposableResource: __addDisposableResource,
  __disposeResources: __disposeResources,
  __rewriteRelativeImportExtension: __rewriteRelativeImportExtension
};

var tslib_es6$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  __addDisposableResource: __addDisposableResource,
  get __assign () { return _assign; },
  __asyncDelegator: __asyncDelegator,
  __asyncGenerator: __asyncGenerator,
  __asyncValues: __asyncValues,
  __await: __await,
  __awaiter: __awaiter,
  __classPrivateFieldGet: __classPrivateFieldGet,
  __classPrivateFieldIn: __classPrivateFieldIn,
  __classPrivateFieldSet: __classPrivateFieldSet,
  __createBinding: __createBinding,
  __decorate: __decorate,
  __disposeResources: __disposeResources,
  __esDecorate: __esDecorate,
  __exportStar: __exportStar,
  __extends: __extends,
  __generator: __generator,
  __importDefault: __importDefault,
  __importStar: __importStar,
  __makeTemplateObject: __makeTemplateObject,
  __metadata: __metadata,
  __param: __param,
  __propKey: __propKey,
  __read: __read,
  __rest: __rest,
  __rewriteRelativeImportExtension: __rewriteRelativeImportExtension,
  __runInitializers: __runInitializers,
  __setFunctionName: __setFunctionName,
  __spread: __spread,
  __spreadArray: __spreadArray,
  __spreadArrays: __spreadArrays,
  __values: __values,
  default: tslib_es6
});

var require$$0 = /*@__PURE__*/getAugmentedNamespace(tslib_es6$1);

var hasRequiredGeturl;
function requireGeturl() {
  if (hasRequiredGeturl) return geturl;
  hasRequiredGeturl = 1;
  Object.defineProperty(geturl, "__esModule", {
    value: true
  });
  geturl.getUrl = geturl.createGetUrl = void 0;
  var tslib_1 = require$$0;
  var http_1 = tslib_1.__importDefault(require$$1);
  var https_1 = tslib_1.__importDefault(require$$2);
  var zlib_1 = require$$3;
  var errors_js_1 = /*@__PURE__*/requireErrors();
  var data_js_1 = /*@__PURE__*/requireData();
  /**
   *  @_ignore:
   */
  function createGetUrl(options) {
    function getUrl(_x, _x2) {
      return _getUrl.apply(this, arguments);
    }
    function _getUrl() {
      _getUrl = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(req, signal) {
        var protocol, method, headers, reqOptions, abort, request, body;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              // Make sure we weren't cancelled before sending
              (0, errors_js_1.assert)(signal == null || !signal.cancelled, "request cancelled before sending", "CANCELLED");
              protocol = req.url.split(":")[0].toLowerCase();
              (0, errors_js_1.assert)(protocol === "http" || protocol === "https", "unsupported protocol ".concat(protocol), "UNSUPPORTED_OPERATION", {
                info: {
                  protocol: protocol
                },
                operation: "request"
              });
              (0, errors_js_1.assert)(protocol === "https" || !req.credentials || req.allowInsecureAuthentication, "insecure authorized connections unsupported", "UNSUPPORTED_OPERATION", {
                operation: "request"
              });
              method = req.method;
              headers = Object.assign({}, req.headers);
              reqOptions = {
                method: method,
                headers: headers
              };
              if (options) {
                if (options.agent) {
                  reqOptions.agent = options.agent;
                }
              }
              // Create a Node-specific AbortController, if available
              abort = null;
              try {
                abort = new AbortController();
                reqOptions.abort = abort.signal;
              } catch (e) {
                console.log(e);
              }
              request = (protocol === "http" ? http_1["default"] : https_1["default"]).request(req.url, reqOptions);
              request.setTimeout(req.timeout);
              body = req.body;
              if (body) {
                request.write(Buffer.from(body));
              }
              request.end();
              return _context.abrupt("return", new Promise(function (resolve, reject) {
                if (signal) {
                  signal.addListener(function () {
                    if (abort) {
                      abort.abort();
                    }
                    reject((0, errors_js_1.makeError)("request cancelled", "CANCELLED"));
                  });
                }
                request.on("timeout", function () {
                  reject((0, errors_js_1.makeError)("request timeout", "TIMEOUT"));
                });
                request.once("response", function (resp) {
                  var statusCode = resp.statusCode || 0;
                  var statusMessage = resp.statusMessage || "";
                  var headers = Object.keys(resp.headers || {}).reduce(function (accum, name) {
                    var value = resp.headers[name] || "";
                    if (Array.isArray(value)) {
                      value = value.join(", ");
                    }
                    accum[name] = value;
                    return accum;
                  }, {});
                  var body = null;
                  //resp.setEncoding("utf8");
                  resp.on("data", function (chunk) {
                    if (signal) {
                      try {
                        signal.checkSignal();
                      } catch (error) {
                        return reject(error);
                      }
                    }
                    if (body == null) {
                      body = chunk;
                    } else {
                      var newBody = new Uint8Array(body.length + chunk.length);
                      newBody.set(body, 0);
                      newBody.set(chunk, body.length);
                      body = newBody;
                    }
                  });
                  resp.on("end", function () {
                    if (headers["content-encoding"] === "gzip" && body) {
                      body = (0, data_js_1.getBytes)((0, zlib_1.gunzipSync)(body));
                    }
                    resolve({
                      statusCode: statusCode,
                      statusMessage: statusMessage,
                      headers: headers,
                      body: body
                    });
                  });
                  resp.on("error", function (error) {
                    //@TODO: Should this just return nornal response with a server error?
                    error.response = {
                      statusCode: statusCode,
                      statusMessage: statusMessage,
                      headers: headers,
                      body: body
                    };
                    reject(error);
                  });
                });
                request.on("error", function (error) {
                  reject(error);
                });
              }));
            case 16:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));
      return _getUrl.apply(this, arguments);
    }
    return getUrl;
  }
  geturl.createGetUrl = createGetUrl;
  // @TODO: remove in v7; provided for backwards compat
  var defaultGetUrl = createGetUrl({});
  /**
   *  @_ignore:
   */
  function getUrl(_x3, _x4) {
    return _getUrl2.apply(this, arguments);
  }
  function _getUrl2() {
    _getUrl2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(req, signal) {
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            return _context2.abrupt("return", defaultGetUrl(req, signal));
          case 1:
          case "end":
            return _context2.stop();
        }
      }, _callee2);
    }));
    return _getUrl2.apply(this, arguments);
  }
  geturl.getUrl = getUrl;
  return geturl;
}

var hasRequiredFetch;
function requireFetch() {
  if (hasRequiredFetch) return fetch;
  hasRequiredFetch = 1;
  Object.defineProperty(fetch, "__esModule", {
    value: true
  });
  fetch.FetchResponse = fetch.FetchRequest = fetch.FetchCancelSignal = void 0;
  /**
   *  Fetching content from the web is environment-specific, so Ethers
   *  provides an abstraction that each environment can implement to provide
   *  this service.
   *
   *  On [Node.js](link-node), the ``http`` and ``https`` libs are used to
   *  create a request object, register event listeners and process data
   *  and populate the [[FetchResponse]].
   *
   *  In a browser, the [DOM fetch](link-js-fetch) is used, and the resulting
   *  ``Promise`` is waited on to retrieve the payload.
   *
   *  The [[FetchRequest]] is responsible for handling many common situations,
   *  such as redirects, server throttling, authentication, etc.
   *
   *  It also handles common gateways, such as IPFS and data URIs.
   *
   *  @_section api/utils/fetching:Fetching Web Content  [about-fetch]
   */
  var base64_js_1 = /*@__PURE__*/requireBase64();
  var data_js_1 = /*@__PURE__*/requireData();
  var errors_js_1 = /*@__PURE__*/requireErrors();
  var properties_js_1 = /*@__PURE__*/requireProperties();
  var utf8_js_1 = /*@__PURE__*/requireUtf8();
  var geturl_js_1 = /*@__PURE__*/requireGeturl();
  var MAX_ATTEMPTS = 12;
  var SLOT_INTERVAL = 250;
  // The global FetchGetUrlFunc implementation.
  var defaultGetUrlFunc = (0, geturl_js_1.createGetUrl)();
  var reData = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i");
  var reIpfs = new RegExp("^ipfs:/\/(ipfs/)?(.*)$", "i");
  // If locked, new Gateways cannot be added
  var locked = false;
  // https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URLs
  function dataGatewayFunc(_x, _x2) {
    return _dataGatewayFunc.apply(this, arguments);
  }
  /**
   *  Returns a [[FetchGatewayFunc]] for fetching content from a standard
   *  IPFS gateway hosted at %%baseUrl%%.
   */
  function _dataGatewayFunc() {
    _dataGatewayFunc = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(url, signal) {
      var match;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            _context2.prev = 0;
            match = url.match(reData);
            if (match) {
              _context2.next = 4;
              break;
            }
            throw new Error("invalid data");
          case 4:
            return _context2.abrupt("return", new FetchResponse(200, "OK", {
              "content-type": match[1] || "text/plain"
            }, match[2] ? (0, base64_js_1.decodeBase64)(match[3]) : unpercent(match[3])));
          case 7:
            _context2.prev = 7;
            _context2.t0 = _context2["catch"](0);
            return _context2.abrupt("return", new FetchResponse(599, "BAD REQUEST (invalid data: URI)", {}, null, new FetchRequest(url)));
          case 10:
          case "end":
            return _context2.stop();
        }
      }, _callee2, null, [[0, 7]]);
    }));
    return _dataGatewayFunc.apply(this, arguments);
  }
  function getIpfsGatewayFunc(baseUrl) {
    function gatewayIpfs(_x3, _x4) {
      return _gatewayIpfs.apply(this, arguments);
    }
    function _gatewayIpfs() {
      _gatewayIpfs = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(url, signal) {
        var match;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              match = url.match(reIpfs);
              if (match) {
                _context.next = 4;
                break;
              }
              throw new Error("invalid link");
            case 4:
              return _context.abrupt("return", new FetchRequest("".concat(baseUrl).concat(match[2])));
            case 7:
              _context.prev = 7;
              _context.t0 = _context["catch"](0);
              return _context.abrupt("return", new FetchResponse(599, "BAD REQUEST (invalid IPFS URI)", {}, null, new FetchRequest(url)));
            case 10:
            case "end":
              return _context.stop();
          }
        }, _callee, null, [[0, 7]]);
      }));
      return _gatewayIpfs.apply(this, arguments);
    }
    return gatewayIpfs;
  }
  var Gateways = {
    "data": dataGatewayFunc,
    "ipfs": getIpfsGatewayFunc("https:/\/gateway.ipfs.io/ipfs/")
  };
  var fetchSignals = new WeakMap();
  /**
   *  @_ignore
   */
  var _listeners = /*#__PURE__*/new WeakMap();
  var _cancelled = /*#__PURE__*/new WeakMap();
  var FetchCancelSignal = /*#__PURE__*/function () {
    function FetchCancelSignal(request) {
      var _this = this;
      _classCallCheck(this, FetchCancelSignal);
      _classPrivateFieldInitSpec(this, _listeners, void 0);
      _classPrivateFieldInitSpec(this, _cancelled, void 0);
      _classPrivateFieldSet2(_listeners, this, []);
      _classPrivateFieldSet2(_cancelled, this, false);
      fetchSignals.set(request, function () {
        if (_classPrivateFieldGet2(_cancelled, _this)) {
          return;
        }
        _classPrivateFieldSet2(_cancelled, _this, true);
        var _iterator = _createForOfIteratorHelper(_classPrivateFieldGet2(_listeners, _this)),
          _step;
        try {
          var _loop = function _loop() {
            var listener = _step.value;
            setTimeout(function () {
              listener();
            }, 0);
          };
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            _loop();
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        _classPrivateFieldSet2(_listeners, _this, []);
      });
    }
    return _createClass(FetchCancelSignal, [{
      key: "addListener",
      value: function addListener(listener) {
        (0, errors_js_1.assert)(!_classPrivateFieldGet2(_cancelled, this), "singal already cancelled", "UNSUPPORTED_OPERATION", {
          operation: "fetchCancelSignal.addCancelListener"
        });
        _classPrivateFieldGet2(_listeners, this).push(listener);
      }
    }, {
      key: "cancelled",
      get: function get() {
        return _classPrivateFieldGet2(_cancelled, this);
      }
    }, {
      key: "checkSignal",
      value: function checkSignal() {
        (0, errors_js_1.assert)(!this.cancelled, "cancelled", "CANCELLED", {});
      }
    }]);
  }();
  fetch.FetchCancelSignal = FetchCancelSignal;
  // Check the signal, throwing if it is cancelled
  function checkSignal(signal) {
    if (signal == null) {
      throw new Error("missing signal; should not happen");
    }
    signal.checkSignal();
    return signal;
  }
  /**
   *  Represents a request for a resource using a URI.
   *
   *  By default, the supported schemes are ``HTTP``, ``HTTPS``, ``data:``,
   *  and ``IPFS:``.
   *
   *  Additional schemes can be added globally using [[registerGateway]].
   *
   *  @example:
   *    req = new FetchRequest("https://www.ricmoo.com")
   *    resp = await req.send()
   *    resp.body.length
   *    //_result:
   */
  var _allowInsecure = /*#__PURE__*/new WeakMap();
  var _gzip = /*#__PURE__*/new WeakMap();
  var _headers = /*#__PURE__*/new WeakMap();
  var _method = /*#__PURE__*/new WeakMap();
  var _timeout = /*#__PURE__*/new WeakMap();
  var _url = /*#__PURE__*/new WeakMap();
  var _body = /*#__PURE__*/new WeakMap();
  var _bodyType = /*#__PURE__*/new WeakMap();
  var _creds = /*#__PURE__*/new WeakMap();
  var _preflight = /*#__PURE__*/new WeakMap();
  var _process = /*#__PURE__*/new WeakMap();
  var _retry = /*#__PURE__*/new WeakMap();
  var _signal = /*#__PURE__*/new WeakMap();
  var _throttle = /*#__PURE__*/new WeakMap();
  var _getUrlFunc = /*#__PURE__*/new WeakMap();
  var _FetchRequest_brand = /*#__PURE__*/new WeakSet();
  var FetchRequest = /*#__PURE__*/function () {
    /**
     *  Create a new FetchRequest instance with default values.
     *
     *  Once created, each property may be set before issuing a
     *  ``.send()`` to make the request.
     */
    function FetchRequest(url) {
      _classCallCheck(this, FetchRequest);
      _classPrivateMethodInitSpec(this, _FetchRequest_brand);
      _classPrivateFieldInitSpec(this, _allowInsecure, void 0);
      _classPrivateFieldInitSpec(this, _gzip, void 0);
      _classPrivateFieldInitSpec(this, _headers, void 0);
      _classPrivateFieldInitSpec(this, _method, void 0);
      _classPrivateFieldInitSpec(this, _timeout, void 0);
      _classPrivateFieldInitSpec(this, _url, void 0);
      _classPrivateFieldInitSpec(this, _body, void 0);
      _classPrivateFieldInitSpec(this, _bodyType, void 0);
      _classPrivateFieldInitSpec(this, _creds, void 0);
      // Hooks
      _classPrivateFieldInitSpec(this, _preflight, void 0);
      _classPrivateFieldInitSpec(this, _process, void 0);
      _classPrivateFieldInitSpec(this, _retry, void 0);
      _classPrivateFieldInitSpec(this, _signal, void 0);
      _classPrivateFieldInitSpec(this, _throttle, void 0);
      _classPrivateFieldInitSpec(this, _getUrlFunc, void 0);
      _classPrivateFieldSet2(_url, this, String(url));
      _classPrivateFieldSet2(_allowInsecure, this, false);
      _classPrivateFieldSet2(_gzip, this, true);
      _classPrivateFieldSet2(_headers, this, {});
      _classPrivateFieldSet2(_method, this, "");
      _classPrivateFieldSet2(_timeout, this, 300000);
      _classPrivateFieldSet2(_throttle, this, {
        slotInterval: SLOT_INTERVAL,
        maxAttempts: MAX_ATTEMPTS
      });
      _classPrivateFieldSet2(_getUrlFunc, this, null);
    }
    return _createClass(FetchRequest, [{
      key: "url",
      get:
      /**
       *  The fetch URL to request.
       */
      function get() {
        return _classPrivateFieldGet2(_url, this);
      },
      set: function set(url) {
        _classPrivateFieldSet2(_url, this, String(url));
      }
      /**
       *  The fetch body, if any, to send as the request body. //(default: null)//
       *
       *  When setting a body, the intrinsic ``Content-Type`` is automatically
       *  set and will be used if **not overridden** by setting a custom
       *  header.
       *
       *  If %%body%% is null, the body is cleared (along with the
       *  intrinsic ``Content-Type``).
       *
       *  If %%body%% is a string, the intrinsic ``Content-Type`` is set to
       *  ``text/plain``.
       *
       *  If %%body%% is a Uint8Array, the intrinsic ``Content-Type`` is set to
       *  ``application/octet-stream``.
       *
       *  If %%body%% is any other object, the intrinsic ``Content-Type`` is
       *  set to ``application/json``.
       */
    }, {
      key: "body",
      get: function get() {
        if (_classPrivateFieldGet2(_body, this) == null) {
          return null;
        }
        return new Uint8Array(_classPrivateFieldGet2(_body, this));
      },
      set: function set(body) {
        if (body == null) {
          _classPrivateFieldSet2(_body, this, undefined);
          _classPrivateFieldSet2(_bodyType, this, undefined);
        } else if (typeof body === "string") {
          _classPrivateFieldSet2(_body, this, (0, utf8_js_1.toUtf8Bytes)(body));
          _classPrivateFieldSet2(_bodyType, this, "text/plain");
        } else if (body instanceof Uint8Array) {
          _classPrivateFieldSet2(_body, this, body);
          _classPrivateFieldSet2(_bodyType, this, "application/octet-stream");
        } else if (_typeof(body) === "object") {
          _classPrivateFieldSet2(_body, this, (0, utf8_js_1.toUtf8Bytes)(JSON.stringify(body)));
          _classPrivateFieldSet2(_bodyType, this, "application/json");
        } else {
          throw new Error("invalid body");
        }
      }
      /**
       *  Returns true if the request has a body.
       */
    }, {
      key: "hasBody",
      value: function hasBody() {
        return _classPrivateFieldGet2(_body, this) != null;
      }
      /**
       *  The HTTP method to use when requesting the URI. If no method
       *  has been explicitly set, then ``GET`` is used if the body is
       *  null and ``POST`` otherwise.
       */
    }, {
      key: "method",
      get: function get() {
        if (_classPrivateFieldGet2(_method, this)) {
          return _classPrivateFieldGet2(_method, this);
        }
        if (this.hasBody()) {
          return "POST";
        }
        return "GET";
      },
      set: function set(method) {
        if (method == null) {
          method = "";
        }
        _classPrivateFieldSet2(_method, this, String(method).toUpperCase());
      }
      /**
       *  The headers that will be used when requesting the URI. All
       *  keys are lower-case.
       *
       *  This object is a copy, so any changes will **NOT** be reflected
       *  in the ``FetchRequest``.
       *
       *  To set a header entry, use the ``setHeader`` method.
       */
    }, {
      key: "headers",
      get: function get() {
        var headers = Object.assign({}, _classPrivateFieldGet2(_headers, this));
        if (_classPrivateFieldGet2(_creds, this)) {
          headers["authorization"] = "Basic ".concat((0, base64_js_1.encodeBase64)((0, utf8_js_1.toUtf8Bytes)(_classPrivateFieldGet2(_creds, this))));
        }
        if (this.allowGzip) {
          headers["accept-encoding"] = "gzip";
        }
        if (headers["content-type"] == null && _classPrivateFieldGet2(_bodyType, this)) {
          headers["content-type"] = _classPrivateFieldGet2(_bodyType, this);
        }
        if (this.body) {
          headers["content-length"] = String(this.body.length);
        }
        return headers;
      }
      /**
       *  Get the header for %%key%%, ignoring case.
       */
    }, {
      key: "getHeader",
      value: function getHeader(key) {
        return this.headers[key.toLowerCase()];
      }
      /**
       *  Set the header for %%key%% to %%value%%. All values are coerced
       *  to a string.
       */
    }, {
      key: "setHeader",
      value: function setHeader(key, value) {
        _classPrivateFieldGet2(_headers, this)[String(key).toLowerCase()] = String(value);
      }
      /**
       *  Clear all headers, resetting all intrinsic headers.
       */
    }, {
      key: "clearHeaders",
      value: function clearHeaders() {
        _classPrivateFieldSet2(_headers, this, {});
      }
    }, {
      key: Symbol.iterator,
      value: function value() {
        var headers = this.headers;
        var keys = Object.keys(headers);
        var index = 0;
        return {
          next: function next() {
            if (index < keys.length) {
              var key = keys[index++];
              return {
                value: [key, headers[key]],
                done: false
              };
            }
            return {
              value: undefined,
              done: true
            };
          }
        };
      }
      /**
       *  The value that will be sent for the ``Authorization`` header.
       *
       *  To set the credentials, use the ``setCredentials`` method.
       */
    }, {
      key: "credentials",
      get: function get() {
        return _classPrivateFieldGet2(_creds, this) || null;
      }
      /**
       *  Sets an ``Authorization`` for %%username%% with %%password%%.
       */
    }, {
      key: "setCredentials",
      value: function setCredentials(username, password) {
        (0, errors_js_1.assertArgument)(!username.match(/:/), "invalid basic authentication username", "username", "[REDACTED]");
        _classPrivateFieldSet2(_creds, this, "".concat(username, ":").concat(password));
      }
      /**
       *  Enable and request gzip-encoded responses. The response will
       *  automatically be decompressed. //(default: true)//
       */
    }, {
      key: "allowGzip",
      get: function get() {
        return _classPrivateFieldGet2(_gzip, this);
      },
      set: function set(value) {
        _classPrivateFieldSet2(_gzip, this, !!value);
      }
      /**
       *  Allow ``Authentication`` credentials to be sent over insecure
       *  channels. //(default: false)//
       */
    }, {
      key: "allowInsecureAuthentication",
      get: function get() {
        return !!_classPrivateFieldGet2(_allowInsecure, this);
      },
      set: function set(value) {
        _classPrivateFieldSet2(_allowInsecure, this, !!value);
      }
      /**
       *  The timeout (in milliseconds) to wait for a complete response.
       *  //(default: 5 minutes)//
       */
    }, {
      key: "timeout",
      get: function get() {
        return _classPrivateFieldGet2(_timeout, this);
      },
      set: function set(timeout) {
        (0, errors_js_1.assertArgument)(timeout >= 0, "timeout must be non-zero", "timeout", timeout);
        _classPrivateFieldSet2(_timeout, this, timeout);
      }
      /**
       *  This function is called prior to each request, for example
       *  during a redirection or retry in case of server throttling.
       *
       *  This offers an opportunity to populate headers or update
       *  content before sending a request.
       */
    }, {
      key: "preflightFunc",
      get: function get() {
        return _classPrivateFieldGet2(_preflight, this) || null;
      },
      set: function set(preflight) {
        _classPrivateFieldSet2(_preflight, this, preflight);
      }
      /**
       *  This function is called after each response, offering an
       *  opportunity to provide client-level throttling or updating
       *  response data.
       *
       *  Any error thrown in this causes the ``send()`` to throw.
       *
       *  To schedule a retry attempt (assuming the maximum retry limit
       *  has not been reached), use [[response.throwThrottleError]].
       */
    }, {
      key: "processFunc",
      get: function get() {
        return _classPrivateFieldGet2(_process, this) || null;
      },
      set: function set(process) {
        _classPrivateFieldSet2(_process, this, process);
      }
      /**
       *  This function is called on each retry attempt.
       */
    }, {
      key: "retryFunc",
      get: function get() {
        return _classPrivateFieldGet2(_retry, this) || null;
      },
      set: function set(retry) {
        _classPrivateFieldSet2(_retry, this, retry);
      }
      /**
       *  This function is called to fetch content from HTTP and
       *  HTTPS URLs and is platform specific (e.g. nodejs vs
       *  browsers).
       *
       *  This is by default the currently registered global getUrl
       *  function, which can be changed using [[registerGetUrl]].
       *  If this has been set, setting is to ``null`` will cause
       *  this FetchRequest (and any future clones) to revert back to
       *  using the currently registered global getUrl function.
       *
       *  Setting this is generally not necessary, but may be useful
       *  for developers that wish to intercept requests or to
       *  configurege a proxy or other agent.
       */
    }, {
      key: "getUrlFunc",
      get: function get() {
        return _classPrivateFieldGet2(_getUrlFunc, this) || defaultGetUrlFunc;
      },
      set: function set(value) {
        _classPrivateFieldSet2(_getUrlFunc, this, value);
      }
    }, {
      key: "toString",
      value: function toString() {
        return "<FetchRequest method=".concat(JSON.stringify(this.method), " url=").concat(JSON.stringify(this.url), " headers=").concat(JSON.stringify(this.headers), " body=").concat(_classPrivateFieldGet2(_body, this) ? (0, data_js_1.hexlify)(_classPrivateFieldGet2(_body, this)) : "null", ">");
      }
      /**
       *  Update the throttle parameters used to determine maximum
       *  attempts and exponential-backoff properties.
       */
    }, {
      key: "setThrottleParams",
      value: function setThrottleParams(params) {
        if (params.slotInterval != null) {
          _classPrivateFieldGet2(_throttle, this).slotInterval = params.slotInterval;
        }
        if (params.maxAttempts != null) {
          _classPrivateFieldGet2(_throttle, this).maxAttempts = params.maxAttempts;
        }
      }
    }, {
      key: "send",
      value:
      /**
       *  Resolves to the response by sending the request.
       */
      function send() {
        (0, errors_js_1.assert)(_classPrivateFieldGet2(_signal, this) == null, "request already sent", "UNSUPPORTED_OPERATION", {
          operation: "fetchRequest.send"
        });
        _classPrivateFieldSet2(_signal, this, new FetchCancelSignal(this));
        return _assertClassBrand(_FetchRequest_brand, this, _send).call(this, 0, getTime() + this.timeout, 0, this, new FetchResponse(0, "", {}, null, this));
      }
      /**
       *  Cancels the inflight response, causing a ``CANCELLED``
       *  error to be rejected from the [[send]].
       */
    }, {
      key: "cancel",
      value: function cancel() {
        (0, errors_js_1.assert)(_classPrivateFieldGet2(_signal, this) != null, "request has not been sent", "UNSUPPORTED_OPERATION", {
          operation: "fetchRequest.cancel"
        });
        var signal = fetchSignals.get(this);
        if (!signal) {
          throw new Error("missing signal; should not happen");
        }
        signal();
      }
      /**
       *  Returns a new [[FetchRequest]] that represents the redirection
       *  to %%location%%.
       */
    }, {
      key: "redirect",
      value: function redirect(location) {
        // Redirection; for now we only support absolute locations
        var current = this.url.split(":")[0].toLowerCase();
        var target = location.split(":")[0].toLowerCase();
        // Don't allow redirecting:
        // - non-GET requests
        // - downgrading the security (e.g. https => http)
        // - to non-HTTP (or non-HTTPS) protocols [this could be relaxed?]
        (0, errors_js_1.assert)(this.method === "GET" && (current !== "https" || target !== "http") && location.match(/^https?:/), "unsupported redirect", "UNSUPPORTED_OPERATION", {
          operation: "redirect(".concat(this.method, " ").concat(JSON.stringify(this.url), " => ").concat(JSON.stringify(location), ")")
        });
        // Create a copy of this request, with a new URL
        var req = new FetchRequest(location);
        req.method = "GET";
        req.allowGzip = this.allowGzip;
        req.timeout = this.timeout;
        _classPrivateFieldSet2(_headers, req, Object.assign({}, _classPrivateFieldGet2(_headers, this)));
        if (_classPrivateFieldGet2(_body, this)) {
          _classPrivateFieldSet2(_body, req, new Uint8Array(_classPrivateFieldGet2(_body, this)));
        }
        _classPrivateFieldSet2(_bodyType, req, _classPrivateFieldGet2(_bodyType, this));
        // Do not forward credentials unless on the same domain; only absolute
        //req.allowInsecure = false;
        // paths are currently supported; may want a way to specify to forward?
        //setStore(req.#props, "creds", getStore(this.#pros, "creds"));
        return req;
      }
      /**
       *  Create a new copy of this request.
       */
    }, {
      key: "clone",
      value: function clone() {
        var clone = new FetchRequest(this.url);
        // Preserve "default method" (i.e. null)
        _classPrivateFieldSet2(_method, clone, _classPrivateFieldGet2(_method, this));
        // Preserve "default body" with type, copying the Uint8Array is present
        if (_classPrivateFieldGet2(_body, this)) {
          _classPrivateFieldSet2(_body, clone, _classPrivateFieldGet2(_body, this));
        }
        _classPrivateFieldSet2(_bodyType, clone, _classPrivateFieldGet2(_bodyType, this));
        // Preserve "default headers"
        _classPrivateFieldSet2(_headers, clone, Object.assign({}, _classPrivateFieldGet2(_headers, this)));
        // Credentials is readonly, so we copy internally
        _classPrivateFieldSet2(_creds, clone, _classPrivateFieldGet2(_creds, this));
        if (this.allowGzip) {
          clone.allowGzip = true;
        }
        clone.timeout = this.timeout;
        if (this.allowInsecureAuthentication) {
          clone.allowInsecureAuthentication = true;
        }
        _classPrivateFieldSet2(_preflight, clone, _classPrivateFieldGet2(_preflight, this));
        _classPrivateFieldSet2(_process, clone, _classPrivateFieldGet2(_process, this));
        _classPrivateFieldSet2(_retry, clone, _classPrivateFieldGet2(_retry, this));
        _classPrivateFieldSet2(_throttle, clone, Object.assign({}, _classPrivateFieldGet2(_throttle, this)));
        _classPrivateFieldSet2(_getUrlFunc, clone, _classPrivateFieldGet2(_getUrlFunc, this));
        return clone;
      }
      /**
       *  Locks all static configuration for gateways and FetchGetUrlFunc
       *  registration.
       */
    }], [{
      key: "lockConfig",
      value: function lockConfig() {
        locked = true;
      }
      /**
       *  Get the current Gateway function for %%scheme%%.
       */
    }, {
      key: "getGateway",
      value: function getGateway(scheme) {
        return Gateways[scheme.toLowerCase()] || null;
      }
      /**
       *  Use the %%func%% when fetching URIs using %%scheme%%.
       *
       *  This method affects all requests globally.
       *
       *  If [[lockConfig]] has been called, no change is made and this
       *  throws.
       */
    }, {
      key: "registerGateway",
      value: function registerGateway(scheme, func) {
        scheme = scheme.toLowerCase();
        if (scheme === "http" || scheme === "https") {
          throw new Error("cannot intercept ".concat(scheme, "; use registerGetUrl"));
        }
        if (locked) {
          throw new Error("gateways locked");
        }
        Gateways[scheme] = func;
      }
      /**
       *  Use %%getUrl%% when fetching URIs over HTTP and HTTPS requests.
       *
       *  This method affects all requests globally.
       *
       *  If [[lockConfig]] has been called, no change is made and this
       *  throws.
       */
    }, {
      key: "registerGetUrl",
      value: function registerGetUrl(getUrl) {
        if (locked) {
          throw new Error("gateways locked");
        }
        defaultGetUrlFunc = getUrl;
      }
      /**
       *  Creates a getUrl function that fetches content from HTTP and
       *  HTTPS URLs.
       *
       *  The available %%options%% are dependent on the platform
       *  implementation of the default getUrl function.
       *
       *  This is not generally something that is needed, but is useful
       *  when trying to customize simple behaviour when fetching HTTP
       *  content.
       */
    }, {
      key: "createGetUrlFunc",
      value: function createGetUrlFunc(options) {
        return (0, geturl_js_1.createGetUrl)(options);
      }
      /**
       *  Creates a function that can "fetch" data URIs.
       *
       *  Note that this is automatically done internally to support
       *  data URIs, so it is not necessary to register it.
       *
       *  This is not generally something that is needed, but may
       *  be useful in a wrapper to perfom custom data URI functionality.
       */
    }, {
      key: "createDataGateway",
      value: function createDataGateway() {
        return dataGatewayFunc;
      }
      /**
       *  Creates a function that will fetch IPFS (unvalidated) from
       *  a custom gateway baseUrl.
       *
       *  The default IPFS gateway used internally is
       *  ``"https:/\/gateway.ipfs.io/ipfs/"``.
       */
    }, {
      key: "createIpfsGatewayFunc",
      value: function createIpfsGatewayFunc(baseUrl) {
        return getIpfsGatewayFunc(baseUrl);
      }
    }]);
  }();
  function _send(_x5, _x6, _x7, _x8, _x9) {
    return _send2.apply(this, arguments);
  }
  function _send2() {
    _send2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(attempt, expires, delay, _request, _response) {
      var req, scheme, result, _response2, resp, response, _req$redirect, location, _req$clone, retryAfter, _delay, _req$clone2, _delay2;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            if (!(attempt >= _classPrivateFieldGet2(_throttle, this).maxAttempts)) {
              _context3.next = 2;
              break;
            }
            return _context3.abrupt("return", _response.makeServerError("exceeded maximum retry limit"));
          case 2:
            (0, errors_js_1.assert)(getTime() <= expires, "timeout", "TIMEOUT", {
              operation: "request.send",
              reason: "timeout",
              request: _request
            });
            if (!(delay > 0)) {
              _context3.next = 6;
              break;
            }
            _context3.next = 6;
            return wait(delay);
          case 6:
            req = this.clone();
            scheme = (req.url.split(":")[0] || "").toLowerCase(); // Process any Gateways
            if (!(scheme in Gateways)) {
              _context3.next = 27;
              break;
            }
            _context3.next = 11;
            return Gateways[scheme](req.url, checkSignal(_classPrivateFieldGet2(_signal, _request)));
          case 11:
            result = _context3.sent;
            if (!(result instanceof FetchResponse)) {
              _context3.next = 26;
              break;
            }
            _response2 = result;
            if (!this.processFunc) {
              _context3.next = 25;
              break;
            }
            checkSignal(_classPrivateFieldGet2(_signal, _request));
            _context3.prev = 16;
            _context3.next = 19;
            return this.processFunc(req, _response2);
          case 19:
            _response2 = _context3.sent;
            _context3.next = 25;
            break;
          case 22:
            _context3.prev = 22;
            _context3.t0 = _context3["catch"](16);
            // Something went wrong during processing; throw a 5xx server error
            if (_context3.t0.throttle == null || typeof _context3.t0.stall !== "number") {
              _response2.makeServerError("error in post-processing function", _context3.t0).assertOk();
            }
            // Ignore throttling
          case 25:
            return _context3.abrupt("return", _response2);
          case 26:
            req = result;
          case 27:
            if (!this.preflightFunc) {
              _context3.next = 31;
              break;
            }
            _context3.next = 30;
            return this.preflightFunc(req);
          case 30:
            req = _context3.sent;
          case 31:
            _context3.next = 33;
            return this.getUrlFunc(req, checkSignal(_classPrivateFieldGet2(_signal, _request)));
          case 33:
            resp = _context3.sent;
            response = new FetchResponse(resp.statusCode, resp.statusMessage, resp.headers, resp.body, _request);
            if (!(response.statusCode === 301 || response.statusCode === 302)) {
              _context3.next = 46;
              break;
            }
            _context3.prev = 36;
            location = response.headers.location || "";
            return _context3.abrupt("return", _assertClassBrand(_FetchRequest_brand, _req$redirect = req.redirect(location), _send).call(_req$redirect, attempt + 1, expires, 0, _request, response));
          case 41:
            _context3.prev = 41;
            _context3.t1 = _context3["catch"](36);
          case 43:
            return _context3.abrupt("return", response);
          case 46:
            if (!(response.statusCode === 429)) {
              _context3.next = 57;
              break;
            }
            _context3.t2 = this.retryFunc == null;
            if (_context3.t2) {
              _context3.next = 52;
              break;
            }
            _context3.next = 51;
            return this.retryFunc(req, response, attempt);
          case 51:
            _context3.t2 = _context3.sent;
          case 52:
            if (!_context3.t2) {
              _context3.next = 57;
              break;
            }
            retryAfter = response.headers["retry-after"];
            _delay = _classPrivateFieldGet2(_throttle, this).slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));
            if (typeof retryAfter === "string" && retryAfter.match(/^[1-9][0-9]*$/)) {
              _delay = parseInt(retryAfter);
            }
            return _context3.abrupt("return", _assertClassBrand(_FetchRequest_brand, _req$clone = req.clone(), _send).call(_req$clone, attempt + 1, expires, _delay, _request, response));
          case 57:
            if (!this.processFunc) {
              _context3.next = 72;
              break;
            }
            checkSignal(_classPrivateFieldGet2(_signal, _request));
            _context3.prev = 59;
            _context3.next = 62;
            return this.processFunc(req, response);
          case 62:
            response = _context3.sent;
            _context3.next = 72;
            break;
          case 65:
            _context3.prev = 65;
            _context3.t3 = _context3["catch"](59);
            // Something went wrong during processing; throw a 5xx server error
            if (_context3.t3.throttle == null || typeof _context3.t3.stall !== "number") {
              response.makeServerError("error in post-processing function", _context3.t3).assertOk();
            }
            // Throttle
            _delay2 = _classPrivateFieldGet2(_throttle, this).slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));
            if (_context3.t3.stall >= 0) {
              _delay2 = _context3.t3.stall;
            }
            return _context3.abrupt("return", _assertClassBrand(_FetchRequest_brand, _req$clone2 = req.clone(), _send).call(_req$clone2, attempt + 1, expires, _delay2, _request, response));
          case 72:
            return _context3.abrupt("return", response);
          case 73:
          case "end":
            return _context3.stop();
        }
      }, _callee3, this, [[16, 22], [36, 41], [59, 65]]);
    }));
    return _send2.apply(this, arguments);
  }
  fetch.FetchRequest = FetchRequest;
  /**
   *  The response for a FetchRequest.
   */
  var _statusCode = /*#__PURE__*/new WeakMap();
  var _statusMessage = /*#__PURE__*/new WeakMap();
  var _headers2 = /*#__PURE__*/new WeakMap();
  var _body2 = /*#__PURE__*/new WeakMap();
  var _request2 = /*#__PURE__*/new WeakMap();
  var _error = /*#__PURE__*/new WeakMap();
  var FetchResponse = /*#__PURE__*/function () {
    function FetchResponse(statusCode, statusMessage, headers, body, request) {
      _classCallCheck(this, FetchResponse);
      _classPrivateFieldInitSpec(this, _statusCode, void 0);
      _classPrivateFieldInitSpec(this, _statusMessage, void 0);
      _classPrivateFieldInitSpec(this, _headers2, void 0);
      _classPrivateFieldInitSpec(this, _body2, void 0);
      _classPrivateFieldInitSpec(this, _request2, void 0);
      _classPrivateFieldInitSpec(this, _error, void 0);
      _classPrivateFieldSet2(_statusCode, this, statusCode);
      _classPrivateFieldSet2(_statusMessage, this, statusMessage);
      _classPrivateFieldSet2(_headers2, this, Object.keys(headers).reduce(function (accum, k) {
        accum[k.toLowerCase()] = String(headers[k]);
        return accum;
      }, {}));
      _classPrivateFieldSet2(_body2, this, body == null ? null : new Uint8Array(body));
      _classPrivateFieldSet2(_request2, this, request || null);
      _classPrivateFieldSet2(_error, this, {
        message: ""
      });
    }
    /**
     *  Return a Response with matching headers and body, but with
     *  an error status code (i.e. 599) and %%message%% with an
     *  optional %%error%%.
     */
    return _createClass(FetchResponse, [{
      key: "toString",
      value: function toString() {
        return "<FetchResponse status=".concat(this.statusCode, " body=").concat(_classPrivateFieldGet2(_body2, this) ? (0, data_js_1.hexlify)(_classPrivateFieldGet2(_body2, this)) : "null", ">");
      }
      /**
       *  The response status code.
       */
    }, {
      key: "statusCode",
      get: function get() {
        return _classPrivateFieldGet2(_statusCode, this);
      }
      /**
       *  The response status message.
       */
    }, {
      key: "statusMessage",
      get: function get() {
        return _classPrivateFieldGet2(_statusMessage, this);
      }
      /**
       *  The response headers. All keys are lower-case.
       */
    }, {
      key: "headers",
      get: function get() {
        return Object.assign({}, _classPrivateFieldGet2(_headers2, this));
      }
      /**
       *  The response body, or ``null`` if there was no body.
       */
    }, {
      key: "body",
      get: function get() {
        return _classPrivateFieldGet2(_body2, this) == null ? null : new Uint8Array(_classPrivateFieldGet2(_body2, this));
      }
      /**
       *  The response body as a UTF-8 encoded string, or the empty
       *  string (i.e. ``""``) if there was no body.
       *
       *  An error is thrown if the body is invalid UTF-8 data.
       */
    }, {
      key: "bodyText",
      get: function get() {
        try {
          return _classPrivateFieldGet2(_body2, this) == null ? "" : (0, utf8_js_1.toUtf8String)(_classPrivateFieldGet2(_body2, this));
        } catch (error) {
          (0, errors_js_1.assert)(false, "response body is not valid UTF-8 data", "UNSUPPORTED_OPERATION", {
            operation: "bodyText",
            info: {
              response: this
            }
          });
        }
      }
      /**
       *  The response body, decoded as JSON.
       *
       *  An error is thrown if the body is invalid JSON-encoded data
       *  or if there was no body.
       */
    }, {
      key: "bodyJson",
      get: function get() {
        try {
          return JSON.parse(this.bodyText);
        } catch (error) {
          (0, errors_js_1.assert)(false, "response body is not valid JSON", "UNSUPPORTED_OPERATION", {
            operation: "bodyJson",
            info: {
              response: this
            }
          });
        }
      }
    }, {
      key: Symbol.iterator,
      value: function value() {
        var headers = this.headers;
        var keys = Object.keys(headers);
        var index = 0;
        return {
          next: function next() {
            if (index < keys.length) {
              var key = keys[index++];
              return {
                value: [key, headers[key]],
                done: false
              };
            }
            return {
              value: undefined,
              done: true
            };
          }
        };
      }
    }, {
      key: "makeServerError",
      value: function makeServerError(message, error) {
        var statusMessage;
        if (!message) {
          message = "".concat(this.statusCode, " ").concat(this.statusMessage);
          statusMessage = "CLIENT ESCALATED SERVER ERROR (".concat(message, ")");
        } else {
          statusMessage = "CLIENT ESCALATED SERVER ERROR (".concat(this.statusCode, " ").concat(this.statusMessage, "; ").concat(message, ")");
        }
        var response = new FetchResponse(599, statusMessage, this.headers, this.body, _classPrivateFieldGet2(_request2, this) || undefined);
        _classPrivateFieldSet2(_error, response, {
          message: message,
          error: error
        });
        return response;
      }
      /**
       *  If called within a [request.processFunc](FetchRequest-processFunc)
       *  call, causes the request to retry as if throttled for %%stall%%
       *  milliseconds.
       */
    }, {
      key: "throwThrottleError",
      value: function throwThrottleError(message, stall) {
        if (stall == null) {
          stall = -1;
        } else {
          (0, errors_js_1.assertArgument)(Number.isInteger(stall) && stall >= 0, "invalid stall timeout", "stall", stall);
        }
        var error = new Error(message || "throttling requests");
        (0, properties_js_1.defineProperties)(error, {
          stall: stall,
          throttle: true
        });
        throw error;
      }
      /**
       *  Get the header value for %%key%%, ignoring case.
       */
    }, {
      key: "getHeader",
      value: function getHeader(key) {
        return this.headers[key.toLowerCase()];
      }
      /**
       *  Returns true if the response has a body.
       */
    }, {
      key: "hasBody",
      value: function hasBody() {
        return _classPrivateFieldGet2(_body2, this) != null;
      }
      /**
       *  The request made for this response.
       */
    }, {
      key: "request",
      get: function get() {
        return _classPrivateFieldGet2(_request2, this);
      }
      /**
       *  Returns true if this response was a success statusCode.
       */
    }, {
      key: "ok",
      value: function ok() {
        return _classPrivateFieldGet2(_error, this).message === "" && this.statusCode >= 200 && this.statusCode < 300;
      }
      /**
       *  Throws a ``SERVER_ERROR`` if this response is not ok.
       */
    }, {
      key: "assertOk",
      value: function assertOk() {
        if (this.ok()) {
          return;
        }
        var _classPrivateFieldGet2$1 = _classPrivateFieldGet2(_error, this),
          message = _classPrivateFieldGet2$1.message,
          error = _classPrivateFieldGet2$1.error;
        if (message === "") {
          message = "server response ".concat(this.statusCode, " ").concat(this.statusMessage);
        }
        var requestUrl = null;
        if (this.request) {
          requestUrl = this.request.url;
        }
        var responseBody = null;
        try {
          if (_classPrivateFieldGet2(_body2, this)) {
            responseBody = (0, utf8_js_1.toUtf8String)(_classPrivateFieldGet2(_body2, this));
          }
        } catch (e) {}
        (0, errors_js_1.assert)(false, message, "SERVER_ERROR", {
          request: this.request || "unknown request",
          response: this,
          error: error,
          info: {
            requestUrl: requestUrl,
            responseBody: responseBody,
            responseStatus: "".concat(this.statusCode, " ").concat(this.statusMessage)
          }
        });
      }
    }]);
  }();
  fetch.FetchResponse = FetchResponse;
  function getTime() {
    return new Date().getTime();
  }
  function unpercent(value) {
    return (0, utf8_js_1.toUtf8Bytes)(value.replace(/%([0-9a-f][0-9a-f])/gi, function (all, code) {
      return String.fromCharCode(parseInt(code, 16));
    }));
  }
  function wait(delay) {
    return new Promise(function (resolve) {
      return setTimeout(resolve, delay);
    });
  }
  return fetch;
}

var fixednumber = {};

var hasRequiredFixednumber;
function requireFixednumber() {
  var _FixedNumber;
  if (hasRequiredFixednumber) return fixednumber;
  hasRequiredFixednumber = 1;
  Object.defineProperty(fixednumber, "__esModule", {
    value: true
  });
  fixednumber.FixedNumber = void 0;
  /**
   *  The **FixedNumber** class permits using values with decimal places,
   *  using fixed-pont math.
   *
   *  Fixed-point math is still based on integers under-the-hood, but uses an
   *  internal offset to store fractional components below, and each operation
   *  corrects for this after each operation.
   *
   *  @_section: api/utils/fixed-point-math:Fixed-Point Maths  [about-fixed-point-math]
   */
  var data_js_1 = /*@__PURE__*/requireData();
  var errors_js_1 = /*@__PURE__*/requireErrors();
  var maths_js_1 = /*@__PURE__*/requireMaths();
  var properties_js_1 = /*@__PURE__*/requireProperties();
  var BN_N1 = BigInt(-1);
  var BN_0 = BigInt(0);
  var BN_1 = BigInt(1);
  var BN_5 = BigInt(5);
  var _guard = {};
  // Constant to pull zeros from for multipliers
  var Zeros = "0000";
  while (Zeros.length < 80) {
    Zeros += Zeros;
  }
  // Returns a string "1" followed by decimal "0"s
  function getTens(decimals) {
    var result = Zeros;
    while (result.length < decimals) {
      result += result;
    }
    return BigInt("1" + result.substring(0, decimals));
  }
  function checkValue(val, format, safeOp) {
    var width = BigInt(format.width);
    if (format.signed) {
      var limit = BN_1 << width - BN_1;
      (0, errors_js_1.assert)(safeOp == null || val >= -limit && val < limit, "overflow", "NUMERIC_FAULT", {
        operation: safeOp,
        fault: "overflow",
        value: val
      });
      if (val > BN_0) {
        val = (0, maths_js_1.fromTwos)((0, maths_js_1.mask)(val, width), width);
      } else {
        val = -(0, maths_js_1.fromTwos)((0, maths_js_1.mask)(-val, width), width);
      }
    } else {
      var _limit = BN_1 << width;
      (0, errors_js_1.assert)(safeOp == null || val >= 0 && val < _limit, "overflow", "NUMERIC_FAULT", {
        operation: safeOp,
        fault: "overflow",
        value: val
      });
      val = (val % _limit + _limit) % _limit & _limit - BN_1;
    }
    return val;
  }
  function getFormat(value) {
    if (typeof value === "number") {
      value = "fixed128x".concat(value);
    }
    var signed = true;
    var width = 128;
    var decimals = 18;
    if (typeof value === "string") {
      // Parse the format string
      if (value === "fixed") ; else if (value === "ufixed") {
        signed = false;
      } else {
        var match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
        (0, errors_js_1.assertArgument)(match, "invalid fixed format", "format", value);
        signed = match[1] !== "u";
        width = parseInt(match[2]);
        decimals = parseInt(match[3]);
      }
    } else if (value) {
      // Extract the values from the object
      var v = value;
      var check = function check(key, type, defaultValue) {
        if (v[key] == null) {
          return defaultValue;
        }
        (0, errors_js_1.assertArgument)(_typeof(v[key]) === type, "invalid fixed format (" + key + " not " + type + ")", "format." + key, v[key]);
        return v[key];
      };
      signed = check("signed", "boolean", signed);
      width = check("width", "number", width);
      decimals = check("decimals", "number", decimals);
    }
    (0, errors_js_1.assertArgument)(width % 8 === 0, "invalid FixedNumber width (not byte aligned)", "format.width", width);
    (0, errors_js_1.assertArgument)(decimals <= 80, "invalid FixedNumber decimals (too large)", "format.decimals", decimals);
    var name = (signed ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
    return {
      signed: signed,
      width: width,
      decimals: decimals,
      name: name
    };
  }
  function toString(val, decimals) {
    var negative = "";
    if (val < BN_0) {
      negative = "-";
      val *= BN_N1;
    }
    var str = val.toString();
    // No decimal point for whole values
    if (decimals === 0) {
      return negative + str;
    }
    // Pad out to the whole component (including a whole digit)
    while (str.length <= decimals) {
      str = Zeros + str;
    }
    // Insert the decimal point
    var index = str.length - decimals;
    str = str.substring(0, index) + "." + str.substring(index);
    // Trim the whole component (leaving at least one 0)
    while (str[0] === "0" && str[1] !== ".") {
      str = str.substring(1);
    }
    // Trim the decimal component (leaving at least one 0)
    while (str[str.length - 1] === "0" && str[str.length - 2] !== ".") {
      str = str.substring(0, str.length - 1);
    }
    return negative + str;
  }
  /**
   *  A FixedNumber represents a value over its [[FixedFormat]]
   *  arithmetic field.
   *
   *  A FixedNumber can be used to perform math, losslessly, on
   *  values which have decmial places.
   *
   *  A FixedNumber has a fixed bit-width to store values in, and stores all
   *  values internally by multiplying the value by 10 raised to the power of
   *  %%decimals%%.
   *
   *  If operations are performed that cause a value to grow too high (close to
   *  positive infinity) or too low (close to negative infinity), the value
   *  is said to //overflow//.
   *
   *  For example, an 8-bit signed value, with 0 decimals may only be within
   *  the range ``-128`` to ``127``; so ``-128 - 1`` will overflow and become
   *  ``127``. Likewise, ``127 + 1`` will overflow and become ``-127``.
   *
   *  Many operation have a normal and //unsafe// variant. The normal variant
   *  will throw a [[NumericFaultError]] on any overflow, while the //unsafe//
   *  variant will silently allow overflow, corrupting its value value.
   *
   *  If operations are performed that cause a value to become too small
   *  (close to zero), the value loses precison and is said to //underflow//.
   *
   *  For example, an value with 1 decimal place may store a number as small
   *  as ``0.1``, but the value of ``0.1 / 2`` is ``0.05``, which cannot fit
   *  into 1 decimal place, so underflow occurs which means precision is lost
   *  and the value becomes ``0``.
   *
   *  Some operations have a normal and //signalling// variant. The normal
   *  variant will silently ignore underflow, while the //signalling// variant
   *  will thow a [[NumericFaultError]] on underflow.
   */
  var _format2 = /*#__PURE__*/new WeakMap();
  var _val = /*#__PURE__*/new WeakMap();
  var _tens = /*#__PURE__*/new WeakMap();
  var _FixedNumber_brand = /*#__PURE__*/new WeakSet();
  var FixedNumber = /*#__PURE__*/function () {
    // Use this when changing this file to get some typing info,
    // but then switch to any to mask the internal type
    //constructor(guard: any, value: bigint, format: _FixedFormat) {
    /**
     *  @private
     */
    function FixedNumber(guard, value, format) {
      _classCallCheck(this, FixedNumber);
      _classPrivateMethodInitSpec(this, _FixedNumber_brand);
      /**
       *  The specific fixed-point arithmetic field for this value.
       */
      _defineProperty(this, "format", void 0);
      _classPrivateFieldInitSpec(this, _format2, void 0);
      // The actual value (accounting for decimals)
      _classPrivateFieldInitSpec(this, _val, void 0);
      // A base-10 value to multiple values by to maintain the magnitude
      _classPrivateFieldInitSpec(this, _tens, void 0);
      /**
       *  This is a property so console.log shows a human-meaningful value.
       *
       *  @private
       */
      _defineProperty(this, "_value", void 0);
      (0, errors_js_1.assertPrivate)(guard, _guard, "FixedNumber");
      _classPrivateFieldSet2(_val, this, value);
      _classPrivateFieldSet2(_format2, this, format);
      var _value = toString(value, format.decimals);
      (0, properties_js_1.defineProperties)(this, {
        format: format.name,
        _value: _value
      });
      _classPrivateFieldSet2(_tens, this, getTens(format.decimals));
    }
    /**
     *  If true, negative values are permitted, otherwise only
     *  positive values and zero are allowed.
     */
    return _createClass(FixedNumber, [{
      key: "signed",
      get: function get() {
        return _classPrivateFieldGet2(_format2, this).signed;
      }
      /**
       *  The number of bits available to store the value.
       */
    }, {
      key: "width",
      get: function get() {
        return _classPrivateFieldGet2(_format2, this).width;
      }
      /**
       *  The number of decimal places in the fixed-point arithment field.
       */
    }, {
      key: "decimals",
      get: function get() {
        return _classPrivateFieldGet2(_format2, this).decimals;
      }
      /**
       *  The value as an integer, based on the smallest unit the
       *  [[decimals]] allow.
       */
    }, {
      key: "value",
      get: function get() {
        return _classPrivateFieldGet2(_val, this);
      }
    }, {
      key: "addUnsafe",
      value:
      /**
       *  Returns a new [[FixedNumber]] with the result of %%this%% added
       *  to %%other%%, ignoring overflow.
       */
      function addUnsafe(other) {
        return _assertClassBrand(_FixedNumber_brand, this, _add).call(this, other);
      }
      /**
       *  Returns a new [[FixedNumber]] with the result of %%this%% added
       *  to %%other%%. A [[NumericFaultError]] is thrown if overflow
       *  occurs.
       */
    }, {
      key: "add",
      value: function add(other) {
        return _assertClassBrand(_FixedNumber_brand, this, _add).call(this, other, "add");
      }
    }, {
      key: "subUnsafe",
      value:
      /**
       *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted
       *  from %%this%%, ignoring overflow.
       */
      function subUnsafe(other) {
        return _assertClassBrand(_FixedNumber_brand, this, _sub).call(this, other);
      }
      /**
       *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted
       *  from %%this%%. A [[NumericFaultError]] is thrown if overflow
       *  occurs.
       */
    }, {
      key: "sub",
      value: function sub(other) {
        return _assertClassBrand(_FixedNumber_brand, this, _sub).call(this, other, "sub");
      }
    }, {
      key: "mulUnsafe",
      value:
      /**
       *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied
       *  by %%other%%, ignoring overflow and underflow (precision loss).
       */
      function mulUnsafe(other) {
        return _assertClassBrand(_FixedNumber_brand, this, _mul).call(this, other);
      }
      /**
       *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied
       *  by %%other%%. A [[NumericFaultError]] is thrown if overflow
       *  occurs.
       */
    }, {
      key: "mul",
      value: function mul(other) {
        return _assertClassBrand(_FixedNumber_brand, this, _mul).call(this, other, "mul");
      }
      /**
       *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied
       *  by %%other%%. A [[NumericFaultError]] is thrown if overflow
       *  occurs or if underflow (precision loss) occurs.
       */
    }, {
      key: "mulSignal",
      value: function mulSignal(other) {
        _assertClassBrand(_FixedNumber_brand, this, _checkFormat).call(this, other);
        var value = _classPrivateFieldGet2(_val, this) * _classPrivateFieldGet2(_val, other);
        (0, errors_js_1.assert)(value % _classPrivateFieldGet2(_tens, this) === BN_0, "precision lost during signalling mul", "NUMERIC_FAULT", {
          operation: "mulSignal",
          fault: "underflow",
          value: this
        });
        return _assertClassBrand(_FixedNumber_brand, this, _checkValue).call(this, value / _classPrivateFieldGet2(_tens, this), "mulSignal");
      }
    }, {
      key: "divUnsafe",
      value:
      /**
       *  Returns a new [[FixedNumber]] with the result of %%this%% divided
       *  by %%other%%, ignoring underflow (precision loss). A
       *  [[NumericFaultError]] is thrown if overflow occurs.
       */
      function divUnsafe(other) {
        return _assertClassBrand(_FixedNumber_brand, this, _div).call(this, other);
      }
      /**
       *  Returns a new [[FixedNumber]] with the result of %%this%% divided
       *  by %%other%%, ignoring underflow (precision loss). A
       *  [[NumericFaultError]] is thrown if overflow occurs.
       */
    }, {
      key: "div",
      value: function div(other) {
        return _assertClassBrand(_FixedNumber_brand, this, _div).call(this, other, "div");
      }
      /**
       *  Returns a new [[FixedNumber]] with the result of %%this%% divided
       *  by %%other%%. A [[NumericFaultError]] is thrown if underflow
       *  (precision loss) occurs.
       */
    }, {
      key: "divSignal",
      value: function divSignal(other) {
        (0, errors_js_1.assert)(_classPrivateFieldGet2(_val, other) !== BN_0, "division by zero", "NUMERIC_FAULT", {
          operation: "div",
          fault: "divide-by-zero",
          value: this
        });
        _assertClassBrand(_FixedNumber_brand, this, _checkFormat).call(this, other);
        var value = _classPrivateFieldGet2(_val, this) * _classPrivateFieldGet2(_tens, this);
        (0, errors_js_1.assert)(value % _classPrivateFieldGet2(_val, other) === BN_0, "precision lost during signalling div", "NUMERIC_FAULT", {
          operation: "divSignal",
          fault: "underflow",
          value: this
        });
        return _assertClassBrand(_FixedNumber_brand, this, _checkValue).call(this, value / _classPrivateFieldGet2(_val, other), "divSignal");
      }
      /**
       *  Returns a comparison result between %%this%% and %%other%%.
       *
       *  This is suitable for use in sorting, where ``-1`` implies %%this%%
       *  is smaller, ``1`` implies %%this%% is larger and ``0`` implies
       *  both are equal.
       */
    }, {
      key: "cmp",
      value: function cmp(other) {
        var a = this.value,
          b = other.value;
        // Coerce a and b to the same magnitude
        var delta = this.decimals - other.decimals;
        if (delta > 0) {
          b *= getTens(delta);
        } else if (delta < 0) {
          a *= getTens(-delta);
        }
        // Comnpare
        if (a < b) {
          return -1;
        }
        if (a > b) {
          return 1;
        }
        return 0;
      }
      /**
       *  Returns true if %%other%% is equal to %%this%%.
       */
    }, {
      key: "eq",
      value: function eq(other) {
        return this.cmp(other) === 0;
      }
      /**
       *  Returns true if %%other%% is less than to %%this%%.
       */
    }, {
      key: "lt",
      value: function lt(other) {
        return this.cmp(other) < 0;
      }
      /**
       *  Returns true if %%other%% is less than or equal to %%this%%.
       */
    }, {
      key: "lte",
      value: function lte(other) {
        return this.cmp(other) <= 0;
      }
      /**
       *  Returns true if %%other%% is greater than to %%this%%.
       */
    }, {
      key: "gt",
      value: function gt(other) {
        return this.cmp(other) > 0;
      }
      /**
       *  Returns true if %%other%% is greater than or equal to %%this%%.
       */
    }, {
      key: "gte",
      value: function gte(other) {
        return this.cmp(other) >= 0;
      }
      /**
       *  Returns a new [[FixedNumber]] which is the largest **integer**
       *  that is less than or equal to %%this%%.
       *
       *  The decimal component of the result will always be ``0``.
       */
    }, {
      key: "floor",
      value: function floor() {
        var val = _classPrivateFieldGet2(_val, this);
        if (_classPrivateFieldGet2(_val, this) < BN_0) {
          val -= _classPrivateFieldGet2(_tens, this) - BN_1;
        }
        val = _classPrivateFieldGet2(_val, this) / _classPrivateFieldGet2(_tens, this) * _classPrivateFieldGet2(_tens, this);
        return _assertClassBrand(_FixedNumber_brand, this, _checkValue).call(this, val, "floor");
      }
      /**
       *  Returns a new [[FixedNumber]] which is the smallest **integer**
       *  that is greater than or equal to %%this%%.
       *
       *  The decimal component of the result will always be ``0``.
       */
    }, {
      key: "ceiling",
      value: function ceiling() {
        var val = _classPrivateFieldGet2(_val, this);
        if (_classPrivateFieldGet2(_val, this) > BN_0) {
          val += _classPrivateFieldGet2(_tens, this) - BN_1;
        }
        val = _classPrivateFieldGet2(_val, this) / _classPrivateFieldGet2(_tens, this) * _classPrivateFieldGet2(_tens, this);
        return _assertClassBrand(_FixedNumber_brand, this, _checkValue).call(this, val, "ceiling");
      }
      /**
       *  Returns a new [[FixedNumber]] with the decimal component
       *  rounded up on ties at %%decimals%% places.
       */
    }, {
      key: "round",
      value: function round(decimals) {
        if (decimals == null) {
          decimals = 0;
        }
        // Not enough precision to not already be rounded
        if (decimals >= this.decimals) {
          return this;
        }
        var delta = this.decimals - decimals;
        var bump = BN_5 * getTens(delta - 1);
        var value = this.value + bump;
        var tens = getTens(delta);
        value = value / tens * tens;
        checkValue(value, _classPrivateFieldGet2(_format2, this), "round");
        return new FixedNumber(_guard, value, _classPrivateFieldGet2(_format2, this));
      }
      /**
       *  Returns true if %%this%% is equal to ``0``.
       */
    }, {
      key: "isZero",
      value: function isZero() {
        return _classPrivateFieldGet2(_val, this) === BN_0;
      }
      /**
       *  Returns true if %%this%% is less than ``0``.
       */
    }, {
      key: "isNegative",
      value: function isNegative() {
        return _classPrivateFieldGet2(_val, this) < BN_0;
      }
      /**
       *  Returns the string representation of %%this%%.
       */
    }, {
      key: "toString",
      value: function toString() {
        return this._value;
      }
      /**
       *  Returns a float approximation.
       *
       *  Due to IEEE 754 precission (or lack thereof), this function
       *  can only return an approximation and most values will contain
       *  rounding errors.
       */
    }, {
      key: "toUnsafeFloat",
      value: function toUnsafeFloat() {
        return parseFloat(this.toString());
      }
      /**
       *  Return a new [[FixedNumber]] with the same value but has had
       *  its field set to %%format%%.
       *
       *  This will throw if the value cannot fit into %%format%%.
       */
    }, {
      key: "toFormat",
      value: function toFormat(format) {
        return FixedNumber.fromString(this.toString(), format);
      }
      /**
       *  Creates a new [[FixedNumber]] for %%value%% divided by
       *  %%decimal%% places with %%format%%.
       *
       *  This will throw a [[NumericFaultError]] if %%value%% (once adjusted
       *  for %%decimals%%) cannot fit in %%format%%, either due to overflow
       *  or underflow (precision loss).
       */
    }], [{
      key: "fromValue",
      value: function fromValue(_value, _decimals, _format) {
        var decimals = _decimals == null ? 0 : (0, maths_js_1.getNumber)(_decimals);
        var format = getFormat(_format);
        var value = (0, maths_js_1.getBigInt)(_value, "value");
        var delta = decimals - format.decimals;
        if (delta > 0) {
          var tens = getTens(delta);
          (0, errors_js_1.assert)(value % tens === BN_0, "value loses precision for format", "NUMERIC_FAULT", {
            operation: "fromValue",
            fault: "underflow",
            value: _value
          });
          value /= tens;
        } else if (delta < 0) {
          value *= getTens(-delta);
        }
        checkValue(value, format, "fromValue");
        return new FixedNumber(_guard, value, format);
      }
      /**
       *  Creates a new [[FixedNumber]] for %%value%% with %%format%%.
       *
       *  This will throw a [[NumericFaultError]] if %%value%% cannot fit
       *  in %%format%%, either due to overflow or underflow (precision loss).
       */
    }, {
      key: "fromString",
      value: function fromString(_value, _format) {
        var match = _value.match(/^(-?)([0-9]*)\.?([0-9]*)$/);
        (0, errors_js_1.assertArgument)(match && match[2].length + match[3].length > 0, "invalid FixedNumber string value", "value", _value);
        var format = getFormat(_format);
        var whole = match[2] || "0",
          decimal = match[3] || "";
        // Pad out the decimals
        while (decimal.length < format.decimals) {
          decimal += Zeros;
        }
        // Check precision is safe
        (0, errors_js_1.assert)(decimal.substring(format.decimals).match(/^0*$/), "too many decimals for format", "NUMERIC_FAULT", {
          operation: "fromString",
          fault: "underflow",
          value: _value
        });
        // Remove extra padding
        decimal = decimal.substring(0, format.decimals);
        var value = BigInt(match[1] + whole + decimal);
        checkValue(value, format, "fromString");
        return new FixedNumber(_guard, value, format);
      }
      /**
       *  Creates a new [[FixedNumber]] with the big-endian representation
       *  %%value%% with %%format%%.
       *
       *  This will throw a [[NumericFaultError]] if %%value%% cannot fit
       *  in %%format%% due to overflow.
       */
    }, {
      key: "fromBytes",
      value: function fromBytes(_value, _format) {
        var value = (0, maths_js_1.toBigInt)((0, data_js_1.getBytes)(_value, "value"));
        var format = getFormat(_format);
        if (format.signed) {
          value = (0, maths_js_1.fromTwos)(value, format.width);
        }
        checkValue(value, format, "fromBytes");
        return new FixedNumber(_guard, value, format);
      }
    }]);
  }();
  _FixedNumber = FixedNumber;
  function _checkFormat(other) {
    (0, errors_js_1.assertArgument)(this.format === other.format, "incompatible format; use fixedNumber.toFormat", "other", other);
  }
  function _checkValue(val, safeOp) {
    /*
            const width = BigInt(this.width);
            if (this.signed) {
                const limit = (BN_1 << (width - BN_1));
                assert(safeOp == null || (val >= -limit  && val < limit), "overflow", "NUMERIC_FAULT", {
                    operation: <string>safeOp, fault: "overflow", value: val
                });
    
                if (val > BN_0) {
                    val = fromTwos(mask(val, width), width);
                } else {
                    val = -fromTwos(mask(-val, width), width);
                }
    
            } else {
                const masked = mask(val, width);
                assert(safeOp == null || (val >= 0 && val === masked), "overflow", "NUMERIC_FAULT", {
                    operation: <string>safeOp, fault: "overflow", value: val
                });
                val = masked;
            }
    */
    val = checkValue(val, _classPrivateFieldGet2(_format2, this), safeOp);
    return new _FixedNumber(_guard, val, _classPrivateFieldGet2(_format2, this));
  }
  function _add(o, safeOp) {
    _assertClassBrand(_FixedNumber_brand, this, _checkFormat).call(this, o);
    return _assertClassBrand(_FixedNumber_brand, this, _checkValue).call(this, _classPrivateFieldGet2(_val, this) + _classPrivateFieldGet2(_val, o), safeOp);
  }
  function _sub(o, safeOp) {
    _assertClassBrand(_FixedNumber_brand, this, _checkFormat).call(this, o);
    return _assertClassBrand(_FixedNumber_brand, this, _checkValue).call(this, _classPrivateFieldGet2(_val, this) - _classPrivateFieldGet2(_val, o), safeOp);
  }
  function _mul(o, safeOp) {
    _assertClassBrand(_FixedNumber_brand, this, _checkFormat).call(this, o);
    return _assertClassBrand(_FixedNumber_brand, this, _checkValue).call(this, _classPrivateFieldGet2(_val, this) * _classPrivateFieldGet2(_val, o) / _classPrivateFieldGet2(_tens, this), safeOp);
  }
  function _div(o, safeOp) {
    (0, errors_js_1.assert)(_classPrivateFieldGet2(_val, o) !== BN_0, "division by zero", "NUMERIC_FAULT", {
      operation: "div",
      fault: "divide-by-zero",
      value: this
    });
    _assertClassBrand(_FixedNumber_brand, this, _checkFormat).call(this, o);
    return _assertClassBrand(_FixedNumber_brand, this, _checkValue).call(this, _classPrivateFieldGet2(_val, this) * _classPrivateFieldGet2(_tens, this) / _classPrivateFieldGet2(_val, o), safeOp);
  }
  fixednumber.FixedNumber = FixedNumber;
  //const f1 = FixedNumber.fromString("12.56", "fixed16x2");
  //const f2 = FixedNumber.fromString("0.3", "fixed16x2");
  //console.log(f1.divSignal(f2));
  //const BUMP = FixedNumber.from("0.5");

  return fixednumber;
}

var rlpDecode = {};

var hasRequiredRlpDecode;
function requireRlpDecode() {
  if (hasRequiredRlpDecode) return rlpDecode;
  hasRequiredRlpDecode = 1;
  //See: https://github.com/ethereum/wiki/wiki/RLP
  Object.defineProperty(rlpDecode, "__esModule", {
    value: true
  });
  rlpDecode.decodeRlp = void 0;
  var data_js_1 = /*@__PURE__*/requireData();
  var errors_js_1 = /*@__PURE__*/requireErrors();
  var data_js_2 = /*@__PURE__*/requireData();
  function hexlifyByte(value) {
    var result = value.toString(16);
    while (result.length < 2) {
      result = "0" + result;
    }
    return "0x" + result;
  }
  function unarrayifyInteger(data, offset, length) {
    var result = 0;
    for (var i = 0; i < length; i++) {
      result = result * 256 + data[offset + i];
    }
    return result;
  }
  function _decodeChildren(data, offset, childOffset, length) {
    var result = [];
    while (childOffset < offset + 1 + length) {
      var decoded = _decode(data, childOffset);
      result.push(decoded.result);
      childOffset += decoded.consumed;
      (0, errors_js_1.assert)(childOffset <= offset + 1 + length, "child data too short", "BUFFER_OVERRUN", {
        buffer: data,
        length: length,
        offset: offset
      });
    }
    return {
      consumed: 1 + length,
      result: result
    };
  }
  // returns { consumed: number, result: Object }
  function _decode(data, offset) {
    (0, errors_js_1.assert)(data.length !== 0, "data too short", "BUFFER_OVERRUN", {
      buffer: data,
      length: 0,
      offset: 1
    });
    var checkOffset = function checkOffset(offset) {
      (0, errors_js_1.assert)(offset <= data.length, "data short segment too short", "BUFFER_OVERRUN", {
        buffer: data,
        length: data.length,
        offset: offset
      });
    };
    // Array with extra length prefix
    if (data[offset] >= 0xf8) {
      var lengthLength = data[offset] - 0xf7;
      checkOffset(offset + 1 + lengthLength);
      var length = unarrayifyInteger(data, offset + 1, lengthLength);
      checkOffset(offset + 1 + lengthLength + length);
      return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);
    } else if (data[offset] >= 0xc0) {
      var _length = data[offset] - 0xc0;
      checkOffset(offset + 1 + _length);
      return _decodeChildren(data, offset, offset + 1, _length);
    } else if (data[offset] >= 0xb8) {
      var _lengthLength = data[offset] - 0xb7;
      checkOffset(offset + 1 + _lengthLength);
      var _length2 = unarrayifyInteger(data, offset + 1, _lengthLength);
      checkOffset(offset + 1 + _lengthLength + _length2);
      var result = (0, data_js_1.hexlify)(data.slice(offset + 1 + _lengthLength, offset + 1 + _lengthLength + _length2));
      return {
        consumed: 1 + _lengthLength + _length2,
        result: result
      };
    } else if (data[offset] >= 0x80) {
      var _length3 = data[offset] - 0x80;
      checkOffset(offset + 1 + _length3);
      var _result = (0, data_js_1.hexlify)(data.slice(offset + 1, offset + 1 + _length3));
      return {
        consumed: 1 + _length3,
        result: _result
      };
    }
    return {
      consumed: 1,
      result: hexlifyByte(data[offset])
    };
  }
  /**
   *  Decodes %%data%% into the structured data it represents.
   */
  function decodeRlp(_data) {
    var data = (0, data_js_2.getBytes)(_data, "data");
    var decoded = _decode(data, 0);
    (0, errors_js_1.assertArgument)(decoded.consumed === data.length, "unexpected junk after rlp payload", "data", _data);
    return decoded.result;
  }
  rlpDecode.decodeRlp = decodeRlp;
  return rlpDecode;
}

var rlpEncode = {};

var hasRequiredRlpEncode;
function requireRlpEncode() {
  if (hasRequiredRlpEncode) return rlpEncode;
  hasRequiredRlpEncode = 1;
  //See: https://github.com/ethereum/wiki/wiki/RLP
  Object.defineProperty(rlpEncode, "__esModule", {
    value: true
  });
  rlpEncode.encodeRlp = void 0;
  var data_js_1 = /*@__PURE__*/requireData();
  function arrayifyInteger(value) {
    var result = [];
    while (value) {
      result.unshift(value & 0xff);
      value >>= 8;
    }
    return result;
  }
  function _encode(object) {
    if (Array.isArray(object)) {
      var payload = [];
      object.forEach(function (child) {
        payload = payload.concat(_encode(child));
      });
      if (payload.length <= 55) {
        payload.unshift(0xc0 + payload.length);
        return payload;
      }
      var _length = arrayifyInteger(payload.length);
      _length.unshift(0xf7 + _length.length);
      return _length.concat(payload);
    }
    var data = Array.prototype.slice.call((0, data_js_1.getBytes)(object, "object"));
    if (data.length === 1 && data[0] <= 0x7f) {
      return data;
    } else if (data.length <= 55) {
      data.unshift(0x80 + data.length);
      return data;
    }
    var length = arrayifyInteger(data.length);
    length.unshift(0xb7 + length.length);
    return length.concat(data);
  }
  var nibbles = "0123456789abcdef";
  /**
   *  Encodes %%object%% as an RLP-encoded [[DataHexString]].
   */
  function encodeRlp(object) {
    var result = "0x";
    var _iterator = _createForOfIteratorHelper(_encode(object)),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var v = _step.value;
        result += nibbles[v >> 4];
        result += nibbles[v & 0xf];
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    return result;
  }
  rlpEncode.encodeRlp = encodeRlp;
  return rlpEncode;
}

var units = {};

var hasRequiredUnits;
function requireUnits() {
  if (hasRequiredUnits) return units;
  hasRequiredUnits = 1;
  Object.defineProperty(units, "__esModule", {
    value: true
  });
  units.parseEther = units.formatEther = units.parseUnits = units.formatUnits = void 0;
  /**
   *  Most interactions with Ethereum requires integer values, which use
   *  the smallest magnitude unit.
   *
   *  For example, imagine dealing with dollars and cents. Since dollars
   *  are divisible, non-integer values are possible, such as ``$10.77``.
   *  By using the smallest indivisible unit (i.e. cents), the value can
   *  be kept as the integer ``1077``.
   *
   *  When receiving decimal input from the user (as a decimal string),
   *  the value should be converted to an integer and when showing a user
   *  a value, the integer value should be converted to a decimal string.
   *
   *  This creates a clear distinction, between values to be used by code
   *  (integers) and values used for display logic to users (decimals).
   *
   *  The native unit in Ethereum, //ether// is divisible to 18 decimal places,
   *  where each individual unit is called a //wei//.
   *
   *  @_subsection api/utils:Unit Conversion  [about-units]
   */
  var errors_js_1 = /*@__PURE__*/requireErrors();
  var fixednumber_js_1 = /*@__PURE__*/requireFixednumber();
  var maths_js_1 = /*@__PURE__*/requireMaths();
  var names = ["wei", "kwei", "mwei", "gwei", "szabo", "finney", "ether"];
  /**
   *  Converts %%value%% into a //decimal string//, assuming %%unit%% decimal
   *  places. The %%unit%% may be the number of decimal places or the name of
   *  a unit (e.g. ``"gwei"`` for 9 decimal places).
   *
   */
  function formatUnits(value, unit) {
    var decimals = 18;
    if (typeof unit === "string") {
      var index = names.indexOf(unit);
      (0, errors_js_1.assertArgument)(index >= 0, "invalid unit", "unit", unit);
      decimals = 3 * index;
    } else if (unit != null) {
      decimals = (0, maths_js_1.getNumber)(unit, "unit");
    }
    return fixednumber_js_1.FixedNumber.fromValue(value, decimals, {
      decimals: decimals,
      width: 512
    }).toString();
  }
  units.formatUnits = formatUnits;
  /**
   *  Converts the //decimal string// %%value%% to a BigInt, assuming
   *  %%unit%% decimal places. The %%unit%% may the number of decimal places
   *  or the name of a unit (e.g. ``"gwei"`` for 9 decimal places).
   */
  function parseUnits(value, unit) {
    (0, errors_js_1.assertArgument)(typeof value === "string", "value must be a string", "value", value);
    var decimals = 18;
    if (typeof unit === "string") {
      var index = names.indexOf(unit);
      (0, errors_js_1.assertArgument)(index >= 0, "invalid unit", "unit", unit);
      decimals = 3 * index;
    } else if (unit != null) {
      decimals = (0, maths_js_1.getNumber)(unit, "unit");
    }
    return fixednumber_js_1.FixedNumber.fromString(value, {
      decimals: decimals,
      width: 512
    }).value;
  }
  units.parseUnits = parseUnits;
  /**
   *  Converts %%value%% into a //decimal string// using 18 decimal places.
   */
  function formatEther(wei) {
    return formatUnits(wei, 18);
  }
  units.formatEther = formatEther;
  /**
   *  Converts the //decimal string// %%ether%% to a BigInt, using 18
   *  decimal places.
   */
  function parseEther(ether) {
    return parseUnits(ether, 18);
  }
  units.parseEther = parseEther;
  return units;
}

var uuid = {};

var hasRequiredUuid;
function requireUuid() {
  if (hasRequiredUuid) return uuid;
  hasRequiredUuid = 1;
  Object.defineProperty(uuid, "__esModule", {
    value: true
  });
  uuid.uuidV4 = void 0;
  /**
   *  Explain UUID and link to RFC here.
   *
   *  @_subsection: api/utils:UUID  [about-uuid]
   */
  var data_js_1 = /*@__PURE__*/requireData();
  /**
   *  Returns the version 4 [[link-uuid]] for the %%randomBytes%%.
   *
   *  @see: https://www.ietf.org/rfc/rfc4122.txt (Section 4.4)
   */
  function uuidV4(randomBytes) {
    var bytes = (0, data_js_1.getBytes)(randomBytes, "randomBytes");
    // Section: 4.1.3:
    // - time_hi_and_version[12:16] = 0b0100
    bytes[6] = bytes[6] & 0x0f | 0x40;
    // Section 4.4
    // - clock_seq_hi_and_reserved[6] = 0b0
    // - clock_seq_hi_and_reserved[7] = 0b1
    bytes[8] = bytes[8] & 0x3f | 0x80;
    var value = (0, data_js_1.hexlify)(bytes);
    return [value.substring(2, 10), value.substring(10, 14), value.substring(14, 18), value.substring(18, 22), value.substring(22, 34)].join("-");
  }
  uuid.uuidV4 = uuidV4;
  return uuid;
}

var hasRequiredUtils$3;
function requireUtils$3() {
  if (hasRequiredUtils$3) return utils$3;
  hasRequiredUtils$3 = 1;
  (function (exports) {

    /**
     *  There are many simple utilities required to interact with
     *  Ethereum and to simplify the library, without increasing
     *  the library dependencies for simple functions.
     *
     *  @_section api/utils:Utilities  [about-utils]
     */
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.toUtf8String = exports.toUtf8CodePoints = exports.toUtf8Bytes = exports.parseUnits = exports.formatUnits = exports.parseEther = exports.formatEther = exports.encodeRlp = exports.decodeRlp = exports.defineProperties = exports.resolveProperties = exports.toQuantity = exports.toBeArray = exports.toBeHex = exports.toNumber = exports.toBigInt = exports.getUint = exports.getNumber = exports.getBigInt = exports.mask = exports.toTwos = exports.fromTwos = exports.FixedNumber = exports.FetchCancelSignal = exports.FetchResponse = exports.FetchRequest = exports.EventPayload = exports.makeError = exports.assertNormalize = exports.assertPrivate = exports.assertArgumentCount = exports.assertArgument = exports.assert = exports.isError = exports.isCallException = exports.zeroPadBytes = exports.zeroPadValue = exports.stripZerosLeft = exports.dataSlice = exports.dataLength = exports.concat = exports.hexlify = exports.isBytesLike = exports.isHexString = exports.getBytesCopy = exports.getBytes = exports.encodeBase64 = exports.decodeBase64 = exports.encodeBase58 = exports.decodeBase58 = void 0;
    exports.uuidV4 = exports.Utf8ErrorFuncs = void 0;
    var base58_js_1 = /*@__PURE__*/requireBase58();
    Object.defineProperty(exports, "decodeBase58", {
      enumerable: true,
      get: function get() {
        return base58_js_1.decodeBase58;
      }
    });
    Object.defineProperty(exports, "encodeBase58", {
      enumerable: true,
      get: function get() {
        return base58_js_1.encodeBase58;
      }
    });
    var base64_js_1 = /*@__PURE__*/requireBase64();
    Object.defineProperty(exports, "decodeBase64", {
      enumerable: true,
      get: function get() {
        return base64_js_1.decodeBase64;
      }
    });
    Object.defineProperty(exports, "encodeBase64", {
      enumerable: true,
      get: function get() {
        return base64_js_1.encodeBase64;
      }
    });
    var data_js_1 = /*@__PURE__*/requireData();
    Object.defineProperty(exports, "getBytes", {
      enumerable: true,
      get: function get() {
        return data_js_1.getBytes;
      }
    });
    Object.defineProperty(exports, "getBytesCopy", {
      enumerable: true,
      get: function get() {
        return data_js_1.getBytesCopy;
      }
    });
    Object.defineProperty(exports, "isHexString", {
      enumerable: true,
      get: function get() {
        return data_js_1.isHexString;
      }
    });
    Object.defineProperty(exports, "isBytesLike", {
      enumerable: true,
      get: function get() {
        return data_js_1.isBytesLike;
      }
    });
    Object.defineProperty(exports, "hexlify", {
      enumerable: true,
      get: function get() {
        return data_js_1.hexlify;
      }
    });
    Object.defineProperty(exports, "concat", {
      enumerable: true,
      get: function get() {
        return data_js_1.concat;
      }
    });
    Object.defineProperty(exports, "dataLength", {
      enumerable: true,
      get: function get() {
        return data_js_1.dataLength;
      }
    });
    Object.defineProperty(exports, "dataSlice", {
      enumerable: true,
      get: function get() {
        return data_js_1.dataSlice;
      }
    });
    Object.defineProperty(exports, "stripZerosLeft", {
      enumerable: true,
      get: function get() {
        return data_js_1.stripZerosLeft;
      }
    });
    Object.defineProperty(exports, "zeroPadValue", {
      enumerable: true,
      get: function get() {
        return data_js_1.zeroPadValue;
      }
    });
    Object.defineProperty(exports, "zeroPadBytes", {
      enumerable: true,
      get: function get() {
        return data_js_1.zeroPadBytes;
      }
    });
    var errors_js_1 = /*@__PURE__*/requireErrors();
    Object.defineProperty(exports, "isCallException", {
      enumerable: true,
      get: function get() {
        return errors_js_1.isCallException;
      }
    });
    Object.defineProperty(exports, "isError", {
      enumerable: true,
      get: function get() {
        return errors_js_1.isError;
      }
    });
    Object.defineProperty(exports, "assert", {
      enumerable: true,
      get: function get() {
        return errors_js_1.assert;
      }
    });
    Object.defineProperty(exports, "assertArgument", {
      enumerable: true,
      get: function get() {
        return errors_js_1.assertArgument;
      }
    });
    Object.defineProperty(exports, "assertArgumentCount", {
      enumerable: true,
      get: function get() {
        return errors_js_1.assertArgumentCount;
      }
    });
    Object.defineProperty(exports, "assertPrivate", {
      enumerable: true,
      get: function get() {
        return errors_js_1.assertPrivate;
      }
    });
    Object.defineProperty(exports, "assertNormalize", {
      enumerable: true,
      get: function get() {
        return errors_js_1.assertNormalize;
      }
    });
    Object.defineProperty(exports, "makeError", {
      enumerable: true,
      get: function get() {
        return errors_js_1.makeError;
      }
    });
    var events_js_1 = /*@__PURE__*/requireEvents();
    Object.defineProperty(exports, "EventPayload", {
      enumerable: true,
      get: function get() {
        return events_js_1.EventPayload;
      }
    });
    var fetch_js_1 = /*@__PURE__*/requireFetch();
    Object.defineProperty(exports, "FetchRequest", {
      enumerable: true,
      get: function get() {
        return fetch_js_1.FetchRequest;
      }
    });
    Object.defineProperty(exports, "FetchResponse", {
      enumerable: true,
      get: function get() {
        return fetch_js_1.FetchResponse;
      }
    });
    Object.defineProperty(exports, "FetchCancelSignal", {
      enumerable: true,
      get: function get() {
        return fetch_js_1.FetchCancelSignal;
      }
    });
    var fixednumber_js_1 = /*@__PURE__*/requireFixednumber();
    Object.defineProperty(exports, "FixedNumber", {
      enumerable: true,
      get: function get() {
        return fixednumber_js_1.FixedNumber;
      }
    });
    var maths_js_1 = /*@__PURE__*/requireMaths();
    Object.defineProperty(exports, "fromTwos", {
      enumerable: true,
      get: function get() {
        return maths_js_1.fromTwos;
      }
    });
    Object.defineProperty(exports, "toTwos", {
      enumerable: true,
      get: function get() {
        return maths_js_1.toTwos;
      }
    });
    Object.defineProperty(exports, "mask", {
      enumerable: true,
      get: function get() {
        return maths_js_1.mask;
      }
    });
    Object.defineProperty(exports, "getBigInt", {
      enumerable: true,
      get: function get() {
        return maths_js_1.getBigInt;
      }
    });
    Object.defineProperty(exports, "getNumber", {
      enumerable: true,
      get: function get() {
        return maths_js_1.getNumber;
      }
    });
    Object.defineProperty(exports, "getUint", {
      enumerable: true,
      get: function get() {
        return maths_js_1.getUint;
      }
    });
    Object.defineProperty(exports, "toBigInt", {
      enumerable: true,
      get: function get() {
        return maths_js_1.toBigInt;
      }
    });
    Object.defineProperty(exports, "toNumber", {
      enumerable: true,
      get: function get() {
        return maths_js_1.toNumber;
      }
    });
    Object.defineProperty(exports, "toBeHex", {
      enumerable: true,
      get: function get() {
        return maths_js_1.toBeHex;
      }
    });
    Object.defineProperty(exports, "toBeArray", {
      enumerable: true,
      get: function get() {
        return maths_js_1.toBeArray;
      }
    });
    Object.defineProperty(exports, "toQuantity", {
      enumerable: true,
      get: function get() {
        return maths_js_1.toQuantity;
      }
    });
    var properties_js_1 = /*@__PURE__*/requireProperties();
    Object.defineProperty(exports, "resolveProperties", {
      enumerable: true,
      get: function get() {
        return properties_js_1.resolveProperties;
      }
    });
    Object.defineProperty(exports, "defineProperties", {
      enumerable: true,
      get: function get() {
        return properties_js_1.defineProperties;
      }
    });
    var rlp_decode_js_1 = /*@__PURE__*/requireRlpDecode();
    Object.defineProperty(exports, "decodeRlp", {
      enumerable: true,
      get: function get() {
        return rlp_decode_js_1.decodeRlp;
      }
    });
    var rlp_encode_js_1 = /*@__PURE__*/requireRlpEncode();
    Object.defineProperty(exports, "encodeRlp", {
      enumerable: true,
      get: function get() {
        return rlp_encode_js_1.encodeRlp;
      }
    });
    var units_js_1 = /*@__PURE__*/requireUnits();
    Object.defineProperty(exports, "formatEther", {
      enumerable: true,
      get: function get() {
        return units_js_1.formatEther;
      }
    });
    Object.defineProperty(exports, "parseEther", {
      enumerable: true,
      get: function get() {
        return units_js_1.parseEther;
      }
    });
    Object.defineProperty(exports, "formatUnits", {
      enumerable: true,
      get: function get() {
        return units_js_1.formatUnits;
      }
    });
    Object.defineProperty(exports, "parseUnits", {
      enumerable: true,
      get: function get() {
        return units_js_1.parseUnits;
      }
    });
    var utf8_js_1 = /*@__PURE__*/requireUtf8();
    Object.defineProperty(exports, "toUtf8Bytes", {
      enumerable: true,
      get: function get() {
        return utf8_js_1.toUtf8Bytes;
      }
    });
    Object.defineProperty(exports, "toUtf8CodePoints", {
      enumerable: true,
      get: function get() {
        return utf8_js_1.toUtf8CodePoints;
      }
    });
    Object.defineProperty(exports, "toUtf8String", {
      enumerable: true,
      get: function get() {
        return utf8_js_1.toUtf8String;
      }
    });
    Object.defineProperty(exports, "Utf8ErrorFuncs", {
      enumerable: true,
      get: function get() {
        return utf8_js_1.Utf8ErrorFuncs;
      }
    });
    var uuid_js_1 = /*@__PURE__*/requireUuid();
    Object.defineProperty(exports, "uuidV4", {
      enumerable: true,
      get: function get() {
        return uuid_js_1.uuidV4;
      }
    });
  })(utils$3);
  return utils$3;
}

var abstractCoder = {};

var hasRequiredAbstractCoder;
function requireAbstractCoder() {
  if (hasRequiredAbstractCoder) return abstractCoder;
  hasRequiredAbstractCoder = 1;
  (function (exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Reader = exports.Writer = exports.Coder = exports.checkResultErrors = exports.Result = exports.WordSize = void 0;
    var index_js_1 = /*@__PURE__*/requireUtils$3();
    /**
     * @_ignore:
     */
    exports.WordSize = 32;
    var Padding = new Uint8Array(exports.WordSize);
    // Properties used to immediate pass through to the underlying object
    // - `then` is used to detect if an object is a Promise for await
    var passProperties = ["then"];
    var _guard = {};
    var resultNames = new WeakMap();
    function getNames(result) {
      return resultNames.get(result);
    }
    function setNames(result, names) {
      resultNames.set(result, names);
    }
    function throwError(name, error) {
      var wrapped = new Error("deferred error during ABI decoding triggered accessing ".concat(name));
      wrapped.error = error;
      throw wrapped;
    }
    function _toObject(names, items, deep) {
      if (names.indexOf(null) >= 0) {
        return items.map(function (item, index) {
          if (item instanceof Result) {
            return _toObject(getNames(item), item, deep);
          }
          return item;
        });
      }
      return names.reduce(function (accum, name, index) {
        var item = items.getValue(name);
        if (!(name in accum)) {
          if (deep && item instanceof Result) {
            item = _toObject(getNames(item), item, deep);
          }
          accum[name] = item;
        }
        return accum;
      }, {});
    }
    /**
     *  A [[Result]] is a sub-class of Array, which allows accessing any
     *  of its values either positionally by its index or, if keys are
     *  provided by its name.
     *
     *  @_docloc: api/abi
     */
    var _names2 = /*#__PURE__*/new WeakMap();
    var Result = /*#__PURE__*/function (_Array) {
      /**
       *  @private
       */
      function Result() {
        var _this;
        _classCallCheck(this, Result);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        // To properly sub-class Array so the other built-in
        // functions work, the constructor has to behave fairly
        // well. So, in the event we are created via fromItems()
        // we build the read-only Result object we want, but on
        // any other input, we use the default constructor
        // constructor(guard: any, items: Array<any>, keys?: Array<null | string>);
        var guard = args[0];
        var items = args[1];
        var names = (args[2] || []).slice();
        var wrap = true;
        if (guard !== _guard) {
          items = args;
          names = [];
          wrap = false;
        }
        // Can't just pass in ...items since an array of length 1
        // is a special case in the super.
        _this = _callSuper(this, Result, [items.length]);
        // No longer used; but cannot be removed as it will remove the
        // #private field from the .d.ts which may break backwards
        // compatibility
        _classPrivateFieldInitSpec(_this, _names2, void 0);
        items.forEach(function (item, index) {
          _this[index] = item;
        });
        // Find all unique keys
        var nameCounts = names.reduce(function (accum, name) {
          if (typeof name === "string") {
            accum.set(name, (accum.get(name) || 0) + 1);
          }
          return accum;
        }, new Map());
        // Remove any key thats not unique
        setNames(_this, Object.freeze(items.map(function (item, index) {
          var name = names[index];
          if (name != null && nameCounts.get(name) === 1) {
            return name;
          }
          return null;
        })));
        // Dummy operations to prevent TypeScript from complaining
        _classPrivateFieldSet2(_names2, _this, []);
        if (_classPrivateFieldGet2(_names2, _this) == null) {
          void _classPrivateFieldGet2(_names2, _this);
        }
        if (!wrap) {
          return _possibleConstructorReturn(_this);
        }
        // A wrapped Result is immutable
        Object.freeze(_this);
        // Proxy indices and names so we can trap deferred errors
        var proxy = new Proxy(_this, {
          get: function get(target, prop, receiver) {
            if (typeof prop === "string") {
              // Index accessor
              if (prop.match(/^[0-9]+$/)) {
                var index = (0, index_js_1.getNumber)(prop, "%index");
                if (index < 0 || index >= _this.length) {
                  throw new RangeError("out of result range");
                }
                var item = target[index];
                if (item instanceof Error) {
                  throwError("index ".concat(index), item);
                }
                return item;
              }
              // Pass important checks (like `then` for Promise) through
              if (passProperties.indexOf(prop) >= 0) {
                return Reflect.get(target, prop, receiver);
              }
              var value = target[prop];
              if (value instanceof Function) {
                // Make sure functions work with private variables
                // See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy#no_private_property_forwarding
                return function () {
                  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                    args[_key2] = arguments[_key2];
                  }
                  return value.apply(this === receiver ? target : this, args);
                };
              } else if (!(prop in target)) {
                // Possible name accessor
                return target.getValue.apply(_this === receiver ? target : _this, [prop]);
              }
            }
            return Reflect.get(target, prop, receiver);
          }
        });
        setNames(proxy, getNames(_this));
        return _possibleConstructorReturn(_this, proxy);
      }
      /**
       *  Returns the Result as a normal Array. If %%deep%%, any children
       *  which are Result objects are also converted to a normal Array.
       *
       *  This will throw if there are any outstanding deferred
       *  errors.
       */
      _inherits(Result, _Array);
      return _createClass(Result, [{
        key: "toArray",
        value: function toArray(deep) {
          var result = [];
          this.forEach(function (item, index) {
            if (item instanceof Error) {
              throwError("index ".concat(index), item);
            }
            if (deep && item instanceof Result) {
              item = item.toArray(deep);
            }
            result.push(item);
          });
          return result;
        }
        /**
         *  Returns the Result as an Object with each name-value pair. If
         *  %%deep%%, any children which are Result objects are also
         *  converted to an Object.
         *
         *  This will throw if any value is unnamed, or if there are
         *  any outstanding deferred errors.
         */
      }, {
        key: "toObject",
        value: function toObject(deep) {
          var _this2 = this;
          var names = getNames(this);
          return names.reduce(function (accum, name, index) {
            (0, index_js_1.assert)(name != null, "value at index ".concat(index, " unnamed"), "UNSUPPORTED_OPERATION", {
              operation: "toObject()"
            });
            return _toObject(names, _this2, deep);
          }, {});
        }
        /**
         *  @_ignore
         */
      }, {
        key: "slice",
        value: function slice(start, end) {
          if (start == null) {
            start = 0;
          }
          if (start < 0) {
            start += this.length;
            if (start < 0) {
              start = 0;
            }
          }
          if (end == null) {
            end = this.length;
          }
          if (end < 0) {
            end += this.length;
            if (end < 0) {
              end = 0;
            }
          }
          if (end > this.length) {
            end = this.length;
          }
          var _names = getNames(this);
          var result = [],
            names = [];
          for (var i = start; i < end; i++) {
            result.push(this[i]);
            names.push(_names[i]);
          }
          return new Result(_guard, result, names);
        }
        /**
         *  @_ignore
         */
      }, {
        key: "filter",
        value: function filter(callback, thisArg) {
          var _names = getNames(this);
          var result = [],
            names = [];
          for (var i = 0; i < this.length; i++) {
            var item = this[i];
            if (item instanceof Error) {
              throwError("index ".concat(i), item);
            }
            if (callback.call(thisArg, item, i, this)) {
              result.push(item);
              names.push(_names[i]);
            }
          }
          return new Result(_guard, result, names);
        }
        /**
         *  @_ignore
         */
      }, {
        key: "map",
        value: function map(callback, thisArg) {
          var result = [];
          for (var i = 0; i < this.length; i++) {
            var item = this[i];
            if (item instanceof Error) {
              throwError("index ".concat(i), item);
            }
            result.push(callback.call(thisArg, item, i, this));
          }
          return result;
        }
        /**
         *  Returns the value for %%name%%.
         *
         *  Since it is possible to have a key whose name conflicts with
         *  a method on a [[Result]] or its superclass Array, or any
         *  JavaScript keyword, this ensures all named values are still
         *  accessible by name.
         */
      }, {
        key: "getValue",
        value: function getValue(name) {
          var index = getNames(this).indexOf(name);
          if (index === -1) {
            return undefined;
          }
          var value = this[index];
          if (value instanceof Error) {
            throwError("property ".concat(JSON.stringify(name)), value.error);
          }
          return value;
        }
        /**
         *  Creates a new [[Result]] for %%items%% with each entry
         *  also accessible by its corresponding name in %%keys%%.
         */
      }], [{
        key: "fromItems",
        value: function fromItems(items, keys) {
          return new Result(_guard, items, keys);
        }
      }]);
    }(/*#__PURE__*/_wrapNativeSuper(Array));
    exports.Result = Result;
    /**
     *  Returns all errors found in a [[Result]].
     *
     *  Since certain errors encountered when creating a [[Result]] do
     *  not impact the ability to continue parsing data, they are
     *  deferred until they are actually accessed. Hence a faulty string
     *  in an Event that is never used does not impact the program flow.
     *
     *  However, sometimes it may be useful to access, identify or
     *  validate correctness of a [[Result]].
     *
     *  @_docloc api/abi
     */
    function checkResultErrors(result) {
      // Find the first error (if any)
      var errors = [];
      var _checkErrors = function checkErrors(path, object) {
        if (!Array.isArray(object)) {
          return;
        }
        for (var key in object) {
          var childPath = path.slice();
          childPath.push(key);
          try {
            _checkErrors(childPath, object[key]);
          } catch (error) {
            errors.push({
              path: childPath,
              error: error
            });
          }
        }
      };
      _checkErrors([], result);
      return errors;
    }
    exports.checkResultErrors = checkResultErrors;
    function getValue(value) {
      var bytes = (0, index_js_1.toBeArray)(value);
      (0, index_js_1.assert)(bytes.length <= exports.WordSize, "value out-of-bounds", "BUFFER_OVERRUN", {
        buffer: bytes,
        length: exports.WordSize,
        offset: bytes.length
      });
      if (bytes.length !== exports.WordSize) {
        bytes = (0, index_js_1.getBytesCopy)((0, index_js_1.concat)([Padding.slice(bytes.length % exports.WordSize), bytes]));
      }
      return bytes;
    }
    /**
     *  @_ignore
     */
    var Coder = /*#__PURE__*/function () {
      function Coder(name, type, localName, dynamic) {
        _classCallCheck(this, Coder);
        // The coder name:
        //   - address, uint256, tuple, array, etc.
        _defineProperty(this, "name", void 0);
        // The fully expanded type, including composite types:
        //   - address, uint256, tuple(address,bytes), uint256[3][4][],  etc.
        _defineProperty(this, "type", void 0);
        // The localName bound in the signature, in this example it is "baz":
        //   - tuple(address foo, uint bar) baz
        _defineProperty(this, "localName", void 0);
        // Whether this type is dynamic:
        //  - Dynamic: bytes, string, address[], tuple(boolean[]), etc.
        //  - Not Dynamic: address, uint256, boolean[3], tuple(address, uint8)
        _defineProperty(this, "dynamic", void 0);
        (0, index_js_1.defineProperties)(this, {
          name: name,
          type: type,
          localName: localName,
          dynamic: dynamic
        }, {
          name: "string",
          type: "string",
          localName: "string",
          dynamic: "boolean"
        });
      }
      return _createClass(Coder, [{
        key: "_throwError",
        value: function _throwError(message, value) {
          (0, index_js_1.assertArgument)(false, message, this.localName, value);
        }
      }]);
    }();
    exports.Coder = Coder;
    /**
     *  @_ignore
     */
    var _data = /*#__PURE__*/new WeakMap();
    var _dataLength = /*#__PURE__*/new WeakMap();
    var _Writer_brand = /*#__PURE__*/new WeakSet();
    var Writer = /*#__PURE__*/function () {
      function Writer() {
        _classCallCheck(this, Writer);
        _classPrivateMethodInitSpec(this, _Writer_brand);
        // An array of WordSize lengthed objects to concatenation
        _classPrivateFieldInitSpec(this, _data, void 0);
        _classPrivateFieldInitSpec(this, _dataLength, void 0);
        _classPrivateFieldSet2(_data, this, []);
        _classPrivateFieldSet2(_dataLength, this, 0);
      }
      return _createClass(Writer, [{
        key: "data",
        get: function get() {
          return (0, index_js_1.concat)(_classPrivateFieldGet2(_data, this));
        }
      }, {
        key: "length",
        get: function get() {
          return _classPrivateFieldGet2(_dataLength, this);
        }
      }, {
        key: "appendWriter",
        value: function appendWriter(writer) {
          return _assertClassBrand(_Writer_brand, this, _writeData).call(this, (0, index_js_1.getBytesCopy)(writer.data));
        }
        // Arrayish item; pad on the right to *nearest* WordSize
      }, {
        key: "writeBytes",
        value: function writeBytes(value) {
          var bytes = (0, index_js_1.getBytesCopy)(value);
          var paddingOffset = bytes.length % exports.WordSize;
          if (paddingOffset) {
            bytes = (0, index_js_1.getBytesCopy)((0, index_js_1.concat)([bytes, Padding.slice(paddingOffset)]));
          }
          return _assertClassBrand(_Writer_brand, this, _writeData).call(this, bytes);
        }
        // Numeric item; pad on the left *to* WordSize
      }, {
        key: "writeValue",
        value: function writeValue(value) {
          return _assertClassBrand(_Writer_brand, this, _writeData).call(this, getValue(value));
        }
        // Inserts a numeric place-holder, returning a callback that can
        // be used to asjust the value later
      }, {
        key: "writeUpdatableValue",
        value: function writeUpdatableValue() {
          var _this3 = this;
          var offset = _classPrivateFieldGet2(_data, this).length;
          _classPrivateFieldGet2(_data, this).push(Padding);
          _classPrivateFieldSet2(_dataLength, this, _classPrivateFieldGet2(_dataLength, this) + exports.WordSize);
          return function (value) {
            _classPrivateFieldGet2(_data, _this3)[offset] = getValue(value);
          };
        }
      }]);
    }();
    function _writeData(data) {
      _classPrivateFieldGet2(_data, this).push(data);
      _classPrivateFieldSet2(_dataLength, this, _classPrivateFieldGet2(_dataLength, this) + data.length);
      return data.length;
    }
    exports.Writer = Writer;
    /**
     *  @_ignore
     */
    var _data2 = /*#__PURE__*/new WeakMap();
    var _offset = /*#__PURE__*/new WeakMap();
    var _bytesRead = /*#__PURE__*/new WeakMap();
    var _parent = /*#__PURE__*/new WeakMap();
    var _maxInflation = /*#__PURE__*/new WeakMap();
    var _Reader_brand = /*#__PURE__*/new WeakSet();
    var Reader = /*#__PURE__*/function () {
      function Reader(data, allowLoose, maxInflation) {
        _classCallCheck(this, Reader);
        _classPrivateMethodInitSpec(this, _Reader_brand);
        // Allows incomplete unpadded data to be read; otherwise an error
        // is raised if attempting to overrun the buffer. This is required
        // to deal with an old Solidity bug, in which event data for
        // external (not public thoguh) was tightly packed.
        _defineProperty(this, "allowLoose", void 0);
        _classPrivateFieldInitSpec(this, _data2, void 0);
        _classPrivateFieldInitSpec(this, _offset, void 0);
        _classPrivateFieldInitSpec(this, _bytesRead, void 0);
        _classPrivateFieldInitSpec(this, _parent, void 0);
        _classPrivateFieldInitSpec(this, _maxInflation, void 0);
        (0, index_js_1.defineProperties)(this, {
          allowLoose: !!allowLoose
        });
        _classPrivateFieldSet2(_data2, this, (0, index_js_1.getBytesCopy)(data));
        _classPrivateFieldSet2(_bytesRead, this, 0);
        _classPrivateFieldSet2(_parent, this, null);
        _classPrivateFieldSet2(_maxInflation, this, maxInflation != null ? maxInflation : 1024);
        _classPrivateFieldSet2(_offset, this, 0);
      }
      return _createClass(Reader, [{
        key: "data",
        get: function get() {
          return (0, index_js_1.hexlify)(_classPrivateFieldGet2(_data2, this));
        }
      }, {
        key: "dataLength",
        get: function get() {
          return _classPrivateFieldGet2(_data2, this).length;
        }
      }, {
        key: "consumed",
        get: function get() {
          return _classPrivateFieldGet2(_offset, this);
        }
      }, {
        key: "bytes",
        get: function get() {
          return new Uint8Array(_classPrivateFieldGet2(_data2, this));
        }
      }, {
        key: "subReader",
        value:
        // Create a sub-reader with the same underlying data, but offset
        function subReader(offset) {
          var reader = new Reader(_classPrivateFieldGet2(_data2, this).slice(_classPrivateFieldGet2(_offset, this) + offset), this.allowLoose, _classPrivateFieldGet2(_maxInflation, this));
          _classPrivateFieldSet2(_parent, reader, this);
          return reader;
        }
        // Read bytes
      }, {
        key: "readBytes",
        value: function readBytes(length, loose) {
          var bytes = _assertClassBrand(_Reader_brand, this, _peekBytes).call(this, 0, length, !!loose);
          _assertClassBrand(_Reader_brand, this, _incrementBytesRead).call(this, length);
          _classPrivateFieldSet2(_offset, this, _classPrivateFieldGet2(_offset, this) + bytes.length);
          // @TODO: Make sure the length..end bytes are all 0?
          return bytes.slice(0, length);
        }
        // Read a numeric values
      }, {
        key: "readValue",
        value: function readValue() {
          return (0, index_js_1.toBigInt)(this.readBytes(exports.WordSize));
        }
      }, {
        key: "readIndex",
        value: function readIndex() {
          return (0, index_js_1.toNumber)(this.readBytes(exports.WordSize));
        }
      }]);
    }();
    function _incrementBytesRead(count) {
      if (_classPrivateFieldGet2(_parent, this)) {
        var _classPrivateFieldGet2$1;
        return _assertClassBrand(_Reader_brand, _classPrivateFieldGet2$1 = _classPrivateFieldGet2(_parent, this), _incrementBytesRead).call(_classPrivateFieldGet2$1, count);
      }
      _classPrivateFieldSet2(_bytesRead, this, _classPrivateFieldGet2(_bytesRead, this) + count);
      // Check for excessive inflation (see: #4537)
      (0, index_js_1.assert)(_classPrivateFieldGet2(_maxInflation, this) < 1 || _classPrivateFieldGet2(_bytesRead, this) <= _classPrivateFieldGet2(_maxInflation, this) * this.dataLength, "compressed ABI data exceeds inflation ratio of ".concat(_classPrivateFieldGet2(_maxInflation, this), " ( see: https://github.com/ethers-io/ethers.js/issues/4537 )"), "BUFFER_OVERRUN", {
        buffer: (0, index_js_1.getBytesCopy)(_classPrivateFieldGet2(_data2, this)),
        offset: _classPrivateFieldGet2(_offset, this),
        length: count,
        info: {
          bytesRead: _classPrivateFieldGet2(_bytesRead, this),
          dataLength: this.dataLength
        }
      });
    }
    function _peekBytes(offset, length, loose) {
      var alignedLength = Math.ceil(length / exports.WordSize) * exports.WordSize;
      if (_classPrivateFieldGet2(_offset, this) + alignedLength > _classPrivateFieldGet2(_data2, this).length) {
        if (this.allowLoose && loose && _classPrivateFieldGet2(_offset, this) + length <= _classPrivateFieldGet2(_data2, this).length) {
          alignedLength = length;
        } else {
          (0, index_js_1.assert)(false, "data out-of-bounds", "BUFFER_OVERRUN", {
            buffer: (0, index_js_1.getBytesCopy)(_classPrivateFieldGet2(_data2, this)),
            length: _classPrivateFieldGet2(_data2, this).length,
            offset: _classPrivateFieldGet2(_offset, this) + alignedLength
          });
        }
      }
      return _classPrivateFieldGet2(_data2, this).slice(_classPrivateFieldGet2(_offset, this), _classPrivateFieldGet2(_offset, this) + alignedLength);
    }
    exports.Reader = Reader;
  })(abstractCoder);
  return abstractCoder;
}

var address$3 = {};

var address$2 = {};

var address$1 = {};

var crypto$2 = {};

var hmac$1 = {};

var crypto$1 = {};

var hasRequiredCrypto$2;
function requireCrypto$2() {
  if (hasRequiredCrypto$2) return crypto$1;
  hasRequiredCrypto$2 = 1;
  (function (exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.randomBytes = exports.pbkdf2Sync = exports.createHmac = exports.createHash = void 0;
    var crypto_1 = require$$5;
    Object.defineProperty(exports, "createHash", {
      enumerable: true,
      get: function get() {
        return crypto_1.createHash;
      }
    });
    Object.defineProperty(exports, "createHmac", {
      enumerable: true,
      get: function get() {
        return crypto_1.createHmac;
      }
    });
    Object.defineProperty(exports, "pbkdf2Sync", {
      enumerable: true,
      get: function get() {
        return crypto_1.pbkdf2Sync;
      }
    });
    Object.defineProperty(exports, "randomBytes", {
      enumerable: true,
      get: function get() {
        return crypto_1.randomBytes;
      }
    });
  })(crypto$1);
  return crypto$1;
}

var hasRequiredHmac$1;
function requireHmac$1() {
  if (hasRequiredHmac$1) return hmac$1;
  hasRequiredHmac$1 = 1;
  Object.defineProperty(hmac$1, "__esModule", {
    value: true
  });
  hmac$1.computeHmac = void 0;
  /**
   *  An **HMAC** enables verification that a given key was used
   *  to authenticate a payload.
   *
   *  See: [[link-wiki-hmac]]
   *
   *  @_subsection: api/crypto:HMAC  [about-hmac]
   */
  var crypto_js_1 = /*@__PURE__*/requireCrypto$2();
  var index_js_1 = /*@__PURE__*/requireUtils$3();
  var locked = false;
  var _computeHmac = function _computeHmac(algorithm, key, data) {
    return (0, crypto_js_1.createHmac)(algorithm, key).update(data).digest();
  };
  var __computeHmac = _computeHmac;
  /**
   *  Return the HMAC for %%data%% using the %%key%% key with the underlying
   *  %%algo%% used for compression.
   *
   *  @example:
   *    key = id("some-secret")
   *
   *    // Compute the HMAC
   *    computeHmac("sha256", key, "0x1337")
   *    //_result:
   *
   *    // To compute the HMAC of UTF-8 data, the data must be
   *    // converted to UTF-8 bytes
   *    computeHmac("sha256", key, toUtf8Bytes("Hello World"))
   *    //_result:
   *
   */
  function computeHmac(algorithm, _key, _data) {
    var key = (0, index_js_1.getBytes)(_key, "key");
    var data = (0, index_js_1.getBytes)(_data, "data");
    return (0, index_js_1.hexlify)(__computeHmac(algorithm, key, data));
  }
  hmac$1.computeHmac = computeHmac;
  computeHmac._ = _computeHmac;
  computeHmac.lock = function () {
    locked = true;
  };
  computeHmac.register = function (func) {
    if (locked) {
      throw new Error("computeHmac is locked");
    }
    __computeHmac = func;
  };
  Object.freeze(computeHmac);
  return hmac$1;
}

var keccak = {};

var sha3 = {};

var _assert = {};

var hasRequired_assert;
function require_assert() {
  if (hasRequired_assert) return _assert;
  hasRequired_assert = 1;
  Object.defineProperty(_assert, "__esModule", {
    value: true
  });
  _assert.output = _assert.exists = _assert.hash = _assert.bytes = _assert.bool = _assert.number = void 0;
  function number(n) {
    if (!Number.isSafeInteger(n) || n < 0) throw new Error("Wrong positive integer: ".concat(n));
  }
  _assert.number = number;
  function bool(b) {
    if (typeof b !== 'boolean') throw new Error("Expected boolean, not ".concat(b));
  }
  _assert.bool = bool;
  function bytes(b) {
    if (!(b instanceof Uint8Array)) throw new Error('Expected Uint8Array');
    for (var _len = arguments.length, lengths = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      lengths[_key - 1] = arguments[_key];
    }
    if (lengths.length > 0 && !lengths.includes(b.length)) throw new Error("Expected Uint8Array of length ".concat(lengths, ", not of length=").concat(b.length));
  }
  _assert.bytes = bytes;
  function hash(hash) {
    if (typeof hash !== 'function' || typeof hash.create !== 'function') throw new Error('Hash should be wrapped by utils.wrapConstructor');
    number(hash.outputLen);
    number(hash.blockLen);
  }
  _assert.hash = hash;
  function exists(instance) {
    var checkFinished = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    if (instance.destroyed) throw new Error('Hash instance has been destroyed');
    if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');
  }
  _assert.exists = exists;
  function output(out, instance) {
    bytes(out);
    var min = instance.outputLen;
    if (out.length < min) {
      throw new Error("digestInto() expects output buffer of length at least ".concat(min));
    }
  }
  _assert.output = output;
  var assert = {
    number: number,
    bool: bool,
    bytes: bytes,
    hash: hash,
    exists: exists,
    output: output
  };
  _assert["default"] = assert;
  return _assert;
}

var _u64 = {};

var hasRequired_u64;
function require_u64() {
  if (hasRequired_u64) return _u64;
  hasRequired_u64 = 1;
  Object.defineProperty(_u64, "__esModule", {
    value: true
  });
  _u64.add5L = _u64.add5H = _u64.add4H = _u64.add4L = _u64.add3H = _u64.add3L = _u64.add = _u64.rotlBL = _u64.rotlBH = _u64.rotlSL = _u64.rotlSH = _u64.rotr32L = _u64.rotr32H = _u64.rotrBL = _u64.rotrBH = _u64.rotrSL = _u64.rotrSH = _u64.shrSL = _u64.shrSH = _u64.toBig = _u64.split = _u64.fromBig = void 0;
  var U32_MASK64 = /* @__PURE__ */BigInt(Math.pow(2, 32) - 1);
  var _32n = /* @__PURE__ */BigInt(32);
  // We are not using BigUint64Array, because they are extremely slow as per 2022
  function fromBig(n) {
    var le = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    if (le) return {
      h: Number(n & U32_MASK64),
      l: Number(n >> _32n & U32_MASK64)
    };
    return {
      h: Number(n >> _32n & U32_MASK64) | 0,
      l: Number(n & U32_MASK64) | 0
    };
  }
  _u64.fromBig = fromBig;
  function split(lst) {
    var le = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var Ah = new Uint32Array(lst.length);
    var Al = new Uint32Array(lst.length);
    for (var i = 0; i < lst.length; i++) {
      var _fromBig = fromBig(lst[i], le),
        h = _fromBig.h,
        l = _fromBig.l;
      var _ref = [h, l];
      Ah[i] = _ref[0];
      Al[i] = _ref[1];
    }
    return [Ah, Al];
  }
  _u64.split = split;
  var toBig = function toBig(h, l) {
    return BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
  };
  _u64.toBig = toBig;
  // for Shift in [0, 32)
  var shrSH = function shrSH(h, _l, s) {
    return h >>> s;
  };
  _u64.shrSH = shrSH;
  var shrSL = function shrSL(h, l, s) {
    return h << 32 - s | l >>> s;
  };
  _u64.shrSL = shrSL;
  // Right rotate for Shift in [1, 32)
  var rotrSH = function rotrSH(h, l, s) {
    return h >>> s | l << 32 - s;
  };
  _u64.rotrSH = rotrSH;
  var rotrSL = function rotrSL(h, l, s) {
    return h << 32 - s | l >>> s;
  };
  _u64.rotrSL = rotrSL;
  // Right rotate for Shift in (32, 64), NOTE: 32 is special case.
  var rotrBH = function rotrBH(h, l, s) {
    return h << 64 - s | l >>> s - 32;
  };
  _u64.rotrBH = rotrBH;
  var rotrBL = function rotrBL(h, l, s) {
    return h >>> s - 32 | l << 64 - s;
  };
  _u64.rotrBL = rotrBL;
  // Right rotate for shift===32 (just swaps l&h)
  var rotr32H = function rotr32H(_h, l) {
    return l;
  };
  _u64.rotr32H = rotr32H;
  var rotr32L = function rotr32L(h, _l) {
    return h;
  };
  _u64.rotr32L = rotr32L;
  // Left rotate for Shift in [1, 32)
  var rotlSH = function rotlSH(h, l, s) {
    return h << s | l >>> 32 - s;
  };
  _u64.rotlSH = rotlSH;
  var rotlSL = function rotlSL(h, l, s) {
    return l << s | h >>> 32 - s;
  };
  _u64.rotlSL = rotlSL;
  // Left rotate for Shift in (32, 64), NOTE: 32 is special case.
  var rotlBH = function rotlBH(h, l, s) {
    return l << s - 32 | h >>> 64 - s;
  };
  _u64.rotlBH = rotlBH;
  var rotlBL = function rotlBL(h, l, s) {
    return h << s - 32 | l >>> 64 - s;
  };
  _u64.rotlBL = rotlBL;
  // JS uses 32-bit signed integers for bitwise operations which means we cannot
  // simple take carry out of low bit sum by shift, we need to use division.
  function add(Ah, Al, Bh, Bl) {
    var l = (Al >>> 0) + (Bl >>> 0);
    return {
      h: Ah + Bh + (l / Math.pow(2, 32) | 0) | 0,
      l: l | 0
    };
  }
  _u64.add = add;
  // Addition with more than 2 elements
  var add3L = function add3L(Al, Bl, Cl) {
    return (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
  };
  _u64.add3L = add3L;
  var add3H = function add3H(low, Ah, Bh, Ch) {
    return Ah + Bh + Ch + (low / Math.pow(2, 32) | 0) | 0;
  };
  _u64.add3H = add3H;
  var add4L = function add4L(Al, Bl, Cl, Dl) {
    return (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
  };
  _u64.add4L = add4L;
  var add4H = function add4H(low, Ah, Bh, Ch, Dh) {
    return Ah + Bh + Ch + Dh + (low / Math.pow(2, 32) | 0) | 0;
  };
  _u64.add4H = add4H;
  var add5L = function add5L(Al, Bl, Cl, Dl, El) {
    return (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
  };
  _u64.add5L = add5L;
  var add5H = function add5H(low, Ah, Bh, Ch, Dh, Eh) {
    return Ah + Bh + Ch + Dh + Eh + (low / Math.pow(2, 32) | 0) | 0;
  };
  _u64.add5H = add5H;
  // prettier-ignore
  var u64 = {
    fromBig: fromBig,
    split: split,
    toBig: toBig,
    shrSH: shrSH,
    shrSL: shrSL,
    rotrSH: rotrSH,
    rotrSL: rotrSL,
    rotrBH: rotrBH,
    rotrBL: rotrBL,
    rotr32H: rotr32H,
    rotr32L: rotr32L,
    rotlSH: rotlSH,
    rotlSL: rotlSL,
    rotlBH: rotlBH,
    rotlBL: rotlBL,
    add: add,
    add3L: add3L,
    add3H: add3H,
    add4L: add4L,
    add4H: add4H,
    add5H: add5H,
    add5L: add5L
  };
  _u64["default"] = u64;
  return _u64;
}

var utils$2 = {};

var crypto = {};

var hasRequiredCrypto$1;
function requireCrypto$1() {
  if (hasRequiredCrypto$1) return crypto;
  hasRequiredCrypto$1 = 1;
  Object.defineProperty(crypto, "__esModule", {
    value: true
  });
  crypto.crypto = void 0;
  crypto.crypto = (typeof globalThis === "undefined" ? "undefined" : _typeof(globalThis)) === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;
  return crypto;
}

var hasRequiredUtils$2;
function requireUtils$2() {
  if (hasRequiredUtils$2) return utils$2;
  hasRequiredUtils$2 = 1;
  (function (exports) {

    /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.randomBytes = exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;
    // We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.
    // node.js versions earlier than v19 don't declare it in global scope.
    // For node.js, package.json#exports field mapping rewrites import
    // from `crypto` to `cryptoNode`, which imports native module.
    // Makes the utils un-importable in browsers without a bundler.
    // Once node.js 18 is deprecated, we can just drop the import.
    var crypto_1 = requireCrypto$1();
    var u8a = function u8a(a) {
      return a instanceof Uint8Array;
    };
    // Cast array to different type
    var u8 = function u8(arr) {
      return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
    };
    exports.u8 = u8;
    var u32 = function u32(arr) {
      return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
    };
    exports.u32 = u32;
    // Cast array to view
    var createView = function createView(arr) {
      return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    };
    exports.createView = createView;
    // The rotate right (circular right shift) operation for uint32
    var rotr = function rotr(word, shift) {
      return word << 32 - shift | word >>> shift;
    };
    exports.rotr = rotr;
    // big-endian hardware is rare. Just in case someone still decides to run hashes:
    // early-throw an error because we don't support BE yet.
    exports.isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;
    if (!exports.isLE) throw new Error('Non little-endian hardware is not supported');
    var hexes = /* @__PURE__ */Array.from({
      length: 256
    }, function (_, i) {
      return i.toString(16).padStart(2, '0');
    });
    /**
     * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'
     */
    function bytesToHex(bytes) {
      if (!u8a(bytes)) throw new Error('Uint8Array expected');
      // pre-caching improves the speed 6x
      var hex = '';
      for (var i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
      }
      return hex;
    }
    exports.bytesToHex = bytesToHex;
    /**
     * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])
     */
    function hexToBytes(hex) {
      if (typeof hex !== 'string') throw new Error('hex string expected, got ' + _typeof(hex));
      var len = hex.length;
      if (len % 2) throw new Error('padded hex string expected, got unpadded hex of length ' + len);
      var array = new Uint8Array(len / 2);
      for (var i = 0; i < array.length; i++) {
        var j = i * 2;
        var hexByte = hex.slice(j, j + 2);
        var _byte = Number.parseInt(hexByte, 16);
        if (Number.isNaN(_byte) || _byte < 0) throw new Error('Invalid byte sequence');
        array[i] = _byte;
      }
      return array;
    }
    exports.hexToBytes = hexToBytes;
    // There is no setImmediate in browser and setTimeout is slow.
    // call of async fn will return Promise, which will be fullfiled only on
    // next scheduler queue processing step and this is exactly what we need.
    var nextTick = /*#__PURE__*/function () {
      var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));
      return function nextTick() {
        return _ref.apply(this, arguments);
      };
    }();
    exports.nextTick = nextTick;
    // Returns control to thread each 'tick' ms to avoid blocking
    function asyncLoop(_x, _x2, _x3) {
      return _asyncLoop.apply(this, arguments);
    }
    function _asyncLoop() {
      _asyncLoop = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(iters, tick, cb) {
        var ts, i, diff;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              ts = Date.now();
              i = 0;
            case 2:
              if (!(i < iters)) {
                _context2.next = 13;
                break;
              }
              cb(i);
              // Date.now() is not monotonic, so in case if clock goes backwards we return return control too
              diff = Date.now() - ts;
              if (!(diff >= 0 && diff < tick)) {
                _context2.next = 7;
                break;
              }
              return _context2.abrupt("continue", 10);
            case 7:
              _context2.next = 9;
              return (0, exports.nextTick)();
            case 9:
              ts += diff;
            case 10:
              i++;
              _context2.next = 2;
              break;
            case 13:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      }));
      return _asyncLoop.apply(this, arguments);
    }
    exports.asyncLoop = asyncLoop;
    /**
     * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])
     */
    function utf8ToBytes(str) {
      if (typeof str !== 'string') throw new Error("utf8ToBytes expected string, got ".concat(_typeof(str)));
      return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
    }
    exports.utf8ToBytes = utf8ToBytes;
    /**
     * Normalizes (non-hex) string or Uint8Array to Uint8Array.
     * Warning: when Uint8Array is passed, it would NOT get copied.
     * Keep in mind for future mutable operations.
     */
    function toBytes(data) {
      if (typeof data === 'string') data = utf8ToBytes(data);
      if (!u8a(data)) throw new Error("expected Uint8Array, got ".concat(_typeof(data)));
      return data;
    }
    exports.toBytes = toBytes;
    /**
     * Copies several Uint8Arrays into one.
     */
    function concatBytes() {
      for (var _len = arguments.length, arrays = new Array(_len), _key = 0; _key < _len; _key++) {
        arrays[_key] = arguments[_key];
      }
      var r = new Uint8Array(arrays.reduce(function (sum, a) {
        return sum + a.length;
      }, 0));
      var pad = 0; // walk through each item, ensure they have proper type
      arrays.forEach(function (a) {
        if (!u8a(a)) throw new Error('Uint8Array expected');
        r.set(a, pad);
        pad += a.length;
      });
      return r;
    }
    exports.concatBytes = concatBytes;
    // For runtime check if class implements interface
    var Hash = /*#__PURE__*/function () {
      function Hash() {
        _classCallCheck(this, Hash);
      }
      return _createClass(Hash, [{
        key: "clone",
        value:
        // Safe version that clones internal state
        function clone() {
          return this._cloneInto();
        }
      }]);
    }();
    exports.Hash = Hash;
    var toStr = {}.toString;
    function checkOpts(defaults, opts) {
      if (opts !== undefined && toStr.call(opts) !== '[object Object]') throw new Error('Options should be object or undefined');
      var merged = Object.assign(defaults, opts);
      return merged;
    }
    exports.checkOpts = checkOpts;
    function wrapConstructor(hashCons) {
      var hashC = function hashC(msg) {
        return hashCons().update(toBytes(msg)).digest();
      };
      var tmp = hashCons();
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = function () {
        return hashCons();
      };
      return hashC;
    }
    exports.wrapConstructor = wrapConstructor;
    function wrapConstructorWithOpts(hashCons) {
      var hashC = function hashC(msg, opts) {
        return hashCons(opts).update(toBytes(msg)).digest();
      };
      var tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = function (opts) {
        return hashCons(opts);
      };
      return hashC;
    }
    exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
    function wrapXOFConstructorWithOpts(hashCons) {
      var hashC = function hashC(msg, opts) {
        return hashCons(opts).update(toBytes(msg)).digest();
      };
      var tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = function (opts) {
        return hashCons(opts);
      };
      return hashC;
    }
    exports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
    /**
     * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.
     */
    function randomBytes() {
      var bytesLength = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 32;
      if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === 'function') {
        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
      }
      throw new Error('crypto.getRandomValues must be defined');
    }
    exports.randomBytes = randomBytes;
  })(utils$2);
  return utils$2;
}

var hasRequiredSha3;
function requireSha3() {
  if (hasRequiredSha3) return sha3;
  hasRequiredSha3 = 1;
  Object.defineProperty(sha3, "__esModule", {
    value: true
  });
  sha3.shake256 = sha3.shake128 = sha3.keccak_512 = sha3.keccak_384 = sha3.keccak_256 = sha3.keccak_224 = sha3.sha3_512 = sha3.sha3_384 = sha3.sha3_256 = sha3.sha3_224 = sha3.Keccak = sha3.keccakP = void 0;
  var _assert_js_1 = /*@__PURE__*/require_assert();
  var _u64_js_1 = /*@__PURE__*/require_u64();
  var utils_js_1 = /*@__PURE__*/requireUtils$2();
  // SHA3 (keccak) is based on a new design: basically, the internal state is bigger than output size.
  // It's called a sponge function.
  // Various per round constants calculations
  var SHA3_PI = [],
    SHA3_ROTL = [],
    _SHA3_IOTA = [];
  var _0n = /* @__PURE__ */BigInt(0);
  var _1n = /* @__PURE__ */BigInt(1);
  var _2n = /* @__PURE__ */BigInt(2);
  var _7n = /* @__PURE__ */BigInt(7);
  var _256n = /* @__PURE__ */BigInt(256);
  var _0x71n = /* @__PURE__ */BigInt(0x71);
  for (var round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
    // Pi
    var _ref = [y, (2 * x + 3 * y) % 5];
    x = _ref[0];
    y = _ref[1];
    SHA3_PI.push(2 * (5 * y + x));
    // Rotational
    SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
    // Iota
    var t = _0n;
    for (var j = 0; j < 7; j++) {
      R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
      if (R & _2n) t ^= _1n << (_1n << /* @__PURE__ */BigInt(j)) - _1n;
    }
    _SHA3_IOTA.push(t);
  }
  var _ref2 = /* @__PURE__ */(0, _u64_js_1.split)(_SHA3_IOTA, true),
    _ref3 = _slicedToArray(_ref2, 2),
    SHA3_IOTA_H = _ref3[0],
    SHA3_IOTA_L = _ref3[1];
  // Left rotation (without 0, 32, 64)
  var rotlH = function rotlH(h, l, s) {
    return s > 32 ? (0, _u64_js_1.rotlBH)(h, l, s) : (0, _u64_js_1.rotlSH)(h, l, s);
  };
  var rotlL = function rotlL(h, l, s) {
    return s > 32 ? (0, _u64_js_1.rotlBL)(h, l, s) : (0, _u64_js_1.rotlSL)(h, l, s);
  };
  // Same as keccakf1600, but allows to skip some rounds
  function keccakP(s) {
    var rounds = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 24;
    var B = new Uint32Array(5 * 2);
    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)
    for (var _round = 24 - rounds; _round < 24; _round++) {
      // Theta 
      for (var _x = 0; _x < 10; _x++) B[_x] = s[_x] ^ s[_x + 10] ^ s[_x + 20] ^ s[_x + 30] ^ s[_x + 40];
      for (var _x2 = 0; _x2 < 10; _x2 += 2) {
        var idx1 = (_x2 + 8) % 10;
        var idx0 = (_x2 + 2) % 10;
        var B0 = B[idx0];
        var B1 = B[idx0 + 1];
        var Th = rotlH(B0, B1, 1) ^ B[idx1];
        var Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
        for (var _y = 0; _y < 50; _y += 10) {
          s[_x2 + _y] ^= Th;
          s[_x2 + _y + 1] ^= Tl;
        }
      }
      // Rho () and Pi ()
      var curH = s[2];
      var curL = s[3];
      for (var _t = 0; _t < 24; _t++) {
        var shift = SHA3_ROTL[_t];
        var _Th = rotlH(curH, curL, shift);
        var _Tl = rotlL(curH, curL, shift);
        var PI = SHA3_PI[_t];
        curH = s[PI];
        curL = s[PI + 1];
        s[PI] = _Th;
        s[PI + 1] = _Tl;
      }
      // Chi ()
      for (var _y2 = 0; _y2 < 50; _y2 += 10) {
        for (var _x3 = 0; _x3 < 10; _x3++) B[_x3] = s[_y2 + _x3];
        for (var _x4 = 0; _x4 < 10; _x4++) s[_y2 + _x4] ^= ~B[(_x4 + 2) % 10] & B[(_x4 + 4) % 10];
      }
      // Iota ()
      s[0] ^= SHA3_IOTA_H[_round];
      s[1] ^= SHA3_IOTA_L[_round];
    }
    B.fill(0);
  }
  sha3.keccakP = keccakP;
  var Keccak = /*#__PURE__*/function (_utils_js_1$Hash) {
    // NOTE: we accept arguments in bytes instead of bits here.
    function Keccak(blockLen, suffix, outputLen) {
      var _this;
      var enableXOF = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      var rounds = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 24;
      _classCallCheck(this, Keccak);
      _this = _callSuper(this, Keccak);
      _this.blockLen = blockLen;
      _this.suffix = suffix;
      _this.outputLen = outputLen;
      _this.enableXOF = enableXOF;
      _this.rounds = rounds;
      _this.pos = 0;
      _this.posOut = 0;
      _this.finished = false;
      _this.destroyed = false;
      // Can be passed from user as dkLen
      (0, _assert_js_1.number)(outputLen);
      // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes
      if (0 >= _this.blockLen || _this.blockLen >= 200) throw new Error('Sha3 supports only keccak-f1600 function');
      _this.state = new Uint8Array(200);
      _this.state32 = (0, utils_js_1.u32)(_this.state);
      return _this;
    }
    _inherits(Keccak, _utils_js_1$Hash);
    return _createClass(Keccak, [{
      key: "keccak",
      value: function keccak() {
        keccakP(this.state32, this.rounds);
        this.posOut = 0;
        this.pos = 0;
      }
    }, {
      key: "update",
      value: function update(data) {
        (0, _assert_js_1.exists)(this);
        var blockLen = this.blockLen,
          state = this.state;
        data = (0, utils_js_1.toBytes)(data);
        var len = data.length;
        for (var pos = 0; pos < len;) {
          var take = Math.min(blockLen - this.pos, len - pos);
          for (var i = 0; i < take; i++) state[this.pos++] ^= data[pos++];
          if (this.pos === blockLen) this.keccak();
        }
        return this;
      }
    }, {
      key: "finish",
      value: function finish() {
        if (this.finished) return;
        this.finished = true;
        var state = this.state,
          suffix = this.suffix,
          pos = this.pos,
          blockLen = this.blockLen;
        // Do the padding
        state[pos] ^= suffix;
        if ((suffix & 0x80) !== 0 && pos === blockLen - 1) this.keccak();
        state[blockLen - 1] ^= 0x80;
        this.keccak();
      }
    }, {
      key: "writeInto",
      value: function writeInto(out) {
        (0, _assert_js_1.exists)(this, false);
        (0, _assert_js_1.bytes)(out);
        this.finish();
        var bufferOut = this.state;
        var blockLen = this.blockLen;
        for (var pos = 0, len = out.length; pos < len;) {
          if (this.posOut >= blockLen) this.keccak();
          var take = Math.min(blockLen - this.posOut, len - pos);
          out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
          this.posOut += take;
          pos += take;
        }
        return out;
      }
    }, {
      key: "xofInto",
      value: function xofInto(out) {
        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF
        if (!this.enableXOF) throw new Error('XOF is not possible for this instance');
        return this.writeInto(out);
      }
    }, {
      key: "xof",
      value: function xof(bytes) {
        (0, _assert_js_1.number)(bytes);
        return this.xofInto(new Uint8Array(bytes));
      }
    }, {
      key: "digestInto",
      value: function digestInto(out) {
        (0, _assert_js_1.output)(out, this);
        if (this.finished) throw new Error('digest() was already called');
        this.writeInto(out);
        this.destroy();
        return out;
      }
    }, {
      key: "digest",
      value: function digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this.destroyed = true;
        this.state.fill(0);
      }
    }, {
      key: "_cloneInto",
      value: function _cloneInto(to) {
        var blockLen = this.blockLen,
          suffix = this.suffix,
          outputLen = this.outputLen,
          rounds = this.rounds,
          enableXOF = this.enableXOF;
        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
        to.state32.set(this.state32);
        to.pos = this.pos;
        to.posOut = this.posOut;
        to.finished = this.finished;
        to.rounds = rounds;
        // Suffix can change in cSHAKE
        to.suffix = suffix;
        to.outputLen = outputLen;
        to.enableXOF = enableXOF;
        to.destroyed = this.destroyed;
        return to;
      }
    }]);
  }(utils_js_1.Hash);
  sha3.Keccak = Keccak;
  var gen = function gen(suffix, blockLen, outputLen) {
    return (0, utils_js_1.wrapConstructor)(function () {
      return new Keccak(blockLen, suffix, outputLen);
    });
  };
  sha3.sha3_224 = gen(0x06, 144, 224 / 8);
  /**
   * SHA3-256 hash function
   * @param message - that would be hashed
   */
  sha3.sha3_256 = gen(0x06, 136, 256 / 8);
  sha3.sha3_384 = gen(0x06, 104, 384 / 8);
  sha3.sha3_512 = gen(0x06, 72, 512 / 8);
  sha3.keccak_224 = gen(0x01, 144, 224 / 8);
  /**
   * keccak-256 hash function. Different from SHA3-256.
   * @param message - that would be hashed
   */
  sha3.keccak_256 = gen(0x01, 136, 256 / 8);
  sha3.keccak_384 = gen(0x01, 104, 384 / 8);
  sha3.keccak_512 = gen(0x01, 72, 512 / 8);
  var genShake = function genShake(suffix, blockLen, outputLen) {
    return (0, utils_js_1.wrapXOFConstructorWithOpts)(function () {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true);
    });
  };
  sha3.shake128 = genShake(0x1f, 168, 128 / 8);
  sha3.shake256 = genShake(0x1f, 136, 256 / 8);
  return sha3;
}

var hasRequiredKeccak;
function requireKeccak() {
  if (hasRequiredKeccak) return keccak;
  hasRequiredKeccak = 1;
  /**
   *  Cryptographic hashing functions
   *
   *  @_subsection: api/crypto:Hash Functions [about-crypto-hashing]
   */
  Object.defineProperty(keccak, "__esModule", {
    value: true
  });
  keccak.keccak256 = void 0;
  var sha3_1 = /*@__PURE__*/requireSha3();
  var index_js_1 = /*@__PURE__*/requireUtils$3();
  var locked = false;
  var _keccak256 = function _keccak256(data) {
    return (0, sha3_1.keccak_256)(data);
  };
  var __keccak256 = _keccak256;
  /**
   *  Compute the cryptographic KECCAK256 hash of %%data%%.
   *
   *  The %%data%% **must** be a data representation, to compute the
   *  hash of UTF-8 data use the [[id]] function.
   *
   *  @returns DataHexstring
   *  @example:
   *    keccak256("0x")
   *    //_result:
   *
   *    keccak256("0x1337")
   *    //_result:
   *
   *    keccak256(new Uint8Array([ 0x13, 0x37 ]))
   *    //_result:
   *
   *    // Strings are assumed to be DataHexString, otherwise it will
   *    // throw. To hash UTF-8 data, see the note above.
   *    keccak256("Hello World")
   *    //_error:
   */
  function keccak256(_data) {
    var data = (0, index_js_1.getBytes)(_data, "data");
    return (0, index_js_1.hexlify)(__keccak256(data));
  }
  keccak.keccak256 = keccak256;
  keccak256._ = _keccak256;
  keccak256.lock = function () {
    locked = true;
  };
  keccak256.register = function (func) {
    if (locked) {
      throw new TypeError("keccak256 is locked");
    }
    __keccak256 = func;
  };
  Object.freeze(keccak256);
  return keccak;
}

var ripemd160$1 = {};

var ripemd160 = {};

var _sha2 = {};

var hasRequired_sha2;
function require_sha2() {
  if (hasRequired_sha2) return _sha2;
  hasRequired_sha2 = 1;
  Object.defineProperty(_sha2, "__esModule", {
    value: true
  });
  _sha2.SHA2 = void 0;
  var _assert_js_1 = /*@__PURE__*/require_assert();
  var utils_js_1 = /*@__PURE__*/requireUtils$2();
  // Polyfill for Safari 14
  function setBigUint64(view, byteOffset, value, isLE) {
    if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);
    var _32n = BigInt(32);
    var _u32_max = BigInt(0xffffffff);
    var wh = Number(value >> _32n & _u32_max);
    var wl = Number(value & _u32_max);
    var h = isLE ? 4 : 0;
    var l = isLE ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE);
    view.setUint32(byteOffset + l, wl, isLE);
  }
  // Base SHA2 class (RFC 6234)
  var SHA2 = /*#__PURE__*/function (_utils_js_1$Hash) {
    function SHA2(blockLen, outputLen, padOffset, isLE) {
      var _this;
      _classCallCheck(this, SHA2);
      _this = _callSuper(this, SHA2);
      _this.blockLen = blockLen;
      _this.outputLen = outputLen;
      _this.padOffset = padOffset;
      _this.isLE = isLE;
      _this.finished = false;
      _this.length = 0;
      _this.pos = 0;
      _this.destroyed = false;
      _this.buffer = new Uint8Array(blockLen);
      _this.view = (0, utils_js_1.createView)(_this.buffer);
      return _this;
    }
    _inherits(SHA2, _utils_js_1$Hash);
    return _createClass(SHA2, [{
      key: "update",
      value: function update(data) {
        (0, _assert_js_1.exists)(this);
        var view = this.view,
          buffer = this.buffer,
          blockLen = this.blockLen;
        data = (0, utils_js_1.toBytes)(data);
        var len = data.length;
        for (var pos = 0; pos < len;) {
          var take = Math.min(blockLen - this.pos, len - pos);
          // Fast path: we have at least one block in input, cast it to view and process
          if (take === blockLen) {
            var dataView = (0, utils_js_1.createView)(data);
            for (; blockLen <= len - pos; pos += blockLen) this.process(dataView, pos);
            continue;
          }
          buffer.set(data.subarray(pos, pos + take), this.pos);
          this.pos += take;
          pos += take;
          if (this.pos === blockLen) {
            this.process(view, 0);
            this.pos = 0;
          }
        }
        this.length += data.length;
        this.roundClean();
        return this;
      }
    }, {
      key: "digestInto",
      value: function digestInto(out) {
        (0, _assert_js_1.exists)(this);
        (0, _assert_js_1.output)(out, this);
        this.finished = true;
        // Padding
        // We can avoid allocation of buffer for padding completely if it
        // was previously not allocated here. But it won't change performance.
        var buffer = this.buffer,
          view = this.view,
          blockLen = this.blockLen,
          isLE = this.isLE;
        var pos = this.pos;
        // append the bit '1' to the message
        buffer[pos++] = 128;
        this.buffer.subarray(pos).fill(0);
        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again
        if (this.padOffset > blockLen - pos) {
          this.process(view, 0);
          pos = 0;
        }
        // Pad until full block byte with zeros
        for (var i = pos; i < blockLen; i++) buffer[i] = 0;
        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that
        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.
        // So we just write lowest 64 bits of that value.
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        var oview = (0, utils_js_1.createView)(out);
        var len = this.outputLen;
        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT
        if (len % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');
        var outLen = len / 4;
        var state = this.get();
        if (outLen > state.length) throw new Error('_sha2: outputLen bigger than state');
        for (var _i = 0; _i < outLen; _i++) oview.setUint32(4 * _i, state[_i], isLE);
      }
    }, {
      key: "digest",
      value: function digest() {
        var buffer = this.buffer,
          outputLen = this.outputLen;
        this.digestInto(buffer);
        var res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
      }
    }, {
      key: "_cloneInto",
      value: function _cloneInto(to) {
        var _to;
        to || (to = new this.constructor());
        (_to = to).set.apply(_to, _toConsumableArray(this.get()));
        var blockLen = this.blockLen,
          buffer = this.buffer,
          length = this.length,
          finished = this.finished,
          destroyed = this.destroyed,
          pos = this.pos;
        to.length = length;
        to.pos = pos;
        to.finished = finished;
        to.destroyed = destroyed;
        if (length % blockLen) to.buffer.set(buffer);
        return to;
      }
    }]);
  }(utils_js_1.Hash);
  _sha2.SHA2 = SHA2;
  return _sha2;
}

var hasRequiredRipemd160$1;
function requireRipemd160$1() {
  if (hasRequiredRipemd160$1) return ripemd160;
  hasRequiredRipemd160$1 = 1;
  Object.defineProperty(ripemd160, "__esModule", {
    value: true
  });
  ripemd160.ripemd160 = ripemd160.RIPEMD160 = void 0;
  var _sha2_js_1 = /*@__PURE__*/require_sha2();
  var utils_js_1 = /*@__PURE__*/requireUtils$2();
  // https://homes.esat.kuleuven.be/~bosselae/ripemd160.html
  // https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf
  var Rho = /* @__PURE__ */new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
  var Id = /* @__PURE__ */Uint8Array.from({
    length: 16
  }, function (_, i) {
    return i;
  });
  var Pi = /* @__PURE__ */Id.map(function (i) {
    return (9 * i + 5) % 16;
  });
  var idxL = [Id];
  var idxR = [Pi];
  for (var i = 0; i < 4; i++) for (var _i = 0, _arr = [idxL, idxR]; _i < _arr.length; _i++) {
    var j = _arr[_i];
    j.push(j[i].map(function (k) {
      return Rho[k];
    }));
  }
  var shifts = /* @__PURE__ */[[11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8], [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7], [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9], [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6], [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]].map(function (i) {
    return new Uint8Array(i);
  });
  var shiftsL = /* @__PURE__ */idxL.map(function (idx, i) {
    return idx.map(function (j) {
      return shifts[i][j];
    });
  });
  var shiftsR = /* @__PURE__ */idxR.map(function (idx, i) {
    return idx.map(function (j) {
      return shifts[i][j];
    });
  });
  var Kl = /* @__PURE__ */new Uint32Array([0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e]);
  var Kr = /* @__PURE__ */new Uint32Array([0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000]);
  // The rotate left (circular left shift) operation for uint32
  var rotl = function rotl(word, shift) {
    return word << shift | word >>> 32 - shift;
  };
  // It's called f() in spec.
  function f(group, x, y, z) {
    if (group === 0) return x ^ y ^ z;else if (group === 1) return x & y | ~x & z;else if (group === 2) return (x | ~y) ^ z;else if (group === 3) return x & z | y & ~z;else return x ^ (y | ~z);
  }
  // Temporary buffer, not used to store anything between runs
  var BUF = /* @__PURE__ */new Uint32Array(16);
  var RIPEMD160 = /*#__PURE__*/function (_sha2_js_1$SHA) {
    function RIPEMD160() {
      var _this;
      _classCallCheck(this, RIPEMD160);
      _this = _callSuper(this, RIPEMD160, [64, 20, 8, true]);
      _this.h0 = 0x67452301 | 0;
      _this.h1 = 0xefcdab89 | 0;
      _this.h2 = 0x98badcfe | 0;
      _this.h3 = 0x10325476 | 0;
      _this.h4 = 0xc3d2e1f0 | 0;
      return _this;
    }
    _inherits(RIPEMD160, _sha2_js_1$SHA);
    return _createClass(RIPEMD160, [{
      key: "get",
      value: function get() {
        var h0 = this.h0,
          h1 = this.h1,
          h2 = this.h2,
          h3 = this.h3,
          h4 = this.h4;
        return [h0, h1, h2, h3, h4];
      }
    }, {
      key: "set",
      value: function set(h0, h1, h2, h3, h4) {
        this.h0 = h0 | 0;
        this.h1 = h1 | 0;
        this.h2 = h2 | 0;
        this.h3 = h3 | 0;
        this.h4 = h4 | 0;
      }
    }, {
      key: "process",
      value: function process(view, offset) {
        for (var _i2 = 0; _i2 < 16; _i2++, offset += 4) BUF[_i2] = view.getUint32(offset, true);
        // prettier-ignore
        var al = this.h0 | 0,
          ar = al,
          bl = this.h1 | 0,
          br = bl,
          cl = this.h2 | 0,
          cr = cl,
          dl = this.h3 | 0,
          dr = dl,
          el = this.h4 | 0,
          er = el;
        // Instead of iterating 0 to 80, we split it into 5 groups
        // And use the groups in constants, functions, etc. Much simpler
        for (var group = 0; group < 5; group++) {
          var rGroup = 4 - group;
          var hbl = Kl[group],
            hbr = Kr[group]; // prettier-ignore
          var rl = idxL[group],
            rr = idxR[group]; // prettier-ignore
          var sl = shiftsL[group],
            sr = shiftsR[group]; // prettier-ignore
          for (var _i3 = 0; _i3 < 16; _i3++) {
            var tl = rotl(al + f(group, bl, cl, dl) + BUF[rl[_i3]] + hbl, sl[_i3]) + el | 0;
            al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore
          }
          // 2 loops are 10% faster
          for (var _i4 = 0; _i4 < 16; _i4++) {
            var tr = rotl(ar + f(rGroup, br, cr, dr) + BUF[rr[_i4]] + hbr, sr[_i4]) + er | 0;
            ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr; // prettier-ignore
          }
        }
        // Add the compressed chunk to the current hash value
        this.set(this.h1 + cl + dr | 0, this.h2 + dl + er | 0, this.h3 + el + ar | 0, this.h4 + al + br | 0, this.h0 + bl + cr | 0);
      }
    }, {
      key: "roundClean",
      value: function roundClean() {
        BUF.fill(0);
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this.destroyed = true;
        this.buffer.fill(0);
        this.set(0, 0, 0, 0, 0);
      }
    }]);
  }(_sha2_js_1.SHA2);
  ripemd160.RIPEMD160 = RIPEMD160;
  /**
   * RIPEMD-160 - a hash function from 1990s.
   * @param message - msg that would be hashed
   */
  ripemd160.ripemd160 = (0, utils_js_1.wrapConstructor)(function () {
    return new RIPEMD160();
  });
  return ripemd160;
}

var hasRequiredRipemd160;
function requireRipemd160() {
  if (hasRequiredRipemd160) return ripemd160$1;
  hasRequiredRipemd160 = 1;
  Object.defineProperty(ripemd160$1, "__esModule", {
    value: true
  });
  ripemd160$1.ripemd160 = void 0;
  var ripemd160_1 = /*@__PURE__*/requireRipemd160$1();
  var index_js_1 = /*@__PURE__*/requireUtils$3();
  var locked = false;
  var _ripemd160 = function _ripemd160(data) {
    return (0, ripemd160_1.ripemd160)(data);
  };
  var __ripemd160 = _ripemd160;
  /**
   *  Compute the cryptographic RIPEMD-160 hash of %%data%%.
   *
   *  @_docloc: api/crypto:Hash Functions
   *  @returns DataHexstring
   *
   *  @example:
   *    ripemd160("0x")
   *    //_result:
   *
   *    ripemd160("0x1337")
   *    //_result:
   *
   *    ripemd160(new Uint8Array([ 0x13, 0x37 ]))
   *    //_result:
   *
   */
  function ripemd160(_data) {
    var data = (0, index_js_1.getBytes)(_data, "data");
    return (0, index_js_1.hexlify)(__ripemd160(data));
  }
  ripemd160$1.ripemd160 = ripemd160;
  ripemd160._ = _ripemd160;
  ripemd160.lock = function () {
    locked = true;
  };
  ripemd160.register = function (func) {
    if (locked) {
      throw new TypeError("ripemd160 is locked");
    }
    __ripemd160 = func;
  };
  Object.freeze(ripemd160);
  return ripemd160$1;
}

var pbkdf2$1 = {};

var hasRequiredPbkdf2$1;
function requirePbkdf2$1() {
  if (hasRequiredPbkdf2$1) return pbkdf2$1;
  hasRequiredPbkdf2$1 = 1;
  /**
   *  A **Password-Based Key-Derivation Function** is designed to create
   *  a sequence of bytes suitible as a **key** from a human-rememberable
   *  password.
   *
   *  @_subsection: api/crypto:Passwords  [about-pbkdf]
   */
  Object.defineProperty(pbkdf2$1, "__esModule", {
    value: true
  });
  pbkdf2$1.pbkdf2 = void 0;
  var crypto_js_1 = /*@__PURE__*/requireCrypto$2();
  var index_js_1 = /*@__PURE__*/requireUtils$3();
  var locked = false;
  var _pbkdf2 = function _pbkdf2(password, salt, iterations, keylen, algo) {
    return (0, crypto_js_1.pbkdf2Sync)(password, salt, iterations, keylen, algo);
  };
  var __pbkdf2 = _pbkdf2;
  /**
   *  Return the [[link-pbkdf2]] for %%keylen%% bytes for %%password%% using
   *  the %%salt%% and using %%iterations%% of %%algo%%.
   *
   *  This PBKDF is outdated and should not be used in new projects, but is
   *  required to decrypt older files.
   *
   *  @example:
   *    // The password must be converted to bytes, and it is generally
   *    // best practices to ensure the string has been normalized. Many
   *    // formats explicitly indicate the normalization form to use.
   *    password = "hello"
   *    passwordBytes = toUtf8Bytes(password, "NFKC")
   *
   *    salt = id("some-salt")
   *
   *    // Compute the PBKDF2
   *    pbkdf2(passwordBytes, salt, 1024, 16, "sha256")
   *    //_result:
   */
  function pbkdf2(_password, _salt, iterations, keylen, algo) {
    var password = (0, index_js_1.getBytes)(_password, "password");
    var salt = (0, index_js_1.getBytes)(_salt, "salt");
    return (0, index_js_1.hexlify)(__pbkdf2(password, salt, iterations, keylen, algo));
  }
  pbkdf2$1.pbkdf2 = pbkdf2;
  pbkdf2._ = _pbkdf2;
  pbkdf2.lock = function () {
    locked = true;
  };
  pbkdf2.register = function (func) {
    if (locked) {
      throw new Error("pbkdf2 is locked");
    }
    __pbkdf2 = func;
  };
  Object.freeze(pbkdf2);
  return pbkdf2$1;
}

var random = {};

var hasRequiredRandom;
function requireRandom() {
  if (hasRequiredRandom) return random;
  hasRequiredRandom = 1;
  Object.defineProperty(random, "__esModule", {
    value: true
  });
  random.randomBytes = void 0;
  /**
   *  A **Cryptographically Secure Random Value** is one that has been
   *  generated with additional care take to prevent side-channels
   *  from allowing others to detect it and prevent others from through
   *  coincidence generate the same values.
   *
   *  @_subsection: api/crypto:Random Values  [about-crypto-random]
   */
  var crypto_js_1 = /*@__PURE__*/requireCrypto$2();
  var locked = false;
  var _randomBytes = function _randomBytes(length) {
    return new Uint8Array((0, crypto_js_1.randomBytes)(length));
  };
  var __randomBytes = _randomBytes;
  /**
   *  Return %%length%% bytes of cryptographically secure random data.
   *
   *  @example:
   *    randomBytes(8)
   *    //_result:
   */
  function randomBytes(length) {
    return __randomBytes(length);
  }
  random.randomBytes = randomBytes;
  randomBytes._ = _randomBytes;
  randomBytes.lock = function () {
    locked = true;
  };
  randomBytes.register = function (func) {
    if (locked) {
      throw new Error("randomBytes is locked");
    }
    __randomBytes = func;
  };
  Object.freeze(randomBytes);
  return random;
}

var scrypt$1 = {};

var scrypt = {};

var sha256 = {};

var hasRequiredSha256;
function requireSha256() {
  if (hasRequiredSha256) return sha256;
  hasRequiredSha256 = 1;
  Object.defineProperty(sha256, "__esModule", {
    value: true
  });
  sha256.sha224 = sha256.sha256 = void 0;
  var _sha2_js_1 = /*@__PURE__*/require_sha2();
  var utils_js_1 = /*@__PURE__*/requireUtils$2();
  // SHA2-256 need to try 2^128 hashes to execute birthday attack.
  // BTC network is doing 2^67 hashes/sec as per early 2023.
  // Choice: a ? b : c
  var Chi = function Chi(a, b, c) {
    return a & b ^ ~a & c;
  };
  // Majority function, true if any two inpust is true
  var Maj = function Maj(a, b, c) {
    return a & b ^ a & c ^ b & c;
  };
  // Round constants:
  // first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)
  // prettier-ignore
  var SHA256_K = /* @__PURE__ */new Uint32Array([0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2]);
  // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):
  // prettier-ignore
  var IV = /* @__PURE__ */new Uint32Array([0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19]);
  // Temporary buffer, not used to store anything between runs
  // Named this way because it matches specification.
  var SHA256_W = /* @__PURE__ */new Uint32Array(64);
  var SHA256 = /*#__PURE__*/function (_sha2_js_1$SHA) {
    function SHA256() {
      var _this;
      _classCallCheck(this, SHA256);
      _this = _callSuper(this, SHA256, [64, 32, 8, false]);
      // We cannot use array here since array allows indexing by variable
      // which means optimizer/compiler cannot use registers.
      _this.A = IV[0] | 0;
      _this.B = IV[1] | 0;
      _this.C = IV[2] | 0;
      _this.D = IV[3] | 0;
      _this.E = IV[4] | 0;
      _this.F = IV[5] | 0;
      _this.G = IV[6] | 0;
      _this.H = IV[7] | 0;
      return _this;
    }
    _inherits(SHA256, _sha2_js_1$SHA);
    return _createClass(SHA256, [{
      key: "get",
      value: function get() {
        var A = this.A,
          B = this.B,
          C = this.C,
          D = this.D,
          E = this.E,
          F = this.F,
          G = this.G,
          H = this.H;
        return [A, B, C, D, E, F, G, H];
      }
      // prettier-ignore
    }, {
      key: "set",
      value: function set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
      }
    }, {
      key: "process",
      value: function process(view, offset) {
        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array
        for (var i = 0; i < 16; i++, offset += 4) SHA256_W[i] = view.getUint32(offset, false);
        for (var _i = 16; _i < 64; _i++) {
          var W15 = SHA256_W[_i - 15];
          var W2 = SHA256_W[_i - 2];
          var s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ W15 >>> 3;
          var s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ W2 >>> 10;
          SHA256_W[_i] = s1 + SHA256_W[_i - 7] + s0 + SHA256_W[_i - 16] | 0;
        }
        // Compression function main loop, 64 rounds
        var A = this.A,
          B = this.B,
          C = this.C,
          D = this.D,
          E = this.E,
          F = this.F,
          G = this.G,
          H = this.H;
        for (var _i2 = 0; _i2 < 64; _i2++) {
          var sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);
          var T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[_i2] + SHA256_W[_i2] | 0;
          var sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);
          var T2 = sigma0 + Maj(A, B, C) | 0;
          H = G;
          G = F;
          F = E;
          E = D + T1 | 0;
          D = C;
          C = B;
          B = A;
          A = T1 + T2 | 0;
        }
        // Add the compressed chunk to the current hash value
        A = A + this.A | 0;
        B = B + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        E = E + this.E | 0;
        F = F + this.F | 0;
        G = G + this.G | 0;
        H = H + this.H | 0;
        this.set(A, B, C, D, E, F, G, H);
      }
    }, {
      key: "roundClean",
      value: function roundClean() {
        SHA256_W.fill(0);
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        this.buffer.fill(0);
      }
    }]);
  }(_sha2_js_1.SHA2); // Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf
  var SHA224 = /*#__PURE__*/function (_SHA) {
    function SHA224() {
      var _this2;
      _classCallCheck(this, SHA224);
      _this2 = _callSuper(this, SHA224);
      _this2.A = 0xc1059ed8 | 0;
      _this2.B = 0x367cd507 | 0;
      _this2.C = 0x3070dd17 | 0;
      _this2.D = 0xf70e5939 | 0;
      _this2.E = 0xffc00b31 | 0;
      _this2.F = 0x68581511 | 0;
      _this2.G = 0x64f98fa7 | 0;
      _this2.H = 0xbefa4fa4 | 0;
      _this2.outputLen = 28;
      return _this2;
    }
    _inherits(SHA224, _SHA);
    return _createClass(SHA224);
  }(SHA256);
  /**
   * SHA2-256 hash function
   * @param message - data that would be hashed
   */
  sha256.sha256 = (0, utils_js_1.wrapConstructor)(function () {
    return new SHA256();
  });
  sha256.sha224 = (0, utils_js_1.wrapConstructor)(function () {
    return new SHA224();
  });
  return sha256;
}

var pbkdf2 = {};

var hmac = {};

var hasRequiredHmac;
function requireHmac() {
  if (hasRequiredHmac) return hmac;
  hasRequiredHmac = 1;
  (function (exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.hmac = exports.HMAC = void 0;
    var _assert_js_1 = /*@__PURE__*/require_assert();
    var utils_js_1 = /*@__PURE__*/requireUtils$2();
    // HMAC (RFC 2104)
    var HMAC = /*#__PURE__*/function (_utils_js_1$Hash) {
      function HMAC(hash, _key) {
        var _this;
        _classCallCheck(this, HMAC);
        _this = _callSuper(this, HMAC);
        _this.finished = false;
        _this.destroyed = false;
        (0, _assert_js_1.hash)(hash);
        var key = (0, utils_js_1.toBytes)(_key);
        _this.iHash = hash.create();
        if (typeof _this.iHash.update !== 'function') throw new Error('Expected instance of class which extends utils.Hash');
        _this.blockLen = _this.iHash.blockLen;
        _this.outputLen = _this.iHash.outputLen;
        var blockLen = _this.blockLen;
        var pad = new Uint8Array(blockLen);
        // blockLen can be bigger than outputLen
        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
        for (var i = 0; i < pad.length; i++) pad[i] ^= 0x36;
        _this.iHash.update(pad);
        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone
        _this.oHash = hash.create();
        // Undo internal XOR && apply outer XOR
        for (var _i = 0; _i < pad.length; _i++) pad[_i] ^= 0x36 ^ 0x5c;
        _this.oHash.update(pad);
        pad.fill(0);
        return _this;
      }
      _inherits(HMAC, _utils_js_1$Hash);
      return _createClass(HMAC, [{
        key: "update",
        value: function update(buf) {
          (0, _assert_js_1.exists)(this);
          this.iHash.update(buf);
          return this;
        }
      }, {
        key: "digestInto",
        value: function digestInto(out) {
          (0, _assert_js_1.exists)(this);
          (0, _assert_js_1.bytes)(out, this.outputLen);
          this.finished = true;
          this.iHash.digestInto(out);
          this.oHash.update(out);
          this.oHash.digestInto(out);
          this.destroy();
        }
      }, {
        key: "digest",
        value: function digest() {
          var out = new Uint8Array(this.oHash.outputLen);
          this.digestInto(out);
          return out;
        }
      }, {
        key: "_cloneInto",
        value: function _cloneInto(to) {
          // Create new instance without calling constructor since key already in state and we don't know it.
          to || (to = Object.create(Object.getPrototypeOf(this), {}));
          var oHash = this.oHash,
            iHash = this.iHash,
            finished = this.finished,
            destroyed = this.destroyed,
            blockLen = this.blockLen,
            outputLen = this.outputLen;
          to = to;
          to.finished = finished;
          to.destroyed = destroyed;
          to.blockLen = blockLen;
          to.outputLen = outputLen;
          to.oHash = oHash._cloneInto(to.oHash);
          to.iHash = iHash._cloneInto(to.iHash);
          return to;
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.destroyed = true;
          this.oHash.destroy();
          this.iHash.destroy();
        }
      }]);
    }(utils_js_1.Hash);
    exports.HMAC = HMAC;
    /**
     * HMAC: RFC2104 message authentication code.
     * @param hash - function that would be used e.g. sha256
     * @param key - message key
     * @param message - message data
     */
    var hmac = function hmac(hash, key, message) {
      return new HMAC(hash, key).update(message).digest();
    };
    exports.hmac = hmac;
    exports.hmac.create = function (hash, key) {
      return new HMAC(hash, key);
    };
  })(hmac);
  return hmac;
}

var hasRequiredPbkdf2;
function requirePbkdf2() {
  if (hasRequiredPbkdf2) return pbkdf2;
  hasRequiredPbkdf2 = 1;
  Object.defineProperty(pbkdf2, "__esModule", {
    value: true
  });
  pbkdf2.pbkdf2Async = pbkdf2.pbkdf2 = void 0;
  var _assert_js_1 = /*@__PURE__*/require_assert();
  var hmac_js_1 = /*@__PURE__*/requireHmac();
  var utils_js_1 = /*@__PURE__*/requireUtils$2();
  // Common prologue and epilogue for sync/async functions
  function pbkdf2Init(hash, _password, _salt, _opts) {
    (0, _assert_js_1.hash)(hash);
    var opts = (0, utils_js_1.checkOpts)({
      dkLen: 32,
      asyncTick: 10
    }, _opts);
    var c = opts.c,
      dkLen = opts.dkLen,
      asyncTick = opts.asyncTick;
    (0, _assert_js_1.number)(c);
    (0, _assert_js_1.number)(dkLen);
    (0, _assert_js_1.number)(asyncTick);
    if (c < 1) throw new Error('PBKDF2: iterations (c) should be >= 1');
    var password = (0, utils_js_1.toBytes)(_password);
    var salt = (0, utils_js_1.toBytes)(_salt);
    // DK = PBKDF2(PRF, Password, Salt, c, dkLen);
    var DK = new Uint8Array(dkLen);
    // U1 = PRF(Password, Salt + INT_32_BE(i))
    var PRF = hmac_js_1.hmac.create(hash, password);
    var PRFSalt = PRF._cloneInto().update(salt);
    return {
      c: c,
      dkLen: dkLen,
      asyncTick: asyncTick,
      DK: DK,
      PRF: PRF,
      PRFSalt: PRFSalt
    };
  }
  function pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {
    PRF.destroy();
    PRFSalt.destroy();
    if (prfW) prfW.destroy();
    u.fill(0);
    return DK;
  }
  /**
   * PBKDF2-HMAC: RFC 2898 key derivation function
   * @param hash - hash function that would be used e.g. sha256
   * @param password - password from which a derived key is generated
   * @param salt - cryptographic salt
   * @param opts - {c, dkLen} where c is work factor and dkLen is output message size
   */
  function pbkdf2$1(hash, password, salt, opts) {
    var _pbkdf2Init = pbkdf2Init(hash, password, salt, opts),
      c = _pbkdf2Init.c,
      dkLen = _pbkdf2Init.dkLen,
      DK = _pbkdf2Init.DK,
      PRF = _pbkdf2Init.PRF,
      PRFSalt = _pbkdf2Init.PRFSalt;
    var prfW; // Working copy
    var arr = new Uint8Array(4);
    var view = (0, utils_js_1.createView)(arr);
    var u = new Uint8Array(PRF.outputLen);
    // DK = T1 + T2 +  + Tdklen/hlen
    for (var ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
      // Ti = F(Password, Salt, c, i)
      var Ti = DK.subarray(pos, pos + PRF.outputLen);
      view.setInt32(0, ti, false);
      // F(Password, Salt, c, i) = U1 ^ U2 ^  ^ Uc
      // U1 = PRF(Password, Salt + INT_32_BE(i))
      (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
      Ti.set(u.subarray(0, Ti.length));
      for (var ui = 1; ui < c; ui++) {
        // Uc = PRF(Password, Uc1)
        PRF._cloneInto(prfW).update(u).digestInto(u);
        for (var i = 0; i < Ti.length; i++) Ti[i] ^= u[i];
      }
    }
    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
  }
  pbkdf2.pbkdf2 = pbkdf2$1;
  function pbkdf2Async(_x, _x2, _x3, _x4) {
    return _pbkdf2Async.apply(this, arguments);
  }
  function _pbkdf2Async() {
    _pbkdf2Async = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(hash, password, salt, opts) {
      var _pbkdf2Init2, c, dkLen, asyncTick, DK, PRF, PRFSalt, prfW, arr, view, u, _loop, ti, pos;
      return _regeneratorRuntime().wrap(function _callee$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            _pbkdf2Init2 = pbkdf2Init(hash, password, salt, opts), c = _pbkdf2Init2.c, dkLen = _pbkdf2Init2.dkLen, asyncTick = _pbkdf2Init2.asyncTick, DK = _pbkdf2Init2.DK, PRF = _pbkdf2Init2.PRF, PRFSalt = _pbkdf2Init2.PRFSalt;
            // Working copy
            arr = new Uint8Array(4);
            view = (0, utils_js_1.createView)(arr);
            u = new Uint8Array(PRF.outputLen); // DK = T1 + T2 +  + Tdklen/hlen
            _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop() {
              var Ti;
              return _regeneratorRuntime().wrap(function _loop$(_context) {
                while (1) switch (_context.prev = _context.next) {
                  case 0:
                    // Ti = F(Password, Salt, c, i)
                    Ti = DK.subarray(pos, pos + PRF.outputLen);
                    view.setInt32(0, ti, false);
                    // F(Password, Salt, c, i) = U1 ^ U2 ^  ^ Uc
                    // U1 = PRF(Password, Salt + INT_32_BE(i))
                    (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
                    Ti.set(u.subarray(0, Ti.length));
                    _context.next = 6;
                    return (0, utils_js_1.asyncLoop)(c - 1, asyncTick, function () {
                      // Uc = PRF(Password, Uc1)
                      PRF._cloneInto(prfW).update(u).digestInto(u);
                      for (var i = 0; i < Ti.length; i++) Ti[i] ^= u[i];
                    });
                  case 6:
                  case "end":
                    return _context.stop();
                }
              }, _loop);
            });
            ti = 1, pos = 0;
          case 6:
            if (!(pos < dkLen)) {
              _context2.next = 11;
              break;
            }
            return _context2.delegateYield(_loop(), "t0", 8);
          case 8:
            ti++, pos += PRF.outputLen;
            _context2.next = 6;
            break;
          case 11:
            return _context2.abrupt("return", pbkdf2Output(PRF, PRFSalt, DK, prfW, u));
          case 12:
          case "end":
            return _context2.stop();
        }
      }, _callee);
    }));
    return _pbkdf2Async.apply(this, arguments);
  }
  pbkdf2.pbkdf2Async = pbkdf2Async;
  return pbkdf2;
}

var hasRequiredScrypt$1;
function requireScrypt$1() {
  if (hasRequiredScrypt$1) return scrypt;
  hasRequiredScrypt$1 = 1;
  Object.defineProperty(scrypt, "__esModule", {
    value: true
  });
  scrypt.scryptAsync = scrypt.scrypt = void 0;
  var _assert_js_1 = /*@__PURE__*/require_assert();
  var sha256_js_1 = /*@__PURE__*/requireSha256();
  var pbkdf2_js_1 = /*@__PURE__*/requirePbkdf2();
  var utils_js_1 = /*@__PURE__*/requireUtils$2();
  // RFC 7914 Scrypt KDF
  // Left rotate for uint32
  var rotl = function rotl(a, b) {
    return a << b | a >>> 32 - b;
  };
  // The main Scrypt loop: uses Salsa extensively.
  // Six versions of the function were tried, this is the fastest one.
  // prettier-ignore
  function XorAndSalsa(prev, pi, input, ii, out, oi) {
    // Based on https://cr.yp.to/salsa20.html
    // Xor blocks
    var y00 = prev[pi++] ^ input[ii++],
      y01 = prev[pi++] ^ input[ii++];
    var y02 = prev[pi++] ^ input[ii++],
      y03 = prev[pi++] ^ input[ii++];
    var y04 = prev[pi++] ^ input[ii++],
      y05 = prev[pi++] ^ input[ii++];
    var y06 = prev[pi++] ^ input[ii++],
      y07 = prev[pi++] ^ input[ii++];
    var y08 = prev[pi++] ^ input[ii++],
      y09 = prev[pi++] ^ input[ii++];
    var y10 = prev[pi++] ^ input[ii++],
      y11 = prev[pi++] ^ input[ii++];
    var y12 = prev[pi++] ^ input[ii++],
      y13 = prev[pi++] ^ input[ii++];
    var y14 = prev[pi++] ^ input[ii++],
      y15 = prev[pi++] ^ input[ii++];
    // Save state to temporary variables (salsa)
    var x00 = y00,
      x01 = y01,
      x02 = y02,
      x03 = y03,
      x04 = y04,
      x05 = y05,
      x06 = y06,
      x07 = y07,
      x08 = y08,
      x09 = y09,
      x10 = y10,
      x11 = y11,
      x12 = y12,
      x13 = y13,
      x14 = y14,
      x15 = y15;
    // Main loop (salsa)
    for (var i = 0; i < 8; i += 2) {
      x04 ^= rotl(x00 + x12 | 0, 7);
      x08 ^= rotl(x04 + x00 | 0, 9);
      x12 ^= rotl(x08 + x04 | 0, 13);
      x00 ^= rotl(x12 + x08 | 0, 18);
      x09 ^= rotl(x05 + x01 | 0, 7);
      x13 ^= rotl(x09 + x05 | 0, 9);
      x01 ^= rotl(x13 + x09 | 0, 13);
      x05 ^= rotl(x01 + x13 | 0, 18);
      x14 ^= rotl(x10 + x06 | 0, 7);
      x02 ^= rotl(x14 + x10 | 0, 9);
      x06 ^= rotl(x02 + x14 | 0, 13);
      x10 ^= rotl(x06 + x02 | 0, 18);
      x03 ^= rotl(x15 + x11 | 0, 7);
      x07 ^= rotl(x03 + x15 | 0, 9);
      x11 ^= rotl(x07 + x03 | 0, 13);
      x15 ^= rotl(x11 + x07 | 0, 18);
      x01 ^= rotl(x00 + x03 | 0, 7);
      x02 ^= rotl(x01 + x00 | 0, 9);
      x03 ^= rotl(x02 + x01 | 0, 13);
      x00 ^= rotl(x03 + x02 | 0, 18);
      x06 ^= rotl(x05 + x04 | 0, 7);
      x07 ^= rotl(x06 + x05 | 0, 9);
      x04 ^= rotl(x07 + x06 | 0, 13);
      x05 ^= rotl(x04 + x07 | 0, 18);
      x11 ^= rotl(x10 + x09 | 0, 7);
      x08 ^= rotl(x11 + x10 | 0, 9);
      x09 ^= rotl(x08 + x11 | 0, 13);
      x10 ^= rotl(x09 + x08 | 0, 18);
      x12 ^= rotl(x15 + x14 | 0, 7);
      x13 ^= rotl(x12 + x15 | 0, 9);
      x14 ^= rotl(x13 + x12 | 0, 13);
      x15 ^= rotl(x14 + x13 | 0, 18);
    }
    // Write output (salsa)
    out[oi++] = y00 + x00 | 0;
    out[oi++] = y01 + x01 | 0;
    out[oi++] = y02 + x02 | 0;
    out[oi++] = y03 + x03 | 0;
    out[oi++] = y04 + x04 | 0;
    out[oi++] = y05 + x05 | 0;
    out[oi++] = y06 + x06 | 0;
    out[oi++] = y07 + x07 | 0;
    out[oi++] = y08 + x08 | 0;
    out[oi++] = y09 + x09 | 0;
    out[oi++] = y10 + x10 | 0;
    out[oi++] = y11 + x11 | 0;
    out[oi++] = y12 + x12 | 0;
    out[oi++] = y13 + x13 | 0;
    out[oi++] = y14 + x14 | 0;
    out[oi++] = y15 + x15 | 0;
  }
  function BlockMix(input, ii, out, oi, r) {
    // The block B is r 128-byte chunks (which is equivalent of 2r 64-byte chunks)
    var head = oi + 0;
    var tail = oi + 16 * r;
    for (var i = 0; i < 16; i++) out[tail + i] = input[ii + (2 * r - 1) * 16 + i]; // X  B[2r1]
    for (var _i = 0; _i < r; _i++, head += 16, ii += 16) {
      // We write odd & even Yi at same time. Even: 0bXXXXX0 Odd:  0bXXXXX1
      XorAndSalsa(out, tail, input, ii, out, head); // head[i] = Salsa(blockIn[2*i] ^ tail[i-1])
      if (_i > 0) tail += 16; // First iteration overwrites tmp value in tail
      XorAndSalsa(out, head, input, ii += 16, out, tail); // tail[i] = Salsa(blockIn[2*i+1] ^ head[i])
    }
  }
  // Common prologue and epilogue for sync/async functions
  function scryptInit(password, salt, _opts) {
    // Maxmem - 1GB+1KB by default
    var opts = (0, utils_js_1.checkOpts)({
      dkLen: 32,
      asyncTick: 10,
      maxmem: Math.pow(1024, 3) + 1024
    }, _opts);
    var N = opts.N,
      r = opts.r,
      p = opts.p,
      dkLen = opts.dkLen,
      asyncTick = opts.asyncTick,
      maxmem = opts.maxmem,
      onProgress = opts.onProgress;
    (0, _assert_js_1.number)(N);
    (0, _assert_js_1.number)(r);
    (0, _assert_js_1.number)(p);
    (0, _assert_js_1.number)(dkLen);
    (0, _assert_js_1.number)(asyncTick);
    (0, _assert_js_1.number)(maxmem);
    if (onProgress !== undefined && typeof onProgress !== 'function') throw new Error('progressCb should be function');
    var blockSize = 128 * r;
    var blockSize32 = blockSize / 4;
    if (N <= 1 || (N & N - 1) !== 0 || N >= Math.pow(2, blockSize / 8) || N > Math.pow(2, 32)) {
      // NOTE: we limit N to be less than 2**32 because of 32 bit variant of Integrify function
      // There is no JS engines that allows alocate more than 4GB per single Uint8Array for now, but can change in future.
      throw new Error('Scrypt: N must be larger than 1, a power of 2, less than 2^(128 * r / 8) and less than 2^32');
    }
    if (p < 0 || p > (Math.pow(2, 32) - 1) * 32 / blockSize) {
      throw new Error('Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)');
    }
    if (dkLen < 0 || dkLen > (Math.pow(2, 32) - 1) * 32) {
      throw new Error('Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32');
    }
    var memUsed = blockSize * (N + p);
    if (memUsed > maxmem) {
      throw new Error("Scrypt: parameters too large, ".concat(memUsed, " (128 * r * (N + p)) > ").concat(maxmem, " (maxmem)"));
    }
    // [B0...Bp1]  PBKDF2HMAC-SHA256(Passphrase, Salt, 1, blockSize*ParallelizationFactor)
    // Since it has only one iteration there is no reason to use async variant
    var B = (0, pbkdf2_js_1.pbkdf2)(sha256_js_1.sha256, password, salt, {
      c: 1,
      dkLen: blockSize * p
    });
    var B32 = (0, utils_js_1.u32)(B);
    // Re-used between parallel iterations. Array(iterations) of B
    var V = (0, utils_js_1.u32)(new Uint8Array(blockSize * N));
    var tmp = (0, utils_js_1.u32)(new Uint8Array(blockSize));
    var blockMixCb = function blockMixCb() {};
    if (onProgress) {
      var totalBlockMix = 2 * N * p;
      // Invoke callback if progress changes from 10.01 to 10.02
      // Allows to draw smooth progress bar on up to 8K screen
      var callbackPer = Math.max(Math.floor(totalBlockMix / 10000), 1);
      var blockMixCnt = 0;
      blockMixCb = function blockMixCb() {
        blockMixCnt++;
        if (onProgress && (!(blockMixCnt % callbackPer) || blockMixCnt === totalBlockMix)) onProgress(blockMixCnt / totalBlockMix);
      };
    }
    return {
      N: N,
      r: r,
      p: p,
      dkLen: dkLen,
      blockSize32: blockSize32,
      V: V,
      B32: B32,
      B: B,
      tmp: tmp,
      blockMixCb: blockMixCb,
      asyncTick: asyncTick
    };
  }
  function scryptOutput(password, dkLen, B, V, tmp) {
    var res = (0, pbkdf2_js_1.pbkdf2)(sha256_js_1.sha256, password, B, {
      c: 1,
      dkLen: dkLen
    });
    B.fill(0);
    V.fill(0);
    tmp.fill(0);
    return res;
  }
  /**
   * Scrypt KDF from RFC 7914.
   * @param password - pass
   * @param salt - salt
   * @param opts - parameters
   * - `N` is cpu/mem work factor (power of 2 e.g. 2**18)
   * - `r` is block size (8 is common), fine-tunes sequential memory read size and performance
   * - `p` is parallelization factor (1 is common)
   * - `dkLen` is output key length in bytes e.g. 32.
   * - `asyncTick` - (default: 10) max time in ms for which async function can block execution
   * - `maxmem` - (default: `1024 ** 3 + 1024` aka 1GB+1KB). A limit that the app could use for scrypt
   * - `onProgress` - callback function that would be executed for progress report
   * @returns Derived key
   */
  function scrypt$1(password, salt, opts) {
    var _scryptInit = scryptInit(password, salt, opts),
      N = _scryptInit.N,
      r = _scryptInit.r,
      p = _scryptInit.p,
      dkLen = _scryptInit.dkLen,
      blockSize32 = _scryptInit.blockSize32,
      V = _scryptInit.V,
      B32 = _scryptInit.B32,
      B = _scryptInit.B,
      tmp = _scryptInit.tmp,
      blockMixCb = _scryptInit.blockMixCb;
    for (var pi = 0; pi < p; pi++) {
      var Pi = blockSize32 * pi;
      for (var i = 0; i < blockSize32; i++) V[i] = B32[Pi + i]; // V[0] = B[i]
      for (var _i2 = 0, pos = 0; _i2 < N - 1; _i2++) {
        BlockMix(V, pos, V, pos += blockSize32, r); // V[i] = BlockMix(V[i-1]);
        blockMixCb();
      }
      BlockMix(V, (N - 1) * blockSize32, B32, Pi, r); // Process last element
      blockMixCb();
      for (var _i3 = 0; _i3 < N; _i3++) {
        // First u32 of the last 64-byte block (u32 is LE)
        var j = B32[Pi + blockSize32 - 16] % N; // j = Integrify(X) % iterations
        for (var k = 0; k < blockSize32; k++) tmp[k] = B32[Pi + k] ^ V[j * blockSize32 + k]; // tmp = B ^ V[j]
        BlockMix(tmp, 0, B32, Pi, r); // B = BlockMix(B ^ V[j])
        blockMixCb();
      }
    }
    return scryptOutput(password, dkLen, B, V, tmp);
  }
  scrypt.scrypt = scrypt$1;
  /**
   * Scrypt KDF from RFC 7914.
   */
  function scryptAsync(_x, _x2, _x3) {
    return _scryptAsync.apply(this, arguments);
  }
  function _scryptAsync() {
    _scryptAsync = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(password, salt, opts) {
      var _scryptInit2, N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick, _loop, pi;
      return _regeneratorRuntime().wrap(function _callee$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            _scryptInit2 = scryptInit(password, salt, opts), N = _scryptInit2.N, r = _scryptInit2.r, p = _scryptInit2.p, dkLen = _scryptInit2.dkLen, blockSize32 = _scryptInit2.blockSize32, V = _scryptInit2.V, B32 = _scryptInit2.B32, B = _scryptInit2.B, tmp = _scryptInit2.tmp, blockMixCb = _scryptInit2.blockMixCb, asyncTick = _scryptInit2.asyncTick;
            _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop() {
              var Pi, i, pos;
              return _regeneratorRuntime().wrap(function _loop$(_context) {
                while (1) switch (_context.prev = _context.next) {
                  case 0:
                    Pi = blockSize32 * pi;
                    for (i = 0; i < blockSize32; i++) V[i] = B32[Pi + i]; // V[0] = B[i]
                    pos = 0;
                    _context.next = 5;
                    return (0, utils_js_1.asyncLoop)(N - 1, asyncTick, function () {
                      BlockMix(V, pos, V, pos += blockSize32, r); // V[i] = BlockMix(V[i-1]);
                      blockMixCb();
                    });
                  case 5:
                    BlockMix(V, (N - 1) * blockSize32, B32, Pi, r); // Process last element
                    blockMixCb();
                    _context.next = 9;
                    return (0, utils_js_1.asyncLoop)(N, asyncTick, function () {
                      // First u32 of the last 64-byte block (u32 is LE)
                      var j = B32[Pi + blockSize32 - 16] % N; // j = Integrify(X) % iterations
                      for (var k = 0; k < blockSize32; k++) tmp[k] = B32[Pi + k] ^ V[j * blockSize32 + k]; // tmp = B ^ V[j]
                      BlockMix(tmp, 0, B32, Pi, r); // B = BlockMix(B ^ V[j])
                      blockMixCb();
                    });
                  case 9:
                  case "end":
                    return _context.stop();
                }
              }, _loop);
            });
            pi = 0;
          case 3:
            if (!(pi < p)) {
              _context2.next = 8;
              break;
            }
            return _context2.delegateYield(_loop(), "t0", 5);
          case 5:
            pi++;
            _context2.next = 3;
            break;
          case 8:
            return _context2.abrupt("return", scryptOutput(password, dkLen, B, V, tmp));
          case 9:
          case "end":
            return _context2.stop();
        }
      }, _callee);
    }));
    return _scryptAsync.apply(this, arguments);
  }
  scrypt.scryptAsync = scryptAsync;
  return scrypt;
}

var hasRequiredScrypt;
function requireScrypt() {
  if (hasRequiredScrypt) return scrypt$1;
  hasRequiredScrypt = 1;
  Object.defineProperty(scrypt$1, "__esModule", {
    value: true
  });
  scrypt$1.scryptSync = scrypt$1.scrypt = void 0;
  var scrypt_1 = /*@__PURE__*/requireScrypt$1();
  var index_js_1 = /*@__PURE__*/requireUtils$3();
  var lockedSync = false,
    lockedAsync = false;
  var _scryptAsync = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(passwd, salt, N, r, p, dkLen, onProgress) {
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return (0, scrypt_1.scryptAsync)(passwd, salt, {
              N: N,
              r: r,
              p: p,
              dkLen: dkLen,
              onProgress: onProgress
            });
          case 2:
            return _context.abrupt("return", _context.sent);
          case 3:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    return function _scryptAsync(_x, _x2, _x3, _x4, _x5, _x6, _x7) {
      return _ref.apply(this, arguments);
    };
  }();
  var _scryptSync = function _scryptSync(passwd, salt, N, r, p, dkLen) {
    return (0, scrypt_1.scrypt)(passwd, salt, {
      N: N,
      r: r,
      p: p,
      dkLen: dkLen
    });
  };
  var __scryptAsync = _scryptAsync;
  var __scryptSync = _scryptSync;
  /**
   *  The [[link-wiki-scrypt]] uses a memory and cpu hard method of
   *  derivation to increase the resource cost to brute-force a password
   *  for a given key.
   *
   *  This means this algorithm is intentionally slow, and can be tuned to
   *  become slower. As computation and memory speed improve over time,
   *  increasing the difficulty maintains the cost of an attacker.
   *
   *  For example, if a target time of 5 seconds is used, a legitimate user
   *  which knows their password requires only 5 seconds to unlock their
   *  account. A 6 character password has 68 billion possibilities, which
   *  would require an attacker to invest over 10,000 years of CPU time. This
   *  is of course a crude example (as password generally aren't random),
   *  but demonstrates to value of imposing large costs to decryption.
   *
   *  For this reason, if building a UI which involved decrypting or
   *  encrypting datsa using scrypt, it is recommended to use a
   *  [[ProgressCallback]] (as event short periods can seem lik an eternity
   *  if the UI freezes). Including the phrase //"decrypting"// in the UI
   *  can also help, assuring the user their waiting is for a good reason.
   *
   *  @_docloc: api/crypto:Passwords
   *
   *  @example:
   *    // The password must be converted to bytes, and it is generally
   *    // best practices to ensure the string has been normalized. Many
   *    // formats explicitly indicate the normalization form to use.
   *    password = "hello"
   *    passwordBytes = toUtf8Bytes(password, "NFKC")
   *
   *    salt = id("some-salt")
   *
   *    // Compute the scrypt
   *    scrypt(passwordBytes, salt, 1024, 8, 1, 16)
   *    //_result:
   */
  function scrypt(_x8, _x9, _x10, _x11, _x12, _x13, _x14) {
    return _scrypt.apply(this, arguments);
  }
  function _scrypt() {
    _scrypt = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(_passwd, _salt, N, r, p, dkLen, progress) {
      var passwd, salt;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            passwd = (0, index_js_1.getBytes)(_passwd, "passwd");
            salt = (0, index_js_1.getBytes)(_salt, "salt");
            _context2.t0 = (index_js_1.hexlify);
            _context2.next = 5;
            return __scryptAsync(passwd, salt, N, r, p, dkLen, progress);
          case 5:
            _context2.t1 = _context2.sent;
            return _context2.abrupt("return", (0, _context2.t0)(_context2.t1));
          case 7:
          case "end":
            return _context2.stop();
        }
      }, _callee2);
    }));
    return _scrypt.apply(this, arguments);
  }
  scrypt$1.scrypt = scrypt;
  scrypt._ = _scryptAsync;
  scrypt.lock = function () {
    lockedAsync = true;
  };
  scrypt.register = function (func) {
    if (lockedAsync) {
      throw new Error("scrypt is locked");
    }
    __scryptAsync = func;
  };
  Object.freeze(scrypt);
  /**
   *  Provides a synchronous variant of [[scrypt]].
   *
   *  This will completely lock up and freeze the UI in a browser and will
   *  prevent any event loop from progressing. For this reason, it is
   *  preferred to use the [async variant](scrypt).
   *
   *  @_docloc: api/crypto:Passwords
   *
   *  @example:
   *    // The password must be converted to bytes, and it is generally
   *    // best practices to ensure the string has been normalized. Many
   *    // formats explicitly indicate the normalization form to use.
   *    password = "hello"
   *    passwordBytes = toUtf8Bytes(password, "NFKC")
   *
   *    salt = id("some-salt")
   *
   *    // Compute the scrypt
   *    scryptSync(passwordBytes, salt, 1024, 8, 1, 16)
   *    //_result:
   */
  function scryptSync(_passwd, _salt, N, r, p, dkLen) {
    var passwd = (0, index_js_1.getBytes)(_passwd, "passwd");
    var salt = (0, index_js_1.getBytes)(_salt, "salt");
    return (0, index_js_1.hexlify)(__scryptSync(passwd, salt, N, r, p, dkLen));
  }
  scrypt$1.scryptSync = scryptSync;
  scryptSync._ = _scryptSync;
  scryptSync.lock = function () {
    lockedSync = true;
  };
  scryptSync.register = function (func) {
    if (lockedSync) {
      throw new Error("scryptSync is locked");
    }
    __scryptSync = func;
  };
  Object.freeze(scryptSync);
  return scrypt$1;
}

var sha2 = {};

var hasRequiredSha2;
function requireSha2() {
  if (hasRequiredSha2) return sha2;
  hasRequiredSha2 = 1;
  Object.defineProperty(sha2, "__esModule", {
    value: true
  });
  sha2.sha512 = sha2.sha256 = void 0;
  var crypto_js_1 = /*@__PURE__*/requireCrypto$2();
  var index_js_1 = /*@__PURE__*/requireUtils$3();
  var _sha256 = function _sha256(data) {
    return (0, crypto_js_1.createHash)("sha256").update(data).digest();
  };
  var _sha512 = function _sha512(data) {
    return (0, crypto_js_1.createHash)("sha512").update(data).digest();
  };
  var __sha256 = _sha256;
  var __sha512 = _sha512;
  var locked256 = false,
    locked512 = false;
  /**
   *  Compute the cryptographic SHA2-256 hash of %%data%%.
   *
   *  @_docloc: api/crypto:Hash Functions
   *  @returns DataHexstring
   *
   *  @example:
   *    sha256("0x")
   *    //_result:
   *
   *    sha256("0x1337")
   *    //_result:
   *
   *    sha256(new Uint8Array([ 0x13, 0x37 ]))
   *    //_result:
   *
   */
  function sha256(_data) {
    var data = (0, index_js_1.getBytes)(_data, "data");
    return (0, index_js_1.hexlify)(__sha256(data));
  }
  sha2.sha256 = sha256;
  sha256._ = _sha256;
  sha256.lock = function () {
    locked256 = true;
  };
  sha256.register = function (func) {
    if (locked256) {
      throw new Error("sha256 is locked");
    }
    __sha256 = func;
  };
  Object.freeze(sha256);
  /**
   *  Compute the cryptographic SHA2-512 hash of %%data%%.
   *
   *  @_docloc: api/crypto:Hash Functions
   *  @returns DataHexstring
   *
   *  @example:
   *    sha512("0x")
   *    //_result:
   *
   *    sha512("0x1337")
   *    //_result:
   *
   *    sha512(new Uint8Array([ 0x13, 0x37 ]))
   *    //_result:
   */
  function sha512(_data) {
    var data = (0, index_js_1.getBytes)(_data, "data");
    return (0, index_js_1.hexlify)(__sha512(data));
  }
  sha2.sha512 = sha512;
  sha512._ = _sha512;
  sha512.lock = function () {
    locked512 = true;
  };
  sha512.register = function (func) {
    if (locked512) {
      throw new Error("sha512 is locked");
    }
    __sha512 = func;
  };
  Object.freeze(sha256);
  return sha2;
}

var signingKey = {};

var secp256k1 = {};

var modular = {};

var utils$1 = {};

var hasRequiredUtils$1;
function requireUtils$1() {
  if (hasRequiredUtils$1) return utils$1;
  hasRequiredUtils$1 = 1;
  Object.defineProperty(utils$1, "__esModule", {
    value: true
  });
  utils$1.validateObject = utils$1.createHmacDrbg = utils$1.bitMask = utils$1.bitSet = utils$1.bitGet = utils$1.bitLen = utils$1.utf8ToBytes = utils$1.equalBytes = utils$1.concatBytes = utils$1.ensureBytes = utils$1.numberToVarBytesBE = utils$1.numberToBytesLE = utils$1.numberToBytesBE = utils$1.bytesToNumberLE = utils$1.bytesToNumberBE = utils$1.hexToBytes = utils$1.hexToNumber = utils$1.numberToHexUnpadded = utils$1.bytesToHex = void 0;
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  // 100 lines of code in the file are duplicated from noble-hashes (utils).
  // This is OK: `abstract` directory does not use noble-hashes.
  // User may opt-in into using different hashing library. This way, noble-hashes
  // won't be included into their bundle.
  var _0n = BigInt(0);
  var _1n = BigInt(1);
  var _2n = BigInt(2);
  var u8a = function u8a(a) {
    return a instanceof Uint8Array;
  };
  var hexes = /* @__PURE__ */Array.from({
    length: 256
  }, function (_, i) {
    return i.toString(16).padStart(2, '0');
  });
  /**
   * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'
   */
  function bytesToHex(bytes) {
    if (!u8a(bytes)) throw new Error('Uint8Array expected');
    // pre-caching improves the speed 6x
    var hex = '';
    for (var i = 0; i < bytes.length; i++) {
      hex += hexes[bytes[i]];
    }
    return hex;
  }
  utils$1.bytesToHex = bytesToHex;
  function numberToHexUnpadded(num) {
    var hex = num.toString(16);
    return hex.length & 1 ? "0".concat(hex) : hex;
  }
  utils$1.numberToHexUnpadded = numberToHexUnpadded;
  function hexToNumber(hex) {
    if (typeof hex !== 'string') throw new Error('hex string expected, got ' + _typeof(hex));
    // Big Endian
    return BigInt(hex === '' ? '0' : "0x".concat(hex));
  }
  utils$1.hexToNumber = hexToNumber;
  /**
   * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])
   */
  function hexToBytes(hex) {
    if (typeof hex !== 'string') throw new Error('hex string expected, got ' + _typeof(hex));
    var len = hex.length;
    if (len % 2) throw new Error('padded hex string expected, got unpadded hex of length ' + len);
    var array = new Uint8Array(len / 2);
    for (var i = 0; i < array.length; i++) {
      var j = i * 2;
      var hexByte = hex.slice(j, j + 2);
      var _byte = Number.parseInt(hexByte, 16);
      if (Number.isNaN(_byte) || _byte < 0) throw new Error('Invalid byte sequence');
      array[i] = _byte;
    }
    return array;
  }
  utils$1.hexToBytes = hexToBytes;
  // BE: Big Endian, LE: Little Endian
  function bytesToNumberBE(bytes) {
    return hexToNumber(bytesToHex(bytes));
  }
  utils$1.bytesToNumberBE = bytesToNumberBE;
  function bytesToNumberLE(bytes) {
    if (!u8a(bytes)) throw new Error('Uint8Array expected');
    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));
  }
  utils$1.bytesToNumberLE = bytesToNumberLE;
  function numberToBytesBE(n, len) {
    return hexToBytes(n.toString(16).padStart(len * 2, '0'));
  }
  utils$1.numberToBytesBE = numberToBytesBE;
  function numberToBytesLE(n, len) {
    return numberToBytesBE(n, len).reverse();
  }
  utils$1.numberToBytesLE = numberToBytesLE;
  // Unpadded, rarely used
  function numberToVarBytesBE(n) {
    return hexToBytes(numberToHexUnpadded(n));
  }
  utils$1.numberToVarBytesBE = numberToVarBytesBE;
  /**
   * Takes hex string or Uint8Array, converts to Uint8Array.
   * Validates output length.
   * Will throw error for other types.
   * @param title descriptive title for an error e.g. 'private key'
   * @param hex hex string or Uint8Array
   * @param expectedLength optional, will compare to result array's length
   * @returns
   */
  function ensureBytes(title, hex, expectedLength) {
    var res;
    if (typeof hex === 'string') {
      try {
        res = hexToBytes(hex);
      } catch (e) {
        throw new Error("".concat(title, " must be valid hex string, got \"").concat(hex, "\". Cause: ").concat(e));
      }
    } else if (u8a(hex)) {
      // Uint8Array.from() instead of hash.slice() because node.js Buffer
      // is instance of Uint8Array, and its slice() creates **mutable** copy
      res = Uint8Array.from(hex);
    } else {
      throw new Error("".concat(title, " must be hex string or Uint8Array"));
    }
    var len = res.length;
    if (typeof expectedLength === 'number' && len !== expectedLength) throw new Error("".concat(title, " expected ").concat(expectedLength, " bytes, got ").concat(len));
    return res;
  }
  utils$1.ensureBytes = ensureBytes;
  /**
   * Copies several Uint8Arrays into one.
   */
  function concatBytes() {
    for (var _len = arguments.length, arrays = new Array(_len), _key = 0; _key < _len; _key++) {
      arrays[_key] = arguments[_key];
    }
    var r = new Uint8Array(arrays.reduce(function (sum, a) {
      return sum + a.length;
    }, 0));
    var pad = 0; // walk through each item, ensure they have proper type
    arrays.forEach(function (a) {
      if (!u8a(a)) throw new Error('Uint8Array expected');
      r.set(a, pad);
      pad += a.length;
    });
    return r;
  }
  utils$1.concatBytes = concatBytes;
  function equalBytes(b1, b2) {
    // We don't care about timing attacks here
    if (b1.length !== b2.length) return false;
    for (var i = 0; i < b1.length; i++) if (b1[i] !== b2[i]) return false;
    return true;
  }
  utils$1.equalBytes = equalBytes;
  /**
   * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])
   */
  function utf8ToBytes(str) {
    if (typeof str !== 'string') throw new Error("utf8ToBytes expected string, got ".concat(_typeof(str)));
    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
  }
  utils$1.utf8ToBytes = utf8ToBytes;
  // Bit operations
  /**
   * Calculates amount of bits in a bigint.
   * Same as `n.toString(2).length`
   */
  function bitLen(n) {
    var len;
    for (len = 0; n > _0n; n >>= _1n, len += 1);
    return len;
  }
  utils$1.bitLen = bitLen;
  /**
   * Gets single bit at position.
   * NOTE: first bit position is 0 (same as arrays)
   * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`
   */
  function bitGet(n, pos) {
    return n >> BigInt(pos) & _1n;
  }
  utils$1.bitGet = bitGet;
  /**
   * Sets single bit at position.
   */
  var bitSet = function bitSet(n, pos, value) {
    return n | (value ? _1n : _0n) << BigInt(pos);
  };
  utils$1.bitSet = bitSet;
  /**
   * Calculate mask for N bits. Not using ** operator with bigints because of old engines.
   * Same as BigInt(`0b${Array(i).fill('1').join('')}`)
   */
  var bitMask = function bitMask(n) {
    return (_2n << BigInt(n - 1)) - _1n;
  };
  utils$1.bitMask = bitMask;
  // DRBG
  var u8n = function u8n(data) {
    return new Uint8Array(data);
  }; // creates Uint8Array
  var u8fr = function u8fr(arr) {
    return Uint8Array.from(arr);
  }; // another shortcut
  /**
   * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.
   * @returns function that will call DRBG until 2nd arg returns something meaningful
   * @example
   *   const drbg = createHmacDRBG<Key>(32, 32, hmac);
   *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined
   */
  function createHmacDrbg(hashLen, qByteLen, hmacFn) {
    if (typeof hashLen !== 'number' || hashLen < 2) throw new Error('hashLen must be a number');
    if (typeof qByteLen !== 'number' || qByteLen < 2) throw new Error('qByteLen must be a number');
    if (typeof hmacFn !== 'function') throw new Error('hmacFn must be a function');
    // Step B, Step C: set hashLen to 8*ceil(hlen/8)
    var v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.
    var k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same
    var i = 0; // Iterations counter, will throw when over 1000
    var reset = function reset() {
      v.fill(1);
      k.fill(0);
      i = 0;
    };
    var h = function h() {
      for (var _len2 = arguments.length, b = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        b[_key2] = arguments[_key2];
      }
      return hmacFn.apply(void 0, [k, v].concat(b));
    }; // hmac(k)(v, ...values)
    var reseed = function reseed() {
      var seed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : u8n();
      // HMAC-DRBG reseed() function. Steps D-G
      k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)
      v = h(); // v = hmac(k || v)
      if (seed.length === 0) return;
      k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)
      v = h(); // v = hmac(k || v)
    };
    var gen = function gen() {
      // HMAC-DRBG generate() function
      if (i++ >= 1000) throw new Error('drbg: tried 1000 values');
      var len = 0;
      var out = [];
      while (len < qByteLen) {
        v = h();
        var sl = v.slice();
        out.push(sl);
        len += v.length;
      }
      return concatBytes.apply(void 0, out);
    };
    var genUntil = function genUntil(seed, pred) {
      reset();
      reseed(seed); // Steps D-G
      var res = undefined; // Step H: grind until k is in [1..n-1]
      while (!(res = pred(gen()))) reseed();
      reset();
      return res;
    };
    return genUntil;
  }
  utils$1.createHmacDrbg = createHmacDrbg;
  // Validating curves and fields
  var validatorFns = {
    bigint: function bigint(val) {
      return typeof val === 'bigint';
    },
    "function": function _function(val) {
      return typeof val === 'function';
    },
    "boolean": function boolean(val) {
      return typeof val === 'boolean';
    },
    string: function string(val) {
      return typeof val === 'string';
    },
    stringOrUint8Array: function stringOrUint8Array(val) {
      return typeof val === 'string' || val instanceof Uint8Array;
    },
    isSafeInteger: function isSafeInteger(val) {
      return Number.isSafeInteger(val);
    },
    array: function array(val) {
      return Array.isArray(val);
    },
    field: function field(val, object) {
      return object.Fp.isValid(val);
    },
    hash: function hash(val) {
      return typeof val === 'function' && Number.isSafeInteger(val.outputLen);
    }
  };
  // type Record<K extends string | number | symbol, T> = { [P in K]: T; }
  function validateObject(object, validators) {
    var optValidators = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var checkField = function checkField(fieldName, type, isOptional) {
      var checkVal = validatorFns[type];
      if (typeof checkVal !== 'function') throw new Error("Invalid validator \"".concat(type, "\", expected function"));
      var val = object[fieldName];
      if (isOptional && val === undefined) return;
      if (!checkVal(val, object)) {
        throw new Error("Invalid param ".concat(String(fieldName), "=").concat(val, " (").concat(_typeof(val), "), expected ").concat(type));
      }
    };
    for (var _i = 0, _Object$entries = Object.entries(validators); _i < _Object$entries.length; _i++) {
      var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
        fieldName = _Object$entries$_i[0],
        type = _Object$entries$_i[1];
      checkField(fieldName, type, false);
    }
    for (var _i2 = 0, _Object$entries2 = Object.entries(optValidators); _i2 < _Object$entries2.length; _i2++) {
      var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i2], 2),
        _fieldName = _Object$entries2$_i[0],
        _type = _Object$entries2$_i[1];
      checkField(_fieldName, _type, true);
    }
    return object;
  }
  utils$1.validateObject = validateObject;
  // validate type tests
  // const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };
  // const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!
  // // Should fail type-check
  // const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });
  // const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });
  // const z3 = validateObject(o, { test: 'boolean', z: 'bug' });
  // const z4 = validateObject(o, { a: 'boolean', z: 'bug' });

  return utils$1;
}

var hasRequiredModular;
function requireModular() {
  if (hasRequiredModular) return modular;
  hasRequiredModular = 1;
  Object.defineProperty(modular, "__esModule", {
    value: true
  });
  modular.mapHashToField = modular.getMinHashLength = modular.getFieldBytesLength = modular.hashToPrivateScalar = modular.FpSqrtEven = modular.FpSqrtOdd = modular.Field = modular.nLength = modular.FpIsSquare = modular.FpDiv = modular.FpInvertBatch = modular.FpPow = modular.validateField = modular.isNegativeLE = modular.FpSqrt = modular.tonelliShanks = modular.invert = modular.pow2 = modular.pow = modular.mod = void 0;
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  // Utilities for modular arithmetics and finite fields
  var utils_js_1 = /*@__PURE__*/requireUtils$1();
  // prettier-ignore
  var _0n = BigInt(0),
    _1n = BigInt(1),
    _2n = BigInt(2),
    _3n = BigInt(3);
  // prettier-ignore
  var _4n = BigInt(4),
    _5n = BigInt(5),
    _8n = BigInt(8);
  // prettier-ignore
  BigInt(9);
    BigInt(16);
  // Calculates a modulo b
  function mod(a, b) {
    var result = a % b;
    return result >= _0n ? result : b + result;
  }
  modular.mod = mod;
  /**
   * Efficiently raise num to power and do modular division.
   * Unsafe in some contexts: uses ladder, so can expose bigint bits.
   * @example
   * pow(2n, 6n, 11n) // 64n % 11n == 9n
   */
  // TODO: use field version && remove
  function pow(num, power, modulo) {
    if (modulo <= _0n || power < _0n) throw new Error('Expected power/modulo > 0');
    if (modulo === _1n) return _0n;
    var res = _1n;
    while (power > _0n) {
      if (power & _1n) res = res * num % modulo;
      num = num * num % modulo;
      power >>= _1n;
    }
    return res;
  }
  modular.pow = pow;
  // Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)
  function pow2(x, power, modulo) {
    var res = x;
    while (power-- > _0n) {
      res *= res;
      res %= modulo;
    }
    return res;
  }
  modular.pow2 = pow2;
  // Inverses number over modulo
  function invert(number, modulo) {
    if (number === _0n || modulo <= _0n) {
      throw new Error("invert: expected positive integers, got n=".concat(number, " mod=").concat(modulo));
    }
    // Euclidean GCD https://brilliant.org/wiki/extended-euclidean-algorithm/
    // Fermat's little theorem "CT-like" version inv(n) = n^(m-2) mod m is 30x slower.
    var a = mod(number, modulo);
    var b = modulo;
    // prettier-ignore
    var x = _0n,
      u = _1n;
    while (a !== _0n) {
      // JIT applies optimization if those two lines follow each other
      var q = b / a;
      var r = b % a;
      var m = x - u * q;
      // prettier-ignore
      b = a, a = r, x = u, u = m;
    }
    var gcd = b;
    if (gcd !== _1n) throw new Error('invert: does not exist');
    return mod(x, modulo);
  }
  modular.invert = invert;
  /**
   * Tonelli-Shanks square root search algorithm.
   * 1. https://eprint.iacr.org/2012/685.pdf (page 12)
   * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks
   * Will start an infinite loop if field order P is not prime.
   * @param P field order
   * @returns function that takes field Fp (created from P) and number n
   */
  function tonelliShanks(P) {
    // Legendre constant: used to calculate Legendre symbol (a | p),
    // which denotes the value of a^((p-1)/2) (mod p).
    // (a | p)  1    if a is a square (mod p)
    // (a | p)  -1   if a is not a square (mod p)
    // (a | p)  0    if a  0 (mod p)
    var legendreC = (P - _1n) / _2n;
    var Q, S, Z;
    // Step 1: By factoring out powers of 2 from p - 1,
    // find q and s such that p - 1 = q*(2^s) with q odd
    for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++);
    // Step 2: Select a non-square z such that (z | p)  -1 and set c  zq
    for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++);
    // Fast-path
    if (S === 1) {
      var p1div4 = (P + _1n) / _4n;
      return function tonelliFast(Fp, n) {
        var root = Fp.pow(n, p1div4);
        if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');
        return root;
      };
    }
    // Slow-path
    var Q1div2 = (Q + _1n) / _2n;
    return function tonelliSlow(Fp, n) {
      // Step 0: Check that n is indeed a square: (n | p) should not be  -1
      if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE)) throw new Error('Cannot find square root');
      var r = S;
      // TODO: will fail at Fp2/etc
      var g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b
      var x = Fp.pow(n, Q1div2); // first guess at the square root
      var b = Fp.pow(n, Q); // first guess at the fudge factor
      while (!Fp.eql(b, Fp.ONE)) {
        if (Fp.eql(b, Fp.ZERO)) return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)
        // Find m such b^(2^m)==1
        var m = 1;
        for (var t2 = Fp.sqr(b); m < r; m++) {
          if (Fp.eql(t2, Fp.ONE)) break;
          t2 = Fp.sqr(t2); // t2 *= t2
        }
        // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow
        var ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)
        g = Fp.sqr(ge); // g = ge * ge
        x = Fp.mul(x, ge); // x *= ge
        b = Fp.mul(b, g); // b *= g
        r = m;
      }
      return x;
    };
  }
  modular.tonelliShanks = tonelliShanks;
  function FpSqrt(P) {
    // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.
    // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).
    // P  3 (mod 4)
    // n = n^((P+1)/4)
    if (P % _4n === _3n) {
      // Not all roots possible!
      // const ORDER =
      //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;
      // const NUM = 72057594037927816n;
      var p1div4 = (P + _1n) / _4n;
      return function sqrt3mod4(Fp, n) {
        var root = Fp.pow(n, p1div4);
        // Throw if root**2 != n
        if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');
        return root;
      };
    }
    // Atkin algorithm for q  5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)
    if (P % _8n === _5n) {
      var c1 = (P - _5n) / _8n;
      return function sqrt5mod8(Fp, n) {
        var n2 = Fp.mul(n, _2n);
        var v = Fp.pow(n2, c1);
        var nv = Fp.mul(n, v);
        var i = Fp.mul(Fp.mul(nv, _2n), v);
        var root = Fp.mul(nv, Fp.sub(i, Fp.ONE));
        if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');
        return root;
      };
    }
    // Other cases: Tonelli-Shanks algorithm
    return tonelliShanks(P);
  }
  modular.FpSqrt = FpSqrt;
  // Little-endian check for first LE bit (last BE bit);
  var isNegativeLE = function isNegativeLE(num, modulo) {
    return (mod(num, modulo) & _1n) === _1n;
  };
  modular.isNegativeLE = isNegativeLE;
  // prettier-ignore
  var FIELD_FIELDS = ['create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr', 'eql', 'add', 'sub', 'mul', 'pow', 'div', 'addN', 'subN', 'mulN', 'sqrN'];
  function validateField(field) {
    var initial = {
      ORDER: 'bigint',
      MASK: 'bigint',
      BYTES: 'isSafeInteger',
      BITS: 'isSafeInteger'
    };
    var opts = FIELD_FIELDS.reduce(function (map, val) {
      map[val] = 'function';
      return map;
    }, initial);
    return (0, utils_js_1.validateObject)(field, opts);
  }
  modular.validateField = validateField;
  // Generic field functions
  /**
   * Same as `pow` but for Fp: non-constant-time.
   * Unsafe in some contexts: uses ladder, so can expose bigint bits.
   */
  function FpPow(f, num, power) {
    // Should have same speed as pow for bigints
    // TODO: benchmark!
    if (power < _0n) throw new Error('Expected power > 0');
    if (power === _0n) return f.ONE;
    if (power === _1n) return num;
    var p = f.ONE;
    var d = num;
    while (power > _0n) {
      if (power & _1n) p = f.mul(p, d);
      d = f.sqr(d);
      power >>= _1n;
    }
    return p;
  }
  modular.FpPow = FpPow;
  /**
   * Efficiently invert an array of Field elements.
   * `inv(0)` will return `undefined` here: make sure to throw an error.
   */
  function FpInvertBatch(f, nums) {
    var tmp = new Array(nums.length);
    // Walk from first to last, multiply them by each other MOD p
    var lastMultiplied = nums.reduce(function (acc, num, i) {
      if (f.is0(num)) return acc;
      tmp[i] = acc;
      return f.mul(acc, num);
    }, f.ONE);
    // Invert last element
    var inverted = f.inv(lastMultiplied);
    // Walk from last to first, multiply them by inverted each other MOD p
    nums.reduceRight(function (acc, num, i) {
      if (f.is0(num)) return acc;
      tmp[i] = f.mul(acc, tmp[i]);
      return f.mul(acc, num);
    }, inverted);
    return tmp;
  }
  modular.FpInvertBatch = FpInvertBatch;
  function FpDiv(f, lhs, rhs) {
    return f.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, f.ORDER) : f.inv(rhs));
  }
  modular.FpDiv = FpDiv;
  // This function returns True whenever the value x is a square in the field F.
  function FpIsSquare(f) {
    var legendreConst = (f.ORDER - _1n) / _2n; // Integer arithmetic
    return function (x) {
      var p = f.pow(x, legendreConst);
      return f.eql(p, f.ZERO) || f.eql(p, f.ONE);
    };
  }
  modular.FpIsSquare = FpIsSquare;
  // CURVE.n lengths
  function nLength(n, nBitLength) {
    // Bit size, byte size of CURVE.n
    var _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;
    var nByteLength = Math.ceil(_nBitLength / 8);
    return {
      nBitLength: _nBitLength,
      nByteLength: nByteLength
    };
  }
  modular.nLength = nLength;
  /**
   * Initializes a finite field over prime. **Non-primes are not supported.**
   * Do not init in loop: slow. Very fragile: always run a benchmark on a change.
   * Major performance optimizations:
   * * a) denormalized operations like mulN instead of mul
   * * b) same object shape: never add or remove keys
   * * c) Object.freeze
   * @param ORDER prime positive bigint
   * @param bitLen how many bits the field consumes
   * @param isLE (def: false) if encoding / decoding should be in little-endian
   * @param redef optional faster redefinitions of sqrt and other methods
   */
  function Field(ORDER, bitLen) {
    var isLE = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var redef = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    if (ORDER <= _0n) throw new Error("Expected Field ORDER > 0, got ".concat(ORDER));
    var _nLength = nLength(ORDER, bitLen),
      BITS = _nLength.nBitLength,
      BYTES = _nLength.nByteLength;
    if (BYTES > 2048) throw new Error('Field lengths over 2048 bytes are not supported');
    var sqrtP = FpSqrt(ORDER);
    var f = Object.freeze({
      ORDER: ORDER,
      BITS: BITS,
      BYTES: BYTES,
      MASK: (0, utils_js_1.bitMask)(BITS),
      ZERO: _0n,
      ONE: _1n,
      create: function create(num) {
        return mod(num, ORDER);
      },
      isValid: function isValid(num) {
        if (typeof num !== 'bigint') throw new Error("Invalid field element: expected bigint, got ".concat(_typeof(num)));
        return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible
      },
      is0: function is0(num) {
        return num === _0n;
      },
      isOdd: function isOdd(num) {
        return (num & _1n) === _1n;
      },
      neg: function neg(num) {
        return mod(-num, ORDER);
      },
      eql: function eql(lhs, rhs) {
        return lhs === rhs;
      },
      sqr: function sqr(num) {
        return mod(num * num, ORDER);
      },
      add: function add(lhs, rhs) {
        return mod(lhs + rhs, ORDER);
      },
      sub: function sub(lhs, rhs) {
        return mod(lhs - rhs, ORDER);
      },
      mul: function mul(lhs, rhs) {
        return mod(lhs * rhs, ORDER);
      },
      pow: function pow(num, power) {
        return FpPow(f, num, power);
      },
      div: function div(lhs, rhs) {
        return mod(lhs * invert(rhs, ORDER), ORDER);
      },
      // Same as above, but doesn't normalize
      sqrN: function sqrN(num) {
        return num * num;
      },
      addN: function addN(lhs, rhs) {
        return lhs + rhs;
      },
      subN: function subN(lhs, rhs) {
        return lhs - rhs;
      },
      mulN: function mulN(lhs, rhs) {
        return lhs * rhs;
      },
      inv: function inv(num) {
        return invert(num, ORDER);
      },
      sqrt: redef.sqrt || function (n) {
        return sqrtP(f, n);
      },
      invertBatch: function invertBatch(lst) {
        return FpInvertBatch(f, lst);
      },
      // TODO: do we really need constant cmov?
      // We don't have const-time bigints anyway, so probably will be not very useful
      cmov: function cmov(a, b, c) {
        return c ? b : a;
      },
      toBytes: function toBytes(num) {
        return isLE ? (0, utils_js_1.numberToBytesLE)(num, BYTES) : (0, utils_js_1.numberToBytesBE)(num, BYTES);
      },
      fromBytes: function fromBytes(bytes) {
        if (bytes.length !== BYTES) throw new Error("Fp.fromBytes: expected ".concat(BYTES, ", got ").concat(bytes.length));
        return isLE ? (0, utils_js_1.bytesToNumberLE)(bytes) : (0, utils_js_1.bytesToNumberBE)(bytes);
      }
    });
    return Object.freeze(f);
  }
  modular.Field = Field;
  function FpSqrtOdd(Fp, elm) {
    if (!Fp.isOdd) throw new Error("Field doesn't have isOdd");
    var root = Fp.sqrt(elm);
    return Fp.isOdd(root) ? root : Fp.neg(root);
  }
  modular.FpSqrtOdd = FpSqrtOdd;
  function FpSqrtEven(Fp, elm) {
    if (!Fp.isOdd) throw new Error("Field doesn't have isOdd");
    var root = Fp.sqrt(elm);
    return Fp.isOdd(root) ? Fp.neg(root) : root;
  }
  modular.FpSqrtEven = FpSqrtEven;
  /**
   * "Constant-time" private key generation utility.
   * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).
   * Which makes it slightly more biased, less secure.
   * @deprecated use mapKeyToField instead
   */
  function hashToPrivateScalar(hash, groupOrder) {
    var isLE = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    hash = (0, utils_js_1.ensureBytes)('privateHash', hash);
    var hashLen = hash.length;
    var minLen = nLength(groupOrder).nByteLength + 8;
    if (minLen < 24 || hashLen < minLen || hashLen > 1024) throw new Error("hashToPrivateScalar: expected ".concat(minLen, "-1024 bytes of input, got ").concat(hashLen));
    var num = isLE ? (0, utils_js_1.bytesToNumberLE)(hash) : (0, utils_js_1.bytesToNumberBE)(hash);
    return mod(num, groupOrder - _1n) + _1n;
  }
  modular.hashToPrivateScalar = hashToPrivateScalar;
  /**
   * Returns total number of bytes consumed by the field element.
   * For example, 32 bytes for usual 256-bit weierstrass curve.
   * @param fieldOrder number of field elements, usually CURVE.n
   * @returns byte length of field
   */
  function getFieldBytesLength(fieldOrder) {
    if (typeof fieldOrder !== 'bigint') throw new Error('field order must be bigint');
    var bitLength = fieldOrder.toString(2).length;
    return Math.ceil(bitLength / 8);
  }
  modular.getFieldBytesLength = getFieldBytesLength;
  /**
   * Returns minimal amount of bytes that can be safely reduced
   * by field order.
   * Should be 2^-128 for 128-bit curve such as P256.
   * @param fieldOrder number of field elements, usually CURVE.n
   * @returns byte length of target hash
   */
  function getMinHashLength(fieldOrder) {
    var length = getFieldBytesLength(fieldOrder);
    return length + Math.ceil(length / 2);
  }
  modular.getMinHashLength = getMinHashLength;
  /**
   * "Constant-time" private key generation utility.
   * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF
   * and convert them into private scalar, with the modulo bias being negligible.
   * Needs at least 48 bytes of input for 32-byte private key.
   * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/
   * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final
   * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5
   * @param hash hash output from SHA3 or a similar function
   * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)
   * @param isLE interpret hash bytes as LE num
   * @returns valid private scalar
   */
  function mapHashToField(key, fieldOrder) {
    var isLE = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var len = key.length;
    var fieldLen = getFieldBytesLength(fieldOrder);
    var minLen = getMinHashLength(fieldOrder);
    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.
    if (len < 16 || len < minLen || len > 1024) throw new Error("expected ".concat(minLen, "-1024 bytes of input, got ").concat(len));
    var num = isLE ? (0, utils_js_1.bytesToNumberBE)(key) : (0, utils_js_1.bytesToNumberLE)(key);
    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0
    var reduced = mod(num, fieldOrder - _1n) + _1n;
    return isLE ? (0, utils_js_1.numberToBytesLE)(reduced, fieldLen) : (0, utils_js_1.numberToBytesBE)(reduced, fieldLen);
  }
  modular.mapHashToField = mapHashToField;
  return modular;
}

var weierstrass = {};

var curve = {};

var hasRequiredCurve;
function requireCurve() {
  if (hasRequiredCurve) return curve;
  hasRequiredCurve = 1;
  Object.defineProperty(curve, "__esModule", {
    value: true
  });
  curve.validateBasic = curve.wNAF = void 0;
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  // Abelian group utilities
  var modular_js_1 = /*@__PURE__*/requireModular();
  var utils_js_1 = /*@__PURE__*/requireUtils$1();
  var _0n = BigInt(0);
  var _1n = BigInt(1);
  // Elliptic curve multiplication of Point by scalar. Fragile.
  // Scalars should always be less than curve order: this should be checked inside of a curve itself.
  // Creates precomputation tables for fast multiplication:
  // - private scalar is split by fixed size windows of W bits
  // - every window point is collected from window's table & added to accumulator
  // - since windows are different, same point inside tables won't be accessed more than once per calc
  // - each multiplication is 'Math.ceil(CURVE_ORDER / ) + 1' point additions (fixed for any scalar)
  // - +1 window is neccessary for wNAF
  // - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication
  // TODO: Research returning 2d JS array of windows, instead of a single window. This would allow
  // windows to be in different memory locations
  function wNAF(c, bits) {
    var constTimeNegate = function constTimeNegate(condition, item) {
      var neg = item.negate();
      return condition ? neg : item;
    };
    var opts = function opts(W) {
      var windows = Math.ceil(bits / W) + 1; // +1, because
      var windowSize = Math.pow(2, W - 1); // -1 because we skip zero
      return {
        windows: windows,
        windowSize: windowSize
      };
    };
    return {
      constTimeNegate: constTimeNegate,
      // non-const time multiplication ladder
      unsafeLadder: function unsafeLadder(elm, n) {
        var p = c.ZERO;
        var d = elm;
        while (n > _0n) {
          if (n & _1n) p = p.add(d);
          d = d["double"]();
          n >>= _1n;
        }
        return p;
      },
      /**
       * Creates a wNAF precomputation window. Used for caching.
       * Default window size is set by `utils.precompute()` and is equal to 8.
       * Number of precomputed points depends on the curve size:
       * 2^(1) * (Math.ceil( / ) + 1), where:
       * -  is the window size
       * -  is the bitlength of the curve order.
       * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
       * @returns precomputed point tables flattened to a single array
       */
      precomputeWindow: function precomputeWindow(elm, W) {
        var _opts = opts(W),
          windows = _opts.windows,
          windowSize = _opts.windowSize;
        var points = [];
        var p = elm;
        var base = p;
        for (var window = 0; window < windows; window++) {
          base = p;
          points.push(base);
          // =1, because we skip zero
          for (var i = 1; i < windowSize; i++) {
            base = base.add(p);
            points.push(base);
          }
          p = base["double"]();
        }
        return points;
      },
      /**
       * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
       * @param W window size
       * @param precomputes precomputed tables
       * @param n scalar (we don't check here, but should be less than curve order)
       * @returns real and fake (for const-time) points
       */
      wNAF: function wNAF(W, precomputes, n) {
        // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise
        // But need to carefully remove other checks before wNAF. ORDER == bits here
        var _opts2 = opts(W),
          windows = _opts2.windows,
          windowSize = _opts2.windowSize;
        var p = c.ZERO;
        var f = c.BASE;
        var mask = BigInt(Math.pow(2, W) - 1); // Create mask with W ones: 0b1111 for W=4 etc.
        var maxNumber = Math.pow(2, W);
        var shiftBy = BigInt(W);
        for (var window = 0; window < windows; window++) {
          var offset = window * windowSize;
          // Extract W bits.
          var wbits = Number(n & mask);
          // Shift number by W bits.
          n >>= shiftBy;
          // If the bits are bigger than max size, we'll split those.
          // +224 => 256 - 32
          if (wbits > windowSize) {
            wbits -= maxNumber;
            n += _1n;
          }
          // This code was first written with assumption that 'f' and 'p' will never be infinity point:
          // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,
          // there is negate now: it is possible that negated element from low value
          // would be the same as high element, which will create carry into next window.
          // It's not obvious how this can fail, but still worth investigating later.
          // Check if we're onto Zero point.
          // Add random point inside current window to f.
          var offset1 = offset;
          var offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero
          var cond1 = window % 2 !== 0;
          var cond2 = wbits < 0;
          if (wbits === 0) {
            // The most important part for const-time getPublicKey
            f = f.add(constTimeNegate(cond1, precomputes[offset1]));
          } else {
            p = p.add(constTimeNegate(cond2, precomputes[offset2]));
          }
        }
        // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()
        // Even if the variable is still unused, there are some checks which will
        // throw an exception, so compiler needs to prove they won't happen, which is hard.
        // At this point there is a way to F be infinity-point even if p is not,
        // which makes it less const-time: around 1 bigint multiply.
        return {
          p: p,
          f: f
        };
      },
      wNAFCached: function wNAFCached(P, precomputesMap, n, transform) {
        // @ts-ignore
        var W = P._WINDOW_SIZE || 1;
        // Calculate precomputes on a first run, reuse them after
        var comp = precomputesMap.get(P);
        if (!comp) {
          comp = this.precomputeWindow(P, W);
          if (W !== 1) {
            precomputesMap.set(P, transform(comp));
          }
        }
        return this.wNAF(W, comp, n);
      }
    };
  }
  curve.wNAF = wNAF;
  function validateBasic(curve) {
    (0, modular_js_1.validateField)(curve.Fp);
    (0, utils_js_1.validateObject)(curve, {
      n: 'bigint',
      h: 'bigint',
      Gx: 'field',
      Gy: 'field'
    }, {
      nBitLength: 'isSafeInteger',
      nByteLength: 'isSafeInteger'
    });
    // Set defaults
    return Object.freeze(_objectSpread2(_objectSpread2(_objectSpread2({}, (0, modular_js_1.nLength)(curve.n, curve.nBitLength)), curve), {
      p: curve.Fp.ORDER
    }));
  }
  curve.validateBasic = validateBasic;
  return curve;
}

var hasRequiredWeierstrass;
function requireWeierstrass() {
  if (hasRequiredWeierstrass) return weierstrass;
  hasRequiredWeierstrass = 1;
  (function (exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.mapToCurveSimpleSWU = exports.SWUFpSqrtRatio = exports.weierstrass = exports.weierstrassPoints = exports.DER = void 0;
    /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
    // Short Weierstrass curve. The formula is: y = x + ax + b
    var mod = /*@__PURE__*/requireModular();
    var ut = /*@__PURE__*/requireUtils$1();
    var utils_js_1 = /*@__PURE__*/requireUtils$1();
    var curve_js_1 = /*@__PURE__*/requireCurve();
    function validatePointOpts(curve) {
      var opts = (0, curve_js_1.validateBasic)(curve);
      ut.validateObject(opts, {
        a: 'field',
        b: 'field'
      }, {
        allowedPrivateKeyLengths: 'array',
        wrapPrivateKey: 'boolean',
        isTorsionFree: 'function',
        clearCofactor: 'function',
        allowInfinityPoint: 'boolean',
        fromBytes: 'function',
        toBytes: 'function'
      });
      var endo = opts.endo,
        Fp = opts.Fp,
        a = opts.a;
      if (endo) {
        if (!Fp.eql(a, Fp.ZERO)) {
          throw new Error('Endomorphism can only be defined for Koblitz curves that have a=0');
        }
        if (_typeof(endo) !== 'object' || typeof endo.beta !== 'bigint' || typeof endo.splitScalar !== 'function') {
          throw new Error('Expected endomorphism with beta: bigint and splitScalar: function');
        }
      }
      return Object.freeze(_objectSpread2({}, opts));
    }
    // ASN.1 DER encoding utilities
    var b2n = ut.bytesToNumberBE,
      h2b = ut.hexToBytes;
    exports.DER = {
      // asn.1 DER encoding utils
      Err: /*#__PURE__*/function (_Error) {
        function DERErr() {
          var m = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
          _classCallCheck(this, DERErr);
          return _callSuper(this, DERErr, [m]);
        }
        _inherits(DERErr, _Error);
        return _createClass(DERErr);
      }(/*#__PURE__*/_wrapNativeSuper(Error)),
      _parseInt: function _parseInt(data) {
        var E = exports.DER.Err;
        if (data.length < 2 || data[0] !== 0x02) throw new E('Invalid signature integer tag');
        var len = data[1];
        var res = data.subarray(2, len + 2);
        if (!len || res.length !== len) throw new E('Invalid signature integer: wrong length');
        // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
        // since we always use positive integers here. It must always be empty:
        // - add zero byte if exists
        // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
        if (res[0] & 128) throw new E('Invalid signature integer: negative');
        if (res[0] === 0x00 && !(res[1] & 128)) throw new E('Invalid signature integer: unnecessary leading zero');
        return {
          d: b2n(res),
          l: data.subarray(len + 2)
        }; // d is data, l is left
      },
      toSig: function toSig(hex) {
        // parse DER signature
        var E = exports.DER.Err;
        var data = typeof hex === 'string' ? h2b(hex) : hex;
        if (!(data instanceof Uint8Array)) throw new Error('ui8a expected');
        var l = data.length;
        if (l < 2 || data[0] != 0x30) throw new E('Invalid signature tag');
        if (data[1] !== l - 2) throw new E('Invalid signature: incorrect length');
        var _exports$DER$_parseIn = exports.DER._parseInt(data.subarray(2)),
          r = _exports$DER$_parseIn.d,
          sBytes = _exports$DER$_parseIn.l;
        var _exports$DER$_parseIn2 = exports.DER._parseInt(sBytes),
          s = _exports$DER$_parseIn2.d,
          rBytesLeft = _exports$DER$_parseIn2.l;
        if (rBytesLeft.length) throw new E('Invalid signature: left bytes after parsing');
        return {
          r: r,
          s: s
        };
      },
      hexFromSig: function hexFromSig(sig) {
        // Add leading zero if first byte has negative bit enabled. More details in '_parseInt'
        var slice = function slice(s) {
          return Number.parseInt(s[0], 16) & 8 ? '00' + s : s;
        };
        var h = function h(num) {
          var hex = num.toString(16);
          return hex.length & 1 ? "0".concat(hex) : hex;
        };
        var s = slice(h(sig.s));
        var r = slice(h(sig.r));
        var shl = s.length / 2;
        var rhl = r.length / 2;
        var sl = h(shl);
        var rl = h(rhl);
        return "30".concat(h(rhl + shl + 4), "02").concat(rl).concat(r, "02").concat(sl).concat(s);
      }
    };
    // Be friendly to bad ECMAScript parsers by not using bigint literals
    // prettier-ignore
    var _0n = BigInt(0),
      _1n = BigInt(1),
      _2n = BigInt(2),
      _3n = BigInt(3),
      _4n = BigInt(4);
    function weierstrassPoints(opts) {
      var CURVE = validatePointOpts(opts);
      var Fp = CURVE.Fp; // All curves has same field / group length as for now, but they can differ
      var toBytes = CURVE.toBytes || function (_c, point, _isCompressed) {
        var a = point.toAffine();
        return ut.concatBytes(Uint8Array.from([0x04]), Fp.toBytes(a.x), Fp.toBytes(a.y));
      };
      var fromBytes = CURVE.fromBytes || function (bytes) {
        // const head = bytes[0];
        var tail = bytes.subarray(1);
        // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');
        var x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
        var y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
        return {
          x: x,
          y: y
        };
      };
      /**
       * y = x + ax + b: Short weierstrass curve formula
       * @returns y
       */
      function weierstrassEquation(x) {
        var a = CURVE.a,
          b = CURVE.b;
        var x2 = Fp.sqr(x); // x * x
        var x3 = Fp.mul(x2, x); // x2 * x
        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b
      }
      // Validate whether the passed curve params are valid.
      // We check if curve equation works for generator point.
      // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.
      // ProjectivePoint class has not been initialized yet.
      if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx))) throw new Error('bad generator point: equation left != right');
      // Valid group elements reside in range 1..n-1
      function isWithinCurveOrder(num) {
        return typeof num === 'bigint' && _0n < num && num < CURVE.n;
      }
      function assertGE(num) {
        if (!isWithinCurveOrder(num)) throw new Error('Expected valid bigint: 0 < bigint < curve.n');
      }
      // Validates if priv key is valid and converts it to bigint.
      // Supports options allowedPrivateKeyLengths and wrapPrivateKey.
      function normPrivateKeyToScalar(key) {
        var lengths = CURVE.allowedPrivateKeyLengths,
          nByteLength = CURVE.nByteLength,
          wrapPrivateKey = CURVE.wrapPrivateKey,
          n = CURVE.n;
        if (lengths && typeof key !== 'bigint') {
          if (key instanceof Uint8Array) key = ut.bytesToHex(key);
          // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes
          if (typeof key !== 'string' || !lengths.includes(key.length)) throw new Error('Invalid key');
          key = key.padStart(nByteLength * 2, '0');
        }
        var num;
        try {
          num = typeof key === 'bigint' ? key : ut.bytesToNumberBE((0, utils_js_1.ensureBytes)('private key', key, nByteLength));
        } catch (error) {
          throw new Error("private key must be ".concat(nByteLength, " bytes, hex or bigint, not ").concat(_typeof(key)));
        }
        if (wrapPrivateKey) num = mod.mod(num, n); // disabled by default, enabled for BLS
        assertGE(num); // num in range [1..N-1]
        return num;
      }
      var pointPrecomputes = new Map();
      function assertPrjPoint(other) {
        if (!(other instanceof Point)) throw new Error('ProjectivePoint expected');
      }
      /**
       * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z)  (x=x/z, y=y/z)
       * Default Point works in 2d / affine coordinates: (x, y)
       * We're doing calculations in projective, because its operations don't require costly inversion.
       */
      var Point = /*#__PURE__*/function () {
        function Point(px, py, pz) {
          _classCallCheck(this, Point);
          this.px = px;
          this.py = py;
          this.pz = pz;
          if (px == null || !Fp.isValid(px)) throw new Error('x required');
          if (py == null || !Fp.isValid(py)) throw new Error('y required');
          if (pz == null || !Fp.isValid(pz)) throw new Error('z required');
        }
        // Does not validate if the point is on-curve.
        // Use fromHex instead, or call assertValidity() later.
        return _createClass(Point, [{
          key: "x",
          get: function get() {
            return this.toAffine().x;
          }
        }, {
          key: "y",
          get: function get() {
            return this.toAffine().y;
          }
          /**
           * Takes a bunch of Projective Points but executes only one
           * inversion on all of them. Inversion is very slow operation,
           * so this improves performance massively.
           * Optimization: converts a list of projective points to a list of identical points with Z=1.
           */
        }, {
          key: "_setWindowSize",
          value:
          // "Private method", don't use it directly
          function _setWindowSize(windowSize) {
            this._WINDOW_SIZE = windowSize;
            pointPrecomputes["delete"](this);
          }
          // A point on curve is valid if it conforms to equation.
        }, {
          key: "assertValidity",
          value: function assertValidity() {
            if (this.is0()) {
              // (0, 1, 0) aka ZERO is invalid in most contexts.
              // In BLS, ZERO can be serialized, so we allow it.
              // (0, 0, 0) is wrong representation of ZERO and is always invalid.
              if (CURVE.allowInfinityPoint && !Fp.is0(this.py)) return;
              throw new Error('bad point: ZERO');
            }
            // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`
            var _this$toAffine = this.toAffine(),
              x = _this$toAffine.x,
              y = _this$toAffine.y;
            // Check if x, y are valid field elements
            if (!Fp.isValid(x) || !Fp.isValid(y)) throw new Error('bad point: x or y not FE');
            var left = Fp.sqr(y); // y
            var right = weierstrassEquation(x); // x + ax + b
            if (!Fp.eql(left, right)) throw new Error('bad point: equation left != right');
            if (!this.isTorsionFree()) throw new Error('bad point: not in prime-order subgroup');
          }
        }, {
          key: "hasEvenY",
          value: function hasEvenY() {
            var _this$toAffine2 = this.toAffine(),
              y = _this$toAffine2.y;
            if (Fp.isOdd) return !Fp.isOdd(y);
            throw new Error("Field doesn't support isOdd");
          }
          /**
           * Compare one point to another.
           */
        }, {
          key: "equals",
          value: function equals(other) {
            assertPrjPoint(other);
            var X1 = this.px,
              Y1 = this.py,
              Z1 = this.pz;
            var X2 = other.px,
              Y2 = other.py,
              Z2 = other.pz;
            var U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));
            var U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
            return U1 && U2;
          }
          /**
           * Flips point to one corresponding to (x, -y) in Affine coordinates.
           */
        }, {
          key: "negate",
          value: function negate() {
            return new Point(this.px, Fp.neg(this.py), this.pz);
          }
          // Renes-Costello-Batina exception-free doubling formula.
          // There is 30% faster Jacobian formula, but it is not complete.
          // https://eprint.iacr.org/2015/1060, algorithm 3
          // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
        }, {
          key: "double",
          value: function _double() {
            var a = CURVE.a,
              b = CURVE.b;
            var b3 = Fp.mul(b, _3n);
            var X1 = this.px,
              Y1 = this.py,
              Z1 = this.pz;
            var X3 = Fp.ZERO,
              Y3 = Fp.ZERO,
              Z3 = Fp.ZERO; // prettier-ignore
            var t0 = Fp.mul(X1, X1); // step 1
            var t1 = Fp.mul(Y1, Y1);
            var t2 = Fp.mul(Z1, Z1);
            var t3 = Fp.mul(X1, Y1);
            t3 = Fp.add(t3, t3); // step 5
            Z3 = Fp.mul(X1, Z1);
            Z3 = Fp.add(Z3, Z3);
            X3 = Fp.mul(a, Z3);
            Y3 = Fp.mul(b3, t2);
            Y3 = Fp.add(X3, Y3); // step 10
            X3 = Fp.sub(t1, Y3);
            Y3 = Fp.add(t1, Y3);
            Y3 = Fp.mul(X3, Y3);
            X3 = Fp.mul(t3, X3);
            Z3 = Fp.mul(b3, Z3); // step 15
            t2 = Fp.mul(a, t2);
            t3 = Fp.sub(t0, t2);
            t3 = Fp.mul(a, t3);
            t3 = Fp.add(t3, Z3);
            Z3 = Fp.add(t0, t0); // step 20
            t0 = Fp.add(Z3, t0);
            t0 = Fp.add(t0, t2);
            t0 = Fp.mul(t0, t3);
            Y3 = Fp.add(Y3, t0);
            t2 = Fp.mul(Y1, Z1); // step 25
            t2 = Fp.add(t2, t2);
            t0 = Fp.mul(t2, t3);
            X3 = Fp.sub(X3, t0);
            Z3 = Fp.mul(t2, t1);
            Z3 = Fp.add(Z3, Z3); // step 30
            Z3 = Fp.add(Z3, Z3);
            return new Point(X3, Y3, Z3);
          }
          // Renes-Costello-Batina exception-free addition formula.
          // There is 30% faster Jacobian formula, but it is not complete.
          // https://eprint.iacr.org/2015/1060, algorithm 1
          // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
        }, {
          key: "add",
          value: function add(other) {
            assertPrjPoint(other);
            var X1 = this.px,
              Y1 = this.py,
              Z1 = this.pz;
            var X2 = other.px,
              Y2 = other.py,
              Z2 = other.pz;
            var X3 = Fp.ZERO,
              Y3 = Fp.ZERO,
              Z3 = Fp.ZERO; // prettier-ignore
            var a = CURVE.a;
            var b3 = Fp.mul(CURVE.b, _3n);
            var t0 = Fp.mul(X1, X2); // step 1
            var t1 = Fp.mul(Y1, Y2);
            var t2 = Fp.mul(Z1, Z2);
            var t3 = Fp.add(X1, Y1);
            var t4 = Fp.add(X2, Y2); // step 5
            t3 = Fp.mul(t3, t4);
            t4 = Fp.add(t0, t1);
            t3 = Fp.sub(t3, t4);
            t4 = Fp.add(X1, Z1);
            var t5 = Fp.add(X2, Z2); // step 10
            t4 = Fp.mul(t4, t5);
            t5 = Fp.add(t0, t2);
            t4 = Fp.sub(t4, t5);
            t5 = Fp.add(Y1, Z1);
            X3 = Fp.add(Y2, Z2); // step 15
            t5 = Fp.mul(t5, X3);
            X3 = Fp.add(t1, t2);
            t5 = Fp.sub(t5, X3);
            Z3 = Fp.mul(a, t4);
            X3 = Fp.mul(b3, t2); // step 20
            Z3 = Fp.add(X3, Z3);
            X3 = Fp.sub(t1, Z3);
            Z3 = Fp.add(t1, Z3);
            Y3 = Fp.mul(X3, Z3);
            t1 = Fp.add(t0, t0); // step 25
            t1 = Fp.add(t1, t0);
            t2 = Fp.mul(a, t2);
            t4 = Fp.mul(b3, t4);
            t1 = Fp.add(t1, t2);
            t2 = Fp.sub(t0, t2); // step 30
            t2 = Fp.mul(a, t2);
            t4 = Fp.add(t4, t2);
            t0 = Fp.mul(t1, t4);
            Y3 = Fp.add(Y3, t0);
            t0 = Fp.mul(t5, t4); // step 35
            X3 = Fp.mul(t3, X3);
            X3 = Fp.sub(X3, t0);
            t0 = Fp.mul(t3, t1);
            Z3 = Fp.mul(t5, Z3);
            Z3 = Fp.add(Z3, t0); // step 40
            return new Point(X3, Y3, Z3);
          }
        }, {
          key: "subtract",
          value: function subtract(other) {
            return this.add(other.negate());
          }
        }, {
          key: "is0",
          value: function is0() {
            return this.equals(Point.ZERO);
          }
        }, {
          key: "wNAF",
          value: function wNAF(n) {
            return wnaf.wNAFCached(this, pointPrecomputes, n, function (comp) {
              var toInv = Fp.invertBatch(comp.map(function (p) {
                return p.pz;
              }));
              return comp.map(function (p, i) {
                return p.toAffine(toInv[i]);
              }).map(Point.fromAffine);
            });
          }
          /**
           * Non-constant-time multiplication. Uses double-and-add algorithm.
           * It's faster, but should only be used when you don't care about
           * an exposed private key e.g. sig verification, which works over *public* keys.
           */
        }, {
          key: "multiplyUnsafe",
          value: function multiplyUnsafe(n) {
            var I = Point.ZERO;
            if (n === _0n) return I;
            assertGE(n); // Will throw on 0
            if (n === _1n) return this;
            var endo = CURVE.endo;
            if (!endo) return wnaf.unsafeLadder(this, n);
            // Apply endomorphism
            var _endo$splitScalar = endo.splitScalar(n),
              k1neg = _endo$splitScalar.k1neg,
              k1 = _endo$splitScalar.k1,
              k2neg = _endo$splitScalar.k2neg,
              k2 = _endo$splitScalar.k2;
            var k1p = I;
            var k2p = I;
            var d = this;
            while (k1 > _0n || k2 > _0n) {
              if (k1 & _1n) k1p = k1p.add(d);
              if (k2 & _1n) k2p = k2p.add(d);
              d = d["double"]();
              k1 >>= _1n;
              k2 >>= _1n;
            }
            if (k1neg) k1p = k1p.negate();
            if (k2neg) k2p = k2p.negate();
            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
            return k1p.add(k2p);
          }
          /**
           * Constant time multiplication.
           * Uses wNAF method. Windowed method may be 10% faster,
           * but takes 2x longer to generate and consumes 2x memory.
           * Uses precomputes when available.
           * Uses endomorphism for Koblitz curves.
           * @param scalar by which the point would be multiplied
           * @returns New point
           */
        }, {
          key: "multiply",
          value: function multiply(scalar) {
            assertGE(scalar);
            var n = scalar;
            var point, fake; // Fake point is used to const-time mult
            var endo = CURVE.endo;
            if (endo) {
              var _endo$splitScalar2 = endo.splitScalar(n),
                k1neg = _endo$splitScalar2.k1neg,
                k1 = _endo$splitScalar2.k1,
                k2neg = _endo$splitScalar2.k2neg,
                k2 = _endo$splitScalar2.k2;
              var _this$wNAF = this.wNAF(k1),
                k1p = _this$wNAF.p,
                f1p = _this$wNAF.f;
              var _this$wNAF2 = this.wNAF(k2),
                k2p = _this$wNAF2.p,
                f2p = _this$wNAF2.f;
              k1p = wnaf.constTimeNegate(k1neg, k1p);
              k2p = wnaf.constTimeNegate(k2neg, k2p);
              k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
              point = k1p.add(k2p);
              fake = f1p.add(f2p);
            } else {
              var _this$wNAF3 = this.wNAF(n),
                p = _this$wNAF3.p,
                f = _this$wNAF3.f;
              point = p;
              fake = f;
            }
            // Normalize `z` for both points, but return only real one
            return Point.normalizeZ([point, fake])[0];
          }
          /**
           * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
           * Not using Strauss-Shamir trick: precomputation tables are faster.
           * The trick could be useful if both P and Q are not G (not in our case).
           * @returns non-zero affine point
           */
        }, {
          key: "multiplyAndAddUnsafe",
          value: function multiplyAndAddUnsafe(Q, a, b) {
            var G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes
            var mul = function mul(P, a // Select faster multiply() method
            ) {
              return a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a);
            };
            var sum = mul(this, a).add(mul(Q, b));
            return sum.is0() ? undefined : sum;
          }
          // Converts Projective point to affine (x, y) coordinates.
          // Can accept precomputed Z^-1 - for example, from invertBatch.
          // (x, y, z)  (x=x/z, y=y/z)
        }, {
          key: "toAffine",
          value: function toAffine(iz) {
            var x = this.px,
              y = this.py,
              z = this.pz;
            var is0 = this.is0();
            // If invZ was 0, we return zero point. However we still want to execute
            // all operations, so we replace invZ with a random number, 1.
            if (iz == null) iz = is0 ? Fp.ONE : Fp.inv(z);
            var ax = Fp.mul(x, iz);
            var ay = Fp.mul(y, iz);
            var zz = Fp.mul(z, iz);
            if (is0) return {
              x: Fp.ZERO,
              y: Fp.ZERO
            };
            if (!Fp.eql(zz, Fp.ONE)) throw new Error('invZ was invalid');
            return {
              x: ax,
              y: ay
            };
          }
        }, {
          key: "isTorsionFree",
          value: function isTorsionFree() {
            var cofactor = CURVE.h,
              isTorsionFree = CURVE.isTorsionFree;
            if (cofactor === _1n) return true; // No subgroups, always torsion-free
            if (isTorsionFree) return isTorsionFree(Point, this);
            throw new Error('isTorsionFree() has not been declared for the elliptic curve');
          }
        }, {
          key: "clearCofactor",
          value: function clearCofactor() {
            var cofactor = CURVE.h,
              clearCofactor = CURVE.clearCofactor;
            if (cofactor === _1n) return this; // Fast-path
            if (clearCofactor) return clearCofactor(Point, this);
            return this.multiplyUnsafe(CURVE.h);
          }
        }, {
          key: "toRawBytes",
          value: function toRawBytes() {
            var isCompressed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
            this.assertValidity();
            return toBytes(Point, this, isCompressed);
          }
        }, {
          key: "toHex",
          value: function toHex() {
            var isCompressed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
            return ut.bytesToHex(this.toRawBytes(isCompressed));
          }
        }], [{
          key: "fromAffine",
          value: function fromAffine(p) {
            var _ref = p || {},
              x = _ref.x,
              y = _ref.y;
            if (!p || !Fp.isValid(x) || !Fp.isValid(y)) throw new Error('invalid affine point');
            if (p instanceof Point) throw new Error('projective point not allowed');
            var is0 = function is0(i) {
              return Fp.eql(i, Fp.ZERO);
            };
            // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)
            if (is0(x) && is0(y)) return Point.ZERO;
            return new Point(x, y, Fp.ONE);
          }
        }, {
          key: "normalizeZ",
          value: function normalizeZ(points) {
            var toInv = Fp.invertBatch(points.map(function (p) {
              return p.pz;
            }));
            return points.map(function (p, i) {
              return p.toAffine(toInv[i]);
            }).map(Point.fromAffine);
          }
          /**
           * Converts hash string or Uint8Array to Point.
           * @param hex short/long ECDSA hex
           */
        }, {
          key: "fromHex",
          value: function fromHex(hex) {
            var P = Point.fromAffine(fromBytes((0, utils_js_1.ensureBytes)('pointHex', hex)));
            P.assertValidity();
            return P;
          }
          // Multiplies generator point by privateKey.
        }, {
          key: "fromPrivateKey",
          value: function fromPrivateKey(privateKey) {
            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));
          }
        }]);
      }();
      Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);
      Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);
      var _bits = CURVE.nBitLength;
      var wnaf = (0, curve_js_1.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
      // Validate if generator point is on curve
      return {
        CURVE: CURVE,
        ProjectivePoint: Point,
        normPrivateKeyToScalar: normPrivateKeyToScalar,
        weierstrassEquation: weierstrassEquation,
        isWithinCurveOrder: isWithinCurveOrder
      };
    }
    exports.weierstrassPoints = weierstrassPoints;
    function validateOpts(curve) {
      var opts = (0, curve_js_1.validateBasic)(curve);
      ut.validateObject(opts, {
        hash: 'hash',
        hmac: 'function',
        randomBytes: 'function'
      }, {
        bits2int: 'function',
        bits2int_modN: 'function',
        lowS: 'boolean'
      });
      return Object.freeze(_objectSpread2({
        lowS: true
      }, opts));
    }
    function weierstrass(curveDef) {
      var CURVE = validateOpts(curveDef);
      var Fp = CURVE.Fp,
        CURVE_ORDER = CURVE.n;
      var compressedLen = Fp.BYTES + 1; // e.g. 33 for 32
      var uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32
      function isValidFieldElement(num) {
        return _0n < num && num < Fp.ORDER; // 0 is banned since it's not invertible FE
      }
      function modN(a) {
        return mod.mod(a, CURVE_ORDER);
      }
      function invN(a) {
        return mod.invert(a, CURVE_ORDER);
      }
      var _weierstrassPoints = weierstrassPoints(_objectSpread2(_objectSpread2({}, CURVE), {}, {
          toBytes: function toBytes(_c, point, isCompressed) {
            var a = point.toAffine();
            var x = Fp.toBytes(a.x);
            var cat = ut.concatBytes;
            if (isCompressed) {
              return cat(Uint8Array.from([point.hasEvenY() ? 0x02 : 0x03]), x);
            } else {
              return cat(Uint8Array.from([0x04]), x, Fp.toBytes(a.y));
            }
          },
          fromBytes: function fromBytes(bytes) {
            var len = bytes.length;
            var head = bytes[0];
            var tail = bytes.subarray(1);
            // this.assertValidity() is done inside of fromHex
            if (len === compressedLen && (head === 0x02 || head === 0x03)) {
              var x = ut.bytesToNumberBE(tail);
              if (!isValidFieldElement(x)) throw new Error('Point is not on curve');
              var y2 = weierstrassEquation(x); // y = x + ax + b
              var y = Fp.sqrt(y2); // y = y ^ (p+1)/4
              var isYOdd = (y & _1n) === _1n;
              // ECDSA
              var isHeadOdd = (head & 1) === 1;
              if (isHeadOdd !== isYOdd) y = Fp.neg(y);
              return {
                x: x,
                y: y
              };
            } else if (len === uncompressedLen && head === 0x04) {
              var _x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
              var _y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
              return {
                x: _x,
                y: _y
              };
            } else {
              throw new Error("Point of length ".concat(len, " was invalid. Expected ").concat(compressedLen, " compressed bytes or ").concat(uncompressedLen, " uncompressed bytes"));
            }
          }
        })),
        Point = _weierstrassPoints.ProjectivePoint,
        normPrivateKeyToScalar = _weierstrassPoints.normPrivateKeyToScalar,
        weierstrassEquation = _weierstrassPoints.weierstrassEquation,
        isWithinCurveOrder = _weierstrassPoints.isWithinCurveOrder;
      var numToNByteStr = function numToNByteStr(num) {
        return ut.bytesToHex(ut.numberToBytesBE(num, CURVE.nByteLength));
      };
      function isBiggerThanHalfOrder(number) {
        var HALF = CURVE_ORDER >> _1n;
        return number > HALF;
      }
      function normalizeS(s) {
        return isBiggerThanHalfOrder(s) ? modN(-s) : s;
      }
      // slice bytes num
      var slcNum = function slcNum(b, from, to) {
        return ut.bytesToNumberBE(b.slice(from, to));
      };
      /**
       * ECDSA signature with its (r, s) properties. Supports DER & compact representations.
       */
      var Signature = /*#__PURE__*/function () {
        function Signature(r, s, recovery) {
          _classCallCheck(this, Signature);
          this.r = r;
          this.s = s;
          this.recovery = recovery;
          this.assertValidity();
        }
        // pair (bytes of r, bytes of s)
        return _createClass(Signature, [{
          key: "assertValidity",
          value: function assertValidity() {
            // can use assertGE here
            if (!isWithinCurveOrder(this.r)) throw new Error('r must be 0 < r < CURVE.n');
            if (!isWithinCurveOrder(this.s)) throw new Error('s must be 0 < s < CURVE.n');
          }
        }, {
          key: "addRecoveryBit",
          value: function addRecoveryBit(recovery) {
            return new Signature(this.r, this.s, recovery);
          }
        }, {
          key: "recoverPublicKey",
          value: function recoverPublicKey(msgHash) {
            var r = this.r,
              s = this.s,
              rec = this.recovery;
            var h = bits2int_modN((0, utils_js_1.ensureBytes)('msgHash', msgHash)); // Truncate hash
            if (rec == null || ![0, 1, 2, 3].includes(rec)) throw new Error('recovery id invalid');
            var radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
            if (radj >= Fp.ORDER) throw new Error('recovery id 2 or 3 invalid');
            var prefix = (rec & 1) === 0 ? '02' : '03';
            var R = Point.fromHex(prefix + numToNByteStr(radj));
            var ir = invN(radj); // r^-1
            var u1 = modN(-h * ir); // -hr^-1
            var u2 = modN(s * ir); // sr^-1
            var Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)
            if (!Q) throw new Error('point at infinify'); // unsafe is fine: no priv data leaked
            Q.assertValidity();
            return Q;
          }
          // Signatures should be low-s, to prevent malleability.
        }, {
          key: "hasHighS",
          value: function hasHighS() {
            return isBiggerThanHalfOrder(this.s);
          }
        }, {
          key: "normalizeS",
          value: function normalizeS() {
            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;
          }
          // DER-encoded
        }, {
          key: "toDERRawBytes",
          value: function toDERRawBytes() {
            return ut.hexToBytes(this.toDERHex());
          }
        }, {
          key: "toDERHex",
          value: function toDERHex() {
            return exports.DER.hexFromSig({
              r: this.r,
              s: this.s
            });
          }
          // padded bytes of r, then padded bytes of s
        }, {
          key: "toCompactRawBytes",
          value: function toCompactRawBytes() {
            return ut.hexToBytes(this.toCompactHex());
          }
        }, {
          key: "toCompactHex",
          value: function toCompactHex() {
            return numToNByteStr(this.r) + numToNByteStr(this.s);
          }
        }], [{
          key: "fromCompact",
          value: function fromCompact(hex) {
            var l = CURVE.nByteLength;
            hex = (0, utils_js_1.ensureBytes)('compactSignature', hex, l * 2);
            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
          }
          // DER encoded ECDSA signature
          // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
        }, {
          key: "fromDER",
          value: function fromDER(hex) {
            var _exports$DER$toSig = exports.DER.toSig((0, utils_js_1.ensureBytes)('DER', hex)),
              r = _exports$DER$toSig.r,
              s = _exports$DER$toSig.s;
            return new Signature(r, s);
          }
        }]);
      }();
      var utils = {
        isValidPrivateKey: function isValidPrivateKey(privateKey) {
          try {
            normPrivateKeyToScalar(privateKey);
            return true;
          } catch (error) {
            return false;
          }
        },
        normPrivateKeyToScalar: normPrivateKeyToScalar,
        /**
         * Produces cryptographically secure private key from random of size
         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
         */
        randomPrivateKey: function randomPrivateKey() {
          var length = mod.getMinHashLength(CURVE.n);
          return mod.mapHashToField(CURVE.randomBytes(length), CURVE.n);
        },
        /**
         * Creates precompute table for an arbitrary EC point. Makes point "cached".
         * Allows to massively speed-up `point.multiply(scalar)`.
         * @returns cached point
         * @example
         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
         * fast.multiply(privKey); // much faster ECDH now
         */
        precompute: function precompute() {
          var windowSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 8;
          var point = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Point.BASE;
          point._setWindowSize(windowSize);
          point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here
          return point;
        }
      };
      /**
       * Computes public key for a private key. Checks for validity of the private key.
       * @param privateKey private key
       * @param isCompressed whether to return compact (default), or full key
       * @returns Public key, full when isCompressed=false; short when isCompressed=true
       */
      function getPublicKey(privateKey) {
        var isCompressed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
      }
      /**
       * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.
       */
      function isProbPub(item) {
        var arr = item instanceof Uint8Array;
        var str = typeof item === 'string';
        var len = (arr || str) && item.length;
        if (arr) return len === compressedLen || len === uncompressedLen;
        if (str) return len === 2 * compressedLen || len === 2 * uncompressedLen;
        if (item instanceof Point) return true;
        return false;
      }
      /**
       * ECDH (Elliptic Curve Diffie Hellman).
       * Computes shared public key from private key and public key.
       * Checks: 1) private key validity 2) shared key is on-curve.
       * Does NOT hash the result.
       * @param privateA private key
       * @param publicB different public key
       * @param isCompressed whether to return compact (default), or full key
       * @returns shared public key
       */
      function getSharedSecret(privateA, publicB) {
        var isCompressed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
        if (isProbPub(privateA)) throw new Error('first arg must be private key');
        if (!isProbPub(publicB)) throw new Error('second arg must be public key');
        var b = Point.fromHex(publicB); // check for being on-curve
        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
      }
      // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.
      // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.
      // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.
      // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors
      var bits2int = CURVE.bits2int || function (bytes) {
        // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)
        // for some cases, since bytes.length * 8 is not actual bitLength.
        var num = ut.bytesToNumberBE(bytes); // check for == u8 done here
        var delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits
        return delta > 0 ? num >> BigInt(delta) : num;
      };
      var bits2int_modN = CURVE.bits2int_modN || function (bytes) {
        return modN(bits2int(bytes)); // can't use bytesToNumberBE here
      };
      // NOTE: pads output with zero as per spec
      var ORDER_MASK = ut.bitMask(CURVE.nBitLength);
      /**
       * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.
       */
      function int2octets(num) {
        if (typeof num !== 'bigint') throw new Error('bigint expected');
        if (!(_0n <= num && num < ORDER_MASK)) throw new Error("bigint expected < 2^".concat(CURVE.nBitLength));
        // works with order, can have different size than numToField!
        return ut.numberToBytesBE(num, CURVE.nByteLength);
      }
      // Steps A, D of RFC6979 3.2
      // Creates RFC6979 seed; converts msg/privKey to numbers.
      // Used only in sign, not in verify.
      // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order, this will be wrong at least for P521.
      // Also it can be bigger for P224 + SHA256
      function prepSig(msgHash, privateKey) {
        var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultSigOpts;
        if (['recovered', 'canonical'].some(function (k) {
          return k in opts;
        })) throw new Error('sign() legacy options not supported');
        var hash = CURVE.hash,
          randomBytes = CURVE.randomBytes;
        var lowS = opts.lowS,
          prehash = opts.prehash,
          ent = opts.extraEntropy; // generates low-s sigs by default
        if (lowS == null) lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash
        msgHash = (0, utils_js_1.ensureBytes)('msgHash', msgHash);
        if (prehash) msgHash = (0, utils_js_1.ensureBytes)('prehashed msgHash', hash(msgHash));
        // We can't later call bits2octets, since nested bits2int is broken for curves
        // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.
        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))
        var h1int = bits2int_modN(msgHash);
        var d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint
        var seedArgs = [int2octets(d), int2octets(h1int)];
        // extraEntropy. RFC6979 3.6: additional k' (optional).
        if (ent != null) {
          // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')
          var e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is
          seedArgs.push((0, utils_js_1.ensureBytes)('extraEntropy', e)); // check for being bytes
        }
        var seed = ut.concatBytes.apply(ut, seedArgs); // Step D of RFC6979 3.2
        var m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!
        // Converts signature params into point w r/s, checks result for validity.
        function k2sig(kBytes) {
          // RFC 6979 Section 3.2, step 3: k = bits2int(T)
          var k = bits2int(kBytes); // Cannot use fields methods, since it is group element
          if (!isWithinCurveOrder(k)) return; // Important: all mod() calls here must be done over N
          var ik = invN(k); // k^-1 mod n
          var q = Point.BASE.multiply(k).toAffine(); // q = Gk
          var r = modN(q.x); // r = q.x mod n
          if (r === _0n) return;
          // Can use scalar blinding b^-1(bm + bdr) where b  [1,q1] according to
          // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:
          // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT
          var s = modN(ik * modN(m + r * d)); // Not using blinding here
          if (s === _0n) return;
          var recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)
          var normS = s;
          if (lowS && isBiggerThanHalfOrder(s)) {
            normS = normalizeS(s); // if lowS was passed, ensure s is always
            recovery ^= 1; // // in the bottom half of N
          }
          return new Signature(r, normS, recovery); // use normS, not s
        }
        return {
          seed: seed,
          k2sig: k2sig
        };
      }
      var defaultSigOpts = {
        lowS: CURVE.lowS,
        prehash: false
      };
      var defaultVerOpts = {
        lowS: CURVE.lowS,
        prehash: false
      };
      /**
       * Signs message hash with a private key.
       * ```
       * sign(m, d, k) where
       *   (x, y) = G  k
       *   r = x mod n
       *   s = (m + dr)/k mod n
       * ```
       * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.
       * @param privKey private key
       * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.
       * @returns signature with recovery param
       */
      function sign(msgHash, privKey) {
        var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultSigOpts;
        var _prepSig = prepSig(msgHash, privKey, opts),
          seed = _prepSig.seed,
          k2sig = _prepSig.k2sig; // Steps A, D of RFC6979 3.2.
        var C = CURVE;
        var drbg = ut.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
        return drbg(seed, k2sig); // Steps B, C, D, E, F, G
      }
      // Enable precomputes. Slows down first publicKey computation by 20ms.
      Point.BASE._setWindowSize(8);
      // utils.precompute(8, ProjectivePoint.BASE)
      /**
       * Verifies a signature against message hash and public key.
       * Rejects lowS signatures by default: to override,
       * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:
       *
       * ```
       * verify(r, s, h, P) where
       *   U1 = hs^-1 mod n
       *   U2 = rs^-1 mod n
       *   R = U1G - U2P
       *   mod(R.x, n) == r
       * ```
       */
      function verify(signature, msgHash, publicKey) {
        var _Point$BASE$multiplyA;
        var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : defaultVerOpts;
        var sg = signature;
        msgHash = (0, utils_js_1.ensureBytes)('msgHash', msgHash);
        publicKey = (0, utils_js_1.ensureBytes)('publicKey', publicKey);
        if ('strict' in opts) throw new Error('options.strict was renamed to lowS');
        var lowS = opts.lowS,
          prehash = opts.prehash;
        var _sig = undefined;
        var P;
        try {
          if (typeof sg === 'string' || sg instanceof Uint8Array) {
            // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).
            // Since DER can also be 2*nByteLength bytes, we check for it first.
            try {
              _sig = Signature.fromDER(sg);
            } catch (derError) {
              if (!(derError instanceof exports.DER.Err)) throw derError;
              _sig = Signature.fromCompact(sg);
            }
          } else if (_typeof(sg) === 'object' && typeof sg.r === 'bigint' && typeof sg.s === 'bigint') {
            var _r = sg.r,
              _s = sg.s;
            _sig = new Signature(_r, _s);
          } else {
            throw new Error('PARSE');
          }
          P = Point.fromHex(publicKey);
        } catch (error) {
          if (error.message === 'PARSE') throw new Error("signature must be Signature instance, Uint8Array or hex string");
          return false;
        }
        if (lowS && _sig.hasHighS()) return false;
        if (prehash) msgHash = CURVE.hash(msgHash);
        var _sig2 = _sig,
          r = _sig2.r,
          s = _sig2.s;
        var h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element
        var is = invN(s); // s^-1
        var u1 = modN(h * is); // u1 = hs^-1 mod n
        var u2 = modN(r * is); // u2 = rs^-1 mod n
        var R = (_Point$BASE$multiplyA = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)) === null || _Point$BASE$multiplyA === void 0 ? void 0 : _Point$BASE$multiplyA.toAffine(); // R = u1G + u2P
        if (!R) return false;
        var v = modN(R.x);
        return v === r;
      }
      return {
        CURVE: CURVE,
        getPublicKey: getPublicKey,
        getSharedSecret: getSharedSecret,
        sign: sign,
        verify: verify,
        ProjectivePoint: Point,
        Signature: Signature,
        utils: utils
      };
    }
    exports.weierstrass = weierstrass;
    /**
     * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.
     * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.
     * b = True and y = sqrt(u / v) if (u / v) is square in F, and
     * b = False and y = sqrt(Z * (u / v)) otherwise.
     * @param Fp
     * @param Z
     * @returns
     */
    function SWUFpSqrtRatio(Fp, Z) {
      // Generic implementation
      var q = Fp.ORDER;
      var l = _0n;
      for (var o = q - _1n; o % _2n === _0n; o /= _2n) l += _1n;
      var c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.
      // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.
      // 2n ** c1 == 2n << (c1-1)
      var _2n_pow_c1_1 = _2n << c1 - _1n - _1n;
      var _2n_pow_c1 = _2n_pow_c1_1 * _2n;
      var c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic
      var c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic
      var c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic
      var c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic
      var c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2
      var c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)
      var sqrtRatio = function sqrtRatio(u, v) {
        var tv1 = c6; // 1. tv1 = c6
        var tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4
        var tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2
        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v
        var tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3
        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3
        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2
        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v
        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u
        var tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2
        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5
        var isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1
        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7
        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1
        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)
        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)
        // 17. for i in (c1, c1 - 1, ..., 2):
        for (var i = c1; i > _1n; i--) {
          var _tv = i - _2n; // 18.    tv5 = i - 2
          _tv = _2n << _tv - _1n; // 19.    tv5 = 2^tv5
          var tvv5 = Fp.pow(tv4, _tv); // 20.    tv5 = tv4^tv5
          var e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1
          tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1
          tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1
          tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1
          tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)
          tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)
        }
        return {
          isValid: isQR,
          value: tv3
        };
      };
      if (Fp.ORDER % _4n === _3n) {
        // sqrt_ratio_3mod4(u, v)
        var _c2 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic
        var _c3 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)
        sqrtRatio = function sqrtRatio(u, v) {
          var tv1 = Fp.sqr(v); // 1. tv1 = v^2
          var tv2 = Fp.mul(u, v); // 2. tv2 = u * v
          tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2
          var y1 = Fp.pow(tv1, _c2); // 4. y1 = tv1^c1
          y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2
          var y2 = Fp.mul(y1, _c3); // 6. y2 = y1 * c2
          var tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v
          var isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u
          var y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)
          return {
            isValid: isQR,
            value: y
          }; // 11. return (isQR, y) isQR ? y : y*c2
        };
      }
      // No curves uses that
      // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8
      return sqrtRatio;
    }
    exports.SWUFpSqrtRatio = SWUFpSqrtRatio;
    /**
     * Simplified Shallue-van de Woestijne-Ulas Method
     * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2
     */
    function mapToCurveSimpleSWU(Fp, opts) {
      mod.validateField(Fp);
      if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z)) throw new Error('mapToCurveSimpleSWU: invalid opts');
      var sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);
      if (!Fp.isOdd) throw new Error('Fp.isOdd is not implemented!');
      // Input: u, an element of F.
      // Output: (x, y), a point on E.
      return function (u) {
        // prettier-ignore
        var tv1, tv2, tv3, tv4, tv5, tv6, x, y;
        tv1 = Fp.sqr(u); // 1.  tv1 = u^2
        tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1
        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2
        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1
        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1
        tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3
        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)
        tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4
        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2
        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2
        tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6
        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5
        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3
        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4
        tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6
        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5
        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3
        var _sqrtRatio = sqrtRatio(tv2, tv6),
          isValid = _sqrtRatio.isValid,
          value = _sqrtRatio.value; // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)
        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1
        y = Fp.mul(y, value); // 20.   y = y * y1
        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)
        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)
        var e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)
        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)
        x = Fp.div(x, tv4); // 25.   x = x / tv4
        return {
          x: x,
          y: y
        };
      };
    }
    exports.mapToCurveSimpleSWU = mapToCurveSimpleSWU;
  })(weierstrass);
  return weierstrass;
}

var hashToCurve = {};

var hasRequiredHashToCurve;
function requireHashToCurve() {
  if (hasRequiredHashToCurve) return hashToCurve;
  hasRequiredHashToCurve = 1;
  Object.defineProperty(hashToCurve, "__esModule", {
    value: true
  });
  hashToCurve.createHasher = hashToCurve.isogenyMap = hashToCurve.hash_to_field = hashToCurve.expand_message_xof = hashToCurve.expand_message_xmd = void 0;
  var modular_js_1 = /*@__PURE__*/requireModular();
  var utils_js_1 = /*@__PURE__*/requireUtils$1();
  function validateDST(dst) {
    if (dst instanceof Uint8Array) return dst;
    if (typeof dst === 'string') return (0, utils_js_1.utf8ToBytes)(dst);
    throw new Error('DST must be Uint8Array or string');
  }
  // Octet Stream to Integer. "spec" implementation of os2ip is 2.5x slower vs bytesToNumberBE.
  var os2ip = utils_js_1.bytesToNumberBE;
  // Integer to Octet Stream (numberToBytesBE)
  function i2osp(value, length) {
    if (value < 0 || value >= 1 << 8 * length) {
      throw new Error("bad I2OSP call: value=".concat(value, " length=").concat(length));
    }
    var res = Array.from({
      length: length
    }).fill(0);
    for (var i = length - 1; i >= 0; i--) {
      res[i] = value & 0xff;
      value >>>= 8;
    }
    return new Uint8Array(res);
  }
  function strxor(a, b) {
    var arr = new Uint8Array(a.length);
    for (var i = 0; i < a.length; i++) {
      arr[i] = a[i] ^ b[i];
    }
    return arr;
  }
  function isBytes(item) {
    if (!(item instanceof Uint8Array)) throw new Error('Uint8Array expected');
  }
  function isNum(item) {
    if (!Number.isSafeInteger(item)) throw new Error('number expected');
  }
  // Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits
  // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1
  function expand_message_xmd(msg, DST, lenInBytes, H) {
    isBytes(msg);
    isBytes(DST);
    isNum(lenInBytes);
    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3
    if (DST.length > 255) DST = H((0, utils_js_1.concatBytes)((0, utils_js_1.utf8ToBytes)('H2C-OVERSIZE-DST-'), DST));
    var b_in_bytes = H.outputLen,
      r_in_bytes = H.blockLen;
    var ell = Math.ceil(lenInBytes / b_in_bytes);
    if (ell > 255) throw new Error('Invalid xmd length');
    var DST_prime = (0, utils_js_1.concatBytes)(DST, i2osp(DST.length, 1));
    var Z_pad = i2osp(0, r_in_bytes);
    var l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str
    var b = new Array(ell);
    var b_0 = H((0, utils_js_1.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
    b[0] = H((0, utils_js_1.concatBytes)(b_0, i2osp(1, 1), DST_prime));
    for (var i = 1; i <= ell; i++) {
      var args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];
      b[i] = H((utils_js_1.concatBytes).apply(void 0, args));
    }
    var pseudo_random_bytes = (utils_js_1.concatBytes).apply(void 0, b);
    return pseudo_random_bytes.slice(0, lenInBytes);
  }
  hashToCurve.expand_message_xmd = expand_message_xmd;
  // Produces a uniformly random byte string using an extendable-output function (XOF) H.
  // 1. The collision resistance of H MUST be at least k bits.
  // 2. H MUST be an XOF that has been proved indifferentiable from
  //    a random oracle under a reasonable cryptographic assumption.
  // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2
  function expand_message_xof(msg, DST, lenInBytes, k, H) {
    isBytes(msg);
    isBytes(DST);
    isNum(lenInBytes);
    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3
    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));
    if (DST.length > 255) {
      var dkLen = Math.ceil(2 * k / 8);
      DST = H.create({
        dkLen: dkLen
      }).update((0, utils_js_1.utf8ToBytes)('H2C-OVERSIZE-DST-')).update(DST).digest();
    }
    if (lenInBytes > 65535 || DST.length > 255) throw new Error('expand_message_xof: invalid lenInBytes');
    return H.create({
      dkLen: lenInBytes
    }).update(msg).update(i2osp(lenInBytes, 2))
    // 2. DST_prime = DST || I2OSP(len(DST), 1)
    .update(DST).update(i2osp(DST.length, 1)).digest();
  }
  hashToCurve.expand_message_xof = expand_message_xof;
  /**
   * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F
   * https://www.rfc-editor.org/rfc/rfc9380#section-5.2
   * @param msg a byte string containing the message to hash
   * @param count the number of elements of F to output
   * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above
   * @returns [u_0, ..., u_(count - 1)], a list of field elements.
   */
  function hash_to_field(msg, count, options) {
    (0, utils_js_1.validateObject)(options, {
      DST: 'stringOrUint8Array',
      p: 'bigint',
      m: 'isSafeInteger',
      k: 'isSafeInteger',
      hash: 'hash'
    });
    var p = options.p,
      k = options.k,
      m = options.m,
      hash = options.hash,
      expand = options.expand,
      _DST = options.DST;
    isBytes(msg);
    isNum(count);
    var DST = validateDST(_DST);
    var log2p = p.toString(2).length;
    var L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above
    var len_in_bytes = count * m * L;
    var prb; // pseudo_random_bytes
    if (expand === 'xmd') {
      prb = expand_message_xmd(msg, DST, len_in_bytes, hash);
    } else if (expand === 'xof') {
      prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);
    } else if (expand === '_internal_pass') {
      // for internal tests only
      prb = msg;
    } else {
      throw new Error('expand must be "xmd" or "xof"');
    }
    var u = new Array(count);
    for (var i = 0; i < count; i++) {
      var e = new Array(m);
      for (var j = 0; j < m; j++) {
        var elm_offset = L * (j + i * m);
        var tv = prb.subarray(elm_offset, elm_offset + L);
        e[j] = (0, modular_js_1.mod)(os2ip(tv), p);
      }
      u[i] = e;
    }
    return u;
  }
  hashToCurve.hash_to_field = hash_to_field;
  function isogenyMap(field, map) {
    // Make same order as in spec
    var COEFF = map.map(function (i) {
      return Array.from(i).reverse();
    });
    return function (x, y) {
      var _COEFF$map = COEFF.map(function (val) {
          return val.reduce(function (acc, i) {
            return field.add(field.mul(acc, x), i);
          });
        }),
        _COEFF$map2 = _slicedToArray(_COEFF$map, 4),
        xNum = _COEFF$map2[0],
        xDen = _COEFF$map2[1],
        yNum = _COEFF$map2[2],
        yDen = _COEFF$map2[3];
      x = field.div(xNum, xDen); // xNum / xDen
      y = field.mul(y, field.div(yNum, yDen)); // y * (yNum / yDev)
      return {
        x: x,
        y: y
      };
    };
  }
  hashToCurve.isogenyMap = isogenyMap;
  function createHasher(Point, mapToCurve, def) {
    if (typeof mapToCurve !== 'function') throw new Error('mapToCurve() must be defined');
    return {
      // Encodes byte string to elliptic curve.
      // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
      hashToCurve: function hashToCurve(msg, options) {
        var u = hash_to_field(msg, 2, _objectSpread2(_objectSpread2({}, def), {}, {
          DST: def.DST
        }, options));
        var u0 = Point.fromAffine(mapToCurve(u[0]));
        var u1 = Point.fromAffine(mapToCurve(u[1]));
        var P = u0.add(u1).clearCofactor();
        P.assertValidity();
        return P;
      },
      // Encodes byte string to elliptic curve.
      // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
      encodeToCurve: function encodeToCurve(msg, options) {
        var u = hash_to_field(msg, 1, _objectSpread2(_objectSpread2({}, def), {}, {
          DST: def.encodeDST
        }, options));
        var P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();
        P.assertValidity();
        return P;
      }
    };
  }
  hashToCurve.createHasher = createHasher;
  return hashToCurve;
}

var _shortw_utils = {};

var hasRequired_shortw_utils;
function require_shortw_utils() {
  if (hasRequired_shortw_utils) return _shortw_utils;
  hasRequired_shortw_utils = 1;
  Object.defineProperty(_shortw_utils, "__esModule", {
    value: true
  });
  _shortw_utils.createCurve = _shortw_utils.getHash = void 0;
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  var hmac_1 = /*@__PURE__*/requireHmac();
  var utils_1 = /*@__PURE__*/requireUtils$2();
  var weierstrass_js_1 = /*@__PURE__*/requireWeierstrass();
  // connects noble-curves to noble-hashes
  function getHash(hash) {
    return {
      hash: hash,
      hmac: function hmac(key) {
        for (var _len = arguments.length, msgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          msgs[_key - 1] = arguments[_key];
        }
        return (0, hmac_1.hmac)(hash, key, (utils_1.concatBytes).apply(void 0, msgs));
      },
      randomBytes: utils_1.randomBytes
    };
  }
  _shortw_utils.getHash = getHash;
  function createCurve(curveDef, defHash) {
    var create = function create(hash) {
      return (0, weierstrass_js_1.weierstrass)(_objectSpread2(_objectSpread2({}, curveDef), getHash(hash)));
    };
    return Object.freeze(_objectSpread2(_objectSpread2({}, create(defHash)), {}, {
      create: create
    }));
  }
  _shortw_utils.createCurve = createCurve;
  return _shortw_utils;
}

var hasRequiredSecp256k1;
function requireSecp256k1() {
  if (hasRequiredSecp256k1) return secp256k1;
  hasRequiredSecp256k1 = 1;
  (function (exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.encodeToCurve = exports.hashToCurve = exports.schnorr = exports.secp256k1 = void 0;
    /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
    var sha256_1 = /*@__PURE__*/requireSha256();
    var utils_1 = /*@__PURE__*/requireUtils$2();
    var modular_js_1 = /*@__PURE__*/requireModular();
    var weierstrass_js_1 = /*@__PURE__*/requireWeierstrass();
    var utils_js_1 = /*@__PURE__*/requireUtils$1();
    var hash_to_curve_js_1 = /*@__PURE__*/requireHashToCurve();
    var _shortw_utils_js_1 = /*@__PURE__*/require_shortw_utils();
    var secp256k1P = BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f');
    var secp256k1N = BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141');
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var divNearest = function divNearest(a, b) {
      return (a + b / _2n) / b;
    };
    /**
     * n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.
     * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]
     */
    function sqrtMod(y) {
      var P = secp256k1P;
      // prettier-ignore
      var _3n = BigInt(3),
        _6n = BigInt(6),
        _11n = BigInt(11),
        _22n = BigInt(22);
      // prettier-ignore
      var _23n = BigInt(23),
        _44n = BigInt(44),
        _88n = BigInt(88);
      var b2 = y * y * y % P; // x^3, 11
      var b3 = b2 * b2 * y % P; // x^7
      var b6 = (0, modular_js_1.pow2)(b3, _3n, P) * b3 % P;
      var b9 = (0, modular_js_1.pow2)(b6, _3n, P) * b3 % P;
      var b11 = (0, modular_js_1.pow2)(b9, _2n, P) * b2 % P;
      var b22 = (0, modular_js_1.pow2)(b11, _11n, P) * b11 % P;
      var b44 = (0, modular_js_1.pow2)(b22, _22n, P) * b22 % P;
      var b88 = (0, modular_js_1.pow2)(b44, _44n, P) * b44 % P;
      var b176 = (0, modular_js_1.pow2)(b88, _88n, P) * b88 % P;
      var b220 = (0, modular_js_1.pow2)(b176, _44n, P) * b44 % P;
      var b223 = (0, modular_js_1.pow2)(b220, _3n, P) * b3 % P;
      var t1 = (0, modular_js_1.pow2)(b223, _23n, P) * b22 % P;
      var t2 = (0, modular_js_1.pow2)(t1, _6n, P) * b2 % P;
      var root = (0, modular_js_1.pow2)(t2, _2n, P);
      if (!Fp.eql(Fp.sqr(root), y)) throw new Error('Cannot find square root');
      return root;
    }
    var Fp = (0, modular_js_1.Field)(secp256k1P, undefined, undefined, {
      sqrt: sqrtMod
    });
    exports.secp256k1 = (0, _shortw_utils_js_1.createCurve)({
      a: BigInt(0),
      b: BigInt(7),
      Fp: Fp,
      n: secp256k1N,
      // Base point (x, y) aka generator point
      Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),
      Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),
      h: BigInt(1),
      lowS: true,
      /**
       * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
       * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
       * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
       * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
       */
      endo: {
        beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),
        splitScalar: function splitScalar(k) {
          var n = secp256k1N;
          var a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');
          var b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');
          var a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');
          var b2 = a1;
          var POW_2_128 = BigInt('0x100000000000000000000000000000000'); // (2n**128n).toString(16)
          var c1 = divNearest(b2 * k, n);
          var c2 = divNearest(-b1 * k, n);
          var k1 = (0, modular_js_1.mod)(k - c1 * a1 - c2 * a2, n);
          var k2 = (0, modular_js_1.mod)(-c1 * b1 - c2 * b2, n);
          var k1neg = k1 > POW_2_128;
          var k2neg = k2 > POW_2_128;
          if (k1neg) k1 = n - k1;
          if (k2neg) k2 = n - k2;
          if (k1 > POW_2_128 || k2 > POW_2_128) {
            throw new Error('splitScalar: Endomorphism failed, k=' + k);
          }
          return {
            k1neg: k1neg,
            k1: k1,
            k2neg: k2neg,
            k2: k2
          };
        }
      }
    }, sha256_1.sha256);
    // Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.
    // https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki
    var _0n = BigInt(0);
    var fe = function fe(x) {
      return typeof x === 'bigint' && _0n < x && x < secp256k1P;
    };
    var ge = function ge(x) {
      return typeof x === 'bigint' && _0n < x && x < secp256k1N;
    };
    /** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */
    var TAGGED_HASH_PREFIXES = {};
    function taggedHash(tag) {
      var tagP = TAGGED_HASH_PREFIXES[tag];
      if (tagP === undefined) {
        var tagH = (0, sha256_1.sha256)(Uint8Array.from(tag, function (c) {
          return c.charCodeAt(0);
        }));
        tagP = (0, utils_js_1.concatBytes)(tagH, tagH);
        TAGGED_HASH_PREFIXES[tag] = tagP;
      }
      for (var _len = arguments.length, messages = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        messages[_key - 1] = arguments[_key];
      }
      return (0, sha256_1.sha256)((utils_js_1.concatBytes).apply(void 0, [tagP].concat(messages)));
    }
    // ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03
    var pointToBytes = function pointToBytes(point) {
      return point.toRawBytes(true).slice(1);
    };
    var numTo32b = function numTo32b(n) {
      return (0, utils_js_1.numberToBytesBE)(n, 32);
    };
    var modP = function modP(x) {
      return (0, modular_js_1.mod)(x, secp256k1P);
    };
    var modN = function modN(x) {
      return (0, modular_js_1.mod)(x, secp256k1N);
    };
    var Point = exports.secp256k1.ProjectivePoint;
    var GmulAdd = function GmulAdd(Q, a, b) {
      return Point.BASE.multiplyAndAddUnsafe(Q, a, b);
    };
    // Calculate point, scalar and bytes
    function schnorrGetExtPubKey(priv) {
      var d_ = exports.secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey
      var p = Point.fromPrivateKey(d_); // P = d'G; 0 < d' < n check is done inside
      var scalar = p.hasEvenY() ? d_ : modN(-d_);
      return {
        scalar: scalar,
        bytes: pointToBytes(p)
      };
    }
    /**
     * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.
     * @returns valid point checked for being on-curve
     */
    function lift_x(x) {
      if (!fe(x)) throw new Error('bad x: need 0 < x < p'); // Fail if x  p.
      var xx = modP(x * x);
      var c = modP(xx * x + BigInt(7)); // Let c = x + 7 mod p.
      var y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.
      if (y % _2n !== _0n) y = modP(-y); // Return the unique point P such that x(P) = x and
      var p = new Point(x, y, _1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.
      p.assertValidity();
      return p;
    }
    /**
     * Create tagged hash, convert it to bigint, reduce modulo-n.
     */
    function challenge() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return modN((0, utils_js_1.bytesToNumberBE)(taggedHash.apply(void 0, ['BIP0340/challenge'].concat(args))));
    }
    /**
     * Schnorr public key is just `x` coordinate of Point as per BIP340.
     */
    function schnorrGetPublicKey(privateKey) {
      return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'n. Ret bytes(d'G)
    }
    /**
     * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.
     * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.
     */
    function schnorrSign(message, privateKey) {
      var auxRand = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : (0, utils_1.randomBytes)(32);
      var m = (0, utils_js_1.ensureBytes)('message', message);
      var _schnorrGetExtPubKey = schnorrGetExtPubKey(privateKey),
        px = _schnorrGetExtPubKey.bytes,
        d = _schnorrGetExtPubKey.scalar; // checks for isWithinCurveOrder
      var a = (0, utils_js_1.ensureBytes)('auxRand', auxRand, 32); // Auxiliary random data a: a 32-byte array
      var t = numTo32b(d ^ (0, utils_js_1.bytesToNumberBE)(taggedHash('BIP0340/aux', a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)
      var rand = taggedHash('BIP0340/nonce', t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)
      var k_ = modN((0, utils_js_1.bytesToNumberBE)(rand)); // Let k' = int(rand) mod n
      if (k_ === _0n) throw new Error('sign failed: k is zero'); // Fail if k' = 0.
      var _schnorrGetExtPubKey2 = schnorrGetExtPubKey(k_),
        rx = _schnorrGetExtPubKey2.bytes,
        k = _schnorrGetExtPubKey2.scalar; // Let R = k'G.
      var e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.
      var sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).
      sig.set(rx, 0);
      sig.set(numTo32b(modN(k + e * d)), 32);
      // If Verify(bytes(P), m, sig) (see below) returns failure, abort
      if (!schnorrVerify(sig, m, px)) throw new Error('sign: Invalid signature produced');
      return sig;
    }
    /**
     * Verifies Schnorr signature.
     * Will swallow errors & return false except for initial type validation of arguments.
     */
    function schnorrVerify(signature, message, publicKey) {
      var sig = (0, utils_js_1.ensureBytes)('signature', signature, 64);
      var m = (0, utils_js_1.ensureBytes)('message', message);
      var pub = (0, utils_js_1.ensureBytes)('publicKey', publicKey, 32);
      try {
        var P = lift_x((0, utils_js_1.bytesToNumberBE)(pub)); // P = lift_x(int(pk)); fail if that fails
        var r = (0, utils_js_1.bytesToNumberBE)(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r  p.
        if (!fe(r)) return false;
        var s = (0, utils_js_1.bytesToNumberBE)(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s  n.
        if (!ge(s)) return false;
        var e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n
        var R = GmulAdd(P, s, modN(-e)); // R = sG - eP
        if (!R || !R.hasEvenY() || R.toAffine().x !== r) return false; // -eP == (n-e)P
        return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R)  r.
      } catch (error) {
        return false;
      }
    }
    exports.schnorr = function () {
      return {
        getPublicKey: schnorrGetPublicKey,
        sign: schnorrSign,
        verify: schnorrVerify,
        utils: {
          randomPrivateKey: exports.secp256k1.utils.randomPrivateKey,
          lift_x: lift_x,
          pointToBytes: pointToBytes,
          numberToBytesBE: utils_js_1.numberToBytesBE,
          bytesToNumberBE: utils_js_1.bytesToNumberBE,
          taggedHash: taggedHash,
          mod: modular_js_1.mod
        }
      };
    }();
    var isoMap = /* @__PURE__ */function () {
      return (0, hash_to_curve_js_1.isogenyMap)(Fp, [
      // xNum
      ['0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7', '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581', '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262', '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c'],
      // xDen
      ['0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b', '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14', '0x0000000000000000000000000000000000000000000000000000000000000001' // LAST 1
      ],
      // yNum
      ['0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c', '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3', '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931', '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84'],
      // yDen
      ['0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b', '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573', '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f', '0x0000000000000000000000000000000000000000000000000000000000000001' // LAST 1
      ]].map(function (i) {
        return i.map(function (j) {
          return BigInt(j);
        });
      }));
    }();
    var mapSWU = /* @__PURE__ */function () {
      return (0, weierstrass_js_1.mapToCurveSimpleSWU)(Fp, {
        A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),
        B: BigInt('1771'),
        Z: Fp.create(BigInt('-11'))
      });
    }();
    var htf = /* @__PURE__ */function () {
      return (0, hash_to_curve_js_1.createHasher)(exports.secp256k1.ProjectivePoint, function (scalars) {
        var _mapSWU = mapSWU(Fp.create(scalars[0])),
          x = _mapSWU.x,
          y = _mapSWU.y;
        return isoMap(x, y);
      }, {
        DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',
        encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',
        p: Fp.ORDER,
        m: 1,
        k: 128,
        expand: 'xmd',
        hash: sha256_1.sha256
      });
    }();
    exports.hashToCurve = function () {
      return htf.hashToCurve;
    }();
    exports.encodeToCurve = function () {
      return htf.encodeToCurve;
    }();
  })(secp256k1);
  return secp256k1;
}

var signature = {};

var constants$1 = {};

var addresses = {};

var hasRequiredAddresses;
function requireAddresses() {
  if (hasRequiredAddresses) return addresses;
  hasRequiredAddresses = 1;
  Object.defineProperty(addresses, "__esModule", {
    value: true
  });
  addresses.ZeroAddress = void 0;
  /**
   *  A constant for the zero address.
   *
   *  (**i.e.** ``"0x0000000000000000000000000000000000000000"``)
   */
  addresses.ZeroAddress = "0x0000000000000000000000000000000000000000";
  return addresses;
}

var hashes = {};

var hasRequiredHashes;
function requireHashes() {
  if (hasRequiredHashes) return hashes;
  hasRequiredHashes = 1;
  Object.defineProperty(hashes, "__esModule", {
    value: true
  });
  hashes.ZeroHash = void 0;
  /**
   *  A constant for the zero hash.
   *
   *  (**i.e.** ``"0x0000000000000000000000000000000000000000000000000000000000000000"``)
   */
  hashes.ZeroHash = "0x0000000000000000000000000000000000000000000000000000000000000000";
  return hashes;
}

var numbers = {};

var hasRequiredNumbers;
function requireNumbers() {
  if (hasRequiredNumbers) return numbers;
  hasRequiredNumbers = 1;
  Object.defineProperty(numbers, "__esModule", {
    value: true
  });
  numbers.MaxInt256 = numbers.MinInt256 = numbers.MaxUint256 = numbers.WeiPerEther = numbers.N = void 0;
  /**
   *  A constant for the order N for the secp256k1 curve.
   *
   *  (**i.e.** ``0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141n``)
   */
  numbers.N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
  /**
   *  A constant for the number of wei in a single ether.
   *
   *  (**i.e.** ``1000000000000000000n``)
   */
  numbers.WeiPerEther = BigInt("1000000000000000000");
  /**
   *  A constant for the maximum value for a ``uint256``.
   *
   *  (**i.e.** ``0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffn``)
   */
  numbers.MaxUint256 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
  /**
   *  A constant for the minimum value for an ``int256``.
   *
   *  (**i.e.** ``-8000000000000000000000000000000000000000000000000000000000000000n``)
   */
  numbers.MinInt256 = BigInt("0x8000000000000000000000000000000000000000000000000000000000000000") * BigInt(-1);
  /**
   *  A constant for the maximum value for an ``int256``.
   *
   *  (**i.e.** ``0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffn``)
   */
  numbers.MaxInt256 = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
  return numbers;
}

var strings = {};

var hasRequiredStrings;
function requireStrings() {
  if (hasRequiredStrings) return strings;
  hasRequiredStrings = 1;
  // NFKC (composed)             // (decomposed)
  Object.defineProperty(strings, "__esModule", {
    value: true
  });
  strings.MessagePrefix = strings.EtherSymbol = void 0;
  /**
   *  A constant for the ether symbol (normalized using NFKC).
   *
   *  (**i.e.** ``"\\u039e"``)
   */
  strings.EtherSymbol = "\u039E"; // "\uD835\uDF63";
  /**
   *  A constant for the [[link-eip-191]] personal message prefix.
   *
   *  (**i.e.** ``"\\x19Ethereum Signed Message:\\n"``)
   */
  strings.MessagePrefix = "\x19Ethereum Signed Message:\n";
  return strings;
}

var hasRequiredConstants$1;
function requireConstants$1() {
  if (hasRequiredConstants$1) return constants$1;
  hasRequiredConstants$1 = 1;
  (function (exports) {

    /**
     *  Some common constants useful for Ethereum.
     *
     *  @_section: api/constants: Constants  [about-constants]
     */
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.MessagePrefix = exports.EtherSymbol = exports.MaxInt256 = exports.MinInt256 = exports.MaxUint256 = exports.WeiPerEther = exports.N = exports.ZeroHash = exports.ZeroAddress = void 0;
    var addresses_js_1 = /*@__PURE__*/requireAddresses();
    Object.defineProperty(exports, "ZeroAddress", {
      enumerable: true,
      get: function get() {
        return addresses_js_1.ZeroAddress;
      }
    });
    var hashes_js_1 = /*@__PURE__*/requireHashes();
    Object.defineProperty(exports, "ZeroHash", {
      enumerable: true,
      get: function get() {
        return hashes_js_1.ZeroHash;
      }
    });
    var numbers_js_1 = /*@__PURE__*/requireNumbers();
    Object.defineProperty(exports, "N", {
      enumerable: true,
      get: function get() {
        return numbers_js_1.N;
      }
    });
    Object.defineProperty(exports, "WeiPerEther", {
      enumerable: true,
      get: function get() {
        return numbers_js_1.WeiPerEther;
      }
    });
    Object.defineProperty(exports, "MaxUint256", {
      enumerable: true,
      get: function get() {
        return numbers_js_1.MaxUint256;
      }
    });
    Object.defineProperty(exports, "MinInt256", {
      enumerable: true,
      get: function get() {
        return numbers_js_1.MinInt256;
      }
    });
    Object.defineProperty(exports, "MaxInt256", {
      enumerable: true,
      get: function get() {
        return numbers_js_1.MaxInt256;
      }
    });
    var strings_js_1 = /*@__PURE__*/requireStrings();
    Object.defineProperty(exports, "EtherSymbol", {
      enumerable: true,
      get: function get() {
        return strings_js_1.EtherSymbol;
      }
    });
    Object.defineProperty(exports, "MessagePrefix", {
      enumerable: true,
      get: function get() {
        return strings_js_1.MessagePrefix;
      }
    });
  })(constants$1);
  return constants$1;
}

var hasRequiredSignature;
function requireSignature() {
  if (hasRequiredSignature) return signature;
  hasRequiredSignature = 1;
  Object.defineProperty(signature, "__esModule", {
    value: true
  });
  signature.Signature = void 0;
  var index_js_1 = /*@__PURE__*/requireConstants$1();
  var index_js_2 = /*@__PURE__*/requireUtils$3();
  // Constants
  var BN_0 = BigInt(0);
  var BN_1 = BigInt(1);
  var BN_2 = BigInt(2);
  var BN_27 = BigInt(27);
  var BN_28 = BigInt(28);
  var BN_35 = BigInt(35);
  var _guard = {};
  function toUint256(value) {
    return (0, index_js_2.zeroPadValue)((0, index_js_2.toBeArray)(value), 32);
  }
  /**
   *  A Signature  @TODO
   *
   *
   *  @_docloc: api/crypto:Signing
   */
  var _r2 = /*#__PURE__*/new WeakMap();
  var _s = /*#__PURE__*/new WeakMap();
  var _v2 = /*#__PURE__*/new WeakMap();
  var _networkV = /*#__PURE__*/new WeakMap();
  var Signature = /*#__PURE__*/function () {
    /**
     *  @private
     */
    function Signature(guard, r, s, v) {
      _classCallCheck(this, Signature);
      _classPrivateFieldInitSpec(this, _r2, void 0);
      _classPrivateFieldInitSpec(this, _s, void 0);
      _classPrivateFieldInitSpec(this, _v2, void 0);
      _classPrivateFieldInitSpec(this, _networkV, void 0);
      (0, index_js_2.assertPrivate)(guard, _guard, "Signature");
      _classPrivateFieldSet2(_r2, this, r);
      _classPrivateFieldSet2(_s, this, s);
      _classPrivateFieldSet2(_v2, this, v);
      _classPrivateFieldSet2(_networkV, this, null);
    }
    return _createClass(Signature, [{
      key: "r",
      get:
      /**
       *  The ``r`` value for a signautre.
       *
       *  This represents the ``x`` coordinate of a "reference" or
       *  challenge point, from which the ``y`` can be computed.
       */
      function get() {
        return _classPrivateFieldGet2(_r2, this);
      },
      set: function set(value) {
        (0, index_js_2.assertArgument)((0, index_js_2.dataLength)(value) === 32, "invalid r", "value", value);
        _classPrivateFieldSet2(_r2, this, (0, index_js_2.hexlify)(value));
      }
      /**
       *  The ``s`` value for a signature.
       */
    }, {
      key: "s",
      get: function get() {
        return _classPrivateFieldGet2(_s, this);
      },
      set: function set(_value) {
        (0, index_js_2.assertArgument)((0, index_js_2.dataLength)(_value) === 32, "invalid s", "value", _value);
        var value = (0, index_js_2.hexlify)(_value);
        (0, index_js_2.assertArgument)(parseInt(value.substring(0, 3)) < 8, "non-canonical s", "value", value);
        _classPrivateFieldSet2(_s, this, value);
      }
      /**
       *  The ``v`` value for a signature.
       *
       *  Since a given ``x`` value for ``r`` has two possible values for
       *  its correspondin ``y``, the ``v`` indicates which of the two ``y``
       *  values to use.
       *
       *  It is normalized to the values ``27`` or ``28`` for legacy
       *  purposes.
       */
    }, {
      key: "v",
      get: function get() {
        return _classPrivateFieldGet2(_v2, this);
      },
      set: function set(value) {
        var v = (0, index_js_2.getNumber)(value, "value");
        (0, index_js_2.assertArgument)(v === 27 || v === 28, "invalid v", "v", value);
        _classPrivateFieldSet2(_v2, this, v);
      }
      /**
       *  The EIP-155 ``v`` for legacy transactions. For non-legacy
       *  transactions, this value is ``null``.
       */
    }, {
      key: "networkV",
      get: function get() {
        return _classPrivateFieldGet2(_networkV, this);
      }
      /**
       *  The chain ID for EIP-155 legacy transactions. For non-legacy
       *  transactions, this value is ``null``.
       */
    }, {
      key: "legacyChainId",
      get: function get() {
        var v = this.networkV;
        if (v == null) {
          return null;
        }
        return Signature.getChainId(v);
      }
      /**
       *  The ``yParity`` for the signature.
       *
       *  See ``v`` for more details on how this value is used.
       */
    }, {
      key: "yParity",
      get: function get() {
        return this.v === 27 ? 0 : 1;
      }
      /**
       *  The [[link-eip-2098]] compact representation of the ``yParity``
       *  and ``s`` compacted into a single ``bytes32``.
       */
    }, {
      key: "yParityAndS",
      get: function get() {
        // The EIP-2098 compact representation
        var yParityAndS = (0, index_js_2.getBytes)(this.s);
        if (this.yParity) {
          yParityAndS[0] |= 0x80;
        }
        return (0, index_js_2.hexlify)(yParityAndS);
      }
      /**
       *  The [[link-eip-2098]] compact representation.
       */
    }, {
      key: "compactSerialized",
      get: function get() {
        return (0, index_js_2.concat)([this.r, this.yParityAndS]);
      }
      /**
       *  The serialized representation.
       */
    }, {
      key: "serialized",
      get: function get() {
        return (0, index_js_2.concat)([this.r, this.s, this.yParity ? "0x1c" : "0x1b"]);
      }
    }, {
      key: Symbol["for"]('nodejs.util.inspect.custom'),
      value: function value() {
        return "Signature { r: \"".concat(this.r, "\", s: \"").concat(this.s, "\", yParity: ").concat(this.yParity, ", networkV: ").concat(this.networkV, " }");
      }
      /**
       *  Returns a new identical [[Signature]].
       */
    }, {
      key: "clone",
      value: function clone() {
        var clone = new Signature(_guard, this.r, this.s, this.v);
        if (this.networkV) {
          _classPrivateFieldSet2(_networkV, clone, this.networkV);
        }
        return clone;
      }
      /**
       *  Returns a representation that is compatible with ``JSON.stringify``.
       */
    }, {
      key: "toJSON",
      value: function toJSON() {
        var networkV = this.networkV;
        return {
          _type: "signature",
          networkV: networkV != null ? networkV.toString() : null,
          r: this.r,
          s: this.s,
          v: this.v
        };
      }
      /**
       *  Compute the chain ID from the ``v`` in a legacy EIP-155 transactions.
       *
       *  @example:
       *    Signature.getChainId(45)
       *    //_result:
       *
       *    Signature.getChainId(46)
       *    //_result:
       */
    }], [{
      key: "getChainId",
      value: function getChainId(v) {
        var bv = (0, index_js_2.getBigInt)(v, "v");
        // The v is not an EIP-155 v, so it is the unspecified chain ID
        if (bv == BN_27 || bv == BN_28) {
          return BN_0;
        }
        // Bad value for an EIP-155 v
        (0, index_js_2.assertArgument)(bv >= BN_35, "invalid EIP-155 v", "v", v);
        return (bv - BN_35) / BN_2;
      }
      /**
       *  Compute the ``v`` for a chain ID for a legacy EIP-155 transactions.
       *
       *  Legacy transactions which use [[link-eip-155]] hijack the ``v``
       *  property to include the chain ID.
       *
       *  @example:
       *    Signature.getChainIdV(5, 27)
       *    //_result:
       *
       *    Signature.getChainIdV(5, 28)
       *    //_result:
       *
       */
    }, {
      key: "getChainIdV",
      value: function getChainIdV(chainId, v) {
        return (0, index_js_2.getBigInt)(chainId) * BN_2 + BigInt(35 + v - 27);
      }
      /**
       *  Compute the normalized legacy transaction ``v`` from a ``yParirty``,
       *  a legacy transaction ``v`` or a legacy [[link-eip-155]] transaction.
       *
       *  @example:
       *    // The values 0 and 1 imply v is actually yParity
       *    Signature.getNormalizedV(0)
       *    //_result:
       *
       *    // Legacy non-EIP-1559 transaction (i.e. 27 or 28)
       *    Signature.getNormalizedV(27)
       *    //_result:
       *
       *    // Legacy EIP-155 transaction (i.e. >= 35)
       *    Signature.getNormalizedV(46)
       *    //_result:
       *
       *    // Invalid values throw
       *    Signature.getNormalizedV(5)
       *    //_error:
       */
    }, {
      key: "getNormalizedV",
      value: function getNormalizedV(v) {
        var bv = (0, index_js_2.getBigInt)(v);
        if (bv === BN_0 || bv === BN_27) {
          return 27;
        }
        if (bv === BN_1 || bv === BN_28) {
          return 28;
        }
        (0, index_js_2.assertArgument)(bv >= BN_35, "invalid v", "v", v);
        // Otherwise, EIP-155 v means odd is 27 and even is 28
        return bv & BN_1 ? 27 : 28;
      }
      /**
       *  Creates a new [[Signature]].
       *
       *  If no %%sig%% is provided, a new [[Signature]] is created
       *  with default values.
       *
       *  If %%sig%% is a string, it is parsed.
       */
    }, {
      key: "from",
      value: function from(sig) {
        function assertError(check, message) {
          (0, index_js_2.assertArgument)(check, message, "signature", sig);
        }
        if (sig == null) {
          return new Signature(_guard, index_js_1.ZeroHash, index_js_1.ZeroHash, 27);
        }
        if (typeof sig === "string") {
          var bytes = (0, index_js_2.getBytes)(sig, "signature");
          if (bytes.length === 64) {
            var _r3 = (0, index_js_2.hexlify)(bytes.slice(0, 32));
            var _s2 = bytes.slice(32, 64);
            var _v3 = _s2[0] & 0x80 ? 28 : 27;
            _s2[0] &= 0x7f;
            return new Signature(_guard, _r3, (0, index_js_2.hexlify)(_s2), _v3);
          }
          if (bytes.length === 65) {
            var _r4 = (0, index_js_2.hexlify)(bytes.slice(0, 32));
            var _s3 = bytes.slice(32, 64);
            assertError((_s3[0] & 0x80) === 0, "non-canonical s");
            var _v4 = Signature.getNormalizedV(bytes[64]);
            return new Signature(_guard, _r4, (0, index_js_2.hexlify)(_s3), _v4);
          }
          assertError(false, "invalid raw signature length");
        }
        if (sig instanceof Signature) {
          return sig.clone();
        }
        // Get r
        var _r = sig.r;
        assertError(_r != null, "missing r");
        var r = toUint256(_r);
        // Get s; by any means necessary (we check consistency below)
        var s = function (s, yParityAndS) {
          if (s != null) {
            return toUint256(s);
          }
          if (yParityAndS != null) {
            assertError((0, index_js_2.isHexString)(yParityAndS, 32), "invalid yParityAndS");
            var _bytes = (0, index_js_2.getBytes)(yParityAndS);
            _bytes[0] &= 0x7f;
            return (0, index_js_2.hexlify)(_bytes);
          }
          assertError(false, "missing s");
        }(sig.s, sig.yParityAndS);
        assertError(((0, index_js_2.getBytes)(s)[0] & 0x80) == 0, "non-canonical s");
        // Get v; by any means necessary (we check consistency below)
        var _ref = function (_v, yParityAndS, yParity) {
            if (_v != null) {
              var _v5 = (0, index_js_2.getBigInt)(_v);
              return {
                networkV: _v5 >= BN_35 ? _v5 : undefined,
                v: Signature.getNormalizedV(_v5)
              };
            }
            if (yParityAndS != null) {
              assertError((0, index_js_2.isHexString)(yParityAndS, 32), "invalid yParityAndS");
              return {
                v: (0, index_js_2.getBytes)(yParityAndS)[0] & 0x80 ? 28 : 27
              };
            }
            if (yParity != null) {
              switch ((0, index_js_2.getNumber)(yParity, "sig.yParity")) {
                case 0:
                  return {
                    v: 27
                  };
                case 1:
                  return {
                    v: 28
                  };
              }
              assertError(false, "invalid yParity");
            }
            assertError(false, "missing v");
          }(sig.v, sig.yParityAndS, sig.yParity),
          networkV = _ref.networkV,
          v = _ref.v;
        var result = new Signature(_guard, r, s, v);
        if (networkV) {
          _classPrivateFieldSet2(_networkV, result, networkV);
        }
        // If multiple of v, yParity, yParityAndS we given, check they match
        assertError(sig.yParity == null || (0, index_js_2.getNumber)(sig.yParity, "sig.yParity") === result.yParity, "yParity mismatch");
        assertError(sig.yParityAndS == null || sig.yParityAndS === result.yParityAndS, "yParityAndS mismatch");
        return result;
      }
    }]);
  }();
  signature.Signature = Signature;
  return signature;
}

var hasRequiredSigningKey;
function requireSigningKey() {
  if (hasRequiredSigningKey) return signingKey;
  hasRequiredSigningKey = 1;
  /**
   *  Add details about signing here.
   *
   *  @_subsection: api/crypto:Signing  [about-signing]
   */
  Object.defineProperty(signingKey, "__esModule", {
    value: true
  });
  signingKey.SigningKey = void 0;
  var secp256k1_1 = /*@__PURE__*/requireSecp256k1();
  var index_js_1 = /*@__PURE__*/requireUtils$3();
  var signature_js_1 = /*@__PURE__*/requireSignature();
  /**
   *  A **SigningKey** provides high-level access to the elliptic curve
   *  cryptography (ECC) operations and key management.
   */
  var _privateKey = /*#__PURE__*/new WeakMap();
  var SigningKey = /*#__PURE__*/function () {
    /**
     *  Creates a new **SigningKey** for %%privateKey%%.
     */
    function SigningKey(privateKey) {
      _classCallCheck(this, SigningKey);
      _classPrivateFieldInitSpec(this, _privateKey, void 0);
      (0, index_js_1.assertArgument)((0, index_js_1.dataLength)(privateKey) === 32, "invalid private key", "privateKey", "[REDACTED]");
      _classPrivateFieldSet2(_privateKey, this, (0, index_js_1.hexlify)(privateKey));
    }
    /**
     *  The private key.
     */
    return _createClass(SigningKey, [{
      key: "privateKey",
      get: function get() {
        return _classPrivateFieldGet2(_privateKey, this);
      }
      /**
       *  The uncompressed public key.
       *
       * This will always begin with the prefix ``0x04`` and be 132
       * characters long (the ``0x`` prefix and 130 hexadecimal nibbles).
       */
    }, {
      key: "publicKey",
      get: function get() {
        return SigningKey.computePublicKey(_classPrivateFieldGet2(_privateKey, this));
      }
      /**
       *  The compressed public key.
       *
       *  This will always begin with either the prefix ``0x02`` or ``0x03``
       *  and be 68 characters long (the ``0x`` prefix and 33 hexadecimal
       *  nibbles)
       */
    }, {
      key: "compressedPublicKey",
      get: function get() {
        return SigningKey.computePublicKey(_classPrivateFieldGet2(_privateKey, this), true);
      }
      /**
       *  Return the signature of the signed %%digest%%.
       */
    }, {
      key: "sign",
      value: function sign(digest) {
        (0, index_js_1.assertArgument)((0, index_js_1.dataLength)(digest) === 32, "invalid digest length", "digest", digest);
        var sig = secp256k1_1.secp256k1.sign((0, index_js_1.getBytesCopy)(digest), (0, index_js_1.getBytesCopy)(_classPrivateFieldGet2(_privateKey, this)), {
          lowS: true
        });
        return signature_js_1.Signature.from({
          r: (0, index_js_1.toBeHex)(sig.r, 32),
          s: (0, index_js_1.toBeHex)(sig.s, 32),
          v: sig.recovery ? 0x1c : 0x1b
        });
      }
      /**
       *  Returns the [[link-wiki-ecdh]] shared secret between this
       *  private key and the %%other%% key.
       *
       *  The %%other%% key may be any type of key, a raw public key,
       *  a compressed/uncompressed pubic key or aprivate key.
       *
       *  Best practice is usually to use a cryptographic hash on the
       *  returned value before using it as a symetric secret.
       *
       *  @example:
       *    sign1 = new SigningKey(id("some-secret-1"))
       *    sign2 = new SigningKey(id("some-secret-2"))
       *
       *    // Notice that privA.computeSharedSecret(pubB)...
       *    sign1.computeSharedSecret(sign2.publicKey)
       *    //_result:
       *
       *    // ...is equal to privB.computeSharedSecret(pubA).
       *    sign2.computeSharedSecret(sign1.publicKey)
       *    //_result:
       */
    }, {
      key: "computeSharedSecret",
      value: function computeSharedSecret(other) {
        var pubKey = SigningKey.computePublicKey(other);
        return (0, index_js_1.hexlify)(secp256k1_1.secp256k1.getSharedSecret((0, index_js_1.getBytesCopy)(_classPrivateFieldGet2(_privateKey, this)), (0, index_js_1.getBytes)(pubKey), false));
      }
      /**
       *  Compute the public key for %%key%%, optionally %%compressed%%.
       *
       *  The %%key%% may be any type of key, a raw public key, a
       *  compressed/uncompressed public key or private key.
       *
       *  @example:
       *    sign = new SigningKey(id("some-secret"));
       *
       *    // Compute the uncompressed public key for a private key
       *    SigningKey.computePublicKey(sign.privateKey)
       *    //_result:
       *
       *    // Compute the compressed public key for a private key
       *    SigningKey.computePublicKey(sign.privateKey, true)
       *    //_result:
       *
       *    // Compute the uncompressed public key
       *    SigningKey.computePublicKey(sign.publicKey, false);
       *    //_result:
       *
       *    // Compute the Compressed a public key
       *    SigningKey.computePublicKey(sign.publicKey, true);
       *    //_result:
       */
    }], [{
      key: "computePublicKey",
      value: function computePublicKey(key, compressed) {
        var bytes = (0, index_js_1.getBytes)(key, "key");
        // private key
        if (bytes.length === 32) {
          var pubKey = secp256k1_1.secp256k1.getPublicKey(bytes, !!compressed);
          return (0, index_js_1.hexlify)(pubKey);
        }
        // raw public key; use uncompressed key with 0x04 prefix
        if (bytes.length === 64) {
          var pub = new Uint8Array(65);
          pub[0] = 0x04;
          pub.set(bytes, 1);
          bytes = pub;
        }
        var point = secp256k1_1.secp256k1.ProjectivePoint.fromHex(bytes);
        return (0, index_js_1.hexlify)(point.toRawBytes(compressed));
      }
      /**
       *  Returns the public key for the private key which produced the
       *  %%signature%% for the given %%digest%%.
       *
       *  @example:
       *    key = new SigningKey(id("some-secret"))
       *    digest = id("hello world")
       *    sig = key.sign(digest)
       *
       *    // Notice the signer public key...
       *    key.publicKey
       *    //_result:
       *
       *    // ...is equal to the recovered public key
       *    SigningKey.recoverPublicKey(digest, sig)
       *    //_result:
       *
       */
    }, {
      key: "recoverPublicKey",
      value: function recoverPublicKey(digest, signature) {
        (0, index_js_1.assertArgument)((0, index_js_1.dataLength)(digest) === 32, "invalid digest length", "digest", digest);
        var sig = signature_js_1.Signature.from(signature);
        var secpSig = secp256k1_1.secp256k1.Signature.fromCompact((0, index_js_1.getBytesCopy)((0, index_js_1.concat)([sig.r, sig.s])));
        secpSig = secpSig.addRecoveryBit(sig.yParity);
        var pubKey = secpSig.recoverPublicKey((0, index_js_1.getBytesCopy)(digest));
        (0, index_js_1.assertArgument)(pubKey != null, "invalid signautre for digest", "signature", signature);
        return "0x" + pubKey.toHex(false);
      }
      /**
       *  Returns the point resulting from adding the ellipic curve points
       *  %%p0%% and %%p1%%.
       *
       *  This is not a common function most developers should require, but
       *  can be useful for certain privacy-specific techniques.
       *
       *  For example, it is used by [[HDNodeWallet]] to compute child
       *  addresses from parent public keys and chain codes.
       */
    }, {
      key: "addPoints",
      value: function addPoints(p0, p1, compressed) {
        var pub0 = secp256k1_1.secp256k1.ProjectivePoint.fromHex(SigningKey.computePublicKey(p0).substring(2));
        var pub1 = secp256k1_1.secp256k1.ProjectivePoint.fromHex(SigningKey.computePublicKey(p1).substring(2));
        return "0x" + pub0.add(pub1).toHex(!!compressed);
      }
    }]);
  }();
  signingKey.SigningKey = SigningKey;
  return signingKey;
}

var hasRequiredCrypto;
function requireCrypto() {
  if (hasRequiredCrypto) return crypto$2;
  hasRequiredCrypto = 1;
  (function (exports) {

    /**
     *  A fundamental building block of Ethereum is the underlying
     *  cryptographic primitives.
     *
     *  @_section: api/crypto:Cryptographic Functions   [about-crypto]
     */
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.lock = exports.Signature = exports.SigningKey = exports.scryptSync = exports.scrypt = exports.pbkdf2 = exports.sha512 = exports.sha256 = exports.ripemd160 = exports.keccak256 = exports.randomBytes = exports.computeHmac = void 0;
    // We import all these so we can export lock()
    var hmac_js_1 = /*@__PURE__*/requireHmac$1();
    Object.defineProperty(exports, "computeHmac", {
      enumerable: true,
      get: function get() {
        return hmac_js_1.computeHmac;
      }
    });
    var keccak_js_1 = /*@__PURE__*/requireKeccak();
    Object.defineProperty(exports, "keccak256", {
      enumerable: true,
      get: function get() {
        return keccak_js_1.keccak256;
      }
    });
    var ripemd160_js_1 = /*@__PURE__*/requireRipemd160();
    Object.defineProperty(exports, "ripemd160", {
      enumerable: true,
      get: function get() {
        return ripemd160_js_1.ripemd160;
      }
    });
    var pbkdf2_js_1 = /*@__PURE__*/requirePbkdf2$1();
    Object.defineProperty(exports, "pbkdf2", {
      enumerable: true,
      get: function get() {
        return pbkdf2_js_1.pbkdf2;
      }
    });
    var random_js_1 = /*@__PURE__*/requireRandom();
    Object.defineProperty(exports, "randomBytes", {
      enumerable: true,
      get: function get() {
        return random_js_1.randomBytes;
      }
    });
    var scrypt_js_1 = /*@__PURE__*/requireScrypt();
    Object.defineProperty(exports, "scrypt", {
      enumerable: true,
      get: function get() {
        return scrypt_js_1.scrypt;
      }
    });
    Object.defineProperty(exports, "scryptSync", {
      enumerable: true,
      get: function get() {
        return scrypt_js_1.scryptSync;
      }
    });
    var sha2_js_1 = /*@__PURE__*/requireSha2();
    Object.defineProperty(exports, "sha256", {
      enumerable: true,
      get: function get() {
        return sha2_js_1.sha256;
      }
    });
    Object.defineProperty(exports, "sha512", {
      enumerable: true,
      get: function get() {
        return sha2_js_1.sha512;
      }
    });
    var signing_key_js_1 = /*@__PURE__*/requireSigningKey();
    Object.defineProperty(exports, "SigningKey", {
      enumerable: true,
      get: function get() {
        return signing_key_js_1.SigningKey;
      }
    });
    var signature_js_1 = /*@__PURE__*/requireSignature();
    Object.defineProperty(exports, "Signature", {
      enumerable: true,
      get: function get() {
        return signature_js_1.Signature;
      }
    });
    /**
     *  Once called, prevents any future change to the underlying cryptographic
     *  primitives using the ``.register`` feature for hooks.
     */
    function lock() {
      hmac_js_1.computeHmac.lock();
      keccak_js_1.keccak256.lock();
      pbkdf2_js_1.pbkdf2.lock();
      random_js_1.randomBytes.lock();
      ripemd160_js_1.ripemd160.lock();
      scrypt_js_1.scrypt.lock();
      scrypt_js_1.scryptSync.lock();
      sha2_js_1.sha256.lock();
      sha2_js_1.sha512.lock();
      random_js_1.randomBytes.lock();
    }
    exports.lock = lock;
  })(crypto$2);
  return crypto$2;
}

var hasRequiredAddress$3;
function requireAddress$3() {
  if (hasRequiredAddress$3) return address$1;
  hasRequiredAddress$3 = 1;
  Object.defineProperty(address$1, "__esModule", {
    value: true
  });
  address$1.getIcapAddress = address$1.getAddress = void 0;
  var index_js_1 = /*@__PURE__*/requireCrypto();
  var index_js_2 = /*@__PURE__*/requireUtils$3();
  var BN_0 = BigInt(0);
  var BN_36 = BigInt(36);
  function getChecksumAddress(address) {
    //    if (!isHexString(address, 20)) {
    //        logger.throwArgumentError("invalid address", "address", address);
    //    }
    address = address.toLowerCase();
    var chars = address.substring(2).split("");
    var expanded = new Uint8Array(40);
    for (var i = 0; i < 40; i++) {
      expanded[i] = chars[i].charCodeAt(0);
    }
    var hashed = (0, index_js_2.getBytes)((0, index_js_1.keccak256)(expanded));
    for (var _i = 0; _i < 40; _i += 2) {
      if (hashed[_i >> 1] >> 4 >= 8) {
        chars[_i] = chars[_i].toUpperCase();
      }
      if ((hashed[_i >> 1] & 0x0f) >= 8) {
        chars[_i + 1] = chars[_i + 1].toUpperCase();
      }
    }
    return "0x" + chars.join("");
  }
  // See: https://en.wikipedia.org/wiki/International_Bank_Account_Number
  // Create lookup table
  var ibanLookup = {};
  for (var i = 0; i < 10; i++) {
    ibanLookup[String(i)] = String(i);
  }
  for (var _i2 = 0; _i2 < 26; _i2++) {
    ibanLookup[String.fromCharCode(65 + _i2)] = String(10 + _i2);
  }
  // How many decimal digits can we process? (for 64-bit float, this is 15)
  // i.e. Math.floor(Math.log10(Number.MAX_SAFE_INTEGER));
  var safeDigits = 15;
  function ibanChecksum(address) {
    address = address.toUpperCase();
    address = address.substring(4) + address.substring(0, 2) + "00";
    var expanded = address.split("").map(function (c) {
      return ibanLookup[c];
    }).join("");
    // Javascript can handle integers safely up to 15 (decimal) digits
    while (expanded.length >= safeDigits) {
      var block = expanded.substring(0, safeDigits);
      expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
    }
    var checksum = String(98 - parseInt(expanded, 10) % 97);
    while (checksum.length < 2) {
      checksum = "0" + checksum;
    }
    return checksum;
  }
  var Base36 = function () {
    var result = {};
    for (var _i3 = 0; _i3 < 36; _i3++) {
      var key = "0123456789abcdefghijklmnopqrstuvwxyz"[_i3];
      result[key] = BigInt(_i3);
    }
    return result;
  }();
  function fromBase36(value) {
    value = value.toLowerCase();
    var result = BN_0;
    for (var _i4 = 0; _i4 < value.length; _i4++) {
      result = result * BN_36 + Base36[value[_i4]];
    }
    return result;
  }
  /**
   *  Returns a normalized and checksumed address for %%address%%.
   *  This accepts non-checksum addresses, checksum addresses and
   *  [[getIcapAddress]] formats.
   *
   *  The checksum in Ethereum uses the capitalization (upper-case
   *  vs lower-case) of the characters within an address to encode
   *  its checksum, which offers, on average, a checksum of 15-bits.
   *
   *  If %%address%% contains both upper-case and lower-case, it is
   *  assumed to already be a checksum address and its checksum is
   *  validated, and if the address fails its expected checksum an
   *  error is thrown.
   *
   *  If you wish the checksum of %%address%% to be ignore, it should
   *  be converted to lower-case (i.e. ``.toLowercase()``) before
   *  being passed in. This should be a very rare situation though,
   *  that you wish to bypass the safegaurds in place to protect
   *  against an address that has been incorrectly copied from another
   *  source.
   *
   *  @example:
   *    // Adds the checksum (via upper-casing specific letters)
   *    getAddress("0x8ba1f109551bd432803012645ac136ddd64dba72")
   *    //_result:
   *
   *    // Converts ICAP address and adds checksum
   *    getAddress("XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36");
   *    //_result:
   *
   *    // Throws an error if an address contains mixed case,
   *    // but the checksum fails
   *    getAddress("0x8Ba1f109551bD432803012645Ac136ddd64DBA72")
   *    //_error:
   */
  function getAddress(address) {
    (0, index_js_2.assertArgument)(typeof address === "string", "invalid address", "address", address);
    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
      // Missing the 0x prefix
      if (!address.startsWith("0x")) {
        address = "0x" + address;
      }
      var result = getChecksumAddress(address);
      // It is a checksummed address with a bad checksum
      (0, index_js_2.assertArgument)(!address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || result === address, "bad address checksum", "address", address);
      return result;
    }
    // Maybe ICAP? (we only support direct mode)
    if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
      // It is an ICAP address with a bad checksum
      (0, index_js_2.assertArgument)(address.substring(2, 4) === ibanChecksum(address), "bad icap checksum", "address", address);
      var _result = fromBase36(address.substring(4)).toString(16);
      while (_result.length < 40) {
        _result = "0" + _result;
      }
      return getChecksumAddress("0x" + _result);
    }
    (0, index_js_2.assertArgument)(false, "invalid address", "address", address);
  }
  address$1.getAddress = getAddress;
  /**
   *  The [ICAP Address format](link-icap) format is an early checksum
   *  format which attempts to be compatible with the banking
   *  industry [IBAN format](link-wiki-iban) for bank accounts.
   *
   *  It is no longer common or a recommended format.
   *
   *  @example:
   *    getIcapAddress("0x8ba1f109551bd432803012645ac136ddd64dba72");
   *    //_result:
   *
   *    getIcapAddress("XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36");
   *    //_result:
   *
   *    // Throws an error if the ICAP checksum is wrong
   *    getIcapAddress("XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK37");
   *    //_error:
   */
  function getIcapAddress(address) {
    //let base36 = _base16To36(getAddress(address).substring(2)).toUpperCase();
    var base36 = BigInt(getAddress(address)).toString(36).toUpperCase();
    while (base36.length < 30) {
      base36 = "0" + base36;
    }
    return "XE" + ibanChecksum("XE00" + base36) + base36;
  }
  address$1.getIcapAddress = getIcapAddress;
  return address$1;
}

var contractAddress = {};

var hasRequiredContractAddress;
function requireContractAddress() {
  if (hasRequiredContractAddress) return contractAddress;
  hasRequiredContractAddress = 1;
  Object.defineProperty(contractAddress, "__esModule", {
    value: true
  });
  contractAddress.getCreate2Address = contractAddress.getCreateAddress = void 0;
  var index_js_1 = /*@__PURE__*/requireCrypto();
  var index_js_2 = /*@__PURE__*/requireUtils$3();
  var address_js_1 = /*@__PURE__*/requireAddress$3();
  // http://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed
  /**
   *  Returns the address that would result from a ``CREATE`` for %%tx%%.
   *
   *  This can be used to compute the address a contract will be
   *  deployed to by an EOA when sending a deployment transaction (i.e.
   *  when the ``to`` address is ``null``).
   *
   *  This can also be used to compute the address a contract will be
   *  deployed to by a contract, by using the contract's address as the
   *  ``to`` and the contract's nonce.
   *
   *  @example
   *    from = "0x8ba1f109551bD432803012645Ac136ddd64DBA72";
   *    nonce = 5;
   *
   *    getCreateAddress({ from, nonce });
   *    //_result:
   */
  function getCreateAddress(tx) {
    var from = (0, address_js_1.getAddress)(tx.from);
    var nonce = (0, index_js_2.getBigInt)(tx.nonce, "tx.nonce");
    var nonceHex = nonce.toString(16);
    if (nonceHex === "0") {
      nonceHex = "0x";
    } else if (nonceHex.length % 2) {
      nonceHex = "0x0" + nonceHex;
    } else {
      nonceHex = "0x" + nonceHex;
    }
    return (0, address_js_1.getAddress)((0, index_js_2.dataSlice)((0, index_js_1.keccak256)((0, index_js_2.encodeRlp)([from, nonceHex])), 12));
  }
  contractAddress.getCreateAddress = getCreateAddress;
  /**
   *  Returns the address that would result from a ``CREATE2`` operation
   *  with the given %%from%%, %%salt%% and %%initCodeHash%%.
   *
   *  To compute the %%initCodeHash%% from a contract's init code, use
   *  the [[keccak256]] function.
   *
   *  For a quick overview and example of ``CREATE2``, see [[link-ricmoo-wisps]].
   *
   *  @example
   *    // The address of the contract
   *    from = "0x8ba1f109551bD432803012645Ac136ddd64DBA72"
   *
   *    // The salt
   *    salt = id("HelloWorld")
   *
   *    // The hash of the initCode
   *    initCode = "0x6394198df16000526103ff60206004601c335afa6040516060f3";
   *    initCodeHash = keccak256(initCode)
   *
   *    getCreate2Address(from, salt, initCodeHash)
   *    //_result:
   */
  function getCreate2Address(_from, _salt, _initCodeHash) {
    var from = (0, address_js_1.getAddress)(_from);
    var salt = (0, index_js_2.getBytes)(_salt, "salt");
    var initCodeHash = (0, index_js_2.getBytes)(_initCodeHash, "initCodeHash");
    (0, index_js_2.assertArgument)(salt.length === 32, "salt must be 32 bytes", "salt", _salt);
    (0, index_js_2.assertArgument)(initCodeHash.length === 32, "initCodeHash must be 32 bytes", "initCodeHash", _initCodeHash);
    return (0, address_js_1.getAddress)((0, index_js_2.dataSlice)((0, index_js_1.keccak256)((0, index_js_2.concat)(["0xff", from, salt, initCodeHash])), 12));
  }
  contractAddress.getCreate2Address = getCreate2Address;
  return contractAddress;
}

var checks = {};

var hasRequiredChecks;
function requireChecks() {
  if (hasRequiredChecks) return checks;
  hasRequiredChecks = 1;
  Object.defineProperty(checks, "__esModule", {
    value: true
  });
  checks.resolveAddress = checks.isAddress = checks.isAddressable = void 0;
  var index_js_1 = /*@__PURE__*/requireUtils$3();
  var address_js_1 = /*@__PURE__*/requireAddress$3();
  /**
   *  Returns true if %%value%% is an object which implements the
   *  [[Addressable]] interface.
   *
   *  @example:
   *    // Wallets and AbstractSigner sub-classes
   *    isAddressable(Wallet.createRandom())
   *    //_result:
   *
   *    // Contracts
   *    contract = new Contract("dai.tokens.ethers.eth", [ ], provider)
   *    isAddressable(contract)
   *    //_result:
   */
  function isAddressable(value) {
    return value && typeof value.getAddress === "function";
  }
  checks.isAddressable = isAddressable;
  /**
   *  Returns true if %%value%% is a valid address.
   *
   *  @example:
   *    // Valid address
   *    isAddress("0x8ba1f109551bD432803012645Ac136ddd64DBA72")
   *    //_result:
   *
   *    // Valid ICAP address
   *    isAddress("XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36")
   *    //_result:
   *
   *    // Invalid checksum
   *    isAddress("0x8Ba1f109551bD432803012645Ac136ddd64DBa72")
   *    //_result:
   *
   *    // Invalid ICAP checksum
   *    isAddress("0x8Ba1f109551bD432803012645Ac136ddd64DBA72")
   *    //_result:
   *
   *    // Not an address (an ENS name requires a provided and an
   *    // asynchronous API to access)
   *    isAddress("ricmoo.eth")
   *    //_result:
   */
  function isAddress(value) {
    try {
      (0, address_js_1.getAddress)(value);
      return true;
    } catch (error) {}
    return false;
  }
  checks.isAddress = isAddress;
  function checkAddress(_x, _x2) {
    return _checkAddress.apply(this, arguments);
  }
  /**
   *  Resolves to an address for the %%target%%, which may be any
   *  supported address type, an [[Addressable]] or a Promise which
   *  resolves to an address.
   *
   *  If an ENS name is provided, but that name has not been correctly
   *  configured a [[UnconfiguredNameError]] is thrown.
   *
   *  @example:
   *    addr = "0x6B175474E89094C44Da98b954EedeAC495271d0F"
   *
   *    // Addresses are return synchronously
   *    resolveAddress(addr, provider)
   *    //_result:
   *
   *    // Address promises are resolved asynchronously
   *    resolveAddress(Promise.resolve(addr))
   *    //_result:
   *
   *    // ENS names are resolved asynchronously
   *    resolveAddress("dai.tokens.ethers.eth", provider)
   *    //_result:
   *
   *    // Addressable objects are resolved asynchronously
   *    contract = new Contract(addr, [ ])
   *    resolveAddress(contract, provider)
   *    //_result:
   *
   *    // Unconfigured ENS names reject
   *    resolveAddress("nothing-here.ricmoo.eth", provider)
   *    //_error:
   *
   *    // ENS names require a NameResolver object passed in
   *    // (notice the provider was omitted)
   *    resolveAddress("nothing-here.ricmoo.eth")
   *    //_error:
   */
  function _checkAddress() {
    _checkAddress = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(target, promise) {
      var result;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return promise;
          case 2:
            result = _context.sent;
            if (result == null || result === "0x0000000000000000000000000000000000000000") {
              (0, index_js_1.assert)(typeof target !== "string", "unconfigured name", "UNCONFIGURED_NAME", {
                value: target
              });
              (0, index_js_1.assertArgument)(false, "invalid AddressLike value; did not resolve to a value address", "target", target);
            }
            return _context.abrupt("return", (0, address_js_1.getAddress)(result));
          case 5:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    return _checkAddress.apply(this, arguments);
  }
  function resolveAddress(target, resolver) {
    if (typeof target === "string") {
      if (target.match(/^0x[0-9a-f]{40}$/i)) {
        return (0, address_js_1.getAddress)(target);
      }
      (0, index_js_1.assert)(resolver != null, "ENS resolution requires a provider", "UNSUPPORTED_OPERATION", {
        operation: "resolveName"
      });
      return checkAddress(target, resolver.resolveName(target));
    } else if (isAddressable(target)) {
      return checkAddress(target, target.getAddress());
    } else if (target && typeof target.then === "function") {
      return checkAddress(target, target);
    }
    (0, index_js_1.assertArgument)(false, "unsupported addressable value", "target", target);
  }
  checks.resolveAddress = resolveAddress;
  return checks;
}

var hasRequiredAddress$2;
function requireAddress$2() {
  if (hasRequiredAddress$2) return address$2;
  hasRequiredAddress$2 = 1;
  (function (exports) {

    /**
     *  Addresses are a fundamental part of interacting with Ethereum. They
     *  represent the gloabal identity of Externally Owned Accounts (accounts
     *  backed by a private key) and contracts.
     *
     *  The Ethereum Naming Service (ENS) provides an interconnected ecosystem
     *  of contracts, standards and libraries which enable looking up an
     *  address for an ENS name.
     *
     *  These functions help convert between various formats, validate
     *  addresses and safely resolve ENS names.
     *
     *  @_section: api/address:Addresses  [about-addresses]
     */
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.resolveAddress = exports.isAddress = exports.isAddressable = exports.getCreate2Address = exports.getCreateAddress = exports.getIcapAddress = exports.getAddress = void 0;
    var address_js_1 = /*@__PURE__*/requireAddress$3();
    Object.defineProperty(exports, "getAddress", {
      enumerable: true,
      get: function get() {
        return address_js_1.getAddress;
      }
    });
    Object.defineProperty(exports, "getIcapAddress", {
      enumerable: true,
      get: function get() {
        return address_js_1.getIcapAddress;
      }
    });
    var contract_address_js_1 = /*@__PURE__*/requireContractAddress();
    Object.defineProperty(exports, "getCreateAddress", {
      enumerable: true,
      get: function get() {
        return contract_address_js_1.getCreateAddress;
      }
    });
    Object.defineProperty(exports, "getCreate2Address", {
      enumerable: true,
      get: function get() {
        return contract_address_js_1.getCreate2Address;
      }
    });
    var checks_js_1 = /*@__PURE__*/requireChecks();
    Object.defineProperty(exports, "isAddressable", {
      enumerable: true,
      get: function get() {
        return checks_js_1.isAddressable;
      }
    });
    Object.defineProperty(exports, "isAddress", {
      enumerable: true,
      get: function get() {
        return checks_js_1.isAddress;
      }
    });
    Object.defineProperty(exports, "resolveAddress", {
      enumerable: true,
      get: function get() {
        return checks_js_1.resolveAddress;
      }
    });
  })(address$2);
  return address$2;
}

var typed = {};

var hasRequiredTyped;
function requireTyped() {
  if (hasRequiredTyped) return typed;
  hasRequiredTyped = 1;
  /**
   *  A Typed object allows a value to have its type explicitly
   *  specified.
   *
   *  For example, in Solidity, the value ``45`` could represent a
   *  ``uint8`` or a ``uint256``. The value ``0x1234`` could represent
   *  a ``bytes2`` or ``bytes``.
   *
   *  Since JavaScript has no meaningful way to explicitly inform any
   *  APIs which what the type is, this allows transparent interoperation
   *  with Soldity.
   *
   *  @_subsection: api/abi:Typed Values
   */
  Object.defineProperty(typed, "__esModule", {
    value: true
  });
  typed.Typed = void 0;
  var index_js_1 = /*@__PURE__*/requireUtils$3();
  var _gaurd = {};
  function n(value, width) {
    var signed = false;
    if (width < 0) {
      signed = true;
      width *= -1;
    }
    // @TODO: Check range is valid for value
    return new Typed(_gaurd, "".concat(signed ? "" : "u", "int").concat(width), value, {
      signed: signed,
      width: width
    });
  }
  function b(value, size) {
    // @TODO: Check range is valid for value
    return new Typed(_gaurd, "bytes".concat(size ? size : ""), value, {
      size: size
    });
  }
  var _typedSymbol = Symbol["for"]("_ethers_typed");
  /**
   *  The **Typed** class to wrap values providing explicit type information.
   */
  var _options = /*#__PURE__*/new WeakMap();
  var Typed = /*#__PURE__*/function () {
    /**
     *  @_ignore:
     */
    function Typed(gaurd, type, value, options) {
      _classCallCheck(this, Typed);
      /**
       *  The type, as a Solidity-compatible type.
       */
      _defineProperty(this, "type", void 0);
      /**
       *  The actual value.
       */
      _defineProperty(this, "value", void 0);
      _classPrivateFieldInitSpec(this, _options, void 0);
      /**
       *  @_ignore:
       */
      _defineProperty(this, "_typedSymbol", void 0);
      if (options == null) {
        options = null;
      }
      (0, index_js_1.assertPrivate)(_gaurd, gaurd, "Typed");
      (0, index_js_1.defineProperties)(this, {
        _typedSymbol: _typedSymbol,
        type: type,
        value: value
      });
      _classPrivateFieldSet2(_options, this, options);
      // Check the value is valid
      this.format();
    }
    /**
     *  Format the type as a Human-Readable type.
     */
    return _createClass(Typed, [{
      key: "format",
      value: function format() {
        if (this.type === "array") {
          throw new Error("");
        } else if (this.type === "dynamicArray") {
          throw new Error("");
        } else if (this.type === "tuple") {
          return "tuple(".concat(this.value.map(function (v) {
            return v.format();
          }).join(","), ")");
        }
        return this.type;
      }
      /**
       *  The default value returned by this type.
       */
    }, {
      key: "defaultValue",
      value: function defaultValue() {
        return 0;
      }
      /**
       *  The minimum value for numeric types.
       */
    }, {
      key: "minValue",
      value: function minValue() {
        return 0;
      }
      /**
       *  The maximum value for numeric types.
       */
    }, {
      key: "maxValue",
      value: function maxValue() {
        return 0;
      }
      /**
       *  Returns ``true`` and provides a type guard is this is a [[TypedBigInt]].
       */
    }, {
      key: "isBigInt",
      value: function isBigInt() {
        return !!this.type.match(/^u?int[0-9]+$/);
      }
      /**
       *  Returns ``true`` and provides a type guard is this is a [[TypedData]].
       */
    }, {
      key: "isData",
      value: function isData() {
        return this.type.startsWith("bytes");
      }
      /**
       *  Returns ``true`` and provides a type guard is this is a [[TypedString]].
       */
    }, {
      key: "isString",
      value: function isString() {
        return this.type === "string";
      }
      /**
       *  Returns the tuple name, if this is a tuple. Throws otherwise.
       */
    }, {
      key: "tupleName",
      get: function get() {
        if (this.type !== "tuple") {
          throw TypeError("not a tuple");
        }
        return _classPrivateFieldGet2(_options, this);
      }
      // Returns the length of this type as an array
      // - `null` indicates the length is unforced, it could be dynamic
      // - `-1` indicates the length is dynamic
      // - any other value indicates it is a static array and is its length
      /**
       *  Returns the length of the array type or ``-1`` if it is dynamic.
       *
       *  Throws if the type is not an array.
       */
    }, {
      key: "arrayLength",
      get: function get() {
        if (this.type !== "array") {
          throw TypeError("not an array");
        }
        if (_classPrivateFieldGet2(_options, this) === true) {
          return -1;
        }
        if (_classPrivateFieldGet2(_options, this) === false) {
          return this.value.length;
        }
        return null;
      }
      /**
       *  Returns a new **Typed** of %%type%% with the %%value%%.
       */
    }], [{
      key: "from",
      value: function from(type, value) {
        return new Typed(_gaurd, type, value);
      }
      /**
       *  Return a new ``uint8`` type for %%v%%.
       */
    }, {
      key: "uint8",
      value: function uint8(v) {
        return n(v, 8);
      }
      /**
       *  Return a new ``uint16`` type for %%v%%.
       */
    }, {
      key: "uint16",
      value: function uint16(v) {
        return n(v, 16);
      }
      /**
       *  Return a new ``uint24`` type for %%v%%.
       */
    }, {
      key: "uint24",
      value: function uint24(v) {
        return n(v, 24);
      }
      /**
       *  Return a new ``uint32`` type for %%v%%.
       */
    }, {
      key: "uint32",
      value: function uint32(v) {
        return n(v, 32);
      }
      /**
       *  Return a new ``uint40`` type for %%v%%.
       */
    }, {
      key: "uint40",
      value: function uint40(v) {
        return n(v, 40);
      }
      /**
       *  Return a new ``uint48`` type for %%v%%.
       */
    }, {
      key: "uint48",
      value: function uint48(v) {
        return n(v, 48);
      }
      /**
       *  Return a new ``uint56`` type for %%v%%.
       */
    }, {
      key: "uint56",
      value: function uint56(v) {
        return n(v, 56);
      }
      /**
       *  Return a new ``uint64`` type for %%v%%.
       */
    }, {
      key: "uint64",
      value: function uint64(v) {
        return n(v, 64);
      }
      /**
       *  Return a new ``uint72`` type for %%v%%.
       */
    }, {
      key: "uint72",
      value: function uint72(v) {
        return n(v, 72);
      }
      /**
       *  Return a new ``uint80`` type for %%v%%.
       */
    }, {
      key: "uint80",
      value: function uint80(v) {
        return n(v, 80);
      }
      /**
       *  Return a new ``uint88`` type for %%v%%.
       */
    }, {
      key: "uint88",
      value: function uint88(v) {
        return n(v, 88);
      }
      /**
       *  Return a new ``uint96`` type for %%v%%.
       */
    }, {
      key: "uint96",
      value: function uint96(v) {
        return n(v, 96);
      }
      /**
       *  Return a new ``uint104`` type for %%v%%.
       */
    }, {
      key: "uint104",
      value: function uint104(v) {
        return n(v, 104);
      }
      /**
       *  Return a new ``uint112`` type for %%v%%.
       */
    }, {
      key: "uint112",
      value: function uint112(v) {
        return n(v, 112);
      }
      /**
       *  Return a new ``uint120`` type for %%v%%.
       */
    }, {
      key: "uint120",
      value: function uint120(v) {
        return n(v, 120);
      }
      /**
       *  Return a new ``uint128`` type for %%v%%.
       */
    }, {
      key: "uint128",
      value: function uint128(v) {
        return n(v, 128);
      }
      /**
       *  Return a new ``uint136`` type for %%v%%.
       */
    }, {
      key: "uint136",
      value: function uint136(v) {
        return n(v, 136);
      }
      /**
       *  Return a new ``uint144`` type for %%v%%.
       */
    }, {
      key: "uint144",
      value: function uint144(v) {
        return n(v, 144);
      }
      /**
       *  Return a new ``uint152`` type for %%v%%.
       */
    }, {
      key: "uint152",
      value: function uint152(v) {
        return n(v, 152);
      }
      /**
       *  Return a new ``uint160`` type for %%v%%.
       */
    }, {
      key: "uint160",
      value: function uint160(v) {
        return n(v, 160);
      }
      /**
       *  Return a new ``uint168`` type for %%v%%.
       */
    }, {
      key: "uint168",
      value: function uint168(v) {
        return n(v, 168);
      }
      /**
       *  Return a new ``uint176`` type for %%v%%.
       */
    }, {
      key: "uint176",
      value: function uint176(v) {
        return n(v, 176);
      }
      /**
       *  Return a new ``uint184`` type for %%v%%.
       */
    }, {
      key: "uint184",
      value: function uint184(v) {
        return n(v, 184);
      }
      /**
       *  Return a new ``uint192`` type for %%v%%.
       */
    }, {
      key: "uint192",
      value: function uint192(v) {
        return n(v, 192);
      }
      /**
       *  Return a new ``uint200`` type for %%v%%.
       */
    }, {
      key: "uint200",
      value: function uint200(v) {
        return n(v, 200);
      }
      /**
       *  Return a new ``uint208`` type for %%v%%.
       */
    }, {
      key: "uint208",
      value: function uint208(v) {
        return n(v, 208);
      }
      /**
       *  Return a new ``uint216`` type for %%v%%.
       */
    }, {
      key: "uint216",
      value: function uint216(v) {
        return n(v, 216);
      }
      /**
       *  Return a new ``uint224`` type for %%v%%.
       */
    }, {
      key: "uint224",
      value: function uint224(v) {
        return n(v, 224);
      }
      /**
       *  Return a new ``uint232`` type for %%v%%.
       */
    }, {
      key: "uint232",
      value: function uint232(v) {
        return n(v, 232);
      }
      /**
       *  Return a new ``uint240`` type for %%v%%.
       */
    }, {
      key: "uint240",
      value: function uint240(v) {
        return n(v, 240);
      }
      /**
       *  Return a new ``uint248`` type for %%v%%.
       */
    }, {
      key: "uint248",
      value: function uint248(v) {
        return n(v, 248);
      }
      /**
       *  Return a new ``uint256`` type for %%v%%.
       */
    }, {
      key: "uint256",
      value: function uint256(v) {
        return n(v, 256);
      }
      /**
       *  Return a new ``uint256`` type for %%v%%.
       */
    }, {
      key: "uint",
      value: function uint(v) {
        return n(v, 256);
      }
      /**
       *  Return a new ``int8`` type for %%v%%.
       */
    }, {
      key: "int8",
      value: function int8(v) {
        return n(v, -8);
      }
      /**
       *  Return a new ``int16`` type for %%v%%.
       */
    }, {
      key: "int16",
      value: function int16(v) {
        return n(v, -16);
      }
      /**
       *  Return a new ``int24`` type for %%v%%.
       */
    }, {
      key: "int24",
      value: function int24(v) {
        return n(v, -24);
      }
      /**
       *  Return a new ``int32`` type for %%v%%.
       */
    }, {
      key: "int32",
      value: function int32(v) {
        return n(v, -32);
      }
      /**
       *  Return a new ``int40`` type for %%v%%.
       */
    }, {
      key: "int40",
      value: function int40(v) {
        return n(v, -40);
      }
      /**
       *  Return a new ``int48`` type for %%v%%.
       */
    }, {
      key: "int48",
      value: function int48(v) {
        return n(v, -48);
      }
      /**
       *  Return a new ``int56`` type for %%v%%.
       */
    }, {
      key: "int56",
      value: function int56(v) {
        return n(v, -56);
      }
      /**
       *  Return a new ``int64`` type for %%v%%.
       */
    }, {
      key: "int64",
      value: function int64(v) {
        return n(v, -64);
      }
      /**
       *  Return a new ``int72`` type for %%v%%.
       */
    }, {
      key: "int72",
      value: function int72(v) {
        return n(v, -72);
      }
      /**
       *  Return a new ``int80`` type for %%v%%.
       */
    }, {
      key: "int80",
      value: function int80(v) {
        return n(v, -80);
      }
      /**
       *  Return a new ``int88`` type for %%v%%.
       */
    }, {
      key: "int88",
      value: function int88(v) {
        return n(v, -88);
      }
      /**
       *  Return a new ``int96`` type for %%v%%.
       */
    }, {
      key: "int96",
      value: function int96(v) {
        return n(v, -96);
      }
      /**
       *  Return a new ``int104`` type for %%v%%.
       */
    }, {
      key: "int104",
      value: function int104(v) {
        return n(v, -104);
      }
      /**
       *  Return a new ``int112`` type for %%v%%.
       */
    }, {
      key: "int112",
      value: function int112(v) {
        return n(v, -112);
      }
      /**
       *  Return a new ``int120`` type for %%v%%.
       */
    }, {
      key: "int120",
      value: function int120(v) {
        return n(v, -120);
      }
      /**
       *  Return a new ``int128`` type for %%v%%.
       */
    }, {
      key: "int128",
      value: function int128(v) {
        return n(v, -128);
      }
      /**
       *  Return a new ``int136`` type for %%v%%.
       */
    }, {
      key: "int136",
      value: function int136(v) {
        return n(v, -136);
      }
      /**
       *  Return a new ``int144`` type for %%v%%.
       */
    }, {
      key: "int144",
      value: function int144(v) {
        return n(v, -144);
      }
      /**
       *  Return a new ``int52`` type for %%v%%.
       */
    }, {
      key: "int152",
      value: function int152(v) {
        return n(v, -152);
      }
      /**
       *  Return a new ``int160`` type for %%v%%.
       */
    }, {
      key: "int160",
      value: function int160(v) {
        return n(v, -160);
      }
      /**
       *  Return a new ``int168`` type for %%v%%.
       */
    }, {
      key: "int168",
      value: function int168(v) {
        return n(v, -168);
      }
      /**
       *  Return a new ``int176`` type for %%v%%.
       */
    }, {
      key: "int176",
      value: function int176(v) {
        return n(v, -176);
      }
      /**
       *  Return a new ``int184`` type for %%v%%.
       */
    }, {
      key: "int184",
      value: function int184(v) {
        return n(v, -184);
      }
      /**
       *  Return a new ``int92`` type for %%v%%.
       */
    }, {
      key: "int192",
      value: function int192(v) {
        return n(v, -192);
      }
      /**
       *  Return a new ``int200`` type for %%v%%.
       */
    }, {
      key: "int200",
      value: function int200(v) {
        return n(v, -200);
      }
      /**
       *  Return a new ``int208`` type for %%v%%.
       */
    }, {
      key: "int208",
      value: function int208(v) {
        return n(v, -208);
      }
      /**
       *  Return a new ``int216`` type for %%v%%.
       */
    }, {
      key: "int216",
      value: function int216(v) {
        return n(v, -216);
      }
      /**
       *  Return a new ``int224`` type for %%v%%.
       */
    }, {
      key: "int224",
      value: function int224(v) {
        return n(v, -224);
      }
      /**
       *  Return a new ``int232`` type for %%v%%.
       */
    }, {
      key: "int232",
      value: function int232(v) {
        return n(v, -232);
      }
      /**
       *  Return a new ``int240`` type for %%v%%.
       */
    }, {
      key: "int240",
      value: function int240(v) {
        return n(v, -240);
      }
      /**
       *  Return a new ``int248`` type for %%v%%.
       */
    }, {
      key: "int248",
      value: function int248(v) {
        return n(v, -248);
      }
      /**
       *  Return a new ``int256`` type for %%v%%.
       */
    }, {
      key: "int256",
      value: function int256(v) {
        return n(v, -256);
      }
      /**
       *  Return a new ``int256`` type for %%v%%.
       */
    }, {
      key: "int",
      value: function _int(v) {
        return n(v, -256);
      }
      /**
       *  Return a new ``bytes1`` type for %%v%%.
       */
    }, {
      key: "bytes1",
      value: function bytes1(v) {
        return b(v, 1);
      }
      /**
       *  Return a new ``bytes2`` type for %%v%%.
       */
    }, {
      key: "bytes2",
      value: function bytes2(v) {
        return b(v, 2);
      }
      /**
       *  Return a new ``bytes3`` type for %%v%%.
       */
    }, {
      key: "bytes3",
      value: function bytes3(v) {
        return b(v, 3);
      }
      /**
       *  Return a new ``bytes4`` type for %%v%%.
       */
    }, {
      key: "bytes4",
      value: function bytes4(v) {
        return b(v, 4);
      }
      /**
       *  Return a new ``bytes5`` type for %%v%%.
       */
    }, {
      key: "bytes5",
      value: function bytes5(v) {
        return b(v, 5);
      }
      /**
       *  Return a new ``bytes6`` type for %%v%%.
       */
    }, {
      key: "bytes6",
      value: function bytes6(v) {
        return b(v, 6);
      }
      /**
       *  Return a new ``bytes7`` type for %%v%%.
       */
    }, {
      key: "bytes7",
      value: function bytes7(v) {
        return b(v, 7);
      }
      /**
       *  Return a new ``bytes8`` type for %%v%%.
       */
    }, {
      key: "bytes8",
      value: function bytes8(v) {
        return b(v, 8);
      }
      /**
       *  Return a new ``bytes9`` type for %%v%%.
       */
    }, {
      key: "bytes9",
      value: function bytes9(v) {
        return b(v, 9);
      }
      /**
       *  Return a new ``bytes10`` type for %%v%%.
       */
    }, {
      key: "bytes10",
      value: function bytes10(v) {
        return b(v, 10);
      }
      /**
       *  Return a new ``bytes11`` type for %%v%%.
       */
    }, {
      key: "bytes11",
      value: function bytes11(v) {
        return b(v, 11);
      }
      /**
       *  Return a new ``bytes12`` type for %%v%%.
       */
    }, {
      key: "bytes12",
      value: function bytes12(v) {
        return b(v, 12);
      }
      /**
       *  Return a new ``bytes13`` type for %%v%%.
       */
    }, {
      key: "bytes13",
      value: function bytes13(v) {
        return b(v, 13);
      }
      /**
       *  Return a new ``bytes14`` type for %%v%%.
       */
    }, {
      key: "bytes14",
      value: function bytes14(v) {
        return b(v, 14);
      }
      /**
       *  Return a new ``bytes15`` type for %%v%%.
       */
    }, {
      key: "bytes15",
      value: function bytes15(v) {
        return b(v, 15);
      }
      /**
       *  Return a new ``bytes16`` type for %%v%%.
       */
    }, {
      key: "bytes16",
      value: function bytes16(v) {
        return b(v, 16);
      }
      /**
       *  Return a new ``bytes17`` type for %%v%%.
       */
    }, {
      key: "bytes17",
      value: function bytes17(v) {
        return b(v, 17);
      }
      /**
       *  Return a new ``bytes18`` type for %%v%%.
       */
    }, {
      key: "bytes18",
      value: function bytes18(v) {
        return b(v, 18);
      }
      /**
       *  Return a new ``bytes19`` type for %%v%%.
       */
    }, {
      key: "bytes19",
      value: function bytes19(v) {
        return b(v, 19);
      }
      /**
       *  Return a new ``bytes20`` type for %%v%%.
       */
    }, {
      key: "bytes20",
      value: function bytes20(v) {
        return b(v, 20);
      }
      /**
       *  Return a new ``bytes21`` type for %%v%%.
       */
    }, {
      key: "bytes21",
      value: function bytes21(v) {
        return b(v, 21);
      }
      /**
       *  Return a new ``bytes22`` type for %%v%%.
       */
    }, {
      key: "bytes22",
      value: function bytes22(v) {
        return b(v, 22);
      }
      /**
       *  Return a new ``bytes23`` type for %%v%%.
       */
    }, {
      key: "bytes23",
      value: function bytes23(v) {
        return b(v, 23);
      }
      /**
       *  Return a new ``bytes24`` type for %%v%%.
       */
    }, {
      key: "bytes24",
      value: function bytes24(v) {
        return b(v, 24);
      }
      /**
       *  Return a new ``bytes25`` type for %%v%%.
       */
    }, {
      key: "bytes25",
      value: function bytes25(v) {
        return b(v, 25);
      }
      /**
       *  Return a new ``bytes26`` type for %%v%%.
       */
    }, {
      key: "bytes26",
      value: function bytes26(v) {
        return b(v, 26);
      }
      /**
       *  Return a new ``bytes27`` type for %%v%%.
       */
    }, {
      key: "bytes27",
      value: function bytes27(v) {
        return b(v, 27);
      }
      /**
       *  Return a new ``bytes28`` type for %%v%%.
       */
    }, {
      key: "bytes28",
      value: function bytes28(v) {
        return b(v, 28);
      }
      /**
       *  Return a new ``bytes29`` type for %%v%%.
       */
    }, {
      key: "bytes29",
      value: function bytes29(v) {
        return b(v, 29);
      }
      /**
       *  Return a new ``bytes30`` type for %%v%%.
       */
    }, {
      key: "bytes30",
      value: function bytes30(v) {
        return b(v, 30);
      }
      /**
       *  Return a new ``bytes31`` type for %%v%%.
       */
    }, {
      key: "bytes31",
      value: function bytes31(v) {
        return b(v, 31);
      }
      /**
       *  Return a new ``bytes32`` type for %%v%%.
       */
    }, {
      key: "bytes32",
      value: function bytes32(v) {
        return b(v, 32);
      }
      /**
       *  Return a new ``address`` type for %%v%%.
       */
    }, {
      key: "address",
      value: function address(v) {
        return new Typed(_gaurd, "address", v);
      }
      /**
       *  Return a new ``bool`` type for %%v%%.
       */
    }, {
      key: "bool",
      value: function bool(v) {
        return new Typed(_gaurd, "bool", !!v);
      }
      /**
       *  Return a new ``bytes`` type for %%v%%.
       */
    }, {
      key: "bytes",
      value: function bytes(v) {
        return new Typed(_gaurd, "bytes", v);
      }
      /**
       *  Return a new ``string`` type for %%v%%.
       */
    }, {
      key: "string",
      value: function string(v) {
        return new Typed(_gaurd, "string", v);
      }
      /**
       *  Return a new ``array`` type for %%v%%, allowing %%dynamic%% length.
       */
    }, {
      key: "array",
      value: function array(v, dynamic) {
        throw new Error("not implemented yet");
      }
      /**
       *  Return a new ``tuple`` type for %%v%%, with the optional %%name%%.
       */
    }, {
      key: "tuple",
      value: function tuple(v, name) {
        throw new Error("not implemented yet");
      }
      /**
       *  Return a new ``uint8`` type for %%v%%.
       */
    }, {
      key: "overrides",
      value: function overrides(v) {
        return new Typed(_gaurd, "overrides", Object.assign({}, v));
      }
      /**
       *  Returns true only if %%value%% is a [[Typed]] instance.
       */
    }, {
      key: "isTyped",
      value: function isTyped(value) {
        return value && _typeof(value) === "object" && "_typedSymbol" in value && value._typedSymbol === _typedSymbol;
      }
      /**
       *  If the value is a [[Typed]] instance, validates the underlying value
       *  and returns it, otherwise returns value directly.
       *
       *  This is useful for functions that with to accept either a [[Typed]]
       *  object or values.
       */
    }, {
      key: "dereference",
      value: function dereference(value, type) {
        if (Typed.isTyped(value)) {
          if (value.type !== type) {
            throw new Error("invalid type: expecetd ".concat(type, ", got ").concat(value.type));
          }
          return value.value;
        }
        return value;
      }
    }]);
  }();
  typed.Typed = Typed;
  return typed;
}

var hasRequiredAddress$1;
function requireAddress$1() {
  if (hasRequiredAddress$1) return address$3;
  hasRequiredAddress$1 = 1;
  Object.defineProperty(address$3, "__esModule", {
    value: true
  });
  address$3.AddressCoder = void 0;
  var index_js_1 = /*@__PURE__*/requireAddress$2();
  var maths_js_1 = /*@__PURE__*/requireMaths();
  var typed_js_1 = /*@__PURE__*/requireTyped();
  var abstract_coder_js_1 = /*@__PURE__*/requireAbstractCoder();
  /**
   *  @_ignore
   */
  var AddressCoder = /*#__PURE__*/function (_abstract_coder_js_1$) {
    function AddressCoder(localName) {
      _classCallCheck(this, AddressCoder);
      return _callSuper(this, AddressCoder, ["address", "address", localName, false]);
    }
    _inherits(AddressCoder, _abstract_coder_js_1$);
    return _createClass(AddressCoder, [{
      key: "defaultValue",
      value: function defaultValue() {
        return "0x0000000000000000000000000000000000000000";
      }
    }, {
      key: "encode",
      value: function encode(writer, _value) {
        var value = typed_js_1.Typed.dereference(_value, "string");
        try {
          value = (0, index_js_1.getAddress)(value);
        } catch (error) {
          return this._throwError(error.message, _value);
        }
        return writer.writeValue(value);
      }
    }, {
      key: "decode",
      value: function decode(reader) {
        return (0, index_js_1.getAddress)((0, maths_js_1.toBeHex)(reader.readValue(), 20));
      }
    }]);
  }(abstract_coder_js_1.Coder);
  address$3.AddressCoder = AddressCoder;
  return address$3;
}

var array = {};

var anonymous = {};

var hasRequiredAnonymous;
function requireAnonymous() {
  if (hasRequiredAnonymous) return anonymous;
  hasRequiredAnonymous = 1;
  Object.defineProperty(anonymous, "__esModule", {
    value: true
  });
  anonymous.AnonymousCoder = void 0;
  var abstract_coder_js_1 = /*@__PURE__*/requireAbstractCoder();
  /**
   *  Clones the functionality of an existing Coder, but without a localName
   *
   *  @_ignore
   */
  var AnonymousCoder = /*#__PURE__*/function (_abstract_coder_js_1$) {
    function AnonymousCoder(coder) {
      var _this;
      _classCallCheck(this, AnonymousCoder);
      _this = _callSuper(this, AnonymousCoder, [coder.name, coder.type, "_", coder.dynamic]);
      _defineProperty(_this, "coder", void 0);
      _this.coder = coder;
      return _this;
    }
    _inherits(AnonymousCoder, _abstract_coder_js_1$);
    return _createClass(AnonymousCoder, [{
      key: "defaultValue",
      value: function defaultValue() {
        return this.coder.defaultValue();
      }
    }, {
      key: "encode",
      value: function encode(writer, value) {
        return this.coder.encode(writer, value);
      }
    }, {
      key: "decode",
      value: function decode(reader) {
        return this.coder.decode(reader);
      }
    }]);
  }(abstract_coder_js_1.Coder);
  anonymous.AnonymousCoder = AnonymousCoder;
  return anonymous;
}

var hasRequiredArray;
function requireArray() {
  if (hasRequiredArray) return array;
  hasRequiredArray = 1;
  Object.defineProperty(array, "__esModule", {
    value: true
  });
  array.ArrayCoder = array.unpack = array.pack = void 0;
  var index_js_1 = /*@__PURE__*/requireUtils$3();
  var typed_js_1 = /*@__PURE__*/requireTyped();
  var abstract_coder_js_1 = /*@__PURE__*/requireAbstractCoder();
  var anonymous_js_1 = /*@__PURE__*/requireAnonymous();
  /**
   *  @_ignore
   */
  function pack(writer, coders, values) {
    var arrayValues = [];
    if (Array.isArray(values)) {
      arrayValues = values;
    } else if (values && _typeof(values) === "object") {
      var unique = {};
      arrayValues = coders.map(function (coder) {
        var name = coder.localName;
        (0, index_js_1.assert)(name, "cannot encode object for signature with missing names", "INVALID_ARGUMENT", {
          argument: "values",
          info: {
            coder: coder
          },
          value: values
        });
        (0, index_js_1.assert)(!unique[name], "cannot encode object for signature with duplicate names", "INVALID_ARGUMENT", {
          argument: "values",
          info: {
            coder: coder
          },
          value: values
        });
        unique[name] = true;
        return values[name];
      });
    } else {
      (0, index_js_1.assertArgument)(false, "invalid tuple value", "tuple", values);
    }
    (0, index_js_1.assertArgument)(coders.length === arrayValues.length, "types/value length mismatch", "tuple", values);
    var staticWriter = new abstract_coder_js_1.Writer();
    var dynamicWriter = new abstract_coder_js_1.Writer();
    var updateFuncs = [];
    coders.forEach(function (coder, index) {
      var value = arrayValues[index];
      if (coder.dynamic) {
        // Get current dynamic offset (for the future pointer)
        var dynamicOffset = dynamicWriter.length;
        // Encode the dynamic value into the dynamicWriter
        coder.encode(dynamicWriter, value);
        // Prepare to populate the correct offset once we are done
        var updateFunc = staticWriter.writeUpdatableValue();
        updateFuncs.push(function (baseOffset) {
          updateFunc(baseOffset + dynamicOffset);
        });
      } else {
        coder.encode(staticWriter, value);
      }
    });
    // Backfill all the dynamic offsets, now that we know the static length
    updateFuncs.forEach(function (func) {
      func(staticWriter.length);
    });
    var length = writer.appendWriter(staticWriter);
    length += writer.appendWriter(dynamicWriter);
    return length;
  }
  array.pack = pack;
  /**
   *  @_ignore
   */
  function unpack(reader, coders) {
    var values = [];
    var keys = [];
    // A reader anchored to this base
    var baseReader = reader.subReader(0);
    coders.forEach(function (coder) {
      var value = null;
      if (coder.dynamic) {
        var offset = reader.readIndex();
        var offsetReader = baseReader.subReader(offset);
        try {
          value = coder.decode(offsetReader);
        } catch (error) {
          // Cannot recover from this
          if ((0, index_js_1.isError)(error, "BUFFER_OVERRUN")) {
            throw error;
          }
          value = error;
          value.baseType = coder.name;
          value.name = coder.localName;
          value.type = coder.type;
        }
      } else {
        try {
          value = coder.decode(reader);
        } catch (error) {
          // Cannot recover from this
          if ((0, index_js_1.isError)(error, "BUFFER_OVERRUN")) {
            throw error;
          }
          value = error;
          value.baseType = coder.name;
          value.name = coder.localName;
          value.type = coder.type;
        }
      }
      if (value == undefined) {
        throw new Error("investigate");
      }
      values.push(value);
      keys.push(coder.localName || null);
    });
    return abstract_coder_js_1.Result.fromItems(values, keys);
  }
  array.unpack = unpack;
  /**
   *  @_ignore
   */
  var ArrayCoder = /*#__PURE__*/function (_abstract_coder_js_1$) {
    function ArrayCoder(coder, length, localName) {
      var _this;
      _classCallCheck(this, ArrayCoder);
      var type = coder.type + "[" + (length >= 0 ? length : "") + "]";
      var dynamic = length === -1 || coder.dynamic;
      _this = _callSuper(this, ArrayCoder, ["array", type, localName, dynamic]);
      _defineProperty(_this, "coder", void 0);
      _defineProperty(_this, "length", void 0);
      (0, index_js_1.defineProperties)(_this, {
        coder: coder,
        length: length
      });
      return _this;
    }
    _inherits(ArrayCoder, _abstract_coder_js_1$);
    return _createClass(ArrayCoder, [{
      key: "defaultValue",
      value: function defaultValue() {
        // Verifies the child coder is valid (even if the array is dynamic or 0-length)
        var defaultChild = this.coder.defaultValue();
        var result = [];
        for (var i = 0; i < this.length; i++) {
          result.push(defaultChild);
        }
        return result;
      }
    }, {
      key: "encode",
      value: function encode(writer, _value) {
        var value = typed_js_1.Typed.dereference(_value, "array");
        if (!Array.isArray(value)) {
          this._throwError("expected array value", value);
        }
        var count = this.length;
        if (count === -1) {
          count = value.length;
          writer.writeValue(value.length);
        }
        (0, index_js_1.assertArgumentCount)(value.length, count, "coder array" + (this.localName ? " " + this.localName : ""));
        var coders = [];
        for (var i = 0; i < value.length; i++) {
          coders.push(this.coder);
        }
        return pack(writer, coders, value);
      }
    }, {
      key: "decode",
      value: function decode(reader) {
        var count = this.length;
        if (count === -1) {
          count = reader.readIndex();
          // Check that there is *roughly* enough data to ensure
          // stray random data is not being read as a length. Each
          // slot requires at least 32 bytes for their value (or 32
          // bytes as a link to the data). This could use a much
          // tighter bound, but we are erroring on the side of safety.
          (0, index_js_1.assert)(count * abstract_coder_js_1.WordSize <= reader.dataLength, "insufficient data length", "BUFFER_OVERRUN", {
            buffer: reader.bytes,
            offset: count * abstract_coder_js_1.WordSize,
            length: reader.dataLength
          });
        }
        var coders = [];
        for (var i = 0; i < count; i++) {
          coders.push(new anonymous_js_1.AnonymousCoder(this.coder));
        }
        return unpack(reader, coders);
      }
    }]);
  }(abstract_coder_js_1.Coder);
  array.ArrayCoder = ArrayCoder;
  return array;
}

var boolean = {};

var hasRequiredBoolean;
function requireBoolean() {
  if (hasRequiredBoolean) return boolean;
  hasRequiredBoolean = 1;
  Object.defineProperty(boolean, "__esModule", {
    value: true
  });
  boolean.BooleanCoder = void 0;
  var typed_js_1 = /*@__PURE__*/requireTyped();
  var abstract_coder_js_1 = /*@__PURE__*/requireAbstractCoder();
  /**
   *  @_ignore
   */
  var BooleanCoder = /*#__PURE__*/function (_abstract_coder_js_1$) {
    function BooleanCoder(localName) {
      _classCallCheck(this, BooleanCoder);
      return _callSuper(this, BooleanCoder, ["bool", "bool", localName, false]);
    }
    _inherits(BooleanCoder, _abstract_coder_js_1$);
    return _createClass(BooleanCoder, [{
      key: "defaultValue",
      value: function defaultValue() {
        return false;
      }
    }, {
      key: "encode",
      value: function encode(writer, _value) {
        var value = typed_js_1.Typed.dereference(_value, "bool");
        return writer.writeValue(value ? 1 : 0);
      }
    }, {
      key: "decode",
      value: function decode(reader) {
        return !!reader.readValue();
      }
    }]);
  }(abstract_coder_js_1.Coder);
  boolean.BooleanCoder = BooleanCoder;
  return boolean;
}

var bytes = {};

var hasRequiredBytes;
function requireBytes() {
  if (hasRequiredBytes) return bytes;
  hasRequiredBytes = 1;
  Object.defineProperty(bytes, "__esModule", {
    value: true
  });
  bytes.BytesCoder = bytes.DynamicBytesCoder = void 0;
  var index_js_1 = /*@__PURE__*/requireUtils$3();
  var abstract_coder_js_1 = /*@__PURE__*/requireAbstractCoder();
  /**
   *  @_ignore
   */
  var DynamicBytesCoder = /*#__PURE__*/function (_abstract_coder_js_1$) {
    function DynamicBytesCoder(type, localName) {
      _classCallCheck(this, DynamicBytesCoder);
      return _callSuper(this, DynamicBytesCoder, [type, type, localName, true]);
    }
    _inherits(DynamicBytesCoder, _abstract_coder_js_1$);
    return _createClass(DynamicBytesCoder, [{
      key: "defaultValue",
      value: function defaultValue() {
        return "0x";
      }
    }, {
      key: "encode",
      value: function encode(writer, value) {
        value = (0, index_js_1.getBytesCopy)(value);
        var length = writer.writeValue(value.length);
        length += writer.writeBytes(value);
        return length;
      }
    }, {
      key: "decode",
      value: function decode(reader) {
        return reader.readBytes(reader.readIndex(), true);
      }
    }]);
  }(abstract_coder_js_1.Coder);
  bytes.DynamicBytesCoder = DynamicBytesCoder;
  /**
   *  @_ignore
   */
  var BytesCoder = /*#__PURE__*/function (_DynamicBytesCoder) {
    function BytesCoder(localName) {
      _classCallCheck(this, BytesCoder);
      return _callSuper(this, BytesCoder, ["bytes", localName]);
    }
    _inherits(BytesCoder, _DynamicBytesCoder);
    return _createClass(BytesCoder, [{
      key: "decode",
      value: function decode(reader) {
        return (0, index_js_1.hexlify)(_superPropGet(BytesCoder, "decode", this, 3)([reader]));
      }
    }]);
  }(DynamicBytesCoder);
  bytes.BytesCoder = BytesCoder;
  return bytes;
}

var fixedBytes = {};

var hasRequiredFixedBytes;
function requireFixedBytes() {
  if (hasRequiredFixedBytes) return fixedBytes;
  hasRequiredFixedBytes = 1;
  Object.defineProperty(fixedBytes, "__esModule", {
    value: true
  });
  fixedBytes.FixedBytesCoder = void 0;
  var index_js_1 = /*@__PURE__*/requireUtils$3();
  var typed_js_1 = /*@__PURE__*/requireTyped();
  var abstract_coder_js_1 = /*@__PURE__*/requireAbstractCoder();
  /**
   *  @_ignore
   */
  var FixedBytesCoder = /*#__PURE__*/function (_abstract_coder_js_1$) {
    function FixedBytesCoder(size, localName) {
      var _this;
      _classCallCheck(this, FixedBytesCoder);
      var name = "bytes" + String(size);
      _this = _callSuper(this, FixedBytesCoder, [name, name, localName, false]);
      _defineProperty(_this, "size", void 0);
      (0, index_js_1.defineProperties)(_this, {
        size: size
      }, {
        size: "number"
      });
      return _this;
    }
    _inherits(FixedBytesCoder, _abstract_coder_js_1$);
    return _createClass(FixedBytesCoder, [{
      key: "defaultValue",
      value: function defaultValue() {
        return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2);
      }
    }, {
      key: "encode",
      value: function encode(writer, _value) {
        var data = (0, index_js_1.getBytesCopy)(typed_js_1.Typed.dereference(_value, this.type));
        if (data.length !== this.size) {
          this._throwError("incorrect data length", _value);
        }
        return writer.writeBytes(data);
      }
    }, {
      key: "decode",
      value: function decode(reader) {
        return (0, index_js_1.hexlify)(reader.readBytes(this.size));
      }
    }]);
  }(abstract_coder_js_1.Coder);
  fixedBytes.FixedBytesCoder = FixedBytesCoder;
  return fixedBytes;
}

var _null = {};

var hasRequired_null;
function require_null() {
  if (hasRequired_null) return _null;
  hasRequired_null = 1;
  Object.defineProperty(_null, "__esModule", {
    value: true
  });
  _null.NullCoder = void 0;
  var abstract_coder_js_1 = /*@__PURE__*/requireAbstractCoder();
  var Empty = new Uint8Array([]);
  /**
   *  @_ignore
   */
  var NullCoder = /*#__PURE__*/function (_abstract_coder_js_1$) {
    function NullCoder(localName) {
      _classCallCheck(this, NullCoder);
      return _callSuper(this, NullCoder, ["null", "", localName, false]);
    }
    _inherits(NullCoder, _abstract_coder_js_1$);
    return _createClass(NullCoder, [{
      key: "defaultValue",
      value: function defaultValue() {
        return null;
      }
    }, {
      key: "encode",
      value: function encode(writer, value) {
        if (value != null) {
          this._throwError("not null", value);
        }
        return writer.writeBytes(Empty);
      }
    }, {
      key: "decode",
      value: function decode(reader) {
        reader.readBytes(0);
        return null;
      }
    }]);
  }(abstract_coder_js_1.Coder);
  _null.NullCoder = NullCoder;
  return _null;
}

var number = {};

var hasRequiredNumber;
function requireNumber() {
  if (hasRequiredNumber) return number;
  hasRequiredNumber = 1;
  Object.defineProperty(number, "__esModule", {
    value: true
  });
  number.NumberCoder = void 0;
  var index_js_1 = /*@__PURE__*/requireUtils$3();
  var typed_js_1 = /*@__PURE__*/requireTyped();
  var abstract_coder_js_1 = /*@__PURE__*/requireAbstractCoder();
  var BN_0 = BigInt(0);
  var BN_1 = BigInt(1);
  var BN_MAX_UINT256 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
  /**
   *  @_ignore
   */
  var NumberCoder = /*#__PURE__*/function (_abstract_coder_js_1$) {
    function NumberCoder(size, signed, localName) {
      var _this;
      _classCallCheck(this, NumberCoder);
      var name = (signed ? "int" : "uint") + size * 8;
      _this = _callSuper(this, NumberCoder, [name, name, localName, false]);
      _defineProperty(_this, "size", void 0);
      _defineProperty(_this, "signed", void 0);
      (0, index_js_1.defineProperties)(_this, {
        size: size,
        signed: signed
      }, {
        size: "number",
        signed: "boolean"
      });
      return _this;
    }
    _inherits(NumberCoder, _abstract_coder_js_1$);
    return _createClass(NumberCoder, [{
      key: "defaultValue",
      value: function defaultValue() {
        return 0;
      }
    }, {
      key: "encode",
      value: function encode(writer, _value) {
        var value = (0, index_js_1.getBigInt)(typed_js_1.Typed.dereference(_value, this.type));
        // Check bounds are safe for encoding
        var maxUintValue = (0, index_js_1.mask)(BN_MAX_UINT256, abstract_coder_js_1.WordSize * 8);
        if (this.signed) {
          var bounds = (0, index_js_1.mask)(maxUintValue, this.size * 8 - 1);
          if (value > bounds || value < -(bounds + BN_1)) {
            this._throwError("value out-of-bounds", _value);
          }
          value = (0, index_js_1.toTwos)(value, 8 * abstract_coder_js_1.WordSize);
        } else if (value < BN_0 || value > (0, index_js_1.mask)(maxUintValue, this.size * 8)) {
          this._throwError("value out-of-bounds", _value);
        }
        return writer.writeValue(value);
      }
    }, {
      key: "decode",
      value: function decode(reader) {
        var value = (0, index_js_1.mask)(reader.readValue(), this.size * 8);
        if (this.signed) {
          value = (0, index_js_1.fromTwos)(value, this.size * 8);
        }
        return value;
      }
    }]);
  }(abstract_coder_js_1.Coder);
  number.NumberCoder = NumberCoder;
  return number;
}

var string = {};

var hasRequiredString;
function requireString() {
  if (hasRequiredString) return string;
  hasRequiredString = 1;
  Object.defineProperty(string, "__esModule", {
    value: true
  });
  string.StringCoder = void 0;
  var utf8_js_1 = /*@__PURE__*/requireUtf8();
  var typed_js_1 = /*@__PURE__*/requireTyped();
  var bytes_js_1 = /*@__PURE__*/requireBytes();
  /**
   *  @_ignore
   */
  var StringCoder = /*#__PURE__*/function (_bytes_js_1$DynamicBy) {
    function StringCoder(localName) {
      _classCallCheck(this, StringCoder);
      return _callSuper(this, StringCoder, ["string", localName]);
    }
    _inherits(StringCoder, _bytes_js_1$DynamicBy);
    return _createClass(StringCoder, [{
      key: "defaultValue",
      value: function defaultValue() {
        return "";
      }
    }, {
      key: "encode",
      value: function encode(writer, _value) {
        return _superPropGet(StringCoder, "encode", this, 3)([writer, (0, utf8_js_1.toUtf8Bytes)(typed_js_1.Typed.dereference(_value, "string"))]);
      }
    }, {
      key: "decode",
      value: function decode(reader) {
        return (0, utf8_js_1.toUtf8String)(_superPropGet(StringCoder, "decode", this, 3)([reader]));
      }
    }]);
  }(bytes_js_1.DynamicBytesCoder);
  string.StringCoder = StringCoder;
  return string;
}

var tuple = {};

var hasRequiredTuple;
function requireTuple() {
  if (hasRequiredTuple) return tuple;
  hasRequiredTuple = 1;
  Object.defineProperty(tuple, "__esModule", {
    value: true
  });
  tuple.TupleCoder = void 0;
  var properties_js_1 = /*@__PURE__*/requireProperties();
  var typed_js_1 = /*@__PURE__*/requireTyped();
  var abstract_coder_js_1 = /*@__PURE__*/requireAbstractCoder();
  var array_js_1 = /*@__PURE__*/requireArray();
  /**
   *  @_ignore
   */
  var TupleCoder = /*#__PURE__*/function (_abstract_coder_js_1$) {
    function TupleCoder(coders, localName) {
      var _this;
      _classCallCheck(this, TupleCoder);
      var dynamic = false;
      var types = [];
      coders.forEach(function (coder) {
        if (coder.dynamic) {
          dynamic = true;
        }
        types.push(coder.type);
      });
      var type = "tuple(" + types.join(",") + ")";
      _this = _callSuper(this, TupleCoder, ["tuple", type, localName, dynamic]);
      _defineProperty(_this, "coders", void 0);
      (0, properties_js_1.defineProperties)(_this, {
        coders: Object.freeze(coders.slice())
      });
      return _this;
    }
    _inherits(TupleCoder, _abstract_coder_js_1$);
    return _createClass(TupleCoder, [{
      key: "defaultValue",
      value: function defaultValue() {
        var values = [];
        this.coders.forEach(function (coder) {
          values.push(coder.defaultValue());
        });
        // We only output named properties for uniquely named coders
        var uniqueNames = this.coders.reduce(function (accum, coder) {
          var name = coder.localName;
          if (name) {
            if (!accum[name]) {
              accum[name] = 0;
            }
            accum[name]++;
          }
          return accum;
        }, {});
        // Add named values
        this.coders.forEach(function (coder, index) {
          var name = coder.localName;
          if (!name || uniqueNames[name] !== 1) {
            return;
          }
          if (name === "length") {
            name = "_length";
          }
          if (values[name] != null) {
            return;
          }
          values[name] = values[index];
        });
        return Object.freeze(values);
      }
    }, {
      key: "encode",
      value: function encode(writer, _value) {
        var value = typed_js_1.Typed.dereference(_value, "tuple");
        return (0, array_js_1.pack)(writer, this.coders, value);
      }
    }, {
      key: "decode",
      value: function decode(reader) {
        return (0, array_js_1.unpack)(reader, this.coders);
      }
    }]);
  }(abstract_coder_js_1.Coder);
  tuple.TupleCoder = TupleCoder;
  return tuple;
}

var fragments = {};

var hash = {};

var id = {};

var hasRequiredId;
function requireId() {
  if (hasRequiredId) return id;
  hasRequiredId = 1;
  Object.defineProperty(id, "__esModule", {
    value: true
  });
  id.id = void 0;
  var index_js_1 = /*@__PURE__*/requireCrypto();
  var index_js_2 = /*@__PURE__*/requireUtils$3();
  /**
   *  A simple hashing function which operates on UTF-8 strings to
   *  compute an 32-byte identifier.
   *
   *  This simply computes the [UTF-8 bytes](toUtf8Bytes) and computes
   *  the [[keccak256]].
   *
   *  @example:
   *    id("hello world")
   *    //_result:
   */
  function id$1(value) {
    return (0, index_js_1.keccak256)((0, index_js_2.toUtf8Bytes)(value));
  }
  id.id = id$1;
  return id;
}

var namehash = {};

var dist = {};

var hasRequiredDist;
function requireDist() {
  if (hasRequiredDist) return dist;
  hasRequiredDist = 1;

  // created 2023-09-25T01:01:55.148Z
  // compressed base64-encoded blob for include-ens data
  // source: https://github.com/adraffy/ens-normalize.js/blob/main/src/make.js
  // see: https://github.com/adraffy/ens-normalize.js#security
  // SHA-256: 0565ed049b9cf1614bb9e11ba7d8ac6a6fb96c893253d890f7e2b2884b9ded32
  var COMPRESSED$1 = 'AEEUdwmgDS8BxQKKAP4BOgDjATAAngDUAIMAoABoAOAAagCOAEQAhABMAHIAOwA9ACsANgAmAGIAHgAuACgAJwAXAC0AGgAjAB8ALwAUACkAEgAeAAkAGwARABkAFgA5ACgALQArADcAFQApABAAHgAiABAAGgAeABMAGAUhBe8BFxREN8sF2wC5AK5HAW8ArQkDzQCuhzc3NzcBP68NEfMABQdHBuw5BV8FYAA9MzkI9r4ZBg7QyQAWA9CeOwLNCjcCjqkChuA/lm+RAsXTAoP6ASfnEQDytQFJAjWVCkeXAOsA6godAB/cwdAUE0WlBCN/AQUCQRjFD/MRBjHxDQSJbw0jBzUAswBxme+tnIcAYwabAysG8QAjAEMMmxcDqgPKQyDXCMMxA7kUQwD3NXOrAKmFIAAfBC0D3x4BJQDBGdUFAhEgVD8JnwmQJiNWYUzrg0oAGwAUAB0AFnNcACkAFgBP9h3gPfsDOWDKneY2ChglX1UDYD30ABsAFAAdABZzIGRAnwDD8wAjAEEMzRbDqgMB2sAFYwXqAtCnAsS4AwpUJKRtFHsadUz9AMMVbwLpABM1NJEX0ZkCgYMBEyMAxRVvAukAEzUBUFAtmUwSAy4DBTER33EftQHfSwB5MxJ/AjkWKQLzL8E/cwBB6QH9LQDPDtO9ASNriQC5DQANAwCK21EFI91zHwCoL9kBqQcHBwcHKzUDowBvAQohPvU3fAQgHwCyAc8CKQMA5zMSezr7ULgFmDp/LzVQBgEGAi8FYQVgt8AFcTtlQhpCWEmfe5tmZ6IAExsDzQ8t+X8rBKtTAltbAn0jsy8Bl6utPWMDTR8Ei2kRANkDBrNHNysDBzECQWUAcwFpJ3kAiyUhAJ0BUb8AL3EfAbfNAz81KUsFWwF3YQZtAm0A+VEfAzEJDQBRSQCzAQBlAHsAM70GD/v3IZWHBwARKQAxALsjTwHZAeMPEzmXgIHwABIAGQA8AEUAQDt3gdvIEGcQZAkGTRFMdEIVEwK0D64L7REdDNkq09PgADSxB/MDWwfzA1sDWwfzB/MDWwfzA1sDWwNbA1scEvAi28gQZw9QBHUFlgWTBN4IiyZREYkHMAjaVBV0JhxPA00BBCMtSSQ7mzMTJUpMFE0LCAQ2SmyvfUADTzGzVP2QqgPTMlc5dAkGHnkSqAAyD3skNb1OhnpPcagKU0+2tYdJak5vAsY6sEAACikJm2/Dd1YGRRAfJ6kQ+ww3AbkBPw3xS9wE9QY/BM0fgRkdD9GVoAipLeEM8SbnLqWAXiP5KocF8Uv4POELUVFsD10LaQnnOmeBUgMlAREijwrhDT0IcRD3Cs1vDekRSQc9A9lJngCpBwULFR05FbkmFGKwCw05ewb/GvoLkyazEy17AAXXGiUGUQEtGwMA0y7rhbRaNVwgT2MGBwspI8sUrFAkDSlAu3hMGh8HGSWtApVDdEqLUToelyH6PEENai4XUYAH+TwJGVMLhTyiRq9FEhHWPpE9TCJNTDAEOYMsMyePCdMPiQy9fHYBXQklCbUMdRM1ERs3yQg9Bx0xlygnGQglRplgngT7owP3E9UDDwVDCUUHFwO5HDETMhUtBRGBKNsC9zbZLrcCk1aEARsFzw8pH+MQVEfkDu0InwJpA4cl7wAxFSUAGyKfCEdnAGOP3FMJLs8Iy2pwI3gDaxTrZRF3B5UOWwerHDcVwxzlcMxeD4YMKKezCV8BeQmdAWME5wgNNV+MpCBFZ1eLXBifIGVBQ14AAjUMaRWjRMGHfAKPD28SHwE5AXcHPQ0FAnsR8RFvEJkI74YINbkz/DopBFMhhyAVCisDU2zSCysm/Qz8bQGnEmYDEDRBd/Jnr2C6KBgBBx0yyUFkIfULlk/RDKAaxRhGVDIZ6AfDA/ca9yfuQVsGAwOnBxc6UTPyBMELbQiPCUMATQ6nGwfbGG4KdYzUATWPAbudA1uVhwJzkwY7Bw8Aaw+LBX3pACECqwinAAkA0wNbAD0CsQehAB0AiUUBQQMrMwEl6QKTA5cINc8BmTMB9y0EH8cMGQD7O25OAsO1AoBuZqYF4VwCkgJNOQFRKQQJUktVA7N15QDfAE8GF+NLARmvTs8e50cB43MvAMsA/wAJOQcJRQHRAfdxALsBYws1Caa3uQFR7S0AhwAZbwHbAo0A4QA5AIP1AVcAUQVd/QXXAlNNARU1HC9bZQG/AyMBNwERAH0Gz5GpzQsjBHEH1wIQHxXlAu8yB7kFAyLjE9FCyQK94lkAMhoKPAqrCqpgX2Q3CjV2PVQAEh+sPss/UgVVO1c7XDtXO1w7VztcO1c7XDtXO1wDm8Pmw+YKcF9JYe8Mqg3YRMw6TRPfYFVgNhPMLbsUxRXSJVoZQRrAJwkl6FUNDwgt12Y0CDA0eRfAAEMpbINFY4oeNApPHOtTlVT8LR8AtUumM7MNsBsZREQFS3XxYi4WEgomAmSFAmJGX1GzAV83JAKh+wJonAJmDQKfiDgfDwJmPwJmKgRyBIMDfxcDfpY5Cjl7GzmGOicnAmwhAjI6OA4CbcsCbbLzjgM3a0kvAWsA4gDlAE4JB5wMkQECD8YAEbkCdzMCdqZDAnlPRwJ4viFg30WyRvcCfEMCeswCfQ0CfPRIBEiBZygALxlJXEpfGRtK0ALRBQLQ0EsrA4hTA4fqRMmRNgLypV0HAwOyS9JMMSkH001QTbMCi0MCitzFHwshR2sJuwKOOwKOYESbhQKO3QKOYHxRuFM5AQ5S2FSJApP/ApMQAO0AIFUiVbNV1AosHymZijLleGpFPz0Cl6MC77ZYJawAXSkClpMCloCgAK1ZsFoNhVEAPwKWuQKWUlxIXNUCmc8CmWhczl0LHQKcnznGOqECnBoCn58CnryOACETNS4TAp31Ap6WALlBYThh8wKe1wKgcgGtAp6jIwKeUqljzGQrKS8CJ7MCJoICoP8CoFDbAqYzAqXSAqgDAIECp/ZogGi1AAdNaiBq1QKs5wKssgKtawKtBgJXIQJV4AKx5dsDH1JsmwKywRECsuwbbORtZ21MYwMl0QK2YD9DbpQDKUkCuGICuUsZArkue3A6cOUCvR0DLbYDMhUCvoxyBgMzdQK+HnMmc1MCw88CwwhzhnRPOUl05AM8qwEDPJ4DPcMCxYACxksCxhSNAshtVQLISALJUwLJMgJkoQLd1nh9ZXiyeSlL1AMYp2cGAmH4GfeVKHsPXpZevxUCz28Cz3AzT1fW9xejAMqxAs93AS3uA04Wfk8JAtwrAtuOAtJTA1JgA1NjAQUDVZCAjUMEzxrxZEl5A4LSg5EC2ssC2eKEFIRNp0ADhqkAMwNkEoZ1Xf0AWQLfaQLevHd7AuIz7RgB8zQrAfSfAfLWiwLr9wLpdH0DAur9AuroAP1LAb0C7o0C66CWrpcHAu5DA4XkmH1w5HGlAvMHAG0DjhqZlwL3FwORcgOSiwL3nAL53QL4apogmq+/O5siA52HAv7+AR8APZ8gAZ+3AwWRA6ZuA6bdANXJAwZuoYyiCQ0DDE0BEwEjB3EGZb1rCQC/BG/DFY8etxEAG3k9ACcDNxJRA42DAWcrJQCM8wAlAOanC6OVCLsGI6fJBgCvBRnDBvElRUYFFoAFcD9GSDNCKUK8X3kZX8QAls0FOgCQVCGbwTsuYDoZutcONxjOGJHJ/gVfBWAFXwVgBWsFYAVfBWAFXwVgBV8FYAVfBWBOHQjfjW8KCgoKbF7xMwTRA7kGN8PDAMMEr8MA70gxFroFTj5xPnhCR0K+X30/X/AAWBkzswCNBsxzzASm70aCRS4rDDMeLz49fnXfcsH5GcoscQFz13Y4HwVnBXLJycnACNdRYwgICAqEXoWTxgA7P4kACxbZBu21Kw0AjMsTAwkVAOVtJUUsJ1JCuULESUArXy9gPi9AKwnJRQYKTD9LPoA+iT54PnkCkULEUUpDX9NWV3JVEjQAc1w3A3IBE3YnX+g7QiMJb6MKaiszRCUuQrNCxDPMCcwEX9EWJzYREBEEBwIHKn6l33JCNVIfybPJtAltydPUCmhBZw/tEKsZAJOVJU1CLRuxbUHOQAo7P0s+eEJHHA8SJVRPdGM0NVrpvBoKhfUlM0JHHGUQUhEWO1xLSj8MO0ucNAqJIzVCRxv9EFsqKyA4OQgNj2nwZgp5ZNFgE2A1K3YHS2AhQQojJmC7DgpzGG1WYFUZCQYHZO9gHWCdYIVgu2BTYJlwFh8GvRbcXbG8YgtDHrMBwzPVyQonHQgkCyYBgQJ0Ajc4nVqIAwGSCsBPIgDsK3SWEtIVBa5N8gGjAo+kVwVIZwD/AEUSCDweX4ITrRQsJ8K3TwBXFDwEAB0TvzVcAtoTS20RIwDgVgZ9BBImYgA5AL4Coi8LFnezOkCnIQFjAY4KBAPh9RcGsgZSBsEAJctdsWIRu2kTkQstRw7DAcMBKgpPBGIGMDAwKCYnKTQaLg4AKRSVAFwCdl+YUZ0JdicFD3lPAdt1F9ZZKCGxuE3yBxkFVGcA/wBFEgiCBwAOLHQSjxOtQDg1z7deFRMAZ8QTAGtKb1ApIiPHADkAvgKiLy1DFtYCmBiDAlDDWNB0eo7fpaMO/aEVRRv0ATEQZBIODyMEAc8JQhCbDRgzFD4TAEMAu9YBCgCsAOkAm5I3ABwAYxvONnR+MhXJAxgKQyxL2+kkJhMbhQKDBMkSsvF0AD9BNQ6uQC7WqSQHwxEAEEIu1hkhAH2z4iQPwyJPHNWpdyYBRSpnJALzoBAEVPPsH20MxA0CCEQKRgAFyAtFAlMNwwjEDUQJRArELtapMg7DDZgJIw+TGukEIwvDFkMAqAtDEMMMBhioe+QAO3MMRAACrgnEBSPY9Q0FDnbSBoMAB8MSYxkSxAEJAPIJAAB8FWMOFtMc/HcXwxhDAC7DAvOowwAewwJdKDKHAAHDAALrFUQVwwAbwyvzpWMWv8wA/ABpAy++bcYDUKPD0KhDCwKmJ1MAAmMA5+UZwxAagwipBRL/eADfw6fDGOMCGsOjk3l6BwOpo4sAEsMOGxMAA5sAbcMOAAvDp0MJGkMDwgipnNIPAwfIqUMGAOGDAAPzABXDAAcDAAnDAGmTABrDAA7DChjDjnEWAwABYwAOcwAuUyYABsMAF8MIKQANUgC6wy4AA8MADqMq8wCyYgAcIwAB8wqpAAXOCx0V4wAHowBCwwEKAGnDAAuDAB3DAAjDCakABdIAbqcZ3QCZCCkABdIAAAFDAAfjAB2jCCkABqIACYMAGzMAbSMA5sOIAAhjAAhDABTDBAkpAAbSAOOTAAlDC6kOzPtnAAdDAG6kQFAATwAKwwwAA0MACbUDPwAHIwAZgwACE6cDAAojAApDAAoDp/MGwwAJIwADEwAQQwgAFEMAEXMAD5MADfMADcMAGRMOFiMAFUMAbqMWuwHDAMIAE0MLAGkzEgDhUwACQwAEWgAXgwUjAAbYABjDBSYBgzBaAEFNALcQBxUMegAwMngBrA0IZgJ0KxQHBREPd1N0ZzKRJwaIHAZqNT4DqQq8BwngAB4DAwt2AX56T1ocKQNXAh1GATQGC3tOxYNagkgAMQA5CQADAQEAWxLjAIOYNAEzAH7tFRk6TglSAF8NAAlYAQ+S1ACAQwQorQBiAN4dAJ1wPyeTANVzuQDX3AIeEMp9eyMgXiUAEdkBkJizKltbVVAaRMqRAAEAhyQ/SDEz6BmfVwB6ATEsOClKIRcDOF0E/832AFNt5AByAnkCRxGCOs94NjXdAwINGBonDBwPALW2AwICAgAAAAAAAAYDBQMDARrUAwAtAAAAAgEGBgYGBgYFBQUFBQUEBQYHCAkEBQUFBQQAAAICAAAAIgCNAJAAlT0A6gC7ANwApEQAwgCyAK0AqADuAKYA2gCjAOcBCAEDAMcAgQBiANIA1AEDAN4A8gCQAKkBMQDqAN8A3AsBCQ8yO9ra2tq8xuLT1tRJOB0BUgFcNU0BWgFpAWgBWwFMUUlLbhMBUxsNEAs6PhMOACcUKy0vMj5AQENDQ0RFFEYGJFdXV1dZWVhZL1pbXVxcI2NnZ2ZoZypsbnZ1eHh4eHh4enp6enp6enp6enp8fH18e2IARPIASQCaAHgAMgBm+ACOAFcAVwA3AnbvAIsABfj4AGQAk/IAnwBPAGIAZP//sACFAIUAaQBWALEAJAC2AIMCQAJDAPwA5wD+AP4A6AD/AOkA6QDoAOYALwJ7AVEBQAE+AVQBPgE+AT4BOQE4ATgBOAEcAVgXADEQCAEAUx8SHgsdHhYAjgCWAKYAUQBqIAIxAHYAbwCXAxUDJzIDIUlGTzEAkQJPAMcCVwKkAMAClgKWApYClgKWApYCiwKWApYClgKWApYClgKVApUCmAKgApcClgKWApQClAKUApQCkgKVAnUB1AKXAp8ClgKWApUeAIETBQD+DQOfAmECOh8BVBg9AuIZEjMbAU4/G1WZAXusRAFpYQEFA0FPAQYAmTEeIJdyADFoAHEANgCRA5zMk/C2jGINwjMWygIZCaXdfDILBCs5dAE7YnQBugDlhoiHhoiGiYqKhouOjIaNkI6Ij4qQipGGkoaThpSSlYaWhpeKmIaZhpqGm4aci52QnoqfhuIC4XTpAt90AIp0LHSoAIsAdHQEQwRABEIERQRDBEkERgRBBEcESQRIBEQERgRJAJ5udACrA490ALxuAQ10ANFZdHQA13QCFHQA/mJ0AP4BIQD+APwA/AD9APwDhGZ03ASMK23HAP4A/AD8AP0A/CR0dACRYnQA/gCRASEA/gCRAvQA/gCRA4RmdNwEjCttxyR0AP9idAEhAP4A/gD8APwA/QD8AP8A/AD8AP0A/AOEZnTcBIwrbcckdHQAkWJ0ASEA/gCRAP4AkQL0AP4AkQOEZnTcBIwrbcckdAJLAT50AlIBQXQCU8l0dAJfdHQDpgL0A6YDpgOnA6cDpwOnA4RmdNwEjCttxyR0dACRYnQBIQOmAJEDpgCRAvQDpgCRA4RmdNwEjCttxyR0BDh0AJEEOQCRDpU5dSgCADR03gV2CwArdAEFAM5iCnR0AF1iAAYcOgp0dACRCnQAXAEIwWZ0CnRmdHQAkWZ0CnRmdEXgAFF03gp0dEY0tlT2u3SOAQTwscwhjZZKrhYcBSfFp9XNbKiVDOD2b+cpe4/Z17mQnbtzzhaeQtE2GGj0IDNTjRUSyTxxw/RPHW/+vS7d1NfRt9z9QPZg4X7QFfhCnkvgNPIItOsC2eV6hPannZNHlZ9xrwZXIMOlu3jSoQSq78WEjwLjw1ELSlF1aBvfzwk5ZX7AUvQzjPQKbDuQ+sm4wNOp4A6AdVuRS0t1y/DZpg4R6m7FNjM9HgvW7Bi88zaMjOo6lM8wtBBdj8LP4ylv3zCXPhebMKJc066o9sF71oFW/8JXu86HJbwDID5lzw5GWLR/LhT0Qqnp2JQxNZNfcbLIzPy+YypqRm/lBmGmex+82+PisxUumSeJkALIT6rJezxMH+CTJmQtt5uwTVbL3ptmjDUQzlSIvWi8Tl7ng1NpuRn1Ng4n14Qc+3Iil7OwkvNWogLSPkn3pihIFytyIGmMhOe3n1tWsuMy9BdKyqF4Z3v2SgggTL9KVvMXPnCbRe+oOuFFP3HejBG/w9gvmfNYvg6JuWia2lcSSN1uIjBktzoIazOHPJZ7kKHPz8mRWVdW3lA8WGF9dQF6Bm673boov3BUWDU2JNcahR23GtfHKLOz/viZ+rYnZFaIznXO67CYEJ1fXuTRpZhYZkKe54xeoagkNGLs+NTZHE0rX45/XvQ2RGADX6vcAvdxIUBV27wxGm2zjZo4X3ILgAlrOFheuZ6wtsvaIj4yLY7qqawlliaIcrz2G+c3vscAnCkCuMzMmZvMfu9lLwTvfX+3cVSyPdN9ZwgDZhfjRgNJcLiJ67b9xx8JHswprbiE3v9UphotAPIgnXVIN5KmMc0piXhc6cChPnN+MRhG9adtdttQTTwSIpl8I4/j//d3sz1326qTBTpPRM/Hgh3kzqEXs8ZAk4ErQhNO8hzrQ0DLkWMA/N+91tn2MdOJnWC2FCZehkQrwzwbKOjhvZsbM95QoeL9skYyMf4srVPVJSgg7pOLUtr/n9eT99oe9nLtFRpjA9okV2Kj8h9k5HaC0oivRD8VyXkJ81tcd4fHNXPCfloIQasxsuO18/46dR2jgul/UIet2G0kRvnyONMKhHs6J26FEoqSqd+rfYjeEGwHWVDpX1fh1jBBcKGMqRepju9Y00mDVHC+Xdij/j44rKfvfjGinNs1jO/0F3jB83XCDINN/HB84axlP+3E/klktRo+vl3U/aiyMJbIodE1XSsDn6UAzIoMtUObY2+k/4gY/l+AkZJ5Sj2vQrkyLm3FoxjhDX+31UXBFf9XrAH31fFqoBmDEZvhvvpnZ87N+oZEu7U9O/nnk+QWj3x8uyoRbEnf+O5UMr9i0nHP38IF5AvzrBW8YWBUR0mIAzIvndQq9N3v/Jto3aPjPXUPl8ASdPPyAp7jENf8bk7VMM9ol9XGmlBmeDMuGqt+WzuL6CXAxXjIhCPM5vACchgMJ/8XBGLO/D1isVvGhwwHHr1DLaI5mn2Jr/b1pUD90uciDaS8cXNDzCWvNmT/PhQe5e8nTnnnkt8Ds/SIjibcum/fqDhKopxAY8AkSrPn+IGDEKOO+U3XOP6djFs2H5N9+orhOahiQk5KnEUWa+CzkVzhp8bMHRbg81qhjjXuIKbHjSLSIBKWqockGtKinY+z4/RdBUF6pcc3JmnlxVcNgrI4SEzKUZSwcD2QCyxzKve+gAmg6ZuSRkpPFa6mfThu7LJNu3H5K42uCpNvPAsoedolKV/LHe/eJ+BbaG5MG0NaSGVPRUmNFMFFSSpXEcXwbVh7UETOZZtoVNRGOIbbkig3McEtR68cG0RZAoJevWYo7Dg/lZ1CQzblWeUvVHmr8fY4Nqd9JJiH/zEX24mJviH60fAyFr0A3c4bC1j3yZU60VgJxXn8JgJXLUIsiBnmKmMYz+7yBQFBvqb2eYnuW59joZBf56/wXvWIR4R8wTmV80i1mZy+S4+BUES+hzjk0uXpC///z/IlqHZ1monzlXp8aCfhGKMti73FI1KbL1q6IKO4fuBuZ59gagjn5xU79muMpHXg6S+e+gDM/U9BKLHbl9l6o8czQKl4RUkJJiqftQG2i3BMg/TQlUYFkJDYBOOvAugYuzYSDnZbDDd/aSd9x0Oe6F+bJcHfl9+gp6L5/TgA+BdFFovbfCrQ40s5vMPw8866pNX8zyFGeFWdxIpPVp9Rg1UPOVFbFZrvaFq/YAzHQgqMWpahMYfqHpmwXfHL1/kpYmGuHFwT55mQu0dylfNuq2Oq0hTMCPwqfxnuBIPLXfci4Y1ANy+1CUipQxld/izVh16WyG2Q0CQQ9NqtAnx1HCHwDj7sYxOSB0wopZSnOzxQOcExmxrVTF2BkOthVpGfuhaGECfCJpJKpjnihY+xOT2QJxN61+9K6QSqtv2Shr82I3jgJrqBg0wELFZPjvHpvzTtaJnLK6Vb97Yn933koO/saN7fsjwNKzp4l2lJVx2orjCGzC/4ZL4zCver6aQYtC5sdoychuFE6ufOiog+VWi5UDkbmvmtah/3aArEBIi39s5ILUnlFLgilcGuz9CQshEY7fw2ouoILAYPVT/gyAIq3TFAIwVsl+ktkRz/qGfnCDGrm5gsl/l9QdvCWGsjPz3dU7XuqKfdUrr/6XIgjp4rey6AJBmCmUJMjITHVdFb5m1p+dLMCL8t55zD42cmftmLEJC0Da04YiRCVUBLLa8D071/N5UBNBXDh0LFsmhV/5B5ExOB4j3WVG/S3lfK5o+V6ELHvy6RR9n4ac+VsK4VE4yphPvV+kG9FegTBH4ZRXL2HytUHCduJazB/KykjfetYxOXTLws267aGOd+I+JhKP//+VnXmS90OD/jvLcVu0asyqcuYN1mSb6XTlCkqv1vigZPIYwNF/zpWcT1GR/6aEIRjkh0yhg4LXJfaGobYJTY4JI58KiAKgmmgAKWdl5nYCeLqavRJGQNuYuZtZFGx+IkI4w4NS2xwbetNMunOjBu/hmKCI/w7tfiiyUd//4rbTeWt4izBY8YvGIN6vyKYmP/8X8wHKCeN+WRcKM70+tXKNGyevU9H2Dg5BsljnTf8YbsJ1TmMs74Ce2XlHisleguhyeg44rQOHZuw/6HTkhnnurK2d62q6yS7210SsAIaR+jXMQA+svkrLpsUY+F30Uw89uOdGAR6vo4FIME0EfVVeHTu6eKicfhSqOeXJhbftcd08sWEnNUL1C9fnprTgd83IMut8onVUF0hvqzZfHduPjbjwEXIcoYmy+P6tcJZHmeOv6VrvEdkHDJecjHuHeWANe79VG662qTjA/HCvumVv3qL+LrOcpqGps2ZGwQdFJ7PU4iuyRlBrwfO+xnPyr47s2cXVbWzAyznDiBGjCM3ksxjjqM62GE9C8f5U38kB3VjtabKp/nRdvMESPGDG90bWRLAt1Qk5DyLuazRR1YzdC1c+hZXvAWV8xA72S4A8B67vjVhbba3MMop293FeEXpe7zItMWrJG/LOH9ByOXmYnNJfjmfuX9KbrpgLOba4nZ+fl8Gbdv/ihv+6wFGKHCYrVwmhFC0J3V2bn2tIB1wCc1CST3d3X2OyxhguXcs4sm679UngzofuSeBewMFJboIQHbUh/m2JhW2hG9DIvG2t7yZIzKBTz9wBtnNC+2pCRYhSIuQ1j8xsz5VvqnyUIthvuoyyu7fNIrg/KQUVmGQaqkqZk/Vx5b33/gsEs8yX7SC1J+NV4icz6bvIE7C5G6McBaI8rVg56q5QBJWxn/87Q1sPK4+sQa8fLU5gXo4paaq4cOcQ4wR0VBHPGjKh+UlPCbA1nLXyEUX45qZ8J7/Ln4FPJE2TdzD0Z8MLSNQiykMMmSyOCiFfy84Rq60emYB2vD09KjYwsoIpeDcBDTElBbXxND72yhd9pC/1CMid/5HUMvAL27OtcIJDzNKpRPNqPOpyt2aPGz9QWIs9hQ9LiX5s8m9hjTUu/f7MyIatjjd+tSfQ3ufZxPpmJhTaBtZtKLUcfOCUqADuO+QoH8B9v6U+P0HV1GLQmtoNFTb3s74ivZgjES0qfK+8RdGgBbcCMSy8eBvh98+et1KIFqSe1KQPyXULBMTsIYnysIwiZBJYdI20vseV+wuJkcqGemehKjaAb9L57xZm3g2zX0bZ2xk/fU+bCo7TlnbW7JuF1YdURo/2Gw7VclDG1W7LOtas2LX4upifZ/23rzpsnY/ALfRgrcWP5hYmV9VxVOQA1fZvp9F2UNU+7d7xRyVm5wiLp3/0dlV7vdw1PMiZrbDAYzIVqEjRY2YU03sJhPnlwIPcZUG5ltL6S8XCxU1eYS5cjr34veBmXAvy7yN4ZjArIG0dfD/5UpBNlX1ZPoxJOwyqRi3wQWtOzd4oNKh0LkoTm8cwqgIfKhqqGOhwo71I+zXnMemTv2B2AUzABWyFztGgGULjDDzWYwJUVBTjKCn5K2QGMK1CQT7SzziOjo+BhAmqBjzuc3xYym2eedGeOIRJVyTwDw37iCMe4g5Vbnsb5ZBdxOAnMT7HU4DHpxWGuQ7GeiY30Cpbvzss55+5Km1YsbD5ea3NI9QNYIXol5apgSu9dZ8f8xS5dtHpido5BclDuLWY4lhik0tbJa07yJhH0BOyEut/GRbYTS6RfiTYWGMCkNpfSHi7HvdiTglEVHKZXaVhezH4kkXiIvKopYAlPusftpE4a5IZwvw1x/eLvoDIh/zpo9FiQInsTb2SAkKHV42XYBjpJDg4374XiVb3ws4qM0s9eSQ5HzsMU4OZJKuopFjBM+dAZEl8RUMx5uU2N486Kr141tVsGQfGjORYMCJAMsxELeNT4RmWjRcpdTGBwcx6XN9drWqPmJzcrGrH4+DRc7+n1w3kPZwu0BkNr6hQrqgo7JTB9A5kdJ/H7P4cWBMwsmuixAzJB3yrQpnGIq90lxAXLzDCdn1LPibsRt7rHNjgQBklRgPZ8vTbjXdgXrTWQsK5MdrXXQVPp0Rinq3frzZKJ0qD6Qhc40VzAraUXlob1gvkhK3vpmHgI6FRlQZNx6eRqkp0zy4AQlX813fAPtL3jMRaitGFFjo0zmErloC+h+YYdVQ6k4F/epxAoF0BmqEoKNTt6j4vQZNQ2BoqF9Vj53TOIoNmDiu9Xp15RkIgQIGcoLpfoIbenzpGUAtqFJp5W+LLnx38jHeECTJ/navKY1NWfN0sY1T8/pB8kIH3DU3DX+u6W3YwpypBMYOhbSxGjq84RZ84fWJow8pyHqn4S/9J15EcCMsXqrfwyd9mhiu3+rEo9pPpoJkdZqHjra4NvzFwuThNKy6hao/SlLw3ZADUcUp3w3SRVfW2rhl80zOgTYnKE0Hs2qp1J6H3xqPqIkvUDRMFDYyRbsFI3M9MEyovPk8rlw7/0a81cDVLmBsR2ze2pBuKb23fbeZC0uXoIvDppfTwIDxk1Oq2dGesGc+oJXWJLGkOha3CX+DUnzgAp9HGH9RsPZN63Hn4RMA5eSVhPHO+9RcRb/IOgtW31V1Q5IPGtoxPjC+MEJbVlIMYADd9aHYWUIQKopuPOHmoqSkubnAKnzgKHqgIOfW5RdAgotN6BN+O2ZYHkuemLnvQ8U9THVrS1RtLmKbcC7PeeDsYznvqzeg6VCNwmr0Yyx1wnLjyT84BZz3EJyCptD3yeueAyDWIs0L2qs/VQ3HUyqfrja0V1LdDzqAikeWuV4sc7RLIB69jEIBjCkyZedoUHqCrOvShVzyd73OdrJW0hPOuQv2qOoHDc9xVb6Yu6uq3Xqp2ZaH46A7lzevbxQEmfrzvAYSJuZ4WDk1Hz3QX1LVdiUK0EvlAGAYlG3Md30r7dcPN63yqBCIj25prpvZP0nI4+EgWoFG95V596CurXpKRBGRjQlHCvy5Ib/iW8nZJWwrET3mgd6mEhfP4KCuaLjopWs7h+MdXFdIv8dHQJgg1xi1eYqB0uDYjxwVmri0Sv5XKut/onqapC+FQiC2C1lvYJ9MVco6yDYsS3AANUfMtvtbYI2hfwZatiSsnoUeMZd34GVjkMMKA+XnjJpXgRW2SHTZplVowPmJsvXy6w3cfO1AK2dvtZEKTkC/TY9LFiKHCG0DnrMQdGm2lzlBHM9iEYynH2UcVMhUEjsc0oDBTgo2ZSQ1gzkAHeWeBXYFjYLuuf8yzTCy7/RFR81WDjXMbq2BOH5dURnxo6oivmxL3cKzKInlZkD31nvpHB9Kk7GfcfE1t+1V64b9LtgeJGlpRFxQCAqWJ5DoY77ski8gsOEOr2uywZaoO/NGa0X0y1pNQHBi3b2SUGNpcZxDT7rLbBf1FSnQ8guxGW3W+36BW0gBje4DOz6Ba6SVk0xiKgt+q2JOFyr4SYfnu+Ic1QZYIuwHBrgzr6UvOcSCzPTOo7D6IC4ISeS7zkl4h+2VoeHpnG/uWR3+ysNgPcOIXQbv0n4mr3BwQcdKJxgPSeyuP/z1Jjg4e9nUvoXegqQVIE30EHx5GHv+FAVUNTowYDJgyFhf5IvlYmEqRif6+WN1MkEJmDcQITx9FX23a4mxy1AQRsOHO/+eImX9l8EMJI3oPWzVXxSOeHU1dUWYr2uAA7AMb+vAEZSbU3qob9ibCyXeypEMpZ6863o6QPqlqGHZkuWABSTVNd4cOh9hv3qEpSx2Zy/DJMP6cItEmiBJ5PFqQnDEIt3NrA3COlOSgz43D7gpNFNJ5MBh4oFzhDPiglC2ypsNU4ISywY2erkyb1NC3Qh/IfWj0eDgZI4/ln8WPfBsT3meTjq1Uqt1E7Zl/qftqkx6aM9KueMCekSnMrcHj1CqTWWzEzPsZGcDe3Ue4Ws+XFYVxNbOFF8ezkvQGR6ZOtOLU2lQEnMBStx47vE6Pb7AYMBRj2OOfZXfisjJnpTfSNjo6sZ6qSvNxZNmDeS7Gk3yYyCk1HtKN2UnhMIjOXUzAqDv90lx9O/q/AT1ZMnit5XQe9wmQxnE/WSH0CqZ9/2Hy+Sfmpeg8RwsHI5Z8kC8H293m/LHVVM/BA7HaTJYg5Enk7M/xWpq0192ACfBai2LA/qrCjCr6Dh1BIMzMXINBmX96MJ5Hn2nxln/RXPFhwHxUmSV0EV2V0jm86/dxxuYSU1W7sVkEbN9EzkG0QFwPhyHKyb3t+Fj5WoUUTErcazE/N6EW6Lvp0d//SDPj7EV9UdJN+Amnf3Wwk3A0SlJ9Z00yvXZ7n3z70G47Hfsow8Wq1JXcfwnA+Yxa5mFsgV464KKP4T31wqIgzFPd3eCe3j5ory5fBF2hgCFyVFrLzI9eetNXvM7oQqyFgDo4CTp/hDV9NMX9JDHQ/nyHTLvZLNLF6ftn2OxjGm8+PqOwhxnPHWipkE/8wbtyri80Sr7pMNkQGMfo4ZYK9OcCC4ESVFFbLMIvlxSoRqWie0wxqnLfcLSXMSpMMQEJYDVObYsXIQNv4TGNwjq1kvT1UOkicTrG3IaBZ3XdScS3u8sgeZPVpOLkbiF940FjbCeNRINNvDbd01EPBrTCPpm12m43ze1bBB59Ia6Ovhnur/Nvx3IxwSWol+3H2qfCJR8df6aQf4v6WiONxkK+IqT4pKQrZK/LplgDI/PJZbOep8dtbV7oCr6CgfpWa8NczOkPx81iSHbsNhVSJBOtrLIMrL31LK9TqHqAbAHe0RLmmV806kRLDLNEhUEJfm9u0sxpkL93Zgd6rw+tqBfTMi59xqXHLXSHwSbSBl0EK0+loECOPtrl+/nsaFe197di4yUgoe4jKoAJDXc6DGDjrQOoFDWZJ9HXwt8xDrQP+7aRwWKWI1GF8s8O4KzxWBBcwnl3vnl1Oez3oh6Ea1vjR7/z7DDTrFtqU2W/KAEzAuXDNZ7MY73MF216dzdSbWmUp4lcm7keJfWaMHgut9x5C9mj66Z0lJ+yhsjVvyiWrfk1lzPOTdhG15Y7gQlXtacvI7qv/XNSscDwqkgwHT/gUsD5yB7LdRRvJxQGYINn9hTpodKFVSTPrtGvyQw+HlRFXIkodErAGu9Iy1YpfSPc3jkFh5CX3lPxv7aqjE/JAfTIpEjGb/H7MO0e2vsViSW1qa/Lmi4/n4DEI3g7lYrcanspDfEpKkdV1OjSLOy0BCUqVoECaB55vs06rXl4jqmLsPsFM/7vYJ0vrBhDCm/00A/H81l1uekJ/6Lml3Hb9+NKiLqATJmDpyzfYZFHumEjC662L0Bwkxi7E9U4cQA0XMVDuMYAIeLMPgQaMVOd8fmt5SflFIfuBoszeAw7ow5gXPE2Y/yBc/7jExARUf/BxIHQBF5Sn3i61w4z5xJdCyO1F1X3+3ax+JSvMeZ7S6QSKp1Fp/sjYz6Z+VgCZzibGeEoujryfMulH7Rai5kAft9ebcW50DyJr2uo2z97mTWIu45YsSnNSMrrNUuG1XsYBtD9TDYzQffKB87vWbkM4EbPAFgoBV4GQS+vtFDUqOFAoi1nTtmIOvg38N4hT2Sn8r8clmBCXspBlMBYTnrqFJGBT3wZOzAyJDre9dHH7+x7qaaKDOB4UQALD5ecS0DE4obubQEiuJZ0EpBVpLuYcce8Aa4PYd/V4DLDAJBYKQPCWTcrEaZ5HYbJi11Gd6hjGom1ii18VHYnG28NKpkz2UKVPxlhYSp8uZr367iOmoy7zsxehW9wzcy2zG0a80PBMCRQMb32hnaHeOR8fnNDzZhaNYhkOdDsBUZ3loDMa1YP0uS0cjUP3b/6DBlqmZOeNABDsLl5BI5QJups8uxAuWJdkUB/pO6Zax6tsg7fN5mjjDgMGngO+DPcKqiHIDbFIGudxtPTIyDi9SFMKBDcfdGQRv41q1AqmxgkVfJMnP8w/Bc7N9/TR6C7mGObFqFkIEom8sKi2xYqJLTCHK7cxzaZvqODo22c3wisBCP4HeAgcRbNPAsBkNRhSmD48dHupdBRw4mIvtS5oeF6zeT1KMCyhMnmhpkFAGWnGscoNkwvQ8ZM5lE/vgTHFYL99OuNxdFBxTEDd5v2qLR8y9WkXsWgG6kZNndFG+pO/UAkOCipqIhL3hq7cRSdrCq7YhUsTocEcnaFa6nVkhnSeRYUA1YO0z5itF9Sly3VlxYDw239TJJH6f3EUfYO5lb7bcFcz8Bp7Oo8QmnsUHOz/fagVUBtKEw1iT88j+aKkv8cscKNkMxjYr8344D1kFoZ7/td1W6LCNYN594301tUGRmFjAzeRg5vyoM1F6+bJZ/Q54jN/k8SFd3DxPTYaAUsivsBfgTn7Mx8H2SpPt4GOdYRnEJOH6jHM2p6SgB0gzIRq6fHxGMmSmqaPCmlfwxiuloaVIitLGN8wie2CDWhkzLoCJcODh7KIOAqbHEvXdUxaS4TTTs07Clzj/6GmVs9kiZDerMxEnhUB6QQPlcfqkG9882RqHoLiHGBoHfQuXIsAG8GTAtao2KVwRnvvam8jo1e312GQAKWEa4sUVEAMG4G6ckcONDwRcg1e2D3+ohXgY4UAWF8wHKQMrSnzCgfFpsxh+aHXMGtPQroQasRY4U6UdG0rz1Vjbka0MekOGRZQEvqQFlxseFor8zWFgHek3v29+WqN6gaK5gZOTOMZzpQIC1201LkMCXild3vWXSc5UX9xcFYfbRPzGFa1FDcPfPB/jUEq/FeGt419CI3YmBlVoHsa4KdcwQP5ZSwHHhFJ7/Ph/Rap/4vmG91eDwPP0lDfCDRCLszTqfzM71xpmiKi2HwS4WlqvGNwtvwF5Dqpn6KTq8ax00UMPkxDcZrEEEsIvHiUXXEphdb4GB4FymlPwBz4Gperqq5pW7TQ6/yNRhW8VT5NhuP0udlxo4gILq5ZxAZk8ZGh3g4CqxJlPKY7AQxupfUcVpWT5VItp1+30UqoyP4wWsRo3olRRgkWZZ2ZN6VC3OZFeXB8NbnUrSdikNptD1QiGuKkr8EmSR/AK9Rw+FF3s5uwuPbvHGiPeFOViltMK7AUaOsq9+x9cndk3iJEE5LKZRlWJbKOZweROzmPNVPkjE3K/TyA57Rs68TkZ3MR8akKpm7cFjnjPd/DdkWjgYoKHSr5Wu5ssoBYU4acRs5g2DHxUmdq8VXOXRbunD8QN0LhgkssgahcdoYsNvuXGUK/KXD/7oFb+VGdhqIn02veuM5bLudJOc2Ky0GMaG4W/xWBxIJcL7yliJOXOpx0AkBqUgzlDczmLT4iILXDxxtRR1oZa2JWFgiAb43obrJnG/TZC2KSK2wqOzRZTXavZZFMb1f3bXvVaNaK828w9TO610gk8JNf3gMfETzXXsbcvRGCG9JWQZ6+cDPqc4466Yo2RcKH+PILeKOqtnlbInR3MmBeGG3FH10yzkybuqEC2HSQwpA0An7d9+73BkDUTm30bZmoP/RGbgFN+GrCOfADgqr0WbI1a1okpFms8iHYw9hm0zUvlEMivBRxModrbJJ+9/p3jUdQQ9BCtQdxnOGrT5dzRUmw0593/mbRSdBg0nRvRZM5/E16m7ZHmDEtWhwvfdZCZ8J8M12W0yRMszXamWfQTwIZ4ayYktrnscQuWr8idp3PjT2eF/jmtdhIfcpMnb+IfZY2FebW6UY/AK3jP4u3Tu4zE4qlnQgLFbM19EBIsNf7KhjdbqQ/D6yiDb+NlEi2SKD+ivXVUK8ib0oBo366gXkR8ZxGjpJIDcEgZPa9TcYe0TIbiPl/rPUQDu3XBJ9X/GNq3FAUsKsll57DzaGMrjcT+gctp+9MLYXCq+sqP81eVQ0r9lt+gcQfZbACRbEjvlMskztZG8gbC8Qn9tt26Q7y7nDrbZq/LEz7kR6Jc6pg3N9rVX8Y5MJrGlML9p9lU4jbTkKqCveeZUJjHB03m2KRKR2TytoFkTXOLg7keU1s1lrPMQJpoOKLuAAC+y1HlJucU6ysB5hsXhvSPPLq5J7JtnqHKZ4vYjC4Vy8153QY+6780xDuGARsGbOs1WqzH0QS765rnSKEbbKlkO8oI/VDwUd0is13tKpqILu1mDJFNy/iJAWcvDgjxvusIT+PGz3ST/J9r9Mtfd0jpaGeiLYIqXc7DiHSS8TcjFVksi66PEkxW1z6ujbLLUGNNYnzOWpH8BZGK4bCK7iR+MbIv8ncDAz1u4StN3vTTzewr9IQjk9wxFxn+6N1ddKs0vffJiS08N3a4G1SVrlZ97Q/M+8G9fe5AP6d9/Qq4WRnORVhofPIKEdCr3llspUfE0oKIIYoByBRPh+bX1HLS3JWGJRhIvE1aW4NTd8ePi4Z+kXb+Z8snYfSNcqijhAgVsx4RCM54cXUiYkjeBmmC4ajOHrChoELscJJC7+9jjMjw5BagZKlgRMiSNYz7h7vvZIoQqbtQmspc0cUk1G/73iXtSpROl5wtLgQi0mW2Ex8i3WULhcggx6E1LMVHUsdc9GHI1PH3U2Ko0PyGdn9KdVOLm7FPBui0i9a0HpA60MsewVE4z8CAt5d401Gv6zXlIT5Ybit1VIA0FCs7wtvYreru1fUyW3oLAZ/+aTnZrOcYRNVA8spoRtlRoWflsRClFcgzkqiHOrf0/SVw+EpVaFlJ0g4Kxq1MMOmiQdpMNpte8lMMQqm6cIFXlnGbfJllysKDi+0JJMotkqgIxOSQgU9dn/lWkeVf8nUm3iwX2Nl3WDw9i6AUK3vBAbZZrcJpDQ/N64AVwjT07Jef30GSSmtNu2WlW7YoyW2FlWfZFQUwk867EdLYKk9VG6JgEnBiBxkY7LMo4YLQJJlAo9l/oTvJkSARDF/XtyAzM8O2t3eT/iXa6wDN3WewNmQHdPfsxChU/KtLG2Mn8i4ZqKdSlIaBZadxJmRzVS/o4yA65RTSViq60oa395Lqw0pzY4SipwE0SXXsKV+GZraGSkr/RW08wPRvqvSUkYBMA9lPx4m24az+IHmCbXA+0faxTRE9wuGeO06DIXa6QlKJ3puIyiuAVfPr736vzo2pBirS+Vxel3TMm3JKhz9o2ZoRvaFVpIkykb0Hcm4oHFBMcNSNj7/4GJt43ogonY2Vg4nsDQIWxAcorpXACzgBqQPjYsE/VUpXpwNManEru4NwMCFPkXvMoqvoeLN3qyu/N1eWEHttMD65v19l/0kH2mR35iv/FI+yjoHJ9gPMz67af3Mq/BoWXqu3rphiWMXVkmnPSEkpGpUI2h1MThideGFEOK6YZHPwYzMBvpNC7+ZHxPb7epfefGyIB4JzO9DTNEYnDLVVHdQyvOEVefrk6Uv5kTQYVYWWdqrdcIl7yljwwIWdfQ/y+2QB3eR/qxYObuYyB4gTbo2in4PzarU1sO9nETkmj9/AoxDA+JM3GMqQtJR4jtduHtnoCLxd1gQUscHRB/MoRYIEsP2pDZ9KvHgtlk1iTbWWbHhohwFEYX7y51fUV2nuUmnoUcqnWIQAAgl9LTVX+Bc0QGNEhChxHR4YjfE51PUdGfsSFE6ck7BL3/hTf9jLq4G1IafINxOLKeAtO7quulYvH5YOBc+zX7CrMgWnW47/jfRsWnJjYYoE7xMfWV2HN2iyIqLI';
  var FENCED = new Map([[8217, "apostrophe"], [8260, "fraction slash"], [12539, "middle dot"]]);
  var NSM_MAX = 4;
  function decode_arithmetic(bytes) {
    var pos = 0;
    function u16() {
      return bytes[pos++] << 8 | bytes[pos++];
    }

    // decode the frequency table
    var symbol_count = u16();
    var total = 1;
    var acc = [0, 1]; // first symbol has frequency 1
    for (var i = 1; i < symbol_count; i++) {
      acc.push(total += u16());
    }

    // skip the sized-payload that the last 3 symbols index into
    var skip = u16();
    var pos_payload = pos;
    pos += skip;
    var read_width = 0;
    var read_buffer = 0;
    function read_bit() {
      if (read_width == 0) {
        // this will read beyond end of buffer
        // but (undefined|0) => zero pad
        read_buffer = read_buffer << 8 | bytes[pos++];
        read_width = 8;
      }
      return read_buffer >> --read_width & 1;
    }
    var N = 31;
    var FULL = Math.pow(2, N);
    var HALF = FULL >>> 1;
    var QRTR = HALF >> 1;
    var MASK = FULL - 1;

    // fill register
    var register = 0;
    for (var _i = 0; _i < N; _i++) register = register << 1 | read_bit();
    var symbols = [];
    var low = 0;
    var range = FULL; // treat like a float
    while (true) {
      var value = Math.floor(((register - low + 1) * total - 1) / range);
      var start = 0;
      var end = symbol_count;
      while (end - start > 1) {
        // binary search
        var mid = start + end >>> 1;
        if (value < acc[mid]) {
          end = mid;
        } else {
          start = mid;
        }
      }
      if (start == 0) break; // first symbol is end mark
      symbols.push(start);
      var a = low + Math.floor(range * acc[start] / total);
      var b = low + Math.floor(range * acc[start + 1] / total) - 1;
      while (((a ^ b) & HALF) == 0) {
        register = register << 1 & MASK | read_bit();
        a = a << 1 & MASK;
        b = b << 1 & MASK | 1;
      }
      while (a & ~b & QRTR) {
        register = register & HALF | register << 1 & MASK >>> 1 | read_bit();
        a = a << 1 ^ HALF;
        b = (b ^ HALF) << 1 | HALF | 1;
      }
      low = a;
      range = 1 + b - a;
    }
    var offset = symbol_count - 4;
    return symbols.map(function (x) {
      // index into payload
      switch (x - offset) {
        case 3:
          return offset + 0x10100 + (bytes[pos_payload++] << 16 | bytes[pos_payload++] << 8 | bytes[pos_payload++]);
        case 2:
          return offset + 0x100 + (bytes[pos_payload++] << 8 | bytes[pos_payload++]);
        case 1:
          return offset + bytes[pos_payload++];
        default:
          return x - 1;
      }
    });
  }

  // returns an iterator which returns the next symbol
  function read_payload(v) {
    var pos = 0;
    return function () {
      return v[pos++];
    };
  }
  function read_compressed_payload(s) {
    return read_payload(decode_arithmetic(unsafe_atob(s)));
  }

  // unsafe in the sense:
  // expected well-formed Base64 w/o padding 
  // 20220922: added for https://github.com/adraffy/ens-normalize.js/issues/4
  function unsafe_atob(s) {
    var lookup = [];
    _toConsumableArray('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/').forEach(function (c, i) {
      return lookup[c.charCodeAt(0)] = i;
    });
    var n = s.length;
    var ret = new Uint8Array(6 * n >> 3);
    for (var i = 0, pos = 0, width = 0, carry = 0; i < n; i++) {
      carry = carry << 6 | lookup[s.charCodeAt(i)];
      width += 6;
      if (width >= 8) {
        ret[pos++] = carry >> (width -= 8);
      }
    }
    return ret;
  }

  // eg. [0,1,2,3...] => [0,-1,1,-2,...]
  function signed(i) {
    return i & 1 ? ~i >> 1 : i >> 1;
  }
  function read_deltas(n, next) {
    var v = Array(n);
    for (var i = 0, x = 0; i < n; i++) v[i] = x += signed(next());
    return v;
  }

  // [123][5] => [0 3] [1 1] [0 0]
  function read_sorted(next) {
    var prev = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var ret = [];
    while (true) {
      var x = next();
      var n = next();
      if (!n) break;
      prev += x;
      for (var i = 0; i < n; i++) {
        ret.push(prev + i);
      }
      prev += n + 1;
    }
    return ret;
  }
  function read_sorted_arrays(next) {
    return read_array_while(function () {
      var v = read_sorted(next);
      if (v.length) return v;
    });
  }

  // returns map of x => ys
  function read_mapped(next) {
    var ret = [];
    while (true) {
      var w = next();
      if (w == 0) break;
      ret.push(read_linear_table(w, next));
    }
    while (true) {
      var _w = next() - 1;
      if (_w < 0) break;
      ret.push(read_replacement_table(_w, next));
    }
    return ret.flat();
  }

  // read until next is falsy
  // return array of read values
  function read_array_while(next) {
    var v = [];
    while (true) {
      var x = next(v.length);
      if (!x) break;
      v.push(x);
    }
    return v;
  }

  // read w columns of length n
  // return as n rows of length w
  function read_transposed(n, w, next) {
    var m = Array(n).fill().map(function () {
      return [];
    });
    for (var i = 0; i < w; i++) {
      read_deltas(n, next).forEach(function (x, j) {
        return m[j].push(x);
      });
    }
    return m;
  }

  // returns [[x, ys], [x+dx, ys+dy], [x+2*dx, ys+2*dy], ...]
  // where dx/dy = steps, n = run size, w = length of y
  function read_linear_table(w, next) {
    var dx = 1 + next();
    var dy = next();
    var vN = read_array_while(next);
    var m = read_transposed(vN.length, 1 + w, next);
    return m.flatMap(function (v, i) {
      var _v = _toArray(v),
        x = _v[0],
        ys = _v.slice(1);
      return Array(vN[i]).fill().map(function (_, j) {
        var j_dy = j * dy;
        return [x + j * dx, ys.map(function (y) {
          return y + j_dy;
        })];
      });
    });
  }

  // return [[x, ys...], ...]
  // where w = length of y
  function read_replacement_table(w, next) {
    var n = 1 + next();
    var m = read_transposed(n, 1 + w, next);
    return m.map(function (v) {
      return [v[0], v.slice(1)];
    });
  }
  function read_trie(next) {
    var ret = [];
    var sorted = read_sorted(next);
    expand(decode([]), []);
    return ret; // not sorted
    function decode(Q) {
      // characters that lead into this node
      var S = next(); // state: valid, save, check
      var B = read_array_while(function () {
        // buckets leading to new nodes
        var cps = read_sorted(next).map(function (i) {
          return sorted[i];
        });
        if (cps.length) return decode(cps);
      });
      return {
        S: S,
        B: B,
        Q: Q
      };
    }
    function expand(_ref, cps, saved) {
      var S = _ref.S,
        B = _ref.B;
      if (S & 4 && saved === cps[cps.length - 1]) return;
      if (S & 2) saved = cps[cps.length - 1];
      if (S & 1) ret.push(cps);
      var _iterator = _createForOfIteratorHelper(B),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var br = _step.value;
          var _iterator2 = _createForOfIteratorHelper(br.Q),
            _step2;
          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              var cp = _step2.value;
              expand(br, [].concat(_toConsumableArray(cps), [cp]), saved);
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
  }
  function hex_cp(cp) {
    return cp.toString(16).toUpperCase().padStart(2, '0');
  }
  function quote_cp(cp) {
    return "{".concat(hex_cp(cp), "}"); // raffy convention: like "\u{X}" w/o the "\u"
  }

  /*
  export function explode_cp(s) {
  	return [...s].map(c => c.codePointAt(0));
  }
  */
  function explode_cp(s) {
    // this is about 2x faster
    var cps = [];
    for (var pos = 0, len = s.length; pos < len;) {
      var cp = s.codePointAt(pos);
      pos += cp < 0x10000 ? 1 : 2;
      cps.push(cp);
    }
    return cps;
  }
  function str_from_cps(cps) {
    var chunk = 4096;
    var len = cps.length;
    if (len < chunk) return String.fromCodePoint.apply(String, _toConsumableArray(cps));
    var buf = [];
    for (var i = 0; i < len;) {
      buf.push(String.fromCodePoint.apply(String, _toConsumableArray(cps.slice(i, i += chunk))));
    }
    return buf.join('');
  }
  function compare_arrays(a, b) {
    var n = a.length;
    var c = n - b.length;
    for (var i = 0; c == 0 && i < n; i++) c = a[i] - b[i];
    return c;
  }

  // created 2023-09-25T01:01:55.148Z
  // compressed base64-encoded blob for include-nf data
  // source: https://github.com/adraffy/ens-normalize.js/blob/main/src/make.js
  // see: https://github.com/adraffy/ens-normalize.js#security
  // SHA-256: a974b6f8541fc29d919bc85118af0a44015851fab5343f8679cb31be2bdb209e
  var COMPRESSED = 'AEUDTAHBCFQATQDRADAAcgAgADQAFAAsABQAHwAOACQADQARAAoAFwAHABIACAAPAAUACwAFAAwABAAQAAMABwAEAAoABQAIAAIACgABAAQAFAALAAIACwABAAIAAQAHAAMAAwAEAAsADAAMAAwACgANAA0AAwAKAAkABAAdAAYAZwDSAdsDJgC0CkMB8xhZAqfoC190UGcThgBurwf7PT09Pb09AjgJum8OjDllxHYUKXAPxzq6tABAxgK8ysUvWAgMPT09PT09PSs6LT2HcgWXWwFLoSMEEEl5RFVMKvO0XQ8ExDdJMnIgsj26PTQyy8FfEQ8AY8IPAGcEbwRwBHEEcgRzBHQEdQR2BHcEeAR6BHsEfAR+BIAEgfndBQoBYgULAWIFDAFiBNcE2ATZBRAFEQUvBdALFAsVDPcNBw13DYcOMA4xDjMB4BllHI0B2grbAMDpHLkQ7QHVAPRNQQFnGRUEg0yEB2uaJF8AJpIBpob5AERSMAKNoAXqaQLUBMCzEiACnwRZEkkVsS7tANAsBG0RuAQLEPABv9HICTUBXigPZwRBApMDOwAamhtaABqEAY8KvKx3LQ4ArAB8UhwEBAVSagD8AEFZADkBIadVj2UMUgx5Il4ANQC9AxIB1BlbEPMAs30CGxlXAhwZKQIECBc6EbsCoxngzv7UzRQA8M0BawL6ZwkN7wABAD33OQRcsgLJCjMCjqUChtw/km+NAsXPAoP2BT84PwURAK0RAvptb6cApQS/OMMey5HJS84UdxpxTPkCogVFITaTOwERAK5pAvkNBOVyA7q3BKlOJSALAgUIBRcEdASpBXqzABXFSWZOawLCOqw//AolCZdvv3dSBkEQGyelEPcMMwG1ATsN7UvYBPEGOwTJH30ZGQ/NlZwIpS3dDO0m4y6hgFoj9SqDBe1L9DzdC01RaA9ZC2UJ4zpjgU4DIQENIosK3Q05CG0Q8wrJaw3lEUUHOQPVSZoApQcBCxEdNRW1JhBirAsJOXcG+xr2C48mrxMpevwF0xohBk0BKRr/AM8u54WwWjFcHE9fBgMLJSPHFKhQIA0lQLd4SBobBxUlqQKRQ3BKh1E2HpMh9jw9DWYuE1F8B/U8BRlPC4E8nkarRQ4R0j6NPUgiSUwsBDV/LC8niwnPD4UMuXxyAVkJIQmxDHETMREXN8UIOQcZLZckJxUIIUaVYJoE958D8xPRAwsFPwlBBxMDtRwtEy4VKQUNgSTXAvM21S6zAo9WgAEXBcsPJR/fEFBH4A7pCJsCZQODJesALRUhABcimwhDYwBfj9hTBS7LCMdqbCN0A2cU52ERcweRDlcHpxwzFb8c4XDIXguGCCijrwlbAXUJmQFfBOMICTVbjKAgQWdTi1gYmyBhQT9d/AIxDGUVn0S9h3gCiw9rEhsBNQFzBzkNAQJ3Ee0RaxCVCOuGBDW1M/g6JQRPIYMgEQonA09szgsnJvkM+GkBoxJiAww0PXfuZ6tgtiQX/QcZMsVBYCHxC5JPzQycGsEYQlQuGeQHvwPzGvMn6kFXBf8DowMTOk0z7gS9C2kIiwk/AEkOoxcH1xhqCnGM0AExiwG3mQNXkYMCb48GNwcLAGcLhwV55QAdAqcIowAFAM8DVwA5Aq0HnQAZAIVBAT0DJy8BIeUCjwOTCDHLAZUvAfMpBBvDDBUA9zduSgLDsQKAamaiBd1YAo4CSTUBTSUEBU5HUQOvceEA2wBLBhPfRwEVq0rLGuNDAd9vKwDHAPsABTUHBUEBzQHzbQC3AV8LMQmis7UBTekpAIMAFWsB1wKJAN0ANQB/8QFTAE0FWfkF0wJPSQERMRgrV2EBuwMfATMBDQB5BsuNpckHHwRtB9MCEBsV4QLvLge1AQMi3xPNQsUCvd5VoWACZIECYkJbTa9bNyACofcCaJgCZgkCn4Q4GwsCZjsCZiYEbgR/A38TA36SOQY5dxc5gjojIwJsHQIyNjgKAm3HAm2u74ozZ0UrAWcA3gDhAEoFB5gMjQD+C8IADbUCdy8CdqI/AnlLQwJ4uh1c20WuRtcCfD8CesgCfQkCfPAFWQUgSABIfWMkAoFtAoAAAoAFAn+uSVhKWxUXSswC0QEC0MxLJwOITwOH5kTFkTIC8qFdAwMDrkvOTC0lA89NTE2vAos/AorYwRsHHUNnBbcCjjcCjlxAl4ECjtkCjlx4UbRTNQpS1FSFApP7ApMMAOkAHFUeVa9V0AYsGymVhjLheGZFOzkCl58C77JYIagAWSUClo8ClnycAKlZrFoJgU0AOwKWtQKWTlxEXNECmcsCmWRcyl0HGQKcmznCOp0CnBYCn5sCnriKAB0PMSoPAp3xAp6SALU9YTRh7wKe0wKgbgGpAp6fHwKeTqVjyGQnJSsCJ68CJn4CoPsCoEwCot0CocQCpi8Cpc4Cp/8AfQKn8mh8aLEAA0lqHGrRAqzjAqyuAq1nAq0CAlcdAlXcArHh1wMfTmyXArK9DQKy6Bds4G1jbUhfAyXNArZcOz9ukAMpRQK4XgK5RxUCuSp3cDZw4QK9GQK72nCWAzIRAr6IcgIDM3ECvhpzInNPAsPLAsMEc4J0SzVFdOADPKcDPJoDPb8CxXwCxkcCxhCJAshpUQLIRALJTwLJLgJknQLd0nh5YXiueSVL0AMYo2cCAmH0GfOVJHsLXpJeuxECz2sCz2wvS1PS8xOfAMatAs9zASnqA04SfksFAtwnAtuKAtJPA1JcA1NfAQEDVYyAiT8AyxbtYEWCHILTgs6DjQLaxwLZ3oQQhEmnPAOGpQAvA2QOhnFZ+QBVAt9lAt64c3cC4i/tFAHzMCcB9JsB8tKHAuvzAulweQLq+QLq5AD5RwG5Au6JAuuclqqXAwLuPwOF4Jh5cOBxoQLzAwBpA44WmZMC9xMDkW4DkocC95gC+dkC+GaaHJqruzebHgOdgwL++gEbADmfHJ+zAwWNA6ZqA6bZANHFAwZqoYiiBQkDDEkCwAA/AwDhQRdTARHzA2sHl2cFAJMtK7evvdsBiZkUfxEEOQH7KQUhDp0JnwCS/SlXxQL3AZ0AtwW5AG8LbUEuFCaNLgFDAYD8AbUmAHUDDgRtACwCFgyhAAAKAj0CagPdA34EkQEgRQUhfAoABQBEABMANhICdwEABdUDa+8KxQIA9wqfJ7+xt+UBkSFBQgHpFH8RNMCJAAQAGwBaAkUChIsABjpTOpSNbQC4Oo860ACNOME63AClAOgAywE6gTo7Ofw5+Tt2iTpbO56JOm85GAFWATMBbAUvNV01njWtNWY1dTW2NcU1gjWRNdI14TWeNa017jX9NbI1wTYCNhE1xjXVNhY2JzXeNe02LjY9Ni41LSE2OjY9Njw2yTcIBJA8VzY4Nt03IDcPNsogN4k3MAoEsDxnNiQ3GTdsOo03IULUQwdC4EMLHA8PCZsobShRVQYA6X8A6bABFCnXAukBowC9BbcAbwNzBL8MDAMMAQgDAAkKCwsLCQoGBAVVBI/DvwDz9b29kaUCb0QtsRTNLt4eGBcSHAMZFhYZEhYEARAEBUEcQRxBHEEcQRxBHEEaQRxBHEFCSTxBPElISUhBNkM2QTYbNklISVmBVIgBFLWZAu0BhQCjBcEAbykBvwGJAaQcEZ0ePCklMAAhMvAIMAL54gC7Bm8EescjzQMpARQpKgDUABavAj626xQAJP0A3etzuf4NNRA7efy2Z9NQrCnC0OSyANz5BBIbJ5IFDR6miIavYS6tprjjmuKebxm5C74Q225X1pkaYYPb6f1DK4k3xMEBb9S2WMjEibTNWhsRJIA+vwNVEiXTE5iXs/wezV66oFLfp9NZGYW+Gk19J2+bCT6Ye2w6LDYdgzKMUabk595eLBCXANz9HUpWbATq9vqXVx9XDg+Pc9Xp4+bsS005SVM/BJBM4687WUuf+Uj9dEi8aDNaPxtpbDxcG1THTImUMZq4UCaaNYpsVqraNyKLJXDYsFZ/5jl7bLRtO88t7P3xZaAxhb5OdPMXqsSkp1WCieG8jXm1U99+blvLlXzPCS+M93VnJCiK+09LfaSaBAVBomyDgJua8dfUzR7ga34IvR2Nvj+A9heJ6lsl1KG4NkI1032Cnff1m1wof2B9oHJK4bi6JkEdSqeNeiuo6QoZZincoc73/TH9SXF8sCE7XyuYyW8WSgbGFCjPV0ihLKhdPs08Tx82fYAkLLc4I2wdl4apY7GU5lHRFzRWJep7Ww3wbeA3qmd59/86P4xuNaqDpygXt6M85glSBHOCGgJDnt+pN9bK7HApMguX6+06RZNjzVmcZJ+wcUrJ9//bpRNxNuKpNl9uFds+S9tdx7LaM5ZkIrPj6nIU9mnbFtVbs9s/uLgl8MVczAwet+iOEzzBlYW7RCMgE6gyNLeq6+1tIx4dpgZnd0DksJS5f+JNDpwwcPNXaaVspq1fbQajOrJgK0ofKtJ1Ne90L6VO4MOl5S886p7u6xo7OLjG8TGL+HU1JXGJgppg4nNbNJ5nlzSpuPYy21JUEcUA94PoFiZfjZue+QnyQ80ekOuZVkxx4g+cvhJfHgNl4hy1/a6+RKcKlar/J29y//EztlbVPHVUeQ1zX86eQVAjR/M3dA9w4W8LfaXp4EgM85wOWasli837PzVMOnsLzR+k3o75/lRPAJSE1xAKQzEi5v10ke+VBvRt1cwQRMd+U5mLCTGVd6XiZtgBG5cDi0w22GKcVNvHiu5LQbZEDVtz0onn7k5+heuKXVsZtSzilkLRAUmjMXEMB3J9YC50XBxPiz53SC+EhnPl9WsKCv92SM/OFFIMJZYfl0WW8tIO3UxYcwdMAj7FSmgrsZ2aAZO03BOhP1bNNZItyXYQFTpC3SG1VuPDqH9GkiCDmE+JwxyIVSO5siDErAOpEXFgjy6PQtOVDj+s6e1r8heWVvmZnTciuf4EiNZzCAd7SOMhXERIOlsHIMG399i9aLTy3m2hRLZjJVDNLS53iGIK11dPqQt0zBDyg6qc7YqkDm2M5Ve6dCWCaCbTXX2rToaIgz6+zh4lYUi/+6nqcFMAkQJKHYLK0wYk5N9szV6xihDbDDFr45lN1K4aCXBq/FitPSud9gLt5ZVn+ZqGX7cwm2z5EGMgfFpIFyhGGuDPmso6TItTMwny+7uPnLCf4W6goFQFV0oQSsc9VfMmVLcLr6ZetDZbaSFTLqnSO/bIPjA3/zAUoqgGFAEQS4IhuMzEp2I3jJzbzkk/IEmyax+rhZTwd6f+CGtwPixu8IvzACquPWPREu9ZvGkUzpRwvRRuaNN6cr0W1wWits9ICdYJ7ltbgMiSL3sTPeufgNcVqMVWFkCPDH4jG2jA0XcVgQj62Cb29v9f/z/+2KbYvIv/zzjpQAPkliaVDzNrW57TZ/ZOyZD0nlfMmAIBIAGAI0D3k/mdN4xr9v85ZbZbbqfH2jGd5hUqNZWwl5SPfoGmfElmazUIeNL1j/mkF7VNAzTq4jNt8JoQ11NQOcmhprXoxSxfRGJ9LDEOAQ+dmxAQH90iti9e2u/MoeuaGcDTHoC+xsmEeWmxEKefQuIzHbpw5Tc5cEocboAD09oipWQhtTO1wivf/O+DRe2rpl/E9wlrzBorjJsOeG1B/XPW4EaJEFdNlECEZga5ZoGRHXgYouGRuVkm8tDESiEyFNo+3s5M5puSdTyUL2llnINVHEt91XUNW4ewdMgJ4boJfEyt/iY5WXqbA+A2Fkt5Z0lutiWhe9nZIyIUjyXDC3UsaG1t+eNx6z4W/OYoTB7A6x+dNSTOi9AInctbESqm5gvOLww7OWXPrmHwVZasrl4eD113pm+JtT7JVOvnCXqdzzdTRHgJ0PiGTFYW5Gvt9R9LD6Lzfs0v/TZZHSmyVNq7viIHE6DBK7Qp07Iz55EM8SYtQvZf/obBniTWi5C2/ovHfw4VndkE5XYdjOhCMRjDeOEfXeN/CwfGduiUIfsoFeUxXeQXba7c7972XNv8w+dTjjUM0QeNAReW+J014dKAD/McQYXT7c0GQPIkn3Ll6R7gGjuiQoZD0TEeEqQpKoZ15g/0OPQI17QiSv9AUROa/V/TQN3dvLArec3RrsYlvBm1b8LWzltdugsC50lNKYLEp2a+ZZYqPejULRlOJh5zj/LVMyTDvwKhMxxwuDkxJ1QpoNI0OTWLom4Z71SNzI9TV1iXJrIu9Wcnd+MCaAw8o1jSXd94YU/1gnkrC9BUEOtQvEIQ7g0i6h+KL2JKk8Ydl7HruvgWMSAmNe+LshGhV4qnWHhO9/RIPQzY1tHRj2VqOyNsDpK0cww+56AdDC4gsWwY0XxoucIWIqs/GcwnWqlaT0KPr8mbK5U94/301i1WLt4YINTVvCFBrFZbIbY8eycOdeJ2teD5IfPLCRg7jjcFTwlMFNl9zdh/o3E/hHPwj7BWg0MU09pPrBLbrCgm54A6H+I6v27+jL5gkjWg/iYdks9jbfVP5y/n0dlgWEMlKasl7JvFZd56LfybW1eeaVO0gxTfXZwD8G4SI116yx7UKVRgui6Ya1YpixqXeNLc8IxtAwCU5IhwQgn+NqHnRaDv61CxKhOq4pOX7M6pkA+Pmpd4j1vn6ACUALoLLc4vpXci8VidLxzm7qFBe7s+quuJs6ETYmnpgS3LwSZxPIltgBDXz8M1k/W2ySNv2f9/NPhxLGK2D21dkHeSGmenRT3Yqcdl0m/h3OYr8V+lXNYGf8aCCpd4bWjE4QIPj7vUKN4Nrfs7ML6Y2OyS830JCnofg/k7lpFpt4SqZc5HGg1HCOrHvOdC8bP6FGDbE/VV0mX4IakzbdS/op+Kt3G24/8QbBV7y86sGSQ/vZzU8FXs7u6jIvwchsEP2BpIhW3G8uWNwa3HmjfH/ZjhhCWvluAcF+nMf14ClKg5hGgtPLJ98ueNAkc5Hs2WZlk2QHvfreCK1CCGO6nMZVSb99VM/ajr8WHTte9JSmkXq/i/U943HEbdzW6Re/S88dKgg8pGOLlAeNiqrcLkUR3/aClFpMXcOUP3rmETcWSfMXZE3TUOi8i+fqRnTYLflVx/Vb/6GJ7eIRZUA6k3RYR3iFSK9c4iDdNwJuZL2FKz/IK5VimcNWEqdXjSoxSgmF0UPlDoUlNrPcM7ftmA8Y9gKiqKEHuWN+AZRIwtVSxye2Kf8rM3lhJ5XcBXU9n4v0Oy1RU2M+4qM8AQPVwse8ErNSob5oFPWxuqZnVzo1qB/IBxkM3EVUKFUUlO3e51259GgNcJbCmlvrdjtoTW7rChm1wyCKzpCTwozUUEOIcWLneRLgMXh+SjGSFkAllzbGS5HK7LlfCMRNRDSvbQPjcXaenNYxCvu2Qyznz6StuxVj66SgI0T8B6/sfHAJYZaZ78thjOSIFumNWLQbeZixDCCC+v0YBtkxiBB3jefHqZ/dFHU+crbj6OvS1x/JDD7vlm7zOVPwpUC01nhxZuY/63E7g';

  // https://unicode.org/reports/tr15/
  // for reference implementation
  // see: /derive/nf.js

  // algorithmic hangul
  // https://www.unicode.org/versions/Unicode15.0.0/ch03.pdf (page 144)
  var S0 = 0xAC00;
  var L0 = 0x1100;
  var V0 = 0x1161;
  var T0 = 0x11A7;
  var L_COUNT = 19;
  var V_COUNT = 21;
  var T_COUNT = 28;
  var N_COUNT = V_COUNT * T_COUNT;
  var S_COUNT = L_COUNT * N_COUNT;
  var S1 = S0 + S_COUNT;
  var L1 = L0 + L_COUNT;
  var V1 = V0 + V_COUNT;
  var T1 = T0 + T_COUNT;
  function unpack_cc(packed) {
    return packed >> 24 & 0xFF;
  }
  function unpack_cp(packed) {
    return packed & 0xFFFFFF;
  }
  var SHIFTED_RANK, EXCLUSIONS, DECOMP, RECOMP;
  function init$1() {
    //console.time('nf');
    var r = read_compressed_payload(COMPRESSED);
    SHIFTED_RANK = new Map(read_sorted_arrays(r).flatMap(function (v, i) {
      return v.map(function (x) {
        return [x, i + 1 << 24];
      });
    })); // pre-shifted
    EXCLUSIONS = new Set(read_sorted(r));
    DECOMP = new Map();
    RECOMP = new Map();
    var _iterator3 = _createForOfIteratorHelper(read_mapped(r)),
      _step3;
    try {
      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
        var _step3$value = _slicedToArray(_step3.value, 2),
          cp = _step3$value[0],
          cps = _step3$value[1];
        if (!EXCLUSIONS.has(cp) && cps.length == 2) {
          var _cps = _slicedToArray(cps, 2),
            a = _cps[0],
            b = _cps[1];
          var bucket = RECOMP.get(a);
          if (!bucket) {
            bucket = new Map();
            RECOMP.set(a, bucket);
          }
          bucket.set(b, cp);
        }
        DECOMP.set(cp, cps.reverse()); // stored reversed
      }
      //console.timeEnd('nf');
      // 20230905: 11ms
    } catch (err) {
      _iterator3.e(err);
    } finally {
      _iterator3.f();
    }
  }
  function is_hangul(cp) {
    return cp >= S0 && cp < S1;
  }
  function compose_pair(a, b) {
    if (a >= L0 && a < L1 && b >= V0 && b < V1) {
      return S0 + (a - L0) * N_COUNT + (b - V0) * T_COUNT;
    } else if (is_hangul(a) && b > T0 && b < T1 && (a - S0) % T_COUNT == 0) {
      return a + (b - T0);
    } else {
      var recomp = RECOMP.get(a);
      if (recomp) {
        recomp = recomp.get(b);
        if (recomp) {
          return recomp;
        }
      }
      return -1;
    }
  }
  function decomposed(cps) {
    if (!SHIFTED_RANK) init$1();
    var ret = [];
    var buf = [];
    var check_order = false;
    function add(cp) {
      var cc = SHIFTED_RANK.get(cp);
      if (cc) {
        check_order = true;
        cp |= cc;
      }
      ret.push(cp);
    }
    var _iterator4 = _createForOfIteratorHelper(cps),
      _step4;
    try {
      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
        var cp = _step4.value;
        while (true) {
          if (cp < 0x80) {
            ret.push(cp);
          } else if (is_hangul(cp)) {
            var s_index = cp - S0;
            var l_index = s_index / N_COUNT | 0;
            var v_index = s_index % N_COUNT / T_COUNT | 0;
            var t_index = s_index % T_COUNT;
            add(L0 + l_index);
            add(V0 + v_index);
            if (t_index > 0) add(T0 + t_index);
          } else {
            var mapped = DECOMP.get(cp);
            if (mapped) {
              buf.push.apply(buf, _toConsumableArray(mapped));
            } else {
              add(cp);
            }
          }
          if (!buf.length) break;
          cp = buf.pop();
        }
      }
    } catch (err) {
      _iterator4.e(err);
    } finally {
      _iterator4.f();
    }
    if (check_order && ret.length > 1) {
      var prev_cc = unpack_cc(ret[0]);
      for (var i = 1; i < ret.length; i++) {
        var cc = unpack_cc(ret[i]);
        if (cc == 0 || prev_cc <= cc) {
          prev_cc = cc;
          continue;
        }
        var j = i - 1;
        while (true) {
          var tmp = ret[j + 1];
          ret[j + 1] = ret[j];
          ret[j] = tmp;
          if (!j) break;
          prev_cc = unpack_cc(ret[--j]);
          if (prev_cc <= cc) break;
        }
        prev_cc = unpack_cc(ret[i]);
      }
    }
    return ret;
  }
  function composed_from_decomposed(v) {
    var ret = [];
    var stack = [];
    var prev_cp = -1;
    var prev_cc = 0;
    var _iterator5 = _createForOfIteratorHelper(v),
      _step5;
    try {
      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
        var packed = _step5.value;
        var cc = unpack_cc(packed);
        var cp = unpack_cp(packed);
        if (prev_cp == -1) {
          if (cc == 0) {
            prev_cp = cp;
          } else {
            ret.push(cp);
          }
        } else if (prev_cc > 0 && prev_cc >= cc) {
          if (cc == 0) {
            ret.push.apply(ret, [prev_cp].concat(stack));
            stack.length = 0;
            prev_cp = cp;
          } else {
            stack.push(cp);
          }
          prev_cc = cc;
        } else {
          var composed = compose_pair(prev_cp, cp);
          if (composed >= 0) {
            prev_cp = composed;
          } else if (prev_cc == 0 && cc == 0) {
            ret.push(prev_cp);
            prev_cp = cp;
          } else {
            stack.push(cp);
            prev_cc = cc;
          }
        }
      }
    } catch (err) {
      _iterator5.e(err);
    } finally {
      _iterator5.f();
    }
    if (prev_cp >= 0) {
      ret.push.apply(ret, [prev_cp].concat(stack));
    }
    return ret;
  }

  // note: cps can be iterable
  function nfd(cps) {
    return decomposed(cps).map(unpack_cp);
  }
  function nfc(cps) {
    return composed_from_decomposed(decomposed(cps));
  }
  var HYPHEN = 0x2D;
  var STOP = 0x2E;
  var STOP_CH = '.';
  var FE0F = 0xFE0F;
  var UNIQUE_PH = 1;

  // 20230913: replace [...v] with Array_from(v) to avoid large spreads
  var Array_from = function Array_from(x) {
    return Array.from(x);
  }; // Array.from.bind(Array);

  function group_has_cp(g, cp) {
    // 20230913: keep primary and secondary distinct instead of creating valid union
    return g.P.has(cp) || g.Q.has(cp);
  }
  var Emoji = /*#__PURE__*/function (_Array) {
    function Emoji() {
      _classCallCheck(this, Emoji);
      return _callSuper(this, Emoji, arguments);
    }
    _inherits(Emoji, _Array);
    return _createClass(Emoji, [{
      key: "is_emoji",
      get: function get() {
        return true;
      } // free tagging system
    }]);
  }(/*#__PURE__*/_wrapNativeSuper(Array));
  var MAPPED, IGNORED, CM, NSM, ESCAPE, NFC_CHECK, GROUPS, WHOLE_VALID, WHOLE_MAP, VALID, EMOJI_LIST, EMOJI_ROOT;
  function init() {
    if (MAPPED) return;
    var r = read_compressed_payload(COMPRESSED$1);
    var read_sorted_array = function read_sorted_array() {
      return read_sorted(r);
    };
    var read_sorted_set = function read_sorted_set() {
      return new Set(read_sorted_array());
    };
    var set_add_many = function set_add_many(set, v) {
      return v.forEach(function (x) {
        return set.add(x);
      });
    };
    MAPPED = new Map(read_mapped(r));
    IGNORED = read_sorted_set(); // ignored characters are not valid, so just read raw codepoints

    /*
    // direct include from payload is smaller than the decompression code
    const FENCED = new Map(read_array_while(() => {
    	let cp = r();
    	if (cp) return [cp, read_str(r())];
    }));
    */
    // 20230217: we still need all CM for proper error formatting
    // but norm only needs NSM subset that are potentially-valid
    CM = read_sorted_array();
    NSM = new Set(read_sorted_array().map(function (i) {
      return CM[i];
    }));
    CM = new Set(CM);
    ESCAPE = read_sorted_set(); // characters that should not be printed
    NFC_CHECK = read_sorted_set(); // only needed to illustrate ens_tokenize() transformations

    var chunks = read_sorted_arrays(r);
    var unrestricted = r();
    //const read_chunked = () => new Set(read_sorted_array().flatMap(i => chunks[i]).concat(read_sorted_array()));
    var read_chunked = function read_chunked() {
      // 20230921: build set in parts, 2x faster
      var set = new Set();
      read_sorted_array().forEach(function (i) {
        return set_add_many(set, chunks[i]);
      });
      set_add_many(set, read_sorted_array());
      return set;
    };
    GROUPS = read_array_while(function (i) {
      // minifier property mangling seems unsafe
      // so these are manually renamed to single chars
      var N = read_array_while(r).map(function (x) {
        return x + 0x60;
      });
      if (N.length) {
        var R = i >= unrestricted; // unrestricted then restricted
        N[0] -= 32; // capitalize
        N = str_from_cps(N);
        if (R) N = "Restricted[".concat(N, "]");
        var P = read_chunked(); // primary
        var Q = read_chunked(); // secondary
        var M = !r(); // not-whitelisted, check for NSM
        // *** this code currently isn't needed ***
        /*
        let V = [...P, ...Q].sort((a, b) => a-b); // derive: sorted valid
        let M = r()-1; // number of combining mark
        if (M < 0) { // whitelisted
        	M = new Map(read_array_while(() => {
        		let i = r();
        		if (i) return [V[i-1], read_array_while(() => {
        			let v = read_array_while(r);
        			if (v.length) return v.map(x => x-1);
        		})];
        	}));
        }*/
        return {
          N: N,
          P: P,
          Q: Q,
          M: M,
          R: R
        };
      }
    });

    // decode compressed wholes
    WHOLE_VALID = read_sorted_set();
    WHOLE_MAP = new Map();
    var wholes = read_sorted_array().concat(Array_from(WHOLE_VALID)).sort(function (a, b) {
      return a - b;
    }); // must be sorted
    wholes.forEach(function (cp, i) {
      var d = r();
      var w = wholes[i] = d ? wholes[i - d] : {
        V: [],
        M: new Map()
      };
      w.V.push(cp); // add to member set
      if (!WHOLE_VALID.has(cp)) {
        WHOLE_MAP.set(cp, w); // register with whole map
      }
    });

    // compute confusable-extent complements
    // usage: WHOLE_MAP.get(cp).M.get(cp) = complement set
    var _iterator6 = _createForOfIteratorHelper(new Set(WHOLE_MAP.values())),
      _step6;
    try {
      for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
        var _step6$value = _step6.value,
          V = _step6$value.V,
          M = _step6$value.M;
        // connect all groups that have each whole character
        var recs = [];
        var _iterator10 = _createForOfIteratorHelper(V),
          _step10;
        try {
          var _loop2 = function _loop2() {
            var cp = _step10.value;
            var gs = GROUPS.filter(function (g) {
              return group_has_cp(g, cp);
            });
            var rec = recs.find(function (_ref2) {
              var G = _ref2.G;
              return gs.some(function (g) {
                return G.has(g);
              });
            });
            if (!rec) {
              rec = {
                G: new Set(),
                V: []
              };
              recs.push(rec);
            }
            rec.V.push(cp);
            set_add_many(rec.G, gs);
          };
          for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
            _loop2();
          }
          // per character cache groups which are not a member of the extent
        } catch (err) {
          _iterator10.e(err);
        } finally {
          _iterator10.f();
        }
        var union = recs.flatMap(function (x) {
          return Array_from(x.G);
        }); // all of the groups used by this whole
        var _loop = function _loop() {
          var _recs$_i = _recs[_i2],
            G = _recs$_i.G,
            V = _recs$_i.V;
          var complement = new Set(union.filter(function (g) {
            return !G.has(g);
          })); // groups not covered by the extent
          var _iterator11 = _createForOfIteratorHelper(V),
            _step11;
          try {
            for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
              var cp = _step11.value;
              M.set(cp, complement); // this is the same reference
            }
          } catch (err) {
            _iterator11.e(err);
          } finally {
            _iterator11.f();
          }
        };
        for (var _i2 = 0, _recs = recs; _i2 < _recs.length; _i2++) {
          _loop();
        }
      }

      // compute valid set
      // 20230924: VALID was union but can be re-used
    } catch (err) {
      _iterator6.e(err);
    } finally {
      _iterator6.f();
    }
    VALID = new Set(); // exists in 1+ groups
    var multi = new Set(); // exists in 2+ groups
    var add_to_union = function add_to_union(cp) {
      return VALID.has(cp) ? multi.add(cp) : VALID.add(cp);
    };
    var _iterator7 = _createForOfIteratorHelper(GROUPS),
      _step7;
    try {
      for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
        var g = _step7.value;
        var _iterator12 = _createForOfIteratorHelper(g.P),
          _step12;
        try {
          for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
            var cp = _step12.value;
            add_to_union(cp);
          }
        } catch (err) {
          _iterator12.e(err);
        } finally {
          _iterator12.f();
        }
        var _iterator13 = _createForOfIteratorHelper(g.Q),
          _step13;
        try {
          for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {
            var _cp = _step13.value;
            add_to_union(_cp);
          }
        } catch (err) {
          _iterator13.e(err);
        } finally {
          _iterator13.f();
        }
      }
      // dual purpose WHOLE_MAP: return placeholder if unique non-confusable
    } catch (err) {
      _iterator7.e(err);
    } finally {
      _iterator7.f();
    }
    var _iterator8 = _createForOfIteratorHelper(VALID),
      _step8;
    try {
      for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
        var _cp2 = _step8.value;
        if (!WHOLE_MAP.has(_cp2) && !multi.has(_cp2)) {
          WHOLE_MAP.set(_cp2, UNIQUE_PH);
        }
      }
      // add all decomposed parts
      // see derive: "Valid is Closed (via Brute-force)"
    } catch (err) {
      _iterator8.e(err);
    } finally {
      _iterator8.f();
    }
    set_add_many(VALID, nfd(VALID));

    // decode emoji
    // 20230719: emoji are now fully-expanded to avoid quirk logic 
    EMOJI_LIST = read_trie(r).map(function (v) {
      return Emoji.from(v);
    }).sort(compare_arrays);
    EMOJI_ROOT = new Map(); // this has approx 7K nodes (2+ per emoji)
    var _iterator9 = _createForOfIteratorHelper(EMOJI_LIST),
      _step9;
    try {
      for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
        var cps = _step9.value;
        // 20230719: change to *slightly* stricter algorithm which disallows 
        // insertion of misplaced FE0F in emoji sequences (matching ENSIP-15)
        // example: beautified [A B] (eg. flag emoji) 
        //  before: allow: [A FE0F B], error: [A FE0F FE0F B] 
        //   after: error: both
        // note: this code now matches ENSNormalize.{cs,java} logic
        var prev = [EMOJI_ROOT];
        var _iterator14 = _createForOfIteratorHelper(cps),
          _step14;
        try {
          var _loop3 = function _loop3() {
            var cp = _step14.value;
            var next = prev.map(function (node) {
              var child = node.get(cp);
              if (!child) {
                // should this be object? 
                // (most have 1-2 items, few have many)
                // 20230719: no, v8 default map is 4?
                child = new Map();
                node.set(cp, child);
              }
              return child;
            });
            if (cp === FE0F) {
              var _prev;
              (_prev = prev).push.apply(_prev, _toConsumableArray(next)); // less than 20 elements
            } else {
              prev = next;
            }
          };
          for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {
            _loop3();
          }
        } catch (err) {
          _iterator14.e(err);
        } finally {
          _iterator14.f();
        }
        var _iterator15 = _createForOfIteratorHelper(prev),
          _step15;
        try {
          for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {
            var x = _step15.value;
            x.V = cps;
          }
        } catch (err) {
          _iterator15.e(err);
        } finally {
          _iterator15.f();
        }
      }
    } catch (err) {
      _iterator9.e(err);
    } finally {
      _iterator9.f();
    }
  }

  // if escaped: {HEX}
  //       else: "x" {HEX}
  function quoted_cp(cp) {
    return (should_escape(cp) ? '' : "".concat(bidi_qq(safe_str_from_cps([cp])), " ")) + quote_cp(cp);
  }

  // 20230211: some messages can be mixed-directional and result in spillover
  // use 200E after a quoted string to force the remainder of a string from 
  // acquring the direction of the quote
  // https://www.w3.org/International/questions/qa-bidi-unicode-controls#exceptions
  function bidi_qq(s) {
    return "\"".concat(s, "\"\u200E"); // strong LTR
  }
  function check_label_extension(cps) {
    if (cps.length >= 4 && cps[2] == HYPHEN && cps[3] == HYPHEN) {
      throw new Error("invalid label extension: \"".concat(str_from_cps(cps.slice(0, 4)), "\"")); // this can only be ascii so cant be bidi
    }
  }
  function check_leading_underscore(cps) {
    var UNDERSCORE = 0x5F;
    for (var i = cps.lastIndexOf(UNDERSCORE); i > 0;) {
      if (cps[--i] !== UNDERSCORE) {
        throw new Error('underscore allowed only at start');
      }
    }
  }
  // check that a fenced cp is not leading, trailing, or touching another fenced cp
  function check_fenced(cps) {
    var cp = cps[0];
    var prev = FENCED.get(cp);
    if (prev) throw error_placement("leading ".concat(prev));
    var n = cps.length;
    var last = -1; // prevents trailing from throwing
    for (var i = 1; i < n; i++) {
      cp = cps[i];
      var match = FENCED.get(cp);
      if (match) {
        // since cps[0] isn't fenced, cps[1] cannot throw
        if (last == i) throw error_placement("".concat(prev, " + ").concat(match));
        last = i + 1;
        prev = match;
      }
    }
    if (last == n) throw error_placement("trailing ".concat(prev));
  }

  // create a safe to print string 
  // invisibles are escaped
  // leading cm uses placeholder
  // if cps exceed max, middle truncate with ellipsis
  // quoter(cp) => string, eg. 3000 => "{3000}"
  // note: in html, you'd call this function then replace [<>&] with entities
  function safe_str_from_cps(cps) {
    var max = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Infinity;
    var quoter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : quote_cp;
    //if (Number.isInteger(cps)) cps = [cps];
    //if (!Array.isArray(cps)) throw new TypeError(`expected codepoints`);
    var buf = [];
    if (is_combining_mark(cps[0])) buf.push('');
    if (cps.length > max) {
      max >>= 1;
      cps = [].concat(_toConsumableArray(cps.slice(0, max)), [0x2026], _toConsumableArray(cps.slice(-max)));
    }
    var prev = 0;
    var n = cps.length;
    for (var i = 0; i < n; i++) {
      var cp = cps[i];
      if (should_escape(cp)) {
        buf.push(str_from_cps(cps.slice(prev, i)));
        buf.push(quoter(cp));
        prev = i + 1;
      }
    }
    buf.push(str_from_cps(cps.slice(prev, n)));
    return buf.join('');
  }

  // note: set(s) cannot be exposed because they can be modified
  // note: Object.freeze() doesn't work
  function is_combining_mark(cp) {
    init();
    return CM.has(cp);
  }
  function should_escape(cp) {
    init();
    return ESCAPE.has(cp);
  }

  // return all supported emoji as fully-qualified emoji 
  // ordered by length then lexicographic 
  function ens_emoji() {
    init();
    return EMOJI_LIST.map(function (x) {
      return x.slice();
    }); // emoji are exposed so copy
  }
  function ens_normalize_fragment(frag, decompose) {
    init();
    var nf = decompose ? nfd : nfc;
    return frag.split(STOP_CH).map(function (label) {
      return str_from_cps(tokens_from_str(explode_cp(label), nf, filter_fe0f).flat());
    }).join(STOP_CH);
  }
  function ens_normalize(name) {
    return flatten(split(name, nfc, filter_fe0f));
  }
  function ens_beautify(name) {
    var labels = split(name, nfc, function (x) {
      return x;
    }); // emoji not exposed
    var _iterator16 = _createForOfIteratorHelper(labels),
      _step16;
    try {
      for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {
        var _step16$value = _step16.value,
          type = _step16$value.type,
          output = _step16$value.output,
          error = _step16$value.error;
        if (error) break; // flatten will throw

        // replace leading/trailing hyphen
        // 20230121: consider beautifing all or leading/trailing hyphen to unicode variant
        // not exactly the same in every font, but very similar: "-" vs ""
        /*
        const UNICODE_HYPHEN = 0x2010;
        // maybe this should replace all for visual consistancy?
        // `node tools/reg-count.js regex ^-\{2,\}` => 592
        //for (let i = 0; i < output.length; i++) if (output[i] == 0x2D) output[i] = 0x2010;
        if (output[0] == HYPHEN) output[0] = UNICODE_HYPHEN;
        let end = output.length-1;
        if (output[end] == HYPHEN) output[end] = UNICODE_HYPHEN;
        */
        // 20230123: WHATWG URL uses "CheckHyphens" false
        // https://url.spec.whatwg.org/#idna

        // update ethereum symbol
        //  =>  if not greek
        if (type !== 'Greek') array_replace(output, 0x3BE, 0x39E);

        // 20221213: fixes bidi subdomain issue, but breaks invariant (200E is disallowed)
        // could be fixed with special case for: 2D (.) + 200E (LTR)
        // https://discuss.ens.domains/t/bidi-label-ordering-spoof/15824
        //output.splice(0, 0, 0x200E);
      }
    } catch (err) {
      _iterator16.e(err);
    } finally {
      _iterator16.f();
    }
    return flatten(labels);
  }
  function array_replace(v, a, b) {
    var prev = 0;
    while (true) {
      var next = v.indexOf(a, prev);
      if (next < 0) break;
      v[next] = b;
      prev = next + 1;
    }
  }
  function ens_split(name, preserve_emoji) {
    return split(name, nfc, preserve_emoji ? function (x) {
      return x.slice();
    } : filter_fe0f); // emoji are exposed so copy
  }
  function split(name, nf, ef) {
    if (!name) return []; // 20230719: empty name allowance
    init();
    var offset = 0;
    // https://unicode.org/reports/tr46/#Validity_Criteria
    // 4.) "The label must not contain a U+002E ( . ) FULL STOP."
    return name.split(STOP_CH).map(function (label) {
      var input = explode_cp(label);
      var info = {
        input: input,
        offset: offset // codepoint, not substring!
      };
      offset += input.length + 1; // + stop
      try {
        // 1.) "The label must be in Unicode Normalization Form NFC"
        var tokens = info.tokens = tokens_from_str(input, nf, ef);
        var token_count = tokens.length;
        var type;
        if (!token_count) {
          // the label was effectively empty (could of had ignored characters)
          //norm = [];
          //type = 'None'; // use this instead of next match, "ASCII"
          // 20230120: change to strict
          // https://discuss.ens.domains/t/ens-name-normalization-2nd/14564/59
          throw new Error("empty label");
        }
        var norm = info.output = tokens.flat();
        check_leading_underscore(norm);
        var emoji = info.emoji = token_count > 1 || tokens[0].is_emoji; // same as: tokens.some(x => x.is_emoji);
        if (!emoji && norm.every(function (cp) {
          return cp < 0x80;
        })) {
          // special case for ascii
          // 20230123: matches matches WHATWG, see note 3.3
          check_label_extension(norm); // only needed for ascii
          // cant have fenced
          // cant have cm
          // cant have wholes
          // see derive: "Fastpath ASCII"
          type = 'ASCII';
        } else {
          var chars = tokens.flatMap(function (x) {
            return x.is_emoji ? [] : x;
          }); // all of the nfc tokens concat together
          if (!chars.length) {
            // theres no text, just emoji
            type = 'Emoji';
          } else {
            // 5.) "The label must not begin with a combining mark, that is: General_Category=Mark."
            if (CM.has(norm[0])) throw error_placement('leading combining mark');
            for (var i = 1; i < token_count; i++) {
              // we've already checked the first token
              var cps = tokens[i];
              if (!cps.is_emoji && CM.has(cps[0])) {
                // every text token has emoji neighbors, eg. EtEEEtEt...
                // bidi_qq() not needed since emoji is LTR and cps is a CM
                throw error_placement("emoji + combining mark: \"".concat(str_from_cps(tokens[i - 1]), " + ").concat(safe_str_from_cps([cps[0]]), "\""));
              }
            }
            check_fenced(norm);
            var unique = Array_from(new Set(chars));
            var _determine_group = determine_group(unique),
              _determine_group2 = _slicedToArray(_determine_group, 1),
              g = _determine_group2[0]; // take the first match
            // see derive: "Matching Groups have Same CM Style"
            // alternative: could form a hybrid type: Latin/Japanese/...	
            check_group(g, chars); // need text in order
            check_whole(g, unique); // only need unique text (order would be required for multiple-char confusables)
            type = g.N;
            // 20230121: consider exposing restricted flag
            // it's simpler to just check for 'Restricted'
            // or even better: type.endsWith(']')
            //if (g.R) info.restricted = true;
          }
        }
        info.type = type;
      } catch (err) {
        info.error = err; // use full error object
      }
      return info;
    });
  }
  function check_whole(group, unique) {
    var maker;
    var shared = [];
    var _iterator17 = _createForOfIteratorHelper(unique),
      _step17;
    try {
      var _loop5 = function _loop5() {
          var cp = _step17.value;
          var whole = WHOLE_MAP.get(cp);
          if (whole === UNIQUE_PH) return {
            v: void 0
          }; // unique, non-confusable
          if (whole) {
            var set = whole.M.get(cp); // groups which have a character that look-like this character
            maker = maker ? maker.filter(function (g) {
              return set.has(g);
            }) : Array_from(set);
            if (!maker.length) return {
              v: void 0
            }; // confusable intersection is empty
          } else {
            shared.push(cp);
          }
        },
        _ret;
      for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {
        _ret = _loop5();
        if (_ret) return _ret.v;
      }
    } catch (err) {
      _iterator17.e(err);
    } finally {
      _iterator17.f();
    }
    if (maker) {
      // we have 1+ confusable
      // check if any of the remaining groups
      // contain the shared characters too
      var _iterator18 = _createForOfIteratorHelper(maker),
        _step18;
      try {
        var _loop4 = function _loop4() {
          var g = _step18.value;
          if (shared.every(function (cp) {
            return group_has_cp(g, cp);
          })) {
            throw new Error("whole-script confusable: ".concat(group.N, "/").concat(g.N));
          }
        };
        for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {
          _loop4();
        }
      } catch (err) {
        _iterator18.e(err);
      } finally {
        _iterator18.f();
      }
    }
  }

  // assumption: unique.size > 0
  // returns list of matching groups
  function determine_group(unique) {
    var groups = GROUPS;
    var _iterator19 = _createForOfIteratorHelper(unique),
      _step19;
    try {
      var _loop6 = function _loop6() {
        var cp = _step19.value;
        // note: we need to dodge CM that are whitelisted
        // but that code isn't currently necessary
        var gs = groups.filter(function (g) {
          return group_has_cp(g, cp);
        });
        if (!gs.length) {
          if (!GROUPS.some(function (g) {
            return group_has_cp(g, cp);
          })) {
            // the character was composed of valid parts
            // but it's NFC form is invalid
            // 20230716: change to more exact statement, see: ENSNormalize.{cs,java}
            // note: this doesn't have to be a composition
            // 20230720: change to full check
            throw error_disallowed(cp); // this should be rare
          } else {
            // there is no group that contains all these characters
            // throw using the highest priority group that matched
            // https://www.unicode.org/reports/tr39/#mixed_script_confusables
            throw error_group_member(groups[0], cp);
          }
        }
        groups = gs;
        if (gs.length == 1) return 1; // break
        // there is only one group left
      };
      for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {
        if (_loop6()) break;
      }
      // there are at least 1 group(s) with all of these characters
    } catch (err) {
      _iterator19.e(err);
    } finally {
      _iterator19.f();
    }
    return groups;
  }

  // throw on first error
  function flatten(split) {
    return split.map(function (_ref3) {
      var input = _ref3.input,
        error = _ref3.error,
        output = _ref3.output;
      if (error) {
        // don't print label again if just a single label
        var msg = error.message;
        // bidi_qq() only necessary if msg is digits
        throw new Error(split.length == 1 ? msg : "Invalid label ".concat(bidi_qq(safe_str_from_cps(input, 63)), ": ").concat(msg));
      }
      return str_from_cps(output);
    }).join(STOP_CH);
  }
  function error_disallowed(cp) {
    // TODO: add cp to error?
    return new Error("disallowed character: ".concat(quoted_cp(cp)));
  }
  function error_group_member(g, cp) {
    var quoted = quoted_cp(cp);
    var gg = GROUPS.find(function (g) {
      return g.P.has(cp);
    }); // only check primary
    if (gg) {
      quoted = "".concat(gg.N, " ").concat(quoted);
    }
    return new Error("illegal mixture: ".concat(g.N, " + ").concat(quoted));
  }
  function error_placement(where) {
    return new Error("illegal placement: ".concat(where));
  }

  // assumption: cps.length > 0
  // assumption: cps[0] isn't a CM
  // assumption: the previous character isn't an emoji
  function check_group(g, cps) {
    var _iterator20 = _createForOfIteratorHelper(cps),
      _step20;
    try {
      for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {
        var _cp3 = _step20.value;
        if (!group_has_cp(g, _cp3)) {
          // for whitelisted scripts, this will throw illegal mixture on invalid cm, eg. "e{300}{300}"
          // at the moment, it's unnecessary to introduce an extra error type
          // until there exists a whitelisted multi-character
          //   eg. if (M < 0 && is_combining_mark(cp)) { ... }
          // there are 3 cases:
          //   1. illegal cm for wrong group => mixture error
          //   2. illegal cm for same group => cm error
          //       requires set of whitelist cm per group: 
          //        eg. new Set([...g.P, ...g.Q].flatMap(nfc).filter(cp => CM.has(cp)))
          //   3. wrong group => mixture error
          throw error_group_member(g, _cp3);
        }
      }
      //if (M >= 0) { // we have a known fixed cm count
    } catch (err) {
      _iterator20.e(err);
    } finally {
      _iterator20.f();
    }
    if (g.M) {
      // we need to check for NSM
      var _decomposed = nfd(cps);
      for (var i = 1, e = _decomposed.length; i < e; i++) {
        // see: assumption
        // 20230210: bugfix: using cps instead of decomposed h/t Carbon225
        /*
        if (CM.has(decomposed[i])) {
        	let j = i + 1;
        	while (j < e && CM.has(decomposed[j])) j++;
        	if (j - i > M) {
        		throw new Error(`too many combining marks: ${g.N} ${bidi_qq(str_from_cps(decomposed.slice(i-1, j)))} (${j-i}/${M})`);
        	}
        	i = j;
        }
        */
        // 20230217: switch to NSM counting
        // https://www.unicode.org/reports/tr39/#Optional_Detection
        if (NSM.has(_decomposed[i])) {
          var j = i + 1;
          for (var cp; j < e && NSM.has(cp = _decomposed[j]); j++) {
            // a. Forbid sequences of the same nonspacing mark.
            for (var k = i; k < j; k++) {
              // O(n^2) but n < 100
              if (_decomposed[k] == cp) {
                throw new Error("duplicate non-spacing marks: ".concat(quoted_cp(cp)));
              }
            }
          }
          // parse to end so we have full nsm count
          // b. Forbid sequences of more than 4 nonspacing marks (gc=Mn or gc=Me).
          if (j - i > NSM_MAX) {
            // note: this slice starts with a base char or spacing-mark cm
            throw new Error("excessive non-spacing marks: ".concat(bidi_qq(safe_str_from_cps(_decomposed.slice(i - 1, j))), " (").concat(j - i, "/").concat(NSM_MAX, ")"));
          }
          i = j;
        }
      }
    }
    // *** this code currently isn't needed ***
    /*
    let cm_whitelist = M instanceof Map;
    for (let i = 0, e = cps.length; i < e; ) {
    	let cp = cps[i++];
    	let seqs = cm_whitelist && M.get(cp);
    	if (seqs) { 
    		// list of codepoints that can follow
    		// if this exists, this will always be 1+
    		let j = i;
    		while (j < e && CM.has(cps[j])) j++;
    		let cms = cps.slice(i, j);
    		let match = seqs.find(seq => !compare_arrays(seq, cms));
    		if (!match) throw new Error(`disallowed combining mark sequence: "${safe_str_from_cps([cp, ...cms])}"`);
    		i = j;
    	} else if (!V.has(cp)) {
    		// https://www.unicode.org/reports/tr39/#mixed_script_confusables
    		let quoted = quoted_cp(cp);
    		for (let cp of cps) {
    			let u = UNIQUE.get(cp);
    			if (u && u !== g) {
    				// if both scripts are restricted this error is confusing
    				// because we don't differentiate RestrictedA from RestrictedB 
    				if (!u.R) quoted = `${quoted} is ${u.N}`;
    				break;
    			}
    		}
    		throw new Error(`disallowed ${g.N} character: ${quoted}`);
    		//throw new Error(`disallowed character: ${quoted} (expected ${g.N})`);
    		//throw new Error(`${g.N} does not allow: ${quoted}`);
    	}
    }
    if (!cm_whitelist) {
    	let decomposed = nfd(cps);
    	for (let i = 1, e = decomposed.length; i < e; i++) { // we know it can't be cm leading
    		if (CM.has(decomposed[i])) {
    			let j = i + 1;
    			while (j < e && CM.has(decomposed[j])) j++;
    			if (j - i > M) {
    				throw new Error(`too many combining marks: "${str_from_cps(decomposed.slice(i-1, j))}" (${j-i}/${M})`);
    			}
    			i = j;
    		}
    	}
    }
    */
  }

  // given a list of codepoints
  // returns a list of lists, where emoji are a fully-qualified (as Array subclass)
  // eg. explode_cp("abcd") => [[61, 62, 63], Emoji[1F4A9, FE0F], [64]]
  // 20230818: rename for 'process' name collision h/t Javarome
  // https://github.com/adraffy/ens-normalize.js/issues/23
  function tokens_from_str(input, nf, ef) {
    var ret = [];
    var chars = [];
    input = input.slice().reverse(); // flip so we can pop
    while (input.length) {
      var emoji = consume_emoji_reversed(input);
      if (emoji) {
        if (chars.length) {
          ret.push(nf(chars));
          chars = [];
        }
        ret.push(ef(emoji));
      } else {
        var cp = input.pop();
        if (VALID.has(cp)) {
          chars.push(cp);
        } else {
          var cps = MAPPED.get(cp);
          if (cps) {
            var _chars;
            (_chars = chars).push.apply(_chars, _toConsumableArray(cps)); // less than 10 elements
          } else if (!IGNORED.has(cp)) {
            // 20230912: unicode 15.1 changed the order of processing such that
            // disallowed parts are only rejected after NFC
            // https://unicode.org/reports/tr46/#Validity_Criteria
            // this doesn't impact normalization as of today
            // technically, this error can be removed as the group logic will apply similar logic
            // however the error type might be less clear
            throw error_disallowed(cp);
          }
        }
      }
    }
    if (chars.length) {
      ret.push(nf(chars));
    }
    return ret;
  }
  function filter_fe0f(cps) {
    return cps.filter(function (cp) {
      return cp != FE0F;
    });
  }

  // given array of codepoints
  // returns the longest valid emoji sequence (or undefined if no match)
  // *MUTATES* the supplied array
  // disallows interleaved ignored characters
  // fills (optional) eaten array with matched codepoints
  function consume_emoji_reversed(cps, eaten) {
    var node = EMOJI_ROOT;
    var emoji;
    var pos = cps.length;
    while (pos) {
      node = node.get(cps[--pos]);
      if (!node) break;
      var _node = node,
        V = _node.V;
      if (V) {
        // this is a valid emoji (so far)
        emoji = V;
        if (eaten) eaten.push.apply(eaten, _toConsumableArray(cps.slice(pos).reverse())); // (optional) copy input, used for ens_tokenize()
        cps.length = pos; // truncate
      }
    }
    return emoji;
  }

  // ************************************************************
  // tokenizer 

  var TY_VALID = 'valid';
  var TY_MAPPED = 'mapped';
  var TY_IGNORED = 'ignored';
  var TY_DISALLOWED = 'disallowed';
  var TY_EMOJI = 'emoji';
  var TY_NFC = 'nfc';
  var TY_STOP = 'stop';
  function ens_tokenize(name) {
    var _ref4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref4$nf = _ref4.nf,
      nf = _ref4$nf === void 0 ? true : _ref4$nf;
    init();
    var input = explode_cp(name).reverse();
    var eaten = [];
    var tokens = [];
    while (input.length) {
      var emoji = consume_emoji_reversed(input, eaten);
      if (emoji) {
        tokens.push({
          type: TY_EMOJI,
          emoji: emoji.slice(),
          // copy emoji
          input: eaten,
          cps: filter_fe0f(emoji)
        });
        eaten = []; // reset buffer
      } else {
        var cp = input.pop();
        if (cp == STOP) {
          tokens.push({
            type: TY_STOP,
            cp: cp
          });
        } else if (VALID.has(cp)) {
          tokens.push({
            type: TY_VALID,
            cps: [cp]
          });
        } else if (IGNORED.has(cp)) {
          tokens.push({
            type: TY_IGNORED,
            cp: cp
          });
        } else {
          var cps = MAPPED.get(cp);
          if (cps) {
            tokens.push({
              type: TY_MAPPED,
              cp: cp,
              cps: cps.slice()
            });
          } else {
            tokens.push({
              type: TY_DISALLOWED,
              cp: cp
            });
          }
        }
      }
    }
    if (nf) {
      for (var i = 0, start = -1; i < tokens.length; i++) {
        var token = tokens[i];
        if (is_valid_or_mapped(token.type)) {
          if (requires_check(token.cps)) {
            // normalization might be needed
            var end = i + 1;
            for (var pos = end; pos < tokens.length; pos++) {
              // find adjacent text
              var _tokens$pos = tokens[pos],
                type = _tokens$pos.type,
                _cps2 = _tokens$pos.cps;
              if (is_valid_or_mapped(type)) {
                if (!requires_check(_cps2)) break;
                end = pos + 1;
              } else if (type !== TY_IGNORED) {
                // || type !== TY_DISALLOWED) { 
                break;
              }
            }
            if (start < 0) start = i;
            var slice = tokens.slice(start, end);
            var cps0 = slice.flatMap(function (x) {
              return is_valid_or_mapped(x.type) ? x.cps : [];
            }); // strip junk tokens
            var _cps3 = nfc(cps0);
            if (compare_arrays(_cps3, cps0)) {
              // bundle into an nfc token
              tokens.splice(start, end - start, {
                type: TY_NFC,
                input: cps0,
                // there are 3 states: tokens0 ==(process)=> input ==(nfc)=> tokens/cps
                cps: _cps3,
                tokens0: collapse_valid_tokens(slice),
                tokens: ens_tokenize(str_from_cps(_cps3), {
                  nf: false
                })
              });
              i = start;
            } else {
              i = end - 1; // skip to end of slice
            }
            start = -1; // reset
          } else {
            start = i; // remember last
          }
        } else if (token.type !== TY_IGNORED) {
          // 20221024: is this correct?
          start = -1; // reset
        }
      }
    }
    return collapse_valid_tokens(tokens);
  }
  function is_valid_or_mapped(type) {
    return type == TY_VALID || type == TY_MAPPED;
  }
  function requires_check(cps) {
    return cps.some(function (cp) {
      return NFC_CHECK.has(cp);
    });
  }
  function collapse_valid_tokens(tokens) {
    for (var i = 0; i < tokens.length; i++) {
      if (tokens[i].type == TY_VALID) {
        var j = i + 1;
        while (j < tokens.length && tokens[j].type == TY_VALID) j++;
        tokens.splice(i, j - i, {
          type: TY_VALID,
          cps: tokens.slice(i, j).flatMap(function (x) {
            return x.cps;
          })
        });
      }
    }
    return tokens;
  }
  dist.ens_beautify = ens_beautify;
  dist.ens_emoji = ens_emoji;
  dist.ens_normalize = ens_normalize;
  dist.ens_normalize_fragment = ens_normalize_fragment;
  dist.ens_split = ens_split;
  dist.ens_tokenize = ens_tokenize;
  dist.is_combining_mark = is_combining_mark;
  dist.nfc = nfc;
  dist.nfd = nfd;
  dist.safe_str_from_cps = safe_str_from_cps;
  dist.should_escape = should_escape;
  return dist;
}

var hasRequiredNamehash;
function requireNamehash() {
  if (hasRequiredNamehash) return namehash;
  hasRequiredNamehash = 1;
  Object.defineProperty(namehash, "__esModule", {
    value: true
  });
  namehash.dnsEncode = namehash.namehash = namehash.isValidName = namehash.ensNormalize = void 0;
  var index_js_1 = /*@__PURE__*/requireCrypto();
  var index_js_2 = /*@__PURE__*/requireUtils$3();
  var ens_normalize_1 = requireDist();
  var Zeros = new Uint8Array(32);
  Zeros.fill(0);
  function checkComponent(comp) {
    (0, index_js_2.assertArgument)(comp.length !== 0, "invalid ENS name; empty component", "comp", comp);
    return comp;
  }
  function ensNameSplit(name) {
    var bytes = (0, index_js_2.toUtf8Bytes)(ensNormalize(name));
    var comps = [];
    if (name.length === 0) {
      return comps;
    }
    var last = 0;
    for (var i = 0; i < bytes.length; i++) {
      var d = bytes[i];
      // A separator (i.e. "."); copy this component
      if (d === 0x2e) {
        comps.push(checkComponent(bytes.slice(last, i)));
        last = i + 1;
      }
    }
    // There was a stray separator at the end of the name
    (0, index_js_2.assertArgument)(last < bytes.length, "invalid ENS name; empty component", "name", name);
    comps.push(checkComponent(bytes.slice(last)));
    return comps;
  }
  /**
   *  Returns the ENS %%name%% normalized.
   */
  function ensNormalize(name) {
    try {
      if (name.length === 0) {
        throw new Error("empty label");
      }
      return (0, ens_normalize_1.ens_normalize)(name);
    } catch (error) {
      (0, index_js_2.assertArgument)(false, "invalid ENS name (".concat(error.message, ")"), "name", name);
    }
  }
  namehash.ensNormalize = ensNormalize;
  /**
   *  Returns ``true`` if %%name%% is a valid ENS name.
   */
  function isValidName(name) {
    try {
      return ensNameSplit(name).length !== 0;
    } catch (error) {}
    return false;
  }
  namehash.isValidName = isValidName;
  /**
   *  Returns the [[link-namehash]] for %%name%%.
   */
  function namehash$1(name) {
    (0, index_js_2.assertArgument)(typeof name === "string", "invalid ENS name; not a string", "name", name);
    (0, index_js_2.assertArgument)(name.length, "invalid ENS name (empty label)", "name", name);
    var result = Zeros;
    var comps = ensNameSplit(name);
    while (comps.length) {
      result = (0, index_js_1.keccak256)((0, index_js_2.concat)([result, (0, index_js_1.keccak256)(comps.pop())]));
    }
    return (0, index_js_2.hexlify)(result);
  }
  namehash.namehash = namehash$1;
  /**
   *  Returns the DNS encoded %%name%%.
   *
   *  This is used for various parts of ENS name resolution, such
   *  as the wildcard resolution.
   */
  function dnsEncode(name, _maxLength) {
    var length = _maxLength != null ? _maxLength : 63;
    (0, index_js_2.assertArgument)(length <= 255, "DNS encoded label cannot exceed 255", "length", length);
    return (0, index_js_2.hexlify)((0, index_js_2.concat)(ensNameSplit(name).map(function (comp) {
      (0, index_js_2.assertArgument)(comp.length <= length, "label ".concat(JSON.stringify(name), " exceeds ").concat(length, " bytes"), "name", name);
      var bytes = new Uint8Array(comp.length + 1);
      bytes.set(comp, 1);
      bytes[0] = bytes.length - 1;
      return bytes;
    }))) + "00";
  }
  namehash.dnsEncode = dnsEncode;
  return namehash;
}

var message = {};

var transaction$1 = {};

var accesslist = {};

var hasRequiredAccesslist;
function requireAccesslist() {
  if (hasRequiredAccesslist) return accesslist;
  hasRequiredAccesslist = 1;
  Object.defineProperty(accesslist, "__esModule", {
    value: true
  });
  accesslist.accessListify = void 0;
  var index_js_1 = /*@__PURE__*/requireAddress$2();
  var index_js_2 = /*@__PURE__*/requireUtils$3();
  function accessSetify(addr, storageKeys) {
    return {
      address: (0, index_js_1.getAddress)(addr),
      storageKeys: storageKeys.map(function (storageKey, index) {
        (0, index_js_2.assertArgument)((0, index_js_2.isHexString)(storageKey, 32), "invalid slot", "storageKeys[".concat(index, "]"), storageKey);
        return storageKey.toLowerCase();
      })
    };
  }
  /**
   *  Returns a [[AccessList]] from any ethers-supported access-list structure.
   */
  function accessListify(value) {
    if (Array.isArray(value)) {
      return value.map(function (set, index) {
        if (Array.isArray(set)) {
          (0, index_js_2.assertArgument)(set.length === 2, "invalid slot set", "value[".concat(index, "]"), set);
          return accessSetify(set[0], set[1]);
        }
        (0, index_js_2.assertArgument)(set != null && _typeof(set) === "object", "invalid address-slot set", "value", value);
        return accessSetify(set.address, set.storageKeys);
      });
    }
    (0, index_js_2.assertArgument)(value != null && _typeof(value) === "object", "invalid access list", "value", value);
    var result = Object.keys(value).map(function (addr) {
      var storageKeys = value[addr].reduce(function (accum, storageKey) {
        accum[storageKey] = true;
        return accum;
      }, {});
      return accessSetify(addr, Object.keys(storageKeys).sort());
    });
    result.sort(function (a, b) {
      return a.address.localeCompare(b.address);
    });
    return result;
  }
  accesslist.accessListify = accessListify;
  return accesslist;
}

var address = {};

var hasRequiredAddress;
function requireAddress() {
  if (hasRequiredAddress) return address;
  hasRequiredAddress = 1;
  Object.defineProperty(address, "__esModule", {
    value: true
  });
  address.recoverAddress = address.computeAddress = void 0;
  var index_js_1 = /*@__PURE__*/requireAddress$2();
  var index_js_2 = /*@__PURE__*/requireCrypto();
  /**
   *  Returns the address for the %%key%%.
   *
   *  The key may be any standard form of public key or a private key.
   */
  function computeAddress(key) {
    var pubkey;
    if (typeof key === "string") {
      pubkey = index_js_2.SigningKey.computePublicKey(key, false);
    } else {
      pubkey = key.publicKey;
    }
    return (0, index_js_1.getAddress)((0, index_js_2.keccak256)("0x" + pubkey.substring(4)).substring(26));
  }
  address.computeAddress = computeAddress;
  /**
   *  Returns the recovered address for the private key that was
   *  used to sign %%digest%% that resulted in %%signature%%.
   */
  function recoverAddress(digest, signature) {
    return computeAddress(index_js_2.SigningKey.recoverPublicKey(digest, signature));
  }
  address.recoverAddress = recoverAddress;
  return address;
}

var transaction = {};

var hasRequiredTransaction$1;
function requireTransaction$1() {
  if (hasRequiredTransaction$1) return transaction;
  hasRequiredTransaction$1 = 1;
  Object.defineProperty(transaction, "__esModule", {
    value: true
  });
  transaction.Transaction = void 0;
  var index_js_1 = /*@__PURE__*/requireAddress$2();
  var addresses_js_1 = /*@__PURE__*/requireAddresses();
  var index_js_2 = /*@__PURE__*/requireCrypto();
  var index_js_3 = /*@__PURE__*/requireUtils$3();
  var accesslist_js_1 = /*@__PURE__*/requireAccesslist();
  var address_js_1 = /*@__PURE__*/requireAddress();
  var BN_0 = BigInt(0);
  var BN_2 = BigInt(2);
  var BN_27 = BigInt(27);
  var BN_28 = BigInt(28);
  var BN_35 = BigInt(35);
  var BN_MAX_UINT = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
  var BLOB_SIZE = 4096 * 32;
  function getVersionedHash(version, hash) {
    var versioned = version.toString(16);
    while (versioned.length < 2) {
      versioned = "0" + versioned;
    }
    versioned += (0, index_js_2.sha256)(hash).substring(4);
    return "0x" + versioned;
  }
  function handleAddress(value) {
    if (value === "0x") {
      return null;
    }
    return (0, index_js_1.getAddress)(value);
  }
  function handleAccessList(value, param) {
    try {
      return (0, accesslist_js_1.accessListify)(value);
    } catch (error) {
      (0, index_js_3.assertArgument)(false, error.message, param, value);
    }
  }
  function handleNumber(_value, param) {
    if (_value === "0x") {
      return 0;
    }
    return (0, index_js_3.getNumber)(_value, param);
  }
  function handleUint(_value, param) {
    if (_value === "0x") {
      return BN_0;
    }
    var value = (0, index_js_3.getBigInt)(_value, param);
    (0, index_js_3.assertArgument)(value <= BN_MAX_UINT, "value exceeds uint size", param, value);
    return value;
  }
  function formatNumber(_value, name) {
    var value = (0, index_js_3.getBigInt)(_value, "value");
    var result = (0, index_js_3.toBeArray)(value);
    (0, index_js_3.assertArgument)(result.length <= 32, "value too large", "tx.".concat(name), value);
    return result;
  }
  function formatAccessList(value) {
    return (0, accesslist_js_1.accessListify)(value).map(function (set) {
      return [set.address, set.storageKeys];
    });
  }
  function formatHashes(value, param) {
    (0, index_js_3.assertArgument)(Array.isArray(value), "invalid ".concat(param), "value", value);
    for (var i = 0; i < value.length; i++) {
      (0, index_js_3.assertArgument)((0, index_js_3.isHexString)(value[i], 32), "invalid ${ param } hash", "value[".concat(i, "]"), value[i]);
    }
    return value;
  }
  function _parseLegacy(data) {
    var fields = (0, index_js_3.decodeRlp)(data);
    (0, index_js_3.assertArgument)(Array.isArray(fields) && (fields.length === 9 || fields.length === 6), "invalid field count for legacy transaction", "data", data);
    var tx = {
      type: 0,
      nonce: handleNumber(fields[0], "nonce"),
      gasPrice: handleUint(fields[1], "gasPrice"),
      gasLimit: handleUint(fields[2], "gasLimit"),
      to: handleAddress(fields[3]),
      value: handleUint(fields[4], "value"),
      data: (0, index_js_3.hexlify)(fields[5]),
      chainId: BN_0
    };
    // Legacy unsigned transaction
    if (fields.length === 6) {
      return tx;
    }
    var v = handleUint(fields[6], "v");
    var r = handleUint(fields[7], "r");
    var s = handleUint(fields[8], "s");
    if (r === BN_0 && s === BN_0) {
      // EIP-155 unsigned transaction
      tx.chainId = v;
    } else {
      // Compute the EIP-155 chain ID (or 0 for legacy)
      var chainId = (v - BN_35) / BN_2;
      if (chainId < BN_0) {
        chainId = BN_0;
      }
      tx.chainId = chainId;
      // Signed Legacy Transaction
      (0, index_js_3.assertArgument)(chainId !== BN_0 || v === BN_27 || v === BN_28, "non-canonical legacy v", "v", fields[6]);
      tx.signature = index_js_2.Signature.from({
        r: (0, index_js_3.zeroPadValue)(fields[7], 32),
        s: (0, index_js_3.zeroPadValue)(fields[8], 32),
        v: v
      });
      //tx.hash = keccak256(data);
    }
    return tx;
  }
  function _serializeLegacy(tx, sig) {
    var fields = [formatNumber(tx.nonce, "nonce"), formatNumber(tx.gasPrice || 0, "gasPrice"), formatNumber(tx.gasLimit, "gasLimit"), tx.to || "0x", formatNumber(tx.value, "value"), tx.data];
    var chainId = BN_0;
    if (tx.chainId != BN_0) {
      // A chainId was provided; if non-zero we'll use EIP-155
      chainId = (0, index_js_3.getBigInt)(tx.chainId, "tx.chainId");
      // We have a chainId in the tx and an EIP-155 v in the signature,
      // make sure they agree with each other
      (0, index_js_3.assertArgument)(!sig || sig.networkV == null || sig.legacyChainId === chainId, "tx.chainId/sig.v mismatch", "sig", sig);
    } else if (tx.signature) {
      // No explicit chainId, but EIP-155 have a derived implicit chainId
      var legacy = tx.signature.legacyChainId;
      if (legacy != null) {
        chainId = legacy;
      }
    }
    // Requesting an unsigned transaction
    if (!sig) {
      // We have an EIP-155 transaction (chainId was specified and non-zero)
      if (chainId !== BN_0) {
        fields.push((0, index_js_3.toBeArray)(chainId));
        fields.push("0x");
        fields.push("0x");
      }
      return (0, index_js_3.encodeRlp)(fields);
    }
    // @TODO: We should probably check that tx.signature, chainId, and sig
    //        match but that logic could break existing code, so schedule
    //        this for the next major bump.
    // Compute the EIP-155 v
    var v = BigInt(27 + sig.yParity);
    if (chainId !== BN_0) {
      v = index_js_2.Signature.getChainIdV(chainId, sig.v);
    } else if (BigInt(sig.v) !== v) {
      (0, index_js_3.assertArgument)(false, "tx.chainId/sig.v mismatch", "sig", sig);
    }
    // Add the signature
    fields.push((0, index_js_3.toBeArray)(v));
    fields.push((0, index_js_3.toBeArray)(sig.r));
    fields.push((0, index_js_3.toBeArray)(sig.s));
    return (0, index_js_3.encodeRlp)(fields);
  }
  function _parseEipSignature(tx, fields) {
    var yParity;
    try {
      yParity = handleNumber(fields[0], "yParity");
      if (yParity !== 0 && yParity !== 1) {
        throw new Error("bad yParity");
      }
    } catch (error) {
      (0, index_js_3.assertArgument)(false, "invalid yParity", "yParity", fields[0]);
    }
    var r = (0, index_js_3.zeroPadValue)(fields[1], 32);
    var s = (0, index_js_3.zeroPadValue)(fields[2], 32);
    var signature = index_js_2.Signature.from({
      r: r,
      s: s,
      yParity: yParity
    });
    tx.signature = signature;
  }
  function _parseEip1559(data) {
    var fields = (0, index_js_3.decodeRlp)((0, index_js_3.getBytes)(data).slice(1));
    (0, index_js_3.assertArgument)(Array.isArray(fields) && (fields.length === 9 || fields.length === 12), "invalid field count for transaction type: 2", "data", (0, index_js_3.hexlify)(data));
    var tx = {
      type: 2,
      chainId: handleUint(fields[0], "chainId"),
      nonce: handleNumber(fields[1], "nonce"),
      maxPriorityFeePerGas: handleUint(fields[2], "maxPriorityFeePerGas"),
      maxFeePerGas: handleUint(fields[3], "maxFeePerGas"),
      gasPrice: null,
      gasLimit: handleUint(fields[4], "gasLimit"),
      to: handleAddress(fields[5]),
      value: handleUint(fields[6], "value"),
      data: (0, index_js_3.hexlify)(fields[7]),
      accessList: handleAccessList(fields[8], "accessList")
    };
    // Unsigned EIP-1559 Transaction
    if (fields.length === 9) {
      return tx;
    }
    //tx.hash = keccak256(data);
    _parseEipSignature(tx, fields.slice(9));
    return tx;
  }
  function _serializeEip1559(tx, sig) {
    var fields = [formatNumber(tx.chainId, "chainId"), formatNumber(tx.nonce, "nonce"), formatNumber(tx.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"), formatNumber(tx.maxFeePerGas || 0, "maxFeePerGas"), formatNumber(tx.gasLimit, "gasLimit"), tx.to || "0x", formatNumber(tx.value, "value"), tx.data, formatAccessList(tx.accessList || [])];
    if (sig) {
      fields.push(formatNumber(sig.yParity, "yParity"));
      fields.push((0, index_js_3.toBeArray)(sig.r));
      fields.push((0, index_js_3.toBeArray)(sig.s));
    }
    return (0, index_js_3.concat)(["0x02", (0, index_js_3.encodeRlp)(fields)]);
  }
  function _parseEip2930(data) {
    var fields = (0, index_js_3.decodeRlp)((0, index_js_3.getBytes)(data).slice(1));
    (0, index_js_3.assertArgument)(Array.isArray(fields) && (fields.length === 8 || fields.length === 11), "invalid field count for transaction type: 1", "data", (0, index_js_3.hexlify)(data));
    var tx = {
      type: 1,
      chainId: handleUint(fields[0], "chainId"),
      nonce: handleNumber(fields[1], "nonce"),
      gasPrice: handleUint(fields[2], "gasPrice"),
      gasLimit: handleUint(fields[3], "gasLimit"),
      to: handleAddress(fields[4]),
      value: handleUint(fields[5], "value"),
      data: (0, index_js_3.hexlify)(fields[6]),
      accessList: handleAccessList(fields[7], "accessList")
    };
    // Unsigned EIP-2930 Transaction
    if (fields.length === 8) {
      return tx;
    }
    //tx.hash = keccak256(data);
    _parseEipSignature(tx, fields.slice(8));
    return tx;
  }
  function _serializeEip2930(tx, sig) {
    var fields = [formatNumber(tx.chainId, "chainId"), formatNumber(tx.nonce, "nonce"), formatNumber(tx.gasPrice || 0, "gasPrice"), formatNumber(tx.gasLimit, "gasLimit"), tx.to || "0x", formatNumber(tx.value, "value"), tx.data, formatAccessList(tx.accessList || [])];
    if (sig) {
      fields.push(formatNumber(sig.yParity, "recoveryParam"));
      fields.push((0, index_js_3.toBeArray)(sig.r));
      fields.push((0, index_js_3.toBeArray)(sig.s));
    }
    return (0, index_js_3.concat)(["0x01", (0, index_js_3.encodeRlp)(fields)]);
  }
  function _parseEip4844(data) {
    var fields = (0, index_js_3.decodeRlp)((0, index_js_3.getBytes)(data).slice(1));
    var typeName = "3";
    var blobs = null;
    // Parse the network format
    if (fields.length === 4 && Array.isArray(fields[0])) {
      typeName = "3 (network format)";
      var fBlobs = fields[1],
        fCommits = fields[2],
        fProofs = fields[3];
      (0, index_js_3.assertArgument)(Array.isArray(fBlobs), "invalid network format: blobs not an array", "fields[1]", fBlobs);
      (0, index_js_3.assertArgument)(Array.isArray(fCommits), "invalid network format: commitments not an array", "fields[2]", fCommits);
      (0, index_js_3.assertArgument)(Array.isArray(fProofs), "invalid network format: proofs not an array", "fields[3]", fProofs);
      (0, index_js_3.assertArgument)(fBlobs.length === fCommits.length, "invalid network format: blobs/commitments length mismatch", "fields", fields);
      (0, index_js_3.assertArgument)(fBlobs.length === fProofs.length, "invalid network format: blobs/proofs length mismatch", "fields", fields);
      blobs = [];
      for (var i = 0; i < fields[1].length; i++) {
        blobs.push({
          data: fBlobs[i],
          commitment: fCommits[i],
          proof: fProofs[i]
        });
      }
      fields = fields[0];
    }
    (0, index_js_3.assertArgument)(Array.isArray(fields) && (fields.length === 11 || fields.length === 14), "invalid field count for transaction type: ".concat(typeName), "data", (0, index_js_3.hexlify)(data));
    var tx = {
      type: 3,
      chainId: handleUint(fields[0], "chainId"),
      nonce: handleNumber(fields[1], "nonce"),
      maxPriorityFeePerGas: handleUint(fields[2], "maxPriorityFeePerGas"),
      maxFeePerGas: handleUint(fields[3], "maxFeePerGas"),
      gasPrice: null,
      gasLimit: handleUint(fields[4], "gasLimit"),
      to: handleAddress(fields[5]),
      value: handleUint(fields[6], "value"),
      data: (0, index_js_3.hexlify)(fields[7]),
      accessList: handleAccessList(fields[8], "accessList"),
      maxFeePerBlobGas: handleUint(fields[9], "maxFeePerBlobGas"),
      blobVersionedHashes: fields[10]
    };
    if (blobs) {
      tx.blobs = blobs;
    }
    (0, index_js_3.assertArgument)(tx.to != null, "invalid address for transaction type: ".concat(typeName), "data", data);
    (0, index_js_3.assertArgument)(Array.isArray(tx.blobVersionedHashes), "invalid blobVersionedHashes: must be an array", "data", data);
    for (var _i = 0; _i < tx.blobVersionedHashes.length; _i++) {
      (0, index_js_3.assertArgument)((0, index_js_3.isHexString)(tx.blobVersionedHashes[_i], 32), "invalid blobVersionedHash at index ".concat(_i, ": must be length 32"), "data", data);
    }
    // Unsigned EIP-4844 Transaction
    if (fields.length === 11) {
      return tx;
    }
    // @TODO: Do we need to do this? This is only called internally
    // and used to verify hashes; it might save time to not do this
    //tx.hash = keccak256(concat([ "0x03", encodeRlp(fields) ]));
    _parseEipSignature(tx, fields.slice(11));
    return tx;
  }
  function _serializeEip4844(tx, sig, blobs) {
    var fields = [formatNumber(tx.chainId, "chainId"), formatNumber(tx.nonce, "nonce"), formatNumber(tx.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"), formatNumber(tx.maxFeePerGas || 0, "maxFeePerGas"), formatNumber(tx.gasLimit, "gasLimit"), tx.to || addresses_js_1.ZeroAddress, formatNumber(tx.value, "value"), tx.data, formatAccessList(tx.accessList || []), formatNumber(tx.maxFeePerBlobGas || 0, "maxFeePerBlobGas"), formatHashes(tx.blobVersionedHashes || [], "blobVersionedHashes")];
    if (sig) {
      fields.push(formatNumber(sig.yParity, "yParity"));
      fields.push((0, index_js_3.toBeArray)(sig.r));
      fields.push((0, index_js_3.toBeArray)(sig.s));
      // We have blobs; return the network wrapped format
      if (blobs) {
        return (0, index_js_3.concat)(["0x03", (0, index_js_3.encodeRlp)([fields, blobs.map(function (b) {
          return b.data;
        }), blobs.map(function (b) {
          return b.commitment;
        }), blobs.map(function (b) {
          return b.proof;
        })])]);
      }
    }
    return (0, index_js_3.concat)(["0x03", (0, index_js_3.encodeRlp)(fields)]);
  }
  /**
   *  A **Transaction** describes an operation to be executed on
   *  Ethereum by an Externally Owned Account (EOA). It includes
   *  who (the [[to]] address), what (the [[data]]) and how much (the
   *  [[value]] in ether) the operation should entail.
   *
   *  @example:
   *    tx = new Transaction()
   *    //_result:
   *
   *    tx.data = "0x1234";
   *    //_result:
   */
  var _type = /*#__PURE__*/new WeakMap();
  var _to = /*#__PURE__*/new WeakMap();
  var _data = /*#__PURE__*/new WeakMap();
  var _nonce = /*#__PURE__*/new WeakMap();
  var _gasLimit = /*#__PURE__*/new WeakMap();
  var _gasPrice = /*#__PURE__*/new WeakMap();
  var _maxPriorityFeePerGas = /*#__PURE__*/new WeakMap();
  var _maxFeePerGas = /*#__PURE__*/new WeakMap();
  var _value2 = /*#__PURE__*/new WeakMap();
  var _chainId = /*#__PURE__*/new WeakMap();
  var _sig = /*#__PURE__*/new WeakMap();
  var _accessList = /*#__PURE__*/new WeakMap();
  var _maxFeePerBlobGas = /*#__PURE__*/new WeakMap();
  var _blobVersionedHashes = /*#__PURE__*/new WeakMap();
  var _kzg = /*#__PURE__*/new WeakMap();
  var _blobs2 = /*#__PURE__*/new WeakMap();
  var _Transaction_brand = /*#__PURE__*/new WeakSet();
  var Transaction = /*#__PURE__*/function () {
    /**
     *  Creates a new Transaction with default values.
     */
    function Transaction() {
      _classCallCheck(this, Transaction);
      _classPrivateMethodInitSpec(this, _Transaction_brand);
      _classPrivateFieldInitSpec(this, _type, void 0);
      _classPrivateFieldInitSpec(this, _to, void 0);
      _classPrivateFieldInitSpec(this, _data, void 0);
      _classPrivateFieldInitSpec(this, _nonce, void 0);
      _classPrivateFieldInitSpec(this, _gasLimit, void 0);
      _classPrivateFieldInitSpec(this, _gasPrice, void 0);
      _classPrivateFieldInitSpec(this, _maxPriorityFeePerGas, void 0);
      _classPrivateFieldInitSpec(this, _maxFeePerGas, void 0);
      _classPrivateFieldInitSpec(this, _value2, void 0);
      _classPrivateFieldInitSpec(this, _chainId, void 0);
      _classPrivateFieldInitSpec(this, _sig, void 0);
      _classPrivateFieldInitSpec(this, _accessList, void 0);
      _classPrivateFieldInitSpec(this, _maxFeePerBlobGas, void 0);
      _classPrivateFieldInitSpec(this, _blobVersionedHashes, void 0);
      _classPrivateFieldInitSpec(this, _kzg, void 0);
      _classPrivateFieldInitSpec(this, _blobs2, void 0);
      _classPrivateFieldSet2(_type, this, null);
      _classPrivateFieldSet2(_to, this, null);
      _classPrivateFieldSet2(_nonce, this, 0);
      _classPrivateFieldSet2(_gasLimit, this, BN_0);
      _classPrivateFieldSet2(_gasPrice, this, null);
      _classPrivateFieldSet2(_maxPriorityFeePerGas, this, null);
      _classPrivateFieldSet2(_maxFeePerGas, this, null);
      _classPrivateFieldSet2(_data, this, "0x");
      _classPrivateFieldSet2(_value2, this, BN_0);
      _classPrivateFieldSet2(_chainId, this, BN_0);
      _classPrivateFieldSet2(_sig, this, null);
      _classPrivateFieldSet2(_accessList, this, null);
      _classPrivateFieldSet2(_maxFeePerBlobGas, this, null);
      _classPrivateFieldSet2(_blobVersionedHashes, this, null);
      _classPrivateFieldSet2(_blobs2, this, null);
      _classPrivateFieldSet2(_kzg, this, null);
    }
    /**
     *  The transaction hash, if signed. Otherwise, ``null``.
     */
    return _createClass(Transaction, [{
      key: "type",
      get:
      /**
       *  The transaction type.
       *
       *  If null, the type will be automatically inferred based on
       *  explicit properties.
       */
      function get() {
        return _classPrivateFieldGet2(_type, this);
      },
      set: function set(value) {
        switch (value) {
          case null:
            _classPrivateFieldSet2(_type, this, null);
            break;
          case 0:
          case "legacy":
            _classPrivateFieldSet2(_type, this, 0);
            break;
          case 1:
          case "berlin":
          case "eip-2930":
            _classPrivateFieldSet2(_type, this, 1);
            break;
          case 2:
          case "london":
          case "eip-1559":
            _classPrivateFieldSet2(_type, this, 2);
            break;
          case 3:
          case "cancun":
          case "eip-4844":
            _classPrivateFieldSet2(_type, this, 3);
            break;
          default:
            (0, index_js_3.assertArgument)(false, "unsupported transaction type", "type", value);
        }
      }
      /**
       *  The name of the transaction type.
       */
    }, {
      key: "typeName",
      get: function get() {
        switch (this.type) {
          case 0:
            return "legacy";
          case 1:
            return "eip-2930";
          case 2:
            return "eip-1559";
          case 3:
            return "eip-4844";
        }
        return null;
      }
      /**
       *  The ``to`` address for the transaction or ``null`` if the
       *  transaction is an ``init`` transaction.
       */
    }, {
      key: "to",
      get: function get() {
        var value = _classPrivateFieldGet2(_to, this);
        if (value == null && this.type === 3) {
          return addresses_js_1.ZeroAddress;
        }
        return value;
      },
      set: function set(value) {
        _classPrivateFieldSet2(_to, this, value == null ? null : (0, index_js_1.getAddress)(value));
      }
      /**
       *  The transaction nonce.
       */
    }, {
      key: "nonce",
      get: function get() {
        return _classPrivateFieldGet2(_nonce, this);
      },
      set: function set(value) {
        _classPrivateFieldSet2(_nonce, this, (0, index_js_3.getNumber)(value, "value"));
      }
      /**
       *  The gas limit.
       */
    }, {
      key: "gasLimit",
      get: function get() {
        return _classPrivateFieldGet2(_gasLimit, this);
      },
      set: function set(value) {
        _classPrivateFieldSet2(_gasLimit, this, (0, index_js_3.getBigInt)(value));
      }
      /**
       *  The gas price.
       *
       *  On legacy networks this defines the fee that will be paid. On
       *  EIP-1559 networks, this should be ``null``.
       */
    }, {
      key: "gasPrice",
      get: function get() {
        var value = _classPrivateFieldGet2(_gasPrice, this);
        if (value == null && (this.type === 0 || this.type === 1)) {
          return BN_0;
        }
        return value;
      },
      set: function set(value) {
        _classPrivateFieldSet2(_gasPrice, this, value == null ? null : (0, index_js_3.getBigInt)(value, "gasPrice"));
      }
      /**
       *  The maximum priority fee per unit of gas to pay. On legacy
       *  networks this should be ``null``.
       */
    }, {
      key: "maxPriorityFeePerGas",
      get: function get() {
        var value = _classPrivateFieldGet2(_maxPriorityFeePerGas, this);
        if (value == null) {
          if (this.type === 2 || this.type === 3) {
            return BN_0;
          }
          return null;
        }
        return value;
      },
      set: function set(value) {
        _classPrivateFieldSet2(_maxPriorityFeePerGas, this, value == null ? null : (0, index_js_3.getBigInt)(value, "maxPriorityFeePerGas"));
      }
      /**
       *  The maximum total fee per unit of gas to pay. On legacy
       *  networks this should be ``null``.
       */
    }, {
      key: "maxFeePerGas",
      get: function get() {
        var value = _classPrivateFieldGet2(_maxFeePerGas, this);
        if (value == null) {
          if (this.type === 2 || this.type === 3) {
            return BN_0;
          }
          return null;
        }
        return value;
      },
      set: function set(value) {
        _classPrivateFieldSet2(_maxFeePerGas, this, value == null ? null : (0, index_js_3.getBigInt)(value, "maxFeePerGas"));
      }
      /**
       *  The transaction data. For ``init`` transactions this is the
       *  deployment code.
       */
    }, {
      key: "data",
      get: function get() {
        return _classPrivateFieldGet2(_data, this);
      },
      set: function set(value) {
        _classPrivateFieldSet2(_data, this, (0, index_js_3.hexlify)(value));
      }
      /**
       *  The amount of ether (in wei) to send in this transactions.
       */
    }, {
      key: "value",
      get: function get() {
        return _classPrivateFieldGet2(_value2, this);
      },
      set: function set(value) {
        _classPrivateFieldSet2(_value2, this, (0, index_js_3.getBigInt)(value, "value"));
      }
      /**
       *  The chain ID this transaction is valid on.
       */
    }, {
      key: "chainId",
      get: function get() {
        return _classPrivateFieldGet2(_chainId, this);
      },
      set: function set(value) {
        _classPrivateFieldSet2(_chainId, this, (0, index_js_3.getBigInt)(value));
      }
      /**
       *  If signed, the signature for this transaction.
       */
    }, {
      key: "signature",
      get: function get() {
        return _classPrivateFieldGet2(_sig, this) || null;
      },
      set: function set(value) {
        _classPrivateFieldSet2(_sig, this, value == null ? null : index_js_2.Signature.from(value));
      }
      /**
       *  The access list.
       *
       *  An access list permits discounted (but pre-paid) access to
       *  bytecode and state variable access within contract execution.
       */
    }, {
      key: "accessList",
      get: function get() {
        var value = _classPrivateFieldGet2(_accessList, this) || null;
        if (value == null) {
          if (this.type === 1 || this.type === 2 || this.type === 3) {
            // @TODO: in v7, this should assign the value or become
            // a live object itself, otherwise mutation is inconsistent
            return [];
          }
          return null;
        }
        return value;
      },
      set: function set(value) {
        _classPrivateFieldSet2(_accessList, this, value == null ? null : (0, accesslist_js_1.accessListify)(value));
      }
      /**
       *  The max fee per blob gas for Cancun transactions.
       */
    }, {
      key: "maxFeePerBlobGas",
      get: function get() {
        var value = _classPrivateFieldGet2(_maxFeePerBlobGas, this);
        if (value == null && this.type === 3) {
          return BN_0;
        }
        return value;
      },
      set: function set(value) {
        _classPrivateFieldSet2(_maxFeePerBlobGas, this, value == null ? null : (0, index_js_3.getBigInt)(value, "maxFeePerBlobGas"));
      }
      /**
       *  The BLOb versioned hashes for Cancun transactions.
       */
    }, {
      key: "blobVersionedHashes",
      get: function get() {
        // @TODO: Mutation is inconsistent; if unset, the returned value
        // cannot mutate the object, if set it can
        var value = _classPrivateFieldGet2(_blobVersionedHashes, this);
        if (value == null && this.type === 3) {
          return [];
        }
        return value;
      },
      set: function set(value) {
        if (value != null) {
          (0, index_js_3.assertArgument)(Array.isArray(value), "blobVersionedHashes must be an Array", "value", value);
          value = value.slice();
          for (var i = 0; i < value.length; i++) {
            (0, index_js_3.assertArgument)((0, index_js_3.isHexString)(value[i], 32), "invalid blobVersionedHash", "value[".concat(i, "]"), value[i]);
          }
        }
        _classPrivateFieldSet2(_blobVersionedHashes, this, value);
      }
      /**
       *  The BLObs for the Transaction, if any.
       *
       *  If ``blobs`` is non-``null``, then the [[seriailized]]
       *  will return the network formatted sidecar, otherwise it
       *  will return the standard [[link-eip-2718]] payload. The
       *  [[unsignedSerialized]] is unaffected regardless.
       *
       *  When setting ``blobs``, either fully valid [[Blob]] objects
       *  may be specified (i.e. correctly padded, with correct
       *  committments and proofs) or a raw [[BytesLike]] may
       *  be provided.
       *
       *  If raw [[BytesLike]] are provided, the [[kzg]] property **must**
       *  be already set. The blob will be correctly padded and the
       *  [[KzgLibrary]] will be used to compute the committment and
       *  proof for the blob.
       *
       *  A BLOb is a sequence of field elements, each of which must
       *  be within the BLS field modulo, so some additional processing
       *  may be required to encode arbitrary data to ensure each 32 byte
       *  field is within the valid range.
       *
       *  Setting this automatically populates [[blobVersionedHashes]],
       *  overwriting any existing values. Setting this to ``null``
       *  does **not** remove the [[blobVersionedHashes]], leaving them
       *  present.
       */
    }, {
      key: "blobs",
      get: function get() {
        if (_classPrivateFieldGet2(_blobs2, this) == null) {
          return null;
        }
        return _classPrivateFieldGet2(_blobs2, this).map(function (b) {
          return Object.assign({}, b);
        });
      },
      set: function set(_blobs) {
        if (_blobs == null) {
          _classPrivateFieldSet2(_blobs2, this, null);
          return;
        }
        var blobs = [];
        var versionedHashes = [];
        for (var i = 0; i < _blobs.length; i++) {
          var blob = _blobs[i];
          if ((0, index_js_3.isBytesLike)(blob)) {
            (0, index_js_3.assert)(_classPrivateFieldGet2(_kzg, this), "adding a raw blob requires a KZG library", "UNSUPPORTED_OPERATION", {
              operation: "set blobs()"
            });
            var data = (0, index_js_3.getBytes)(blob);
            (0, index_js_3.assertArgument)(data.length <= BLOB_SIZE, "blob is too large", "blobs[".concat(i, "]"), blob);
            // Pad blob if necessary
            if (data.length !== BLOB_SIZE) {
              var padded = new Uint8Array(BLOB_SIZE);
              padded.set(data);
              data = padded;
            }
            var commit = _classPrivateFieldGet2(_kzg, this).blobToKzgCommitment(data);
            var proof = (0, index_js_3.hexlify)(_classPrivateFieldGet2(_kzg, this).computeBlobKzgProof(data, commit));
            blobs.push({
              data: (0, index_js_3.hexlify)(data),
              commitment: (0, index_js_3.hexlify)(commit),
              proof: proof
            });
            versionedHashes.push(getVersionedHash(1, commit));
          } else {
            var _commit = (0, index_js_3.hexlify)(blob.commitment);
            blobs.push({
              data: (0, index_js_3.hexlify)(blob.data),
              commitment: _commit,
              proof: (0, index_js_3.hexlify)(blob.proof)
            });
            versionedHashes.push(getVersionedHash(1, _commit));
          }
        }
        _classPrivateFieldSet2(_blobs2, this, blobs);
        _classPrivateFieldSet2(_blobVersionedHashes, this, versionedHashes);
      }
    }, {
      key: "kzg",
      get: function get() {
        return _classPrivateFieldGet2(_kzg, this);
      },
      set: function set(kzg) {
        _classPrivateFieldSet2(_kzg, this, kzg);
      }
    }, {
      key: "hash",
      get: function get() {
        if (this.signature == null) {
          return null;
        }
        return (0, index_js_2.keccak256)(_assertClassBrand(_Transaction_brand, this, _getSerialized).call(this, true, false));
      }
      /**
       *  The pre-image hash of this transaction.
       *
       *  This is the digest that a [[Signer]] must sign to authorize
       *  this transaction.
       */
    }, {
      key: "unsignedHash",
      get: function get() {
        return (0, index_js_2.keccak256)(this.unsignedSerialized);
      }
      /**
       *  The sending address, if signed. Otherwise, ``null``.
       */
    }, {
      key: "from",
      get: function get() {
        if (this.signature == null) {
          return null;
        }
        return (0, address_js_1.recoverAddress)(this.unsignedHash, this.signature);
      }
      /**
       *  The public key of the sender, if signed. Otherwise, ``null``.
       */
    }, {
      key: "fromPublicKey",
      get: function get() {
        if (this.signature == null) {
          return null;
        }
        return index_js_2.SigningKey.recoverPublicKey(this.unsignedHash, this.signature);
      }
      /**
       *  Returns true if signed.
       *
       *  This provides a Type Guard that properties requiring a signed
       *  transaction are non-null.
       */
    }, {
      key: "isSigned",
      value: function isSigned() {
        return this.signature != null;
      }
    }, {
      key: "serialized",
      get:
      /**
       *  The serialized transaction.
       *
       *  This throws if the transaction is unsigned. For the pre-image,
       *  use [[unsignedSerialized]].
       */
      function get() {
        return _assertClassBrand(_Transaction_brand, this, _getSerialized).call(this, true, true);
      }
      /**
       *  The transaction pre-image.
       *
       *  The hash of this is the digest which needs to be signed to
       *  authorize this transaction.
       */
    }, {
      key: "unsignedSerialized",
      get: function get() {
        return _assertClassBrand(_Transaction_brand, this, _getSerialized).call(this, false, false);
      }
      /**
       *  Return the most "likely" type; currently the highest
       *  supported transaction type.
       */
    }, {
      key: "inferType",
      value: function inferType() {
        var types = this.inferTypes();
        // Prefer London (EIP-1559) over Cancun (BLOb)
        if (types.indexOf(2) >= 0) {
          return 2;
        }
        // Return the highest inferred type
        return types.pop();
      }
      /**
       *  Validates the explicit properties and returns a list of compatible
       *  transaction types.
       */
    }, {
      key: "inferTypes",
      value: function inferTypes() {
        // Checks that there are no conflicting properties set
        var hasGasPrice = this.gasPrice != null;
        var hasFee = this.maxFeePerGas != null || this.maxPriorityFeePerGas != null;
        var hasAccessList = this.accessList != null;
        var hasBlob = _classPrivateFieldGet2(_maxFeePerBlobGas, this) != null || _classPrivateFieldGet2(_blobVersionedHashes, this);
        //if (hasGasPrice && hasFee) {
        //    throw new Error("transaction cannot have gasPrice and maxFeePerGas");
        //}
        if (this.maxFeePerGas != null && this.maxPriorityFeePerGas != null) {
          (0, index_js_3.assert)(this.maxFeePerGas >= this.maxPriorityFeePerGas, "priorityFee cannot be more than maxFee", "BAD_DATA", {
            value: this
          });
        }
        //if (this.type === 2 && hasGasPrice) {
        //    throw new Error("eip-1559 transaction cannot have gasPrice");
        //}
        (0, index_js_3.assert)(!hasFee || this.type !== 0 && this.type !== 1, "transaction type cannot have maxFeePerGas or maxPriorityFeePerGas", "BAD_DATA", {
          value: this
        });
        (0, index_js_3.assert)(this.type !== 0 || !hasAccessList, "legacy transaction cannot have accessList", "BAD_DATA", {
          value: this
        });
        var types = [];
        // Explicit type
        if (this.type != null) {
          types.push(this.type);
        } else {
          if (hasFee) {
            types.push(2);
          } else if (hasGasPrice) {
            types.push(1);
            if (!hasAccessList) {
              types.push(0);
            }
          } else if (hasAccessList) {
            types.push(1);
            types.push(2);
          } else if (hasBlob && this.to) {
            types.push(3);
          } else {
            types.push(0);
            types.push(1);
            types.push(2);
            types.push(3);
          }
        }
        types.sort();
        return types;
      }
      /**
       *  Returns true if this transaction is a legacy transaction (i.e.
       *  ``type === 0``).
       *
       *  This provides a Type Guard that the related properties are
       *  non-null.
       */
    }, {
      key: "isLegacy",
      value: function isLegacy() {
        return this.type === 0;
      }
      /**
       *  Returns true if this transaction is berlin hardform transaction (i.e.
       *  ``type === 1``).
       *
       *  This provides a Type Guard that the related properties are
       *  non-null.
       */
    }, {
      key: "isBerlin",
      value: function isBerlin() {
        return this.type === 1;
      }
      /**
       *  Returns true if this transaction is london hardform transaction (i.e.
       *  ``type === 2``).
       *
       *  This provides a Type Guard that the related properties are
       *  non-null.
       */
    }, {
      key: "isLondon",
      value: function isLondon() {
        return this.type === 2;
      }
      /**
       *  Returns true if this transaction is an [[link-eip-4844]] BLOB
       *  transaction.
       *
       *  This provides a Type Guard that the related properties are
       *  non-null.
       */
    }, {
      key: "isCancun",
      value: function isCancun() {
        return this.type === 3;
      }
      /**
       *  Create a copy of this transaciton.
       */
    }, {
      key: "clone",
      value: function clone() {
        return Transaction.from(this);
      }
      /**
       *  Return a JSON-friendly object.
       */
    }, {
      key: "toJSON",
      value: function toJSON() {
        var s = function s(v) {
          if (v == null) {
            return null;
          }
          return v.toString();
        };
        return {
          type: this.type,
          to: this.to,
          //            from: this.from,
          data: this.data,
          nonce: this.nonce,
          gasLimit: s(this.gasLimit),
          gasPrice: s(this.gasPrice),
          maxPriorityFeePerGas: s(this.maxPriorityFeePerGas),
          maxFeePerGas: s(this.maxFeePerGas),
          value: s(this.value),
          chainId: s(this.chainId),
          sig: this.signature ? this.signature.toJSON() : null,
          accessList: this.accessList
        };
      }
      /**
       *  Create a **Transaction** from a serialized transaction or a
       *  Transaction-like object.
       */
    }], [{
      key: "from",
      value: function from(tx) {
        if (tx == null) {
          return new Transaction();
        }
        if (typeof tx === "string") {
          var payload = (0, index_js_3.getBytes)(tx);
          if (payload[0] >= 0x7f) {
            // @TODO: > vs >= ??
            return Transaction.from(_parseLegacy(payload));
          }
          switch (payload[0]) {
            case 1:
              return Transaction.from(_parseEip2930(payload));
            case 2:
              return Transaction.from(_parseEip1559(payload));
            case 3:
              return Transaction.from(_parseEip4844(payload));
          }
          (0, index_js_3.assert)(false, "unsupported transaction type", "UNSUPPORTED_OPERATION", {
            operation: "from"
          });
        }
        var result = new Transaction();
        if (tx.type != null) {
          result.type = tx.type;
        }
        if (tx.to != null) {
          result.to = tx.to;
        }
        if (tx.nonce != null) {
          result.nonce = tx.nonce;
        }
        if (tx.gasLimit != null) {
          result.gasLimit = tx.gasLimit;
        }
        if (tx.gasPrice != null) {
          result.gasPrice = tx.gasPrice;
        }
        if (tx.maxPriorityFeePerGas != null) {
          result.maxPriorityFeePerGas = tx.maxPriorityFeePerGas;
        }
        if (tx.maxFeePerGas != null) {
          result.maxFeePerGas = tx.maxFeePerGas;
        }
        if (tx.maxFeePerBlobGas != null) {
          result.maxFeePerBlobGas = tx.maxFeePerBlobGas;
        }
        if (tx.data != null) {
          result.data = tx.data;
        }
        if (tx.value != null) {
          result.value = tx.value;
        }
        if (tx.chainId != null) {
          result.chainId = tx.chainId;
        }
        if (tx.signature != null) {
          result.signature = index_js_2.Signature.from(tx.signature);
        }
        if (tx.accessList != null) {
          result.accessList = tx.accessList;
        }
        // This will get overwritten by blobs, if present
        if (tx.blobVersionedHashes != null) {
          result.blobVersionedHashes = tx.blobVersionedHashes;
        }
        // Make sure we assign the kzg before assigning blobs, which
        // require the library in the event raw blob data is provided.
        if (tx.kzg != null) {
          result.kzg = tx.kzg;
        }
        if (tx.blobs != null) {
          result.blobs = tx.blobs;
        }
        if (tx.hash != null) {
          (0, index_js_3.assertArgument)(result.isSigned(), "unsigned transaction cannot define '.hash'", "tx", tx);
          (0, index_js_3.assertArgument)(result.hash === tx.hash, "hash mismatch", "tx", tx);
        }
        if (tx.from != null) {
          (0, index_js_3.assertArgument)(result.isSigned(), "unsigned transaction cannot define '.from'", "tx", tx);
          (0, index_js_3.assertArgument)(result.from.toLowerCase() === (tx.from || "").toLowerCase(), "from mismatch", "tx", tx);
        }
        return result;
      }
    }]);
  }();
  function _getSerialized(signed, sidecar) {
    (0, index_js_3.assert)(!signed || this.signature != null, "cannot serialize unsigned transaction; maybe you meant .unsignedSerialized", "UNSUPPORTED_OPERATION", {
      operation: ".serialized"
    });
    var sig = signed ? this.signature : null;
    switch (this.inferType()) {
      case 0:
        return _serializeLegacy(this, sig);
      case 1:
        return _serializeEip2930(this, sig);
      case 2:
        return _serializeEip1559(this, sig);
      case 3:
        return _serializeEip4844(this, sig, sidecar ? this.blobs : null);
    }
    (0, index_js_3.assert)(false, "unsupported transaction type", "UNSUPPORTED_OPERATION", {
      operation: ".serialized"
    });
  }
  transaction.Transaction = Transaction;
  return transaction;
}

var hasRequiredTransaction;
function requireTransaction() {
  if (hasRequiredTransaction) return transaction$1;
  hasRequiredTransaction = 1;
  (function (exports) {

    /**
     *  Each state-changing operation on Ethereum requires a transaction.
     *
     *  @_section api/transaction:Transactions  [about-transactions]
     */
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Transaction = exports.recoverAddress = exports.computeAddress = exports.accessListify = void 0;
    var accesslist_js_1 = /*@__PURE__*/requireAccesslist();
    Object.defineProperty(exports, "accessListify", {
      enumerable: true,
      get: function get() {
        return accesslist_js_1.accessListify;
      }
    });
    var address_js_1 = /*@__PURE__*/requireAddress();
    Object.defineProperty(exports, "computeAddress", {
      enumerable: true,
      get: function get() {
        return address_js_1.computeAddress;
      }
    });
    Object.defineProperty(exports, "recoverAddress", {
      enumerable: true,
      get: function get() {
        return address_js_1.recoverAddress;
      }
    });
    var transaction_js_1 = /*@__PURE__*/requireTransaction$1();
    Object.defineProperty(exports, "Transaction", {
      enumerable: true,
      get: function get() {
        return transaction_js_1.Transaction;
      }
    });
  })(transaction$1);
  return transaction$1;
}

var hasRequiredMessage;
function requireMessage() {
  if (hasRequiredMessage) return message;
  hasRequiredMessage = 1;
  Object.defineProperty(message, "__esModule", {
    value: true
  });
  message.verifyMessage = message.hashMessage = void 0;
  var index_js_1 = /*@__PURE__*/requireCrypto();
  var index_js_2 = /*@__PURE__*/requireConstants$1();
  var index_js_3 = /*@__PURE__*/requireTransaction();
  var index_js_4 = /*@__PURE__*/requireUtils$3();
  /**
   *  Computes the [[link-eip-191]] personal-sign message digest to sign.
   *
   *  This prefixes the message with [[MessagePrefix]] and the decimal length
   *  of %%message%% and computes the [[keccak256]] digest.
   *
   *  If %%message%% is a string, it is converted to its UTF-8 bytes
   *  first. To compute the digest of a [[DataHexString]], it must be converted
   *  to [bytes](getBytes).
   *
   *  @example:
   *    hashMessage("Hello World")
   *    //_result:
   *
   *    // Hashes the SIX (6) string characters, i.e.
   *    // [ "0", "x", "4", "2", "4", "3" ]
   *    hashMessage("0x4243")
   *    //_result:
   *
   *    // Hashes the TWO (2) bytes [ 0x42, 0x43 ]...
   *    hashMessage(getBytes("0x4243"))
   *    //_result:
   *
   *    // ...which is equal to using data
   *    hashMessage(new Uint8Array([ 0x42, 0x43 ]))
   *    //_result:
   *
   */
  function hashMessage(message) {
    if (typeof message === "string") {
      message = (0, index_js_4.toUtf8Bytes)(message);
    }
    return (0, index_js_1.keccak256)((0, index_js_4.concat)([(0, index_js_4.toUtf8Bytes)(index_js_2.MessagePrefix), (0, index_js_4.toUtf8Bytes)(String(message.length)), message]));
  }
  message.hashMessage = hashMessage;
  /**
   *  Return the address of the private key that produced
   *  the signature %%sig%% during signing for %%message%%.
   */
  function verifyMessage(message, sig) {
    var digest = hashMessage(message);
    return (0, index_js_3.recoverAddress)(digest, sig);
  }
  message.verifyMessage = verifyMessage;
  return message;
}

var solidity = {};

var hasRequiredSolidity;
function requireSolidity() {
  if (hasRequiredSolidity) return solidity;
  hasRequiredSolidity = 1;
  Object.defineProperty(solidity, "__esModule", {
    value: true
  });
  solidity.solidityPackedSha256 = solidity.solidityPackedKeccak256 = solidity.solidityPacked = void 0;
  var index_js_1 = /*@__PURE__*/requireAddress$2();
  var index_js_2 = /*@__PURE__*/requireCrypto();
  var index_js_3 = /*@__PURE__*/requireUtils$3();
  var regexBytes = new RegExp("^bytes([0-9]+)$");
  var regexNumber = new RegExp("^(u?int)([0-9]*)$");
  var regexArray = new RegExp("^(.*)\\[([0-9]*)\\]$");
  function _pack(type, value, isArray) {
    switch (type) {
      case "address":
        if (isArray) {
          return (0, index_js_3.getBytes)((0, index_js_3.zeroPadValue)(value, 32));
        }
        return (0, index_js_3.getBytes)((0, index_js_1.getAddress)(value));
      case "string":
        return (0, index_js_3.toUtf8Bytes)(value);
      case "bytes":
        return (0, index_js_3.getBytes)(value);
      case "bool":
        value = !!value ? "0x01" : "0x00";
        if (isArray) {
          return (0, index_js_3.getBytes)((0, index_js_3.zeroPadValue)(value, 32));
        }
        return (0, index_js_3.getBytes)(value);
    }
    var match = type.match(regexNumber);
    if (match) {
      var signed = match[1] === "int";
      var size = parseInt(match[2] || "256");
      (0, index_js_3.assertArgument)((!match[2] || match[2] === String(size)) && size % 8 === 0 && size !== 0 && size <= 256, "invalid number type", "type", type);
      if (isArray) {
        size = 256;
      }
      if (signed) {
        value = (0, index_js_3.toTwos)(value, size);
      }
      return (0, index_js_3.getBytes)((0, index_js_3.zeroPadValue)((0, index_js_3.toBeArray)(value), size / 8));
    }
    match = type.match(regexBytes);
    if (match) {
      var _size = parseInt(match[1]);
      (0, index_js_3.assertArgument)(String(_size) === match[1] && _size !== 0 && _size <= 32, "invalid bytes type", "type", type);
      (0, index_js_3.assertArgument)((0, index_js_3.dataLength)(value) === _size, "invalid value for ".concat(type), "value", value);
      if (isArray) {
        return (0, index_js_3.getBytes)((0, index_js_3.zeroPadBytes)(value, 32));
      }
      return value;
    }
    match = type.match(regexArray);
    if (match && Array.isArray(value)) {
      var baseType = match[1];
      var count = parseInt(match[2] || String(value.length));
      (0, index_js_3.assertArgument)(count === value.length, "invalid array length for ".concat(type), "value", value);
      var result = [];
      value.forEach(function (value) {
        result.push(_pack(baseType, value, true));
      });
      return (0, index_js_3.getBytes)((0, index_js_3.concat)(result));
    }
    (0, index_js_3.assertArgument)(false, "invalid type", "type", type);
  }
  // @TODO: Array Enum
  /**
   *   Computes the [[link-solc-packed]] representation of %%values%%
   *   respectively to their %%types%%.
   *
   *   @example:
   *       addr = "0x8ba1f109551bd432803012645ac136ddd64dba72"
   *       solidityPacked([ "address", "uint" ], [ addr, 45 ]);
   *       //_result:
   */
  function solidityPacked(types, values) {
    (0, index_js_3.assertArgument)(types.length === values.length, "wrong number of values; expected ${ types.length }", "values", values);
    var tight = [];
    types.forEach(function (type, index) {
      tight.push(_pack(type, values[index]));
    });
    return (0, index_js_3.hexlify)((0, index_js_3.concat)(tight));
  }
  solidity.solidityPacked = solidityPacked;
  /**
   *   Computes the [[link-solc-packed]] [[keccak256]] hash of %%values%%
   *   respectively to their %%types%%.
   *
   *   @example:
   *       addr = "0x8ba1f109551bd432803012645ac136ddd64dba72"
   *       solidityPackedKeccak256([ "address", "uint" ], [ addr, 45 ]);
   *       //_result:
   */
  function solidityPackedKeccak256(types, values) {
    return (0, index_js_2.keccak256)(solidityPacked(types, values));
  }
  solidity.solidityPackedKeccak256 = solidityPackedKeccak256;
  /**
   *   Computes the [[link-solc-packed]] [[sha256]] hash of %%values%%
   *   respectively to their %%types%%.
   *
   *   @example:
   *       addr = "0x8ba1f109551bd432803012645ac136ddd64dba72"
   *       solidityPackedSha256([ "address", "uint" ], [ addr, 45 ]);
   *       //_result:
   */
  function solidityPackedSha256(types, values) {
    return (0, index_js_2.sha256)(solidityPacked(types, values));
  }
  solidity.solidityPackedSha256 = solidityPackedSha256;
  return solidity;
}

var typedData = {};

var hasRequiredTypedData;
function requireTypedData() {
  if (hasRequiredTypedData) return typedData;
  hasRequiredTypedData = 1;
  Object.defineProperty(typedData, "__esModule", {
    value: true
  });
  typedData.verifyTypedData = typedData.TypedDataEncoder = void 0;
  //import { TypedDataDomain, TypedDataField } from "@ethersproject/providerabstract-signer";
  var index_js_1 = /*@__PURE__*/requireAddress$2();
  var index_js_2 = /*@__PURE__*/requireCrypto();
  var index_js_3 = /*@__PURE__*/requireTransaction();
  var index_js_4 = /*@__PURE__*/requireUtils$3();
  var id_js_1 = /*@__PURE__*/requireId();
  var padding = new Uint8Array(32);
  padding.fill(0);
  var BN__1 = BigInt(-1);
  var BN_0 = BigInt(0);
  var BN_1 = BigInt(1);
  var BN_MAX_UINT256 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
  function hexPadRight(value) {
    var bytes = (0, index_js_4.getBytes)(value);
    var padOffset = bytes.length % 32;
    if (padOffset) {
      return (0, index_js_4.concat)([bytes, padding.slice(padOffset)]);
    }
    return (0, index_js_4.hexlify)(bytes);
  }
  var hexTrue = (0, index_js_4.toBeHex)(BN_1, 32);
  var hexFalse = (0, index_js_4.toBeHex)(BN_0, 32);
  var domainFieldTypes = {
    name: "string",
    version: "string",
    chainId: "uint256",
    verifyingContract: "address",
    salt: "bytes32"
  };
  var domainFieldNames = ["name", "version", "chainId", "verifyingContract", "salt"];
  function checkString(key) {
    return function (value) {
      (0, index_js_4.assertArgument)(typeof value === "string", "invalid domain value for ".concat(JSON.stringify(key)), "domain.".concat(key), value);
      return value;
    };
  }
  var domainChecks = {
    name: checkString("name"),
    version: checkString("version"),
    chainId: function chainId(_value) {
      var value = (0, index_js_4.getBigInt)(_value, "domain.chainId");
      (0, index_js_4.assertArgument)(value >= 0, "invalid chain ID", "domain.chainId", _value);
      if (Number.isSafeInteger(value)) {
        return Number(value);
      }
      return (0, index_js_4.toQuantity)(value);
    },
    verifyingContract: function verifyingContract(value) {
      try {
        return (0, index_js_1.getAddress)(value).toLowerCase();
      } catch (error) {}
      (0, index_js_4.assertArgument)(false, "invalid domain value \"verifyingContract\"", "domain.verifyingContract", value);
    },
    salt: function salt(value) {
      var bytes = (0, index_js_4.getBytes)(value, "domain.salt");
      (0, index_js_4.assertArgument)(bytes.length === 32, "invalid domain value \"salt\"", "domain.salt", value);
      return (0, index_js_4.hexlify)(bytes);
    }
  };
  function getBaseEncoder(type) {
    // intXX and uintXX
    {
      var match = type.match(/^(u?)int(\d+)$/);
      if (match) {
        var signed = match[1] === "";
        var width = parseInt(match[2]);
        (0, index_js_4.assertArgument)(width % 8 === 0 && width !== 0 && width <= 256 && match[2] === String(width), "invalid numeric width", "type", type);
        var boundsUpper = (0, index_js_4.mask)(BN_MAX_UINT256, signed ? width - 1 : width);
        var boundsLower = signed ? (boundsUpper + BN_1) * BN__1 : BN_0;
        return function (_value) {
          var value = (0, index_js_4.getBigInt)(_value, "value");
          (0, index_js_4.assertArgument)(value >= boundsLower && value <= boundsUpper, "value out-of-bounds for ".concat(type), "value", value);
          return (0, index_js_4.toBeHex)(signed ? (0, index_js_4.toTwos)(value, 256) : value, 32);
        };
      }
    }
    // bytesXX
    {
      var _match = type.match(/^bytes(\d+)$/);
      if (_match) {
        var _width = parseInt(_match[1]);
        (0, index_js_4.assertArgument)(_width !== 0 && _width <= 32 && _match[1] === String(_width), "invalid bytes width", "type", type);
        return function (value) {
          var bytes = (0, index_js_4.getBytes)(value);
          (0, index_js_4.assertArgument)(bytes.length === _width, "invalid length for ".concat(type), "value", value);
          return hexPadRight(value);
        };
      }
    }
    switch (type) {
      case "address":
        return function (value) {
          return (0, index_js_4.zeroPadValue)((0, index_js_1.getAddress)(value), 32);
        };
      case "bool":
        return function (value) {
          return !value ? hexFalse : hexTrue;
        };
      case "bytes":
        return function (value) {
          return (0, index_js_2.keccak256)(value);
        };
      case "string":
        return function (value) {
          return (0, id_js_1.id)(value);
        };
    }
    return null;
  }
  function encodeType(name, fields) {
    return "".concat(name, "(").concat(fields.map(function (_ref) {
      var name = _ref.name,
        type = _ref.type;
      return type + " " + name;
    }).join(","), ")");
  }
  // foo[][3] => { base: "foo", index: "[][3]", array: {
  //     base: "foo", prefix: "foo[]", count: 3 } }
  function splitArray(type) {
    var match = type.match(/^([^\x5b]*)((\x5b\d*\x5d)*)(\x5b(\d*)\x5d)$/);
    if (match) {
      return {
        base: match[1],
        index: match[2] + match[4],
        array: {
          base: match[1],
          prefix: match[1] + match[2],
          count: match[5] ? parseInt(match[5]) : -1
        }
      };
    }
    return {
      base: type
    };
  }
  /**
   *  A **TypedDataEncode** prepares and encodes [[link-eip-712]] payloads
   *  for signed typed data.
   *
   *  This is useful for those that wish to compute various components of a
   *  typed data hash, primary types, or sub-components, but generally the
   *  higher level [[Signer-signTypedData]] is more useful.
   */
  var _types2 = /*#__PURE__*/new WeakMap();
  var _fullTypes = /*#__PURE__*/new WeakMap();
  var _encoderCache = /*#__PURE__*/new WeakMap();
  var _TypedDataEncoder_brand = /*#__PURE__*/new WeakSet();
  var TypedDataEncoder = /*#__PURE__*/function () {
    /**
     *  Create a new **TypedDataEncoder** for %%types%%.
     *
     *  This performs all necessary checking that types are valid and
     *  do not violate the [[link-eip-712]] structural constraints as
     *  well as computes the [[primaryType]].
     */
    function TypedDataEncoder(_types) {
      _classCallCheck(this, TypedDataEncoder);
      _classPrivateMethodInitSpec(this, _TypedDataEncoder_brand);
      /**
       *  The primary type for the structured [[types]].
       *
       *  This is derived automatically from the [[types]], since no
       *  recursion is possible, once the DAG for the types is consturcted
       *  internally, the primary type must be the only remaining type with
       *  no parent nodes.
       */
      _defineProperty(this, "primaryType", void 0);
      _classPrivateFieldInitSpec(this, _types2, void 0);
      _classPrivateFieldInitSpec(this, _fullTypes, void 0);
      _classPrivateFieldInitSpec(this, _encoderCache, void 0);
      _classPrivateFieldSet2(_fullTypes, this, new Map());
      _classPrivateFieldSet2(_encoderCache, this, new Map());
      // Link struct types to their direct child structs
      var links = new Map();
      // Link structs to structs which contain them as a child
      var parents = new Map();
      // Link all subtypes within a given struct
      var subtypes = new Map();
      var types = {};
      Object.keys(_types).forEach(function (type) {
        types[type] = _types[type].map(function (_ref2) {
          var name = _ref2.name,
            type = _ref2.type;
          // Normalize the base type (unless name conflict)
          var _splitArray = splitArray(type),
            base = _splitArray.base,
            index = _splitArray.index;
          if (base === "int" && !_types["int"]) {
            base = "int256";
          }
          if (base === "uint" && !_types["uint"]) {
            base = "uint256";
          }
          return {
            name: name,
            type: base + (index || "")
          };
        });
        links.set(type, new Set());
        parents.set(type, []);
        subtypes.set(type, new Set());
      });
      _classPrivateFieldSet2(_types2, this, JSON.stringify(types));
      for (var name in types) {
        var uniqueNames = new Set();
        var _iterator = _createForOfIteratorHelper(types[name]),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var field = _step.value;
            // Check each field has a unique name
            (0, index_js_4.assertArgument)(!uniqueNames.has(field.name), "duplicate variable name ".concat(JSON.stringify(field.name), " in ").concat(JSON.stringify(name)), "types", _types);
            uniqueNames.add(field.name);
            // Get the base type (drop any array specifiers)
            var baseType = splitArray(field.type).base;
            (0, index_js_4.assertArgument)(baseType !== name, "circular type reference to ".concat(JSON.stringify(baseType)), "types", _types);
            // Is this a base encoding type?
            var encoder = getBaseEncoder(baseType);
            if (encoder) {
              continue;
            }
            (0, index_js_4.assertArgument)(parents.has(baseType), "unknown type ".concat(JSON.stringify(baseType)), "types", _types);
            // Add linkage
            parents.get(baseType).push(name);
            links.get(name).add(baseType);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
      // Deduce the primary type
      var primaryTypes = Array.from(parents.keys()).filter(function (n) {
        return parents.get(n).length === 0;
      });
      (0, index_js_4.assertArgument)(primaryTypes.length !== 0, "missing primary type", "types", _types);
      (0, index_js_4.assertArgument)(primaryTypes.length === 1, "ambiguous primary types or unused types: ".concat(primaryTypes.map(function (t) {
        return JSON.stringify(t);
      }).join(", ")), "types", _types);
      (0, index_js_4.defineProperties)(this, {
        primaryType: primaryTypes[0]
      });
      // Check for circular type references
      function checkCircular(type, found) {
        (0, index_js_4.assertArgument)(!found.has(type), "circular type reference to ".concat(JSON.stringify(type)), "types", _types);
        found.add(type);
        var _iterator2 = _createForOfIteratorHelper(links.get(type)),
          _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var child = _step2.value;
            if (!parents.has(child)) {
              continue;
            }
            // Recursively check children
            checkCircular(child, found);
            // Mark all ancestors as having this decendant
            var _iterator3 = _createForOfIteratorHelper(found),
              _step3;
            try {
              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                var subtype = _step3.value;
                subtypes.get(subtype).add(child);
              }
            } catch (err) {
              _iterator3.e(err);
            } finally {
              _iterator3.f();
            }
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
        found["delete"](type);
      }
      checkCircular(this.primaryType, new Set());
      // Compute each fully describe type
      var _iterator4 = _createForOfIteratorHelper(subtypes),
        _step4;
      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var _step4$value = _slicedToArray(_step4.value, 2),
            _name = _step4$value[0],
            set = _step4$value[1];
          var st = Array.from(set);
          st.sort();
          _classPrivateFieldGet2(_fullTypes, this).set(_name, encodeType(_name, types[_name]) + st.map(function (t) {
            return encodeType(t, types[t]);
          }).join(""));
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
    }
    /**
     *  Returnthe encoder for the specific %%type%%.
     */
    return _createClass(TypedDataEncoder, [{
      key: "types",
      get:
      /**
       *  The types.
       */
      function get() {
        return JSON.parse(_classPrivateFieldGet2(_types2, this));
      }
    }, {
      key: "getEncoder",
      value: function getEncoder(type) {
        var encoder = _classPrivateFieldGet2(_encoderCache, this).get(type);
        if (!encoder) {
          encoder = _assertClassBrand(_TypedDataEncoder_brand, this, _getEncoder).call(this, type);
          _classPrivateFieldGet2(_encoderCache, this).set(type, encoder);
        }
        return encoder;
      }
    }, {
      key: "encodeType",
      value:
      /**
       *  Return the full type for %%name%%.
       */
      function encodeType(name) {
        var result = _classPrivateFieldGet2(_fullTypes, this).get(name);
        (0, index_js_4.assertArgument)(result, "unknown type: ".concat(JSON.stringify(name)), "name", name);
        return result;
      }
      /**
       *  Return the encoded %%value%% for the %%type%%.
       */
    }, {
      key: "encodeData",
      value: function encodeData(type, value) {
        return this.getEncoder(type)(value);
      }
      /**
       *  Returns the hash of %%value%% for the type of %%name%%.
       */
    }, {
      key: "hashStruct",
      value: function hashStruct(name, value) {
        return (0, index_js_2.keccak256)(this.encodeData(name, value));
      }
      /**
       *  Return the fulled encoded %%value%% for the [[types]].
       */
    }, {
      key: "encode",
      value: function encode(value) {
        return this.encodeData(this.primaryType, value);
      }
      /**
       *  Return the hash of the fully encoded %%value%% for the [[types]].
       */
    }, {
      key: "hash",
      value: function hash(value) {
        return this.hashStruct(this.primaryType, value);
      }
      /**
       *  @_ignore:
       */
    }, {
      key: "_visit",
      value: function _visit(type, value, callback) {
        var _this = this;
        // Basic encoder type (address, bool, uint256, etc)
        {
          var encoder = getBaseEncoder(type);
          if (encoder) {
            return callback(type, value);
          }
        }
        // Array
        var array = splitArray(type).array;
        if (array) {
          (0, index_js_4.assertArgument)(array.count === -1 || array.count === value.length, "array length mismatch; expected length ".concat(array.count), "value", value);
          return value.map(function (v) {
            return _this._visit(array.prefix, v, callback);
          });
        }
        // Struct
        var fields = this.types[type];
        if (fields) {
          return fields.reduce(function (accum, _ref3) {
            var name = _ref3.name,
              type = _ref3.type;
            accum[name] = _this._visit(type, value[name], callback);
            return accum;
          }, {});
        }
        (0, index_js_4.assertArgument)(false, "unknown type: ".concat(type), "type", type);
      }
      /**
       *  Call %%calback%% for each value in %%value%%, passing the type and
       *  component within %%value%%.
       *
       *  This is useful for replacing addresses or other transformation that
       *  may be desired on each component, based on its type.
       */
    }, {
      key: "visit",
      value: function visit(value, callback) {
        return this._visit(this.primaryType, value, callback);
      }
      /**
       *  Create a new **TypedDataEncoder** for %%types%%.
       */
    }], [{
      key: "from",
      value: function from(types) {
        return new TypedDataEncoder(types);
      }
      /**
       *  Return the primary type for %%types%%.
       */
    }, {
      key: "getPrimaryType",
      value: function getPrimaryType(types) {
        return TypedDataEncoder.from(types).primaryType;
      }
      /**
       *  Return the hashed struct for %%value%% using %%types%% and %%name%%.
       */
    }, {
      key: "hashStruct",
      value: function hashStruct(name, types, value) {
        return TypedDataEncoder.from(types).hashStruct(name, value);
      }
      /**
       *  Return the domain hash for %%domain%%.
       */
    }, {
      key: "hashDomain",
      value: function hashDomain(domain) {
        var domainFields = [];
        for (var name in domain) {
          if (domain[name] == null) {
            continue;
          }
          var type = domainFieldTypes[name];
          (0, index_js_4.assertArgument)(type, "invalid typed-data domain key: ".concat(JSON.stringify(name)), "domain", domain);
          domainFields.push({
            name: name,
            type: type
          });
        }
        domainFields.sort(function (a, b) {
          return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b.name);
        });
        return TypedDataEncoder.hashStruct("EIP712Domain", {
          EIP712Domain: domainFields
        }, domain);
      }
      /**
       *  Return the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.
       */
    }, {
      key: "encode",
      value: function encode(domain, types, value) {
        return (0, index_js_4.concat)(["0x1901", TypedDataEncoder.hashDomain(domain), TypedDataEncoder.from(types).hash(value)]);
      }
      /**
       *  Return the hash of the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.
       */
    }, {
      key: "hash",
      value: function hash(domain, types, value) {
        return (0, index_js_2.keccak256)(TypedDataEncoder.encode(domain, types, value));
      }
      // Replaces all address types with ENS names with their looked up address
      /**
       * Resolves to the value from resolving all addresses in %%value%% for
       * %%types%% and the %%domain%%.
       */
    }, {
      key: "resolveNames",
      value: function () {
        var _resolveNames = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(domain, types, value, resolveName) {
          var key, ensCache, encoder, name;
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                // Make a copy to isolate it from the object passed in
                domain = Object.assign({}, domain);
                // Allow passing null to ignore value
                for (key in domain) {
                  if (domain[key] == null) {
                    delete domain[key];
                  }
                }
                // Look up all ENS names
                ensCache = {}; // Do we need to look up the domain's verifyingContract?
                if (domain.verifyingContract && !(0, index_js_4.isHexString)(domain.verifyingContract, 20)) {
                  ensCache[domain.verifyingContract] = "0x";
                }
                // We are going to use the encoder to visit all the base values
                encoder = TypedDataEncoder.from(types); // Get a list of all the addresses
                encoder.visit(value, function (type, value) {
                  if (type === "address" && !(0, index_js_4.isHexString)(value, 20)) {
                    ensCache[value] = "0x";
                  }
                  return value;
                });
                // Lookup each name
                _context.t0 = _regeneratorRuntime().keys(ensCache);
              case 7:
                if ((_context.t1 = _context.t0()).done) {
                  _context.next = 14;
                  break;
                }
                name = _context.t1.value;
                _context.next = 11;
                return resolveName(name);
              case 11:
                ensCache[name] = _context.sent;
                _context.next = 7;
                break;
              case 14:
                // Replace the domain verifyingContract if needed
                if (domain.verifyingContract && ensCache[domain.verifyingContract]) {
                  domain.verifyingContract = ensCache[domain.verifyingContract];
                }
                // Replace all ENS names with their address
                value = encoder.visit(value, function (type, value) {
                  if (type === "address" && ensCache[value]) {
                    return ensCache[value];
                  }
                  return value;
                });
                return _context.abrupt("return", {
                  domain: domain,
                  value: value
                });
              case 17:
              case "end":
                return _context.stop();
            }
          }, _callee);
        }));
        function resolveNames(_x, _x2, _x3, _x4) {
          return _resolveNames.apply(this, arguments);
        }
        return resolveNames;
      }()
      /**
       *  Returns the JSON-encoded payload expected by nodes which implement
       *  the JSON-RPC [[link-eip-712]] method.
       */
    }, {
      key: "getPayload",
      value: function getPayload(domain, types, value) {
        // Validate the domain fields
        TypedDataEncoder.hashDomain(domain);
        // Derive the EIP712Domain Struct reference type
        var domainValues = {};
        var domainTypes = [];
        domainFieldNames.forEach(function (name) {
          var value = domain[name];
          if (value == null) {
            return;
          }
          domainValues[name] = domainChecks[name](value);
          domainTypes.push({
            name: name,
            type: domainFieldTypes[name]
          });
        });
        var encoder = TypedDataEncoder.from(types);
        // Get the normalized types
        types = encoder.types;
        var typesWithDomain = Object.assign({}, types);
        (0, index_js_4.assertArgument)(typesWithDomain.EIP712Domain == null, "types must not contain EIP712Domain type", "types.EIP712Domain", types);
        typesWithDomain.EIP712Domain = domainTypes;
        // Validate the data structures and types
        encoder.encode(value);
        return {
          types: typesWithDomain,
          domain: domainValues,
          primaryType: encoder.primaryType,
          message: encoder.visit(value, function (type, value) {
            // bytes
            if (type.match(/^bytes(\d*)/)) {
              return (0, index_js_4.hexlify)((0, index_js_4.getBytes)(value));
            }
            // uint or int
            if (type.match(/^u?int/)) {
              return (0, index_js_4.getBigInt)(value).toString();
            }
            switch (type) {
              case "address":
                return value.toLowerCase();
              case "bool":
                return !!value;
              case "string":
                (0, index_js_4.assertArgument)(typeof value === "string", "invalid string", "value", value);
                return value;
            }
            (0, index_js_4.assertArgument)(false, "unsupported type", "type", type);
          })
        };
      }
    }]);
  }();
  function _getEncoder(type) {
    var _this2 = this;
    // Basic encoder type (address, bool, uint256, etc)
    {
      var encoder = getBaseEncoder(type);
      if (encoder) {
        return encoder;
      }
    }
    // Array
    var array = splitArray(type).array;
    if (array) {
      var subtype = array.prefix;
      var subEncoder = this.getEncoder(subtype);
      return function (value) {
        (0, index_js_4.assertArgument)(array.count === -1 || array.count === value.length, "array length mismatch; expected length ".concat(array.count), "value", value);
        var result = value.map(subEncoder);
        if (_classPrivateFieldGet2(_fullTypes, _this2).has(subtype)) {
          result = result.map(index_js_2.keccak256);
        }
        return (0, index_js_2.keccak256)((0, index_js_4.concat)(result));
      };
    }
    // Struct
    var fields = this.types[type];
    if (fields) {
      var encodedType = (0, id_js_1.id)(_classPrivateFieldGet2(_fullTypes, this).get(type));
      return function (value) {
        var values = fields.map(function (_ref4) {
          var name = _ref4.name,
            type = _ref4.type;
          var result = _this2.getEncoder(type)(value[name]);
          if (_classPrivateFieldGet2(_fullTypes, _this2).has(type)) {
            return (0, index_js_2.keccak256)(result);
          }
          return result;
        });
        values.unshift(encodedType);
        return (0, index_js_4.concat)(values);
      };
    }
    (0, index_js_4.assertArgument)(false, "unknown type: ".concat(type), "type", type);
  }
  typedData.TypedDataEncoder = TypedDataEncoder;
  /**
   *  Compute the address used to sign the typed data for the %%signature%%.
   */
  function verifyTypedData(domain, types, value, signature) {
    return (0, index_js_3.recoverAddress)(TypedDataEncoder.hash(domain, types, value), signature);
  }
  typedData.verifyTypedData = verifyTypedData;
  return typedData;
}

var hasRequiredHash;
function requireHash() {
  if (hasRequiredHash) return hash;
  hasRequiredHash = 1;
  (function (exports) {

    /**
     *  Utilities for common tasks involving hashing. Also see
     *  [cryptographic hashing](about-crypto-hashing).
     *
     *  @_section: api/hashing:Hashing Utilities  [about-hashing]
     */
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.verifyTypedData = exports.TypedDataEncoder = exports.solidityPackedSha256 = exports.solidityPackedKeccak256 = exports.solidityPacked = exports.verifyMessage = exports.hashMessage = exports.dnsEncode = exports.namehash = exports.isValidName = exports.ensNormalize = exports.id = void 0;
    var id_js_1 = /*@__PURE__*/requireId();
    Object.defineProperty(exports, "id", {
      enumerable: true,
      get: function get() {
        return id_js_1.id;
      }
    });
    var namehash_js_1 = /*@__PURE__*/requireNamehash();
    Object.defineProperty(exports, "ensNormalize", {
      enumerable: true,
      get: function get() {
        return namehash_js_1.ensNormalize;
      }
    });
    Object.defineProperty(exports, "isValidName", {
      enumerable: true,
      get: function get() {
        return namehash_js_1.isValidName;
      }
    });
    Object.defineProperty(exports, "namehash", {
      enumerable: true,
      get: function get() {
        return namehash_js_1.namehash;
      }
    });
    Object.defineProperty(exports, "dnsEncode", {
      enumerable: true,
      get: function get() {
        return namehash_js_1.dnsEncode;
      }
    });
    var message_js_1 = /*@__PURE__*/requireMessage();
    Object.defineProperty(exports, "hashMessage", {
      enumerable: true,
      get: function get() {
        return message_js_1.hashMessage;
      }
    });
    Object.defineProperty(exports, "verifyMessage", {
      enumerable: true,
      get: function get() {
        return message_js_1.verifyMessage;
      }
    });
    var solidity_js_1 = /*@__PURE__*/requireSolidity();
    Object.defineProperty(exports, "solidityPacked", {
      enumerable: true,
      get: function get() {
        return solidity_js_1.solidityPacked;
      }
    });
    Object.defineProperty(exports, "solidityPackedKeccak256", {
      enumerable: true,
      get: function get() {
        return solidity_js_1.solidityPackedKeccak256;
      }
    });
    Object.defineProperty(exports, "solidityPackedSha256", {
      enumerable: true,
      get: function get() {
        return solidity_js_1.solidityPackedSha256;
      }
    });
    var typed_data_js_1 = /*@__PURE__*/requireTypedData();
    Object.defineProperty(exports, "TypedDataEncoder", {
      enumerable: true,
      get: function get() {
        return typed_data_js_1.TypedDataEncoder;
      }
    });
    Object.defineProperty(exports, "verifyTypedData", {
      enumerable: true,
      get: function get() {
        return typed_data_js_1.verifyTypedData;
      }
    });
  })(hash);
  return hash;
}

var hasRequiredFragments;
function requireFragments() {
  var _TokenString;
  if (hasRequiredFragments) return fragments;
  hasRequiredFragments = 1;
  /**
   *  A fragment is a single item from an ABI, which may represent any of:
   *
   *  - [Functions](FunctionFragment)
   *  - [Events](EventFragment)
   *  - [Constructors](ConstructorFragment)
   *  - Custom [Errors](ErrorFragment)
   *  - [Fallback or Receive](FallbackFragment) functions
   *
   *  @_subsection api/abi/abi-coder:Fragments  [about-fragments]
   */
  Object.defineProperty(fragments, "__esModule", {
    value: true
  });
  fragments.StructFragment = fragments.FunctionFragment = fragments.FallbackFragment = fragments.ConstructorFragment = fragments.EventFragment = fragments.ErrorFragment = fragments.NamedFragment = fragments.Fragment = fragments.ParamType = void 0;
  var index_js_1 = /*@__PURE__*/requireUtils$3();
  var index_js_2 = /*@__PURE__*/requireHash();
  // [ "a", "b" ] => { "a": 1, "b": 1 }
  function setify(items) {
    var result = new Set();
    items.forEach(function (k) {
      return result.add(k);
    });
    return Object.freeze(result);
  }
  var _kwVisibDeploy = "external public payable override";
  var KwVisibDeploy = setify(_kwVisibDeploy.split(" "));
  // Visibility Keywords
  var _kwVisib = "constant external internal payable private public pure view override";
  var KwVisib = setify(_kwVisib.split(" "));
  var _kwTypes = "constructor error event fallback function receive struct";
  var KwTypes = setify(_kwTypes.split(" "));
  var _kwModifiers = "calldata memory storage payable indexed";
  var KwModifiers = setify(_kwModifiers.split(" "));
  var _kwOther = "tuple returns";
  // All Keywords
  var _keywords = [_kwTypes, _kwModifiers, _kwOther, _kwVisib].join(" ");
  var Keywords = setify(_keywords.split(" "));
  // Single character tokens
  var SimpleTokens = {
    "(": "OPEN_PAREN",
    ")": "CLOSE_PAREN",
    "[": "OPEN_BRACKET",
    "]": "CLOSE_BRACKET",
    ",": "COMMA",
    "@": "AT"
  };
  // Parser regexes to consume the next token
  var regexWhitespacePrefix = new RegExp("^(\\s*)");
  var regexNumberPrefix = new RegExp("^([0-9]+)");
  var regexIdPrefix = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)");
  // Parser regexs to check validity
  var regexId = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)$");
  var regexType = new RegExp("^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$");
  var _offset = /*#__PURE__*/new WeakMap();
  var _tokens = /*#__PURE__*/new WeakMap();
  var _TokenString_brand = /*#__PURE__*/new WeakSet();
  var TokenString = /*#__PURE__*/function () {
    function TokenString(tokens) {
      _classCallCheck(this, TokenString);
      _classPrivateMethodInitSpec(this, _TokenString_brand);
      _classPrivateFieldInitSpec(this, _offset, void 0);
      _classPrivateFieldInitSpec(this, _tokens, void 0);
      _classPrivateFieldSet2(_offset, this, 0);
      _classPrivateFieldSet2(_tokens, this, tokens.slice());
    }
    return _createClass(TokenString, [{
      key: "offset",
      get: function get() {
        return _classPrivateFieldGet2(_offset, this);
      }
    }, {
      key: "length",
      get: function get() {
        return _classPrivateFieldGet2(_tokens, this).length - _classPrivateFieldGet2(_offset, this);
      }
    }, {
      key: "clone",
      value: function clone() {
        return new TokenString(_classPrivateFieldGet2(_tokens, this));
      }
    }, {
      key: "reset",
      value: function reset() {
        _classPrivateFieldSet2(_offset, this, 0);
      }
    }, {
      key: "popKeyword",
      value:
      // Pops and returns the value of the next token, if it is a keyword in allowed; throws if out of tokens
      function popKeyword(allowed) {
        var top = this.peek();
        if (top.type !== "KEYWORD" || !allowed.has(top.text)) {
          throw new Error("expected keyword ".concat(top.text));
        }
        return this.pop().text;
      }
      // Pops and returns the value of the next token if it is `type`; throws if out of tokens
    }, {
      key: "popType",
      value: function popType(type) {
        if (this.peek().type !== type) {
          var top = this.peek();
          throw new Error("expected ".concat(type, "; got ").concat(top.type, " ").concat(JSON.stringify(top.text)));
        }
        return this.pop().text;
      }
      // Pops and returns a "(" TOKENS ")"
    }, {
      key: "popParen",
      value: function popParen() {
        var top = this.peek();
        if (top.type !== "OPEN_PAREN") {
          throw new Error("bad start");
        }
        var result = _assertClassBrand(_TokenString_brand, this, _subTokenString).call(this, _classPrivateFieldGet2(_offset, this) + 1, top.match + 1);
        _classPrivateFieldSet2(_offset, this, top.match + 1);
        return result;
      }
      // Pops and returns the items within "(" ITEM1 "," ITEM2 "," ... ")"
    }, {
      key: "popParams",
      value: function popParams() {
        var top = this.peek();
        if (top.type !== "OPEN_PAREN") {
          throw new Error("bad start");
        }
        var result = [];
        while (_classPrivateFieldGet2(_offset, this) < top.match - 1) {
          var link = this.peek().linkNext;
          result.push(_assertClassBrand(_TokenString_brand, this, _subTokenString).call(this, _classPrivateFieldGet2(_offset, this) + 1, link));
          _classPrivateFieldSet2(_offset, this, link);
        }
        _classPrivateFieldSet2(_offset, this, top.match + 1);
        return result;
      }
      // Returns the top Token, throwing if out of tokens
    }, {
      key: "peek",
      value: function peek() {
        if (_classPrivateFieldGet2(_offset, this) >= _classPrivateFieldGet2(_tokens, this).length) {
          throw new Error("out-of-bounds");
        }
        return _classPrivateFieldGet2(_tokens, this)[_classPrivateFieldGet2(_offset, this)];
      }
      // Returns the next value, if it is a keyword in `allowed`
    }, {
      key: "peekKeyword",
      value: function peekKeyword(allowed) {
        var top = this.peekType("KEYWORD");
        return top != null && allowed.has(top) ? top : null;
      }
      // Returns the value of the next token if it is `type`
    }, {
      key: "peekType",
      value: function peekType(type) {
        if (this.length === 0) {
          return null;
        }
        var top = this.peek();
        return top.type === type ? top.text : null;
      }
      // Returns the next token; throws if out of tokens
    }, {
      key: "pop",
      value: function pop() {
        var _this$offset;
        var result = this.peek();
        _classPrivateFieldSet2(_offset, this, (_this$offset = _classPrivateFieldGet2(_offset, this), _this$offset++, _this$offset));
        return result;
      }
    }, {
      key: "toString",
      value: function toString() {
        var tokens = [];
        for (var i = _classPrivateFieldGet2(_offset, this); i < _classPrivateFieldGet2(_tokens, this).length; i++) {
          var token = _classPrivateFieldGet2(_tokens, this)[i];
          tokens.push("".concat(token.type, ":").concat(token.text));
        }
        return "<TokenString ".concat(tokens.join(" "), ">");
      }
    }]);
  }();
  _TokenString = TokenString;
  function _subTokenString() {
    var from = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    return new _TokenString(_classPrivateFieldGet2(_tokens, this).slice(from, to).map(function (t) {
      return Object.freeze(Object.assign({}, t, {
        match: t.match - from,
        linkBack: t.linkBack - from,
        linkNext: t.linkNext - from
      }));
    }));
  }
  function lex(text) {
    var tokens = [];
    var throwError = function throwError(message) {
      var token = offset < text.length ? JSON.stringify(text[offset]) : "$EOI";
      throw new Error("invalid token ".concat(token, " at ").concat(offset, ": ").concat(message));
    };
    var brackets = [];
    var commas = [];
    var offset = 0;
    while (offset < text.length) {
      // Strip off any leading whitespace
      var cur = text.substring(offset);
      var match = cur.match(regexWhitespacePrefix);
      if (match) {
        offset += match[1].length;
        cur = text.substring(offset);
      }
      var token = {
        depth: brackets.length,
        linkBack: -1,
        linkNext: -1,
        match: -1,
        type: "",
        text: "",
        offset: offset,
        value: -1
      };
      tokens.push(token);
      var type = SimpleTokens[cur[0]] || "";
      if (type) {
        token.type = type;
        token.text = cur[0];
        offset++;
        if (type === "OPEN_PAREN") {
          brackets.push(tokens.length - 1);
          commas.push(tokens.length - 1);
        } else if (type == "CLOSE_PAREN") {
          if (brackets.length === 0) {
            throwError("no matching open bracket");
          }
          token.match = brackets.pop();
          tokens[token.match].match = tokens.length - 1;
          token.depth--;
          token.linkBack = commas.pop();
          tokens[token.linkBack].linkNext = tokens.length - 1;
        } else if (type === "COMMA") {
          token.linkBack = commas.pop();
          tokens[token.linkBack].linkNext = tokens.length - 1;
          commas.push(tokens.length - 1);
        } else if (type === "OPEN_BRACKET") {
          token.type = "BRACKET";
        } else if (type === "CLOSE_BRACKET") {
          // Remove the CLOSE_BRACKET
          var suffix = tokens.pop().text;
          if (tokens.length > 0 && tokens[tokens.length - 1].type === "NUMBER") {
            var value = tokens.pop().text;
            suffix = value + suffix;
            tokens[tokens.length - 1].value = (0, index_js_1.getNumber)(value);
          }
          if (tokens.length === 0 || tokens[tokens.length - 1].type !== "BRACKET") {
            throw new Error("missing opening bracket");
          }
          tokens[tokens.length - 1].text += suffix;
        }
        continue;
      }
      match = cur.match(regexIdPrefix);
      if (match) {
        token.text = match[1];
        offset += token.text.length;
        if (Keywords.has(token.text)) {
          token.type = "KEYWORD";
          continue;
        }
        if (token.text.match(regexType)) {
          token.type = "TYPE";
          continue;
        }
        token.type = "ID";
        continue;
      }
      match = cur.match(regexNumberPrefix);
      if (match) {
        token.text = match[1];
        token.type = "NUMBER";
        offset += token.text.length;
        continue;
      }
      throw new Error("unexpected token ".concat(JSON.stringify(cur[0]), " at position ").concat(offset));
    }
    return new TokenString(tokens.map(function (t) {
      return Object.freeze(t);
    }));
  }
  // Check only one of `allowed` is in `set`
  function allowSingle(set, allowed) {
    var included = [];
    for (var key in allowed.keys()) {
      if (set.has(key)) {
        included.push(key);
      }
    }
    if (included.length > 1) {
      throw new Error("conflicting types: ".concat(included.join(", ")));
    }
  }
  // Functions to process a Solidity Signature TokenString from left-to-right for...
  // ...the name with an optional type, returning the name
  function consumeName(type, tokens) {
    if (tokens.peekKeyword(KwTypes)) {
      var keyword = tokens.pop().text;
      if (keyword !== type) {
        throw new Error("expected ".concat(type, ", got ").concat(keyword));
      }
    }
    return tokens.popType("ID");
  }
  // ...all keywords matching allowed, returning the keywords
  function consumeKeywords(tokens, allowed) {
    var keywords = new Set();
    while (true) {
      var keyword = tokens.peekType("KEYWORD");
      if (keyword == null || allowed && !allowed.has(keyword)) {
        break;
      }
      tokens.pop();
      if (keywords.has(keyword)) {
        throw new Error("duplicate keywords: ".concat(JSON.stringify(keyword)));
      }
      keywords.add(keyword);
    }
    return Object.freeze(keywords);
  }
  // ...all visibility keywords, returning the coalesced mutability
  function consumeMutability(tokens) {
    var modifiers = consumeKeywords(tokens, KwVisib);
    // Detect conflicting modifiers
    allowSingle(modifiers, setify("constant payable nonpayable".split(" ")));
    allowSingle(modifiers, setify("pure view payable nonpayable".split(" ")));
    // Process mutability states
    if (modifiers.has("view")) {
      return "view";
    }
    if (modifiers.has("pure")) {
      return "pure";
    }
    if (modifiers.has("payable")) {
      return "payable";
    }
    if (modifiers.has("nonpayable")) {
      return "nonpayable";
    }
    // Process legacy `constant` last
    if (modifiers.has("constant")) {
      return "view";
    }
    return "nonpayable";
  }
  // ...a parameter list, returning the ParamType list
  function consumeParams(tokens, allowIndexed) {
    return tokens.popParams().map(function (t) {
      return ParamType.from(t, allowIndexed);
    });
  }
  // ...a gas limit, returning a BigNumber or null if none
  function consumeGas(tokens) {
    if (tokens.peekType("AT")) {
      tokens.pop();
      if (tokens.peekType("NUMBER")) {
        return (0, index_js_1.getBigInt)(tokens.pop().text);
      }
      throw new Error("invalid gas");
    }
    return null;
  }
  function consumeEoi(tokens) {
    if (tokens.length) {
      throw new Error("unexpected tokens at offset ".concat(tokens.offset, ": ").concat(tokens.toString()));
    }
  }
  var regexArrayType = new RegExp(/^(.*)\[([0-9]*)\]$/);
  function verifyBasicType(type) {
    var match = type.match(regexType);
    (0, index_js_1.assertArgument)(match, "invalid type", "type", type);
    if (type === "uint") {
      return "uint256";
    }
    if (type === "int") {
      return "int256";
    }
    if (match[2]) {
      // bytesXX
      var length = parseInt(match[2]);
      (0, index_js_1.assertArgument)(length !== 0 && length <= 32, "invalid bytes length", "type", type);
    } else if (match[3]) {
      // intXX or uintXX
      var size = parseInt(match[3]);
      (0, index_js_1.assertArgument)(size !== 0 && size <= 256 && size % 8 === 0, "invalid numeric width", "type", type);
    }
    return type;
  }
  // Make the Fragment constructors effectively private
  var _guard = {};
  var internal = Symbol["for"]("_ethers_internal");
  var ParamTypeInternal = "_ParamTypeInternal";
  var ErrorFragmentInternal = "_ErrorInternal";
  var EventFragmentInternal = "_EventInternal";
  var ConstructorFragmentInternal = "_ConstructorInternal";
  var FallbackFragmentInternal = "_FallbackInternal";
  var FunctionFragmentInternal = "_FunctionInternal";
  var StructFragmentInternal = "_StructInternal";
  /**
   *  Each input and output of a [[Fragment]] is an Array of **ParamType**.
   */
  var _ParamType_brand = /*#__PURE__*/new WeakSet();
  var ParamType = /*#__PURE__*/function () {
    /**
     *  @private
     */
    function ParamType(guard, name, type, baseType, indexed, _components, arrayLength, arrayChildren) {
      _classCallCheck(this, ParamType);
      _classPrivateMethodInitSpec(this, _ParamType_brand);
      /**
       *  The local name of the parameter (or ``""`` if unbound)
       */
      _defineProperty(this, "name", void 0);
      /**
       *  The fully qualified type (e.g. ``"address"``, ``"tuple(address)"``,
       *  ``"uint256[3][]"``)
       */
      _defineProperty(this, "type", void 0);
      /**
       *  The base type (e.g. ``"address"``, ``"tuple"``, ``"array"``)
       */
      _defineProperty(this, "baseType", void 0);
      /**
       *  True if the parameters is indexed.
       *
       *  For non-indexable types this is ``null``.
       */
      _defineProperty(this, "indexed", void 0);
      /**
       *  The components for the tuple.
       *
       *  For non-tuple types this is ``null``.
       */
      _defineProperty(this, "components", void 0);
      /**
       *  The array length, or ``-1`` for dynamic-lengthed arrays.
       *
       *  For non-array types this is ``null``.
       */
      _defineProperty(this, "arrayLength", void 0);
      /**
       *  The type of each child in the array.
       *
       *  For non-array types this is ``null``.
       */
      _defineProperty(this, "arrayChildren", void 0);
      (0, index_js_1.assertPrivate)(guard, _guard, "ParamType");
      Object.defineProperty(this, internal, {
        value: ParamTypeInternal
      });
      if (_components) {
        _components = Object.freeze(_components.slice());
      }
      if (baseType === "array") {
        if (arrayLength == null || arrayChildren == null) {
          throw new Error("");
        }
      } else if (arrayLength != null || arrayChildren != null) {
        throw new Error("");
      }
      if (baseType === "tuple") {
        if (_components == null) {
          throw new Error("");
        }
      } else if (_components != null) {
        throw new Error("");
      }
      (0, index_js_1.defineProperties)(this, {
        name: name,
        type: type,
        baseType: baseType,
        indexed: indexed,
        components: _components,
        arrayLength: arrayLength,
        arrayChildren: arrayChildren
      });
    }
    /**
     *  Return a string representation of this type.
     *
     *  For example,
     *
     *  ``sighash" => "(uint256,address)"``
     *
     *  ``"minimal" => "tuple(uint256,address) indexed"``
     *
     *  ``"full" => "tuple(uint256 foo, address bar) indexed baz"``
     */
    return _createClass(ParamType, [{
      key: "format",
      value: function format(_format) {
        if (_format == null) {
          _format = "sighash";
        }
        if (_format === "json") {
          var name = this.name || "";
          if (this.isArray()) {
            var _result = JSON.parse(this.arrayChildren.format("json"));
            _result.name = name;
            _result.type += "[".concat(this.arrayLength < 0 ? "" : String(this.arrayLength), "]");
            return JSON.stringify(_result);
          }
          var _result2 = {
            type: this.baseType === "tuple" ? "tuple" : this.type,
            name: name
          };
          if (typeof this.indexed === "boolean") {
            _result2.indexed = this.indexed;
          }
          if (this.isTuple()) {
            _result2.components = this.components.map(function (c) {
              return JSON.parse(c.format(_format));
            });
          }
          return JSON.stringify(_result2);
        }
        var result = "";
        // Array
        if (this.isArray()) {
          result += this.arrayChildren.format(_format);
          result += "[".concat(this.arrayLength < 0 ? "" : String(this.arrayLength), "]");
        } else {
          if (this.isTuple()) {
            result += "(" + this.components.map(function (comp) {
              return comp.format(_format);
            }).join(_format === "full" ? ", " : ",") + ")";
          } else {
            result += this.type;
          }
        }
        if (_format !== "sighash") {
          if (this.indexed === true) {
            result += " indexed";
          }
          if (_format === "full" && this.name) {
            result += " " + this.name;
          }
        }
        return result;
      }
      /**
       *  Returns true if %%this%% is an Array type.
       *
       *  This provides a type gaurd ensuring that [[arrayChildren]]
       *  and [[arrayLength]] are non-null.
       */
    }, {
      key: "isArray",
      value: function isArray() {
        return this.baseType === "array";
      }
      /**
       *  Returns true if %%this%% is a Tuple type.
       *
       *  This provides a type gaurd ensuring that [[components]]
       *  is non-null.
       */
    }, {
      key: "isTuple",
      value: function isTuple() {
        return this.baseType === "tuple";
      }
      /**
       *  Returns true if %%this%% is an Indexable type.
       *
       *  This provides a type gaurd ensuring that [[indexed]]
       *  is non-null.
       */
    }, {
      key: "isIndexable",
      value: function isIndexable() {
        return this.indexed != null;
      }
      /**
       *  Walks the **ParamType** with %%value%%, calling %%process%%
       *  on each type, destructing the %%value%% recursively.
       */
    }, {
      key: "walk",
      value: function walk(value, process) {
        if (this.isArray()) {
          if (!Array.isArray(value)) {
            throw new Error("invalid array value");
          }
          if (this.arrayLength !== -1 && value.length !== this.arrayLength) {
            throw new Error("array is wrong length");
          }
          var _this = this;
          return value.map(function (v) {
            return _this.arrayChildren.walk(v, process);
          });
        }
        if (this.isTuple()) {
          if (!Array.isArray(value)) {
            throw new Error("invalid tuple value");
          }
          if (value.length !== this.components.length) {
            throw new Error("array is wrong length");
          }
          var _this2 = this;
          return value.map(function (v, i) {
            return _this2.components[i].walk(v, process);
          });
        }
        return process(this.type, value);
      }
    }, {
      key: "walkAsync",
      value: (
      /**
       *  Walks the **ParamType** with %%value%%, asynchronously calling
       *  %%process%% on each type, destructing the %%value%% recursively.
       *
       *  This can be used to resolve ENS names by walking and resolving each
       *  ``"address"`` type.
       */
      function () {
        var _walkAsync2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(value, process) {
          var promises, result;
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                promises = [];
                result = [value];
                _assertClassBrand(_ParamType_brand, this, _walkAsync).call(this, promises, value, process, function (value) {
                  result[0] = value;
                });
                if (!promises.length) {
                  _context.next = 6;
                  break;
                }
                _context.next = 6;
                return Promise.all(promises);
              case 6:
                return _context.abrupt("return", result[0]);
              case 7:
              case "end":
                return _context.stop();
            }
          }, _callee, this);
        }));
        function walkAsync(_x, _x2) {
          return _walkAsync2.apply(this, arguments);
        }
        return walkAsync;
      }()
      /**
       *  Creates a new **ParamType** for %%obj%%.
       *
       *  If %%allowIndexed%% then the ``indexed`` keyword is permitted,
       *  otherwise the ``indexed`` keyword will throw an error.
       */
      )
    }], [{
      key: "from",
      value: function from(obj, allowIndexed) {
        if (ParamType.isParamType(obj)) {
          return obj;
        }
        if (typeof obj === "string") {
          try {
            return ParamType.from(lex(obj), allowIndexed);
          } catch (error) {
            (0, index_js_1.assertArgument)(false, "invalid param type", "obj", obj);
          }
        } else if (obj instanceof TokenString) {
          var _type = "",
            baseType = "";
          var comps = null;
          if (consumeKeywords(obj, setify(["tuple"])).has("tuple") || obj.peekType("OPEN_PAREN")) {
            // Tuple
            baseType = "tuple";
            comps = obj.popParams().map(function (t) {
              return ParamType.from(t);
            });
            _type = "tuple(".concat(comps.map(function (c) {
              return c.format();
            }).join(","), ")");
          } else {
            // Normal
            _type = verifyBasicType(obj.popType("TYPE"));
            baseType = _type;
          }
          // Check for Array
          var arrayChildren = null;
          var arrayLength = null;
          while (obj.length && obj.peekType("BRACKET")) {
            var bracket = obj.pop(); //arrays[i];
            arrayChildren = new ParamType(_guard, "", _type, baseType, null, comps, arrayLength, arrayChildren);
            arrayLength = bracket.value;
            _type += bracket.text;
            baseType = "array";
            comps = null;
          }
          var _indexed = null;
          var keywords = consumeKeywords(obj, KwModifiers);
          if (keywords.has("indexed")) {
            if (!allowIndexed) {
              throw new Error("");
            }
            _indexed = true;
          }
          var _name = obj.peekType("ID") ? obj.pop().text : "";
          if (obj.length) {
            throw new Error("leftover tokens");
          }
          return new ParamType(_guard, _name, _type, baseType, _indexed, comps, arrayLength, arrayChildren);
        }
        var name = obj.name;
        (0, index_js_1.assertArgument)(!name || typeof name === "string" && name.match(regexId), "invalid name", "obj.name", name);
        var indexed = obj.indexed;
        if (indexed != null) {
          (0, index_js_1.assertArgument)(allowIndexed, "parameter cannot be indexed", "obj.indexed", obj.indexed);
          indexed = !!indexed;
        }
        var type = obj.type;
        var arrayMatch = type.match(regexArrayType);
        if (arrayMatch) {
          var _arrayLength = parseInt(arrayMatch[2] || "-1");
          var _arrayChildren = ParamType.from({
            type: arrayMatch[1],
            components: obj.components
          });
          return new ParamType(_guard, name || "", type, "array", indexed, null, _arrayLength, _arrayChildren);
        }
        if (type === "tuple" || type.startsWith("tuple(" /* fix: ) */) || type.startsWith("(" /* fix: ) */)) {
          var _comps = obj.components != null ? obj.components.map(function (c) {
            return ParamType.from(c);
          }) : null;
          var tuple = new ParamType(_guard, name || "", type, "tuple", indexed, _comps, null, null);
          // @TODO: use lexer to validate and normalize type
          return tuple;
        }
        type = verifyBasicType(obj.type);
        return new ParamType(_guard, name || "", type, type, indexed, null, null, null);
      }
      /**
       *  Returns true if %%value%% is a **ParamType**.
       */
    }, {
      key: "isParamType",
      value: function isParamType(value) {
        return value && value[internal] === ParamTypeInternal;
      }
    }]);
  }();
  function _walkAsync(promises, value, process, setValue) {
    if (this.isArray()) {
      if (!Array.isArray(value)) {
        throw new Error("invalid array value");
      }
      if (this.arrayLength !== -1 && value.length !== this.arrayLength) {
        throw new Error("array is wrong length");
      }
      var childType = this.arrayChildren;
      var _result3 = value.slice();
      _result3.forEach(function (value, index) {
        _assertClassBrand(_ParamType_brand, childType, _walkAsync).call(childType, promises, value, process, function (value) {
          _result3[index] = value;
        });
      });
      setValue(_result3);
      return;
    }
    if (this.isTuple()) {
      var components = this.components;
      // Convert the object into an array
      var _result4;
      if (Array.isArray(value)) {
        _result4 = value.slice();
      } else {
        if (value == null || _typeof(value) !== "object") {
          throw new Error("invalid tuple value");
        }
        _result4 = components.map(function (param) {
          if (!param.name) {
            throw new Error("cannot use object value with unnamed components");
          }
          if (!(param.name in value)) {
            throw new Error("missing value for component ".concat(param.name));
          }
          return value[param.name];
        });
      }
      if (_result4.length !== this.components.length) {
        throw new Error("array is wrong length");
      }
      _result4.forEach(function (value, index) {
        var _components$index;
        _assertClassBrand(_ParamType_brand, _components$index = components[index], _walkAsync).call(_components$index, promises, value, process, function (value) {
          _result4[index] = value;
        });
      });
      setValue(_result4);
      return;
    }
    var result = process(this.type, value);
    if (result.then) {
      promises.push(_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.t0 = setValue;
              _context2.next = 3;
              return result;
            case 3:
              _context2.t1 = _context2.sent;
              (0, _context2.t0)(_context2.t1);
            case 5:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      }))());
    } else {
      setValue(result);
    }
  }
  fragments.ParamType = ParamType;
  /**
   *  An abstract class to represent An individual fragment from a parse ABI.
   */
  var Fragment = /*#__PURE__*/function () {
    /**
     *  @private
     */
    function Fragment(guard, type, inputs) {
      _classCallCheck(this, Fragment);
      /**
       *  The type of the fragment.
       */
      _defineProperty(this, "type", void 0);
      /**
       *  The inputs for the fragment.
       */
      _defineProperty(this, "inputs", void 0);
      (0, index_js_1.assertPrivate)(guard, _guard, "Fragment");
      inputs = Object.freeze(inputs.slice());
      (0, index_js_1.defineProperties)(this, {
        type: type,
        inputs: inputs
      });
    }
    /**
     *  Creates a new **Fragment** for %%obj%%, wich can be any supported
     *  ABI frgament type.
     */
    return _createClass(Fragment, null, [{
      key: "from",
      value: function from(obj) {
        if (typeof obj === "string") {
          // Try parsing JSON...
          try {
            Fragment.from(JSON.parse(obj));
          } catch (e) {}
          // ...otherwise, use the human-readable lexer
          return Fragment.from(lex(obj));
        }
        if (obj instanceof TokenString) {
          // Human-readable ABI (already lexed)
          var type = obj.peekKeyword(KwTypes);
          switch (type) {
            case "constructor":
              return ConstructorFragment.from(obj);
            case "error":
              return ErrorFragment.from(obj);
            case "event":
              return EventFragment.from(obj);
            case "fallback":
            case "receive":
              return FallbackFragment.from(obj);
            case "function":
              return FunctionFragment.from(obj);
            case "struct":
              return StructFragment.from(obj);
          }
        } else if (_typeof(obj) === "object") {
          // JSON ABI
          switch (obj.type) {
            case "constructor":
              return ConstructorFragment.from(obj);
            case "error":
              return ErrorFragment.from(obj);
            case "event":
              return EventFragment.from(obj);
            case "fallback":
            case "receive":
              return FallbackFragment.from(obj);
            case "function":
              return FunctionFragment.from(obj);
            case "struct":
              return StructFragment.from(obj);
          }
          (0, index_js_1.assert)(false, "unsupported type: ".concat(obj.type), "UNSUPPORTED_OPERATION", {
            operation: "Fragment.from"
          });
        }
        (0, index_js_1.assertArgument)(false, "unsupported frgament object", "obj", obj);
      }
      /**
       *  Returns true if %%value%% is a [[ConstructorFragment]].
       */
    }, {
      key: "isConstructor",
      value: function isConstructor(value) {
        return ConstructorFragment.isFragment(value);
      }
      /**
       *  Returns true if %%value%% is an [[ErrorFragment]].
       */
    }, {
      key: "isError",
      value: function isError(value) {
        return ErrorFragment.isFragment(value);
      }
      /**
       *  Returns true if %%value%% is an [[EventFragment]].
       */
    }, {
      key: "isEvent",
      value: function isEvent(value) {
        return EventFragment.isFragment(value);
      }
      /**
       *  Returns true if %%value%% is a [[FunctionFragment]].
       */
    }, {
      key: "isFunction",
      value: function isFunction(value) {
        return FunctionFragment.isFragment(value);
      }
      /**
       *  Returns true if %%value%% is a [[StructFragment]].
       */
    }, {
      key: "isStruct",
      value: function isStruct(value) {
        return StructFragment.isFragment(value);
      }
    }]);
  }();
  fragments.Fragment = Fragment;
  /**
   *  An abstract class to represent An individual fragment
   *  which has a name from a parse ABI.
   */
  var NamedFragment = /*#__PURE__*/function (_Fragment2) {
    /**
     *  @private
     */
    function NamedFragment(guard, type, name, inputs) {
      var _this3;
      _classCallCheck(this, NamedFragment);
      _this3 = _callSuper(this, NamedFragment, [guard, type, inputs]);
      /**
       *  The name of the fragment.
       */
      _defineProperty(_this3, "name", void 0);
      (0, index_js_1.assertArgument)(typeof name === "string" && name.match(regexId), "invalid identifier", "name", name);
      inputs = Object.freeze(inputs.slice());
      (0, index_js_1.defineProperties)(_this3, {
        name: name
      });
      return _this3;
    }
    _inherits(NamedFragment, _Fragment2);
    return _createClass(NamedFragment);
  }(Fragment);
  fragments.NamedFragment = NamedFragment;
  function joinParams(format, params) {
    return "(" + params.map(function (p) {
      return p.format(format);
    }).join(format === "full" ? ", " : ",") + ")";
  }
  /**
   *  A Fragment which represents a //Custom Error//.
   */
  var ErrorFragment = /*#__PURE__*/function (_NamedFragment2) {
    /**
     *  @private
     */
    function ErrorFragment(guard, name, inputs) {
      var _this4;
      _classCallCheck(this, ErrorFragment);
      _this4 = _callSuper(this, ErrorFragment, [guard, "error", name, inputs]);
      Object.defineProperty(_this4, internal, {
        value: ErrorFragmentInternal
      });
      return _this4;
    }
    /**
     *  The Custom Error selector.
     */
    _inherits(ErrorFragment, _NamedFragment2);
    return _createClass(ErrorFragment, [{
      key: "selector",
      get: function get() {
        return (0, index_js_2.id)(this.format("sighash")).substring(0, 10);
      }
      /**
       *  Returns a string representation of this fragment as %%format%%.
       */
    }, {
      key: "format",
      value: function format(_format2) {
        if (_format2 == null) {
          _format2 = "sighash";
        }
        if (_format2 === "json") {
          return JSON.stringify({
            type: "error",
            name: this.name,
            inputs: this.inputs.map(function (input) {
              return JSON.parse(input.format(_format2));
            })
          });
        }
        var result = [];
        if (_format2 !== "sighash") {
          result.push("error");
        }
        result.push(this.name + joinParams(_format2, this.inputs));
        return result.join(" ");
      }
      /**
       *  Returns a new **ErrorFragment** for %%obj%%.
       */
    }], [{
      key: "from",
      value: function from(obj) {
        if (ErrorFragment.isFragment(obj)) {
          return obj;
        }
        if (typeof obj === "string") {
          return ErrorFragment.from(lex(obj));
        } else if (obj instanceof TokenString) {
          var name = consumeName("error", obj);
          var inputs = consumeParams(obj);
          consumeEoi(obj);
          return new ErrorFragment(_guard, name, inputs);
        }
        return new ErrorFragment(_guard, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);
      }
      /**
       *  Returns ``true`` and provides a type guard if %%value%% is an
       *  **ErrorFragment**.
       */
    }, {
      key: "isFragment",
      value: function isFragment(value) {
        return value && value[internal] === ErrorFragmentInternal;
      }
    }]);
  }(NamedFragment);
  fragments.ErrorFragment = ErrorFragment;
  /**
   *  A Fragment which represents an Event.
   */
  var EventFragment = /*#__PURE__*/function (_NamedFragment3) {
    /**
     *  @private
     */
    function EventFragment(guard, name, inputs, anonymous) {
      var _this5;
      _classCallCheck(this, EventFragment);
      _this5 = _callSuper(this, EventFragment, [guard, "event", name, inputs]);
      /**
       *  Whether this event is anonymous.
       */
      _defineProperty(_this5, "anonymous", void 0);
      Object.defineProperty(_this5, internal, {
        value: EventFragmentInternal
      });
      (0, index_js_1.defineProperties)(_this5, {
        anonymous: anonymous
      });
      return _this5;
    }
    /**
     *  The Event topic hash.
     */
    _inherits(EventFragment, _NamedFragment3);
    return _createClass(EventFragment, [{
      key: "topicHash",
      get: function get() {
        return (0, index_js_2.id)(this.format("sighash"));
      }
      /**
       *  Returns a string representation of this event as %%format%%.
       */
    }, {
      key: "format",
      value: function format(_format3) {
        if (_format3 == null) {
          _format3 = "sighash";
        }
        if (_format3 === "json") {
          return JSON.stringify({
            type: "event",
            anonymous: this.anonymous,
            name: this.name,
            inputs: this.inputs.map(function (i) {
              return JSON.parse(i.format(_format3));
            })
          });
        }
        var result = [];
        if (_format3 !== "sighash") {
          result.push("event");
        }
        result.push(this.name + joinParams(_format3, this.inputs));
        if (_format3 !== "sighash" && this.anonymous) {
          result.push("anonymous");
        }
        return result.join(" ");
      }
      /**
       *  Return the topic hash for an event with %%name%% and %%params%%.
       */
    }], [{
      key: "getTopicHash",
      value: function getTopicHash(name, params) {
        params = (params || []).map(function (p) {
          return ParamType.from(p);
        });
        var fragment = new EventFragment(_guard, name, params, false);
        return fragment.topicHash;
      }
      /**
       *  Returns a new **EventFragment** for %%obj%%.
       */
    }, {
      key: "from",
      value: function from(obj) {
        if (EventFragment.isFragment(obj)) {
          return obj;
        }
        if (typeof obj === "string") {
          try {
            return EventFragment.from(lex(obj));
          } catch (error) {
            (0, index_js_1.assertArgument)(false, "invalid event fragment", "obj", obj);
          }
        } else if (obj instanceof TokenString) {
          var name = consumeName("event", obj);
          var inputs = consumeParams(obj, true);
          var anonymous = !!consumeKeywords(obj, setify(["anonymous"])).has("anonymous");
          consumeEoi(obj);
          return new EventFragment(_guard, name, inputs, anonymous);
        }
        return new EventFragment(_guard, obj.name, obj.inputs ? obj.inputs.map(function (p) {
          return ParamType.from(p, true);
        }) : [], !!obj.anonymous);
      }
      /**
       *  Returns ``true`` and provides a type guard if %%value%% is an
       *  **EventFragment**.
       */
    }, {
      key: "isFragment",
      value: function isFragment(value) {
        return value && value[internal] === EventFragmentInternal;
      }
    }]);
  }(NamedFragment);
  fragments.EventFragment = EventFragment;
  /**
   *  A Fragment which represents a constructor.
   */
  var ConstructorFragment = /*#__PURE__*/function (_Fragment3) {
    /**
     *  @private
     */
    function ConstructorFragment(guard, type, inputs, payable, gas) {
      var _this6;
      _classCallCheck(this, ConstructorFragment);
      _this6 = _callSuper(this, ConstructorFragment, [guard, type, inputs]);
      /**
       *  Whether the constructor can receive an endowment.
       */
      _defineProperty(_this6, "payable", void 0);
      /**
       *  The recommended gas limit for deployment or ``null``.
       */
      _defineProperty(_this6, "gas", void 0);
      Object.defineProperty(_this6, internal, {
        value: ConstructorFragmentInternal
      });
      (0, index_js_1.defineProperties)(_this6, {
        payable: payable,
        gas: gas
      });
      return _this6;
    }
    /**
     *  Returns a string representation of this constructor as %%format%%.
     */
    _inherits(ConstructorFragment, _Fragment3);
    return _createClass(ConstructorFragment, [{
      key: "format",
      value: function format(_format4) {
        (0, index_js_1.assert)(_format4 != null && _format4 !== "sighash", "cannot format a constructor for sighash", "UNSUPPORTED_OPERATION", {
          operation: "format(sighash)"
        });
        if (_format4 === "json") {
          return JSON.stringify({
            type: "constructor",
            stateMutability: this.payable ? "payable" : "undefined",
            payable: this.payable,
            gas: this.gas != null ? this.gas : undefined,
            inputs: this.inputs.map(function (i) {
              return JSON.parse(i.format(_format4));
            })
          });
        }
        var result = ["constructor".concat(joinParams(_format4, this.inputs))];
        if (this.payable) {
          result.push("payable");
        }
        if (this.gas != null) {
          result.push("@".concat(this.gas.toString()));
        }
        return result.join(" ");
      }
      /**
       *  Returns a new **ConstructorFragment** for %%obj%%.
       */
    }], [{
      key: "from",
      value: function from(obj) {
        if (ConstructorFragment.isFragment(obj)) {
          return obj;
        }
        if (typeof obj === "string") {
          try {
            return ConstructorFragment.from(lex(obj));
          } catch (error) {
            (0, index_js_1.assertArgument)(false, "invalid constuctor fragment", "obj", obj);
          }
        } else if (obj instanceof TokenString) {
          consumeKeywords(obj, setify(["constructor"]));
          var inputs = consumeParams(obj);
          var payable = !!consumeKeywords(obj, KwVisibDeploy).has("payable");
          var gas = consumeGas(obj);
          consumeEoi(obj);
          return new ConstructorFragment(_guard, "constructor", inputs, payable, gas);
        }
        return new ConstructorFragment(_guard, "constructor", obj.inputs ? obj.inputs.map(ParamType.from) : [], !!obj.payable, obj.gas != null ? obj.gas : null);
      }
      /**
       *  Returns ``true`` and provides a type guard if %%value%% is a
       *  **ConstructorFragment**.
       */
    }, {
      key: "isFragment",
      value: function isFragment(value) {
        return value && value[internal] === ConstructorFragmentInternal;
      }
    }]);
  }(Fragment);
  fragments.ConstructorFragment = ConstructorFragment;
  /**
   *  A Fragment which represents a method.
   */
  var FallbackFragment = /*#__PURE__*/function (_Fragment4) {
    function FallbackFragment(guard, inputs, payable) {
      var _this7;
      _classCallCheck(this, FallbackFragment);
      _this7 = _callSuper(this, FallbackFragment, [guard, "fallback", inputs]);
      /**
       *  If the function can be sent value during invocation.
       */
      _defineProperty(_this7, "payable", void 0);
      Object.defineProperty(_this7, internal, {
        value: FallbackFragmentInternal
      });
      (0, index_js_1.defineProperties)(_this7, {
        payable: payable
      });
      return _this7;
    }
    /**
     *  Returns a string representation of this fallback as %%format%%.
     */
    _inherits(FallbackFragment, _Fragment4);
    return _createClass(FallbackFragment, [{
      key: "format",
      value: function format(_format5) {
        var type = this.inputs.length === 0 ? "receive" : "fallback";
        if (_format5 === "json") {
          var stateMutability = this.payable ? "payable" : "nonpayable";
          return JSON.stringify({
            type: type,
            stateMutability: stateMutability
          });
        }
        return "".concat(type, "()").concat(this.payable ? " payable" : "");
      }
      /**
       *  Returns a new **FallbackFragment** for %%obj%%.
       */
    }], [{
      key: "from",
      value: function from(obj) {
        if (FallbackFragment.isFragment(obj)) {
          return obj;
        }
        if (typeof obj === "string") {
          try {
            return FallbackFragment.from(lex(obj));
          } catch (error) {
            (0, index_js_1.assertArgument)(false, "invalid fallback fragment", "obj", obj);
          }
        } else if (obj instanceof TokenString) {
          var errorObj = obj.toString();
          var topIsValid = obj.peekKeyword(setify(["fallback", "receive"]));
          (0, index_js_1.assertArgument)(topIsValid, "type must be fallback or receive", "obj", errorObj);
          var type = obj.popKeyword(setify(["fallback", "receive"]));
          // receive()
          if (type === "receive") {
            var _inputs = consumeParams(obj);
            (0, index_js_1.assertArgument)(_inputs.length === 0, "receive cannot have arguments", "obj.inputs", _inputs);
            consumeKeywords(obj, setify(["payable"]));
            consumeEoi(obj);
            return new FallbackFragment(_guard, [], true);
          }
          // fallback() [payable]
          // fallback(bytes) [payable] returns (bytes)
          var inputs = consumeParams(obj);
          if (inputs.length) {
            (0, index_js_1.assertArgument)(inputs.length === 1 && inputs[0].type === "bytes", "invalid fallback inputs", "obj.inputs", inputs.map(function (i) {
              return i.format("minimal");
            }).join(", "));
          } else {
            inputs = [ParamType.from("bytes")];
          }
          var mutability = consumeMutability(obj);
          (0, index_js_1.assertArgument)(mutability === "nonpayable" || mutability === "payable", "fallback cannot be constants", "obj.stateMutability", mutability);
          if (consumeKeywords(obj, setify(["returns"])).has("returns")) {
            var outputs = consumeParams(obj);
            (0, index_js_1.assertArgument)(outputs.length === 1 && outputs[0].type === "bytes", "invalid fallback outputs", "obj.outputs", outputs.map(function (i) {
              return i.format("minimal");
            }).join(", "));
          }
          consumeEoi(obj);
          return new FallbackFragment(_guard, inputs, mutability === "payable");
        }
        if (obj.type === "receive") {
          return new FallbackFragment(_guard, [], true);
        }
        if (obj.type === "fallback") {
          var _inputs2 = [ParamType.from("bytes")];
          var payable = obj.stateMutability === "payable";
          return new FallbackFragment(_guard, _inputs2, payable);
        }
        (0, index_js_1.assertArgument)(false, "invalid fallback description", "obj", obj);
      }
      /**
       *  Returns ``true`` and provides a type guard if %%value%% is a
       *  **FallbackFragment**.
       */
    }, {
      key: "isFragment",
      value: function isFragment(value) {
        return value && value[internal] === FallbackFragmentInternal;
      }
    }]);
  }(Fragment);
  fragments.FallbackFragment = FallbackFragment;
  /**
   *  A Fragment which represents a method.
   */
  var FunctionFragment = /*#__PURE__*/function (_NamedFragment4) {
    /**
     *  @private
     */
    function FunctionFragment(guard, name, stateMutability, inputs, outputs, gas) {
      var _this8;
      _classCallCheck(this, FunctionFragment);
      _this8 = _callSuper(this, FunctionFragment, [guard, "function", name, inputs]);
      /**
       *  If the function is constant (e.g. ``pure`` or ``view`` functions).
       */
      _defineProperty(_this8, "constant", void 0);
      /**
       *  The returned types for the result of calling this function.
       */
      _defineProperty(_this8, "outputs", void 0);
      /**
       *  The state mutability (e.g. ``payable``, ``nonpayable``, ``view``
       *  or ``pure``)
       */
      _defineProperty(_this8, "stateMutability", void 0);
      /**
       *  If the function can be sent value during invocation.
       */
      _defineProperty(_this8, "payable", void 0);
      /**
       *  The recommended gas limit to send when calling this function.
       */
      _defineProperty(_this8, "gas", void 0);
      Object.defineProperty(_this8, internal, {
        value: FunctionFragmentInternal
      });
      outputs = Object.freeze(outputs.slice());
      var constant = stateMutability === "view" || stateMutability === "pure";
      var payable = stateMutability === "payable";
      (0, index_js_1.defineProperties)(_this8, {
        constant: constant,
        gas: gas,
        outputs: outputs,
        payable: payable,
        stateMutability: stateMutability
      });
      return _this8;
    }
    /**
     *  The Function selector.
     */
    _inherits(FunctionFragment, _NamedFragment4);
    return _createClass(FunctionFragment, [{
      key: "selector",
      get: function get() {
        return (0, index_js_2.id)(this.format("sighash")).substring(0, 10);
      }
      /**
       *  Returns a string representation of this function as %%format%%.
       */
    }, {
      key: "format",
      value: function format(_format6) {
        if (_format6 == null) {
          _format6 = "sighash";
        }
        if (_format6 === "json") {
          return JSON.stringify({
            type: "function",
            name: this.name,
            constant: this.constant,
            stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : undefined,
            payable: this.payable,
            gas: this.gas != null ? this.gas : undefined,
            inputs: this.inputs.map(function (i) {
              return JSON.parse(i.format(_format6));
            }),
            outputs: this.outputs.map(function (o) {
              return JSON.parse(o.format(_format6));
            })
          });
        }
        var result = [];
        if (_format6 !== "sighash") {
          result.push("function");
        }
        result.push(this.name + joinParams(_format6, this.inputs));
        if (_format6 !== "sighash") {
          if (this.stateMutability !== "nonpayable") {
            result.push(this.stateMutability);
          }
          if (this.outputs && this.outputs.length) {
            result.push("returns");
            result.push(joinParams(_format6, this.outputs));
          }
          if (this.gas != null) {
            result.push("@".concat(this.gas.toString()));
          }
        }
        return result.join(" ");
      }
      /**
       *  Return the selector for a function with %%name%% and %%params%%.
       */
    }], [{
      key: "getSelector",
      value: function getSelector(name, params) {
        params = (params || []).map(function (p) {
          return ParamType.from(p);
        });
        var fragment = new FunctionFragment(_guard, name, "view", params, [], null);
        return fragment.selector;
      }
      /**
       *  Returns a new **FunctionFragment** for %%obj%%.
       */
    }, {
      key: "from",
      value: function from(obj) {
        if (FunctionFragment.isFragment(obj)) {
          return obj;
        }
        if (typeof obj === "string") {
          try {
            return FunctionFragment.from(lex(obj));
          } catch (error) {
            (0, index_js_1.assertArgument)(false, "invalid function fragment", "obj", obj);
          }
        } else if (obj instanceof TokenString) {
          var name = consumeName("function", obj);
          var inputs = consumeParams(obj);
          var mutability = consumeMutability(obj);
          var outputs = [];
          if (consumeKeywords(obj, setify(["returns"])).has("returns")) {
            outputs = consumeParams(obj);
          }
          var gas = consumeGas(obj);
          consumeEoi(obj);
          return new FunctionFragment(_guard, name, mutability, inputs, outputs, gas);
        }
        var stateMutability = obj.stateMutability;
        // Use legacy Solidity ABI logic if stateMutability is missing
        if (stateMutability == null) {
          stateMutability = "payable";
          if (typeof obj.constant === "boolean") {
            stateMutability = "view";
            if (!obj.constant) {
              stateMutability = "payable";
              if (typeof obj.payable === "boolean" && !obj.payable) {
                stateMutability = "nonpayable";
              }
            }
          } else if (typeof obj.payable === "boolean" && !obj.payable) {
            stateMutability = "nonpayable";
          }
        }
        // @TODO: verifyState for stateMutability (e.g. throw if
        //        payable: false but stateMutability is "nonpayable")
        return new FunctionFragment(_guard, obj.name, stateMutability, obj.inputs ? obj.inputs.map(ParamType.from) : [], obj.outputs ? obj.outputs.map(ParamType.from) : [], obj.gas != null ? obj.gas : null);
      }
      /**
       *  Returns ``true`` and provides a type guard if %%value%% is a
       *  **FunctionFragment**.
       */
    }, {
      key: "isFragment",
      value: function isFragment(value) {
        return value && value[internal] === FunctionFragmentInternal;
      }
    }]);
  }(NamedFragment);
  fragments.FunctionFragment = FunctionFragment;
  /**
   *  A Fragment which represents a structure.
   */
  var StructFragment = /*#__PURE__*/function (_NamedFragment5) {
    /**
     *  @private
     */
    function StructFragment(guard, name, inputs) {
      var _this9;
      _classCallCheck(this, StructFragment);
      _this9 = _callSuper(this, StructFragment, [guard, "struct", name, inputs]);
      Object.defineProperty(_this9, internal, {
        value: StructFragmentInternal
      });
      return _this9;
    }
    /**
     *  Returns a string representation of this struct as %%format%%.
     */
    _inherits(StructFragment, _NamedFragment5);
    return _createClass(StructFragment, [{
      key: "format",
      value: function format() {
        throw new Error("@TODO");
      }
      /**
       *  Returns a new **StructFragment** for %%obj%%.
       */
    }], [{
      key: "from",
      value: function from(obj) {
        if (typeof obj === "string") {
          try {
            return StructFragment.from(lex(obj));
          } catch (error) {
            (0, index_js_1.assertArgument)(false, "invalid struct fragment", "obj", obj);
          }
        } else if (obj instanceof TokenString) {
          var name = consumeName("struct", obj);
          var inputs = consumeParams(obj);
          consumeEoi(obj);
          return new StructFragment(_guard, name, inputs);
        }
        return new StructFragment(_guard, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);
      }
      // @TODO: fix this return type
      /**
       *  Returns ``true`` and provides a type guard if %%value%% is a
       *  **StructFragment**.
       */
    }, {
      key: "isFragment",
      value: function isFragment(value) {
        return value && value[internal] === StructFragmentInternal;
      }
    }]);
  }(NamedFragment);
  fragments.StructFragment = StructFragment;
  return fragments;
}

var hasRequiredAbiCoder;
function requireAbiCoder() {
  if (hasRequiredAbiCoder) return abiCoder;
  hasRequiredAbiCoder = 1;
  /**
   *  When sending values to or receiving values from a [[Contract]], the
   *  data is generally encoded using the [ABI standard](link-solc-abi).
   *
   *  The AbiCoder provides a utility to encode values to ABI data and
   *  decode values from ABI data.
   *
   *  Most of the time, developers should favour the [[Contract]] class,
   *  which further abstracts a lot of the finer details of ABI data.
   *
   *  @_section api/abi/abi-coder:ABI Encoding
   */
  Object.defineProperty(abiCoder, "__esModule", {
    value: true
  });
  abiCoder.AbiCoder = void 0;
  // See: https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI
  var index_js_1 = /*@__PURE__*/requireUtils$3();
  var abstract_coder_js_1 = /*@__PURE__*/requireAbstractCoder();
  var address_js_1 = /*@__PURE__*/requireAddress$1();
  var array_js_1 = /*@__PURE__*/requireArray();
  var boolean_js_1 = /*@__PURE__*/requireBoolean();
  var bytes_js_1 = /*@__PURE__*/requireBytes();
  var fixed_bytes_js_1 = /*@__PURE__*/requireFixedBytes();
  var null_js_1 = /*@__PURE__*/require_null();
  var number_js_1 = /*@__PURE__*/requireNumber();
  var string_js_1 = /*@__PURE__*/requireString();
  var tuple_js_1 = /*@__PURE__*/requireTuple();
  var fragments_js_1 = /*@__PURE__*/requireFragments();
  var index_js_2 = /*@__PURE__*/requireAddress$2();
  var index_js_3 = /*@__PURE__*/requireUtils$3();
  // https://docs.soliditylang.org/en/v0.8.17/control-structures.html
  var PanicReasons = new Map();
  PanicReasons.set(0x00, "GENERIC_PANIC");
  PanicReasons.set(0x01, "ASSERT_FALSE");
  PanicReasons.set(0x11, "OVERFLOW");
  PanicReasons.set(0x12, "DIVIDE_BY_ZERO");
  PanicReasons.set(0x21, "ENUM_RANGE_ERROR");
  PanicReasons.set(0x22, "BAD_STORAGE_DATA");
  PanicReasons.set(0x31, "STACK_UNDERFLOW");
  PanicReasons.set(0x32, "ARRAY_RANGE_ERROR");
  PanicReasons.set(0x41, "OUT_OF_MEMORY");
  PanicReasons.set(0x51, "UNINITIALIZED_FUNCTION_CALL");
  var paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);
  var paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);
  var defaultCoder = null;
  var defaultMaxInflation = 1024;
  function _getBuiltinCallException(action, tx, data, abiCoder) {
    var message = "missing revert data";
    var reason = null;
    var invocation = null;
    var revert = null;
    if (data) {
      message = "execution reverted";
      var bytes = (0, index_js_3.getBytes)(data);
      data = (0, index_js_3.hexlify)(data);
      if (bytes.length === 0) {
        message += " (no data present; likely require(false) occurred";
        reason = "require(false)";
      } else if (bytes.length % 32 !== 4) {
        message += " (could not decode reason; invalid data length)";
      } else if ((0, index_js_3.hexlify)(bytes.slice(0, 4)) === "0x08c379a0") {
        // Error(string)
        try {
          reason = abiCoder.decode(["string"], bytes.slice(4))[0];
          revert = {
            signature: "Error(string)",
            name: "Error",
            args: [reason]
          };
          message += ": ".concat(JSON.stringify(reason));
        } catch (error) {
          message += " (could not decode reason; invalid string data)";
        }
      } else if ((0, index_js_3.hexlify)(bytes.slice(0, 4)) === "0x4e487b71") {
        // Panic(uint256)
        try {
          var code = Number(abiCoder.decode(["uint256"], bytes.slice(4))[0]);
          revert = {
            signature: "Panic(uint256)",
            name: "Panic",
            args: [code]
          };
          reason = "Panic due to ".concat(PanicReasons.get(code) || "UNKNOWN", "(").concat(code, ")");
          message += ": ".concat(reason);
        } catch (error) {
          message += " (could not decode panic code)";
        }
      } else {
        message += " (unknown custom error)";
      }
    }
    var transaction = {
      to: tx.to ? (0, index_js_2.getAddress)(tx.to) : null,
      data: tx.data || "0x"
    };
    if (tx.from) {
      transaction.from = (0, index_js_2.getAddress)(tx.from);
    }
    return (0, index_js_3.makeError)(message, "CALL_EXCEPTION", {
      action: action,
      data: data,
      reason: reason,
      transaction: transaction,
      invocation: invocation,
      revert: revert
    });
  }
  /**
   *  The **AbiCoder** is a low-level class responsible for encoding JavaScript
   *  values into binary data and decoding binary data into JavaScript values.
   */
  var _AbiCoder_brand = /*#__PURE__*/new WeakSet();
  var AbiCoder = /*#__PURE__*/function () {
    function AbiCoder() {
      _classCallCheck(this, AbiCoder);
      _classPrivateMethodInitSpec(this, _AbiCoder_brand);
    }
    return _createClass(AbiCoder, [{
      key: "getDefaultValue",
      value:
      /**
       *  Get the default values for the given %%types%%.
       *
       *  For example, a ``uint`` is by default ``0`` and ``bool``
       *  is by default ``false``.
       */
      function getDefaultValue(types) {
        var _this = this;
        var coders = types.map(function (type) {
          return _assertClassBrand(_AbiCoder_brand, _this, _getCoder).call(_this, fragments_js_1.ParamType.from(type));
        });
        var coder = new tuple_js_1.TupleCoder(coders, "_");
        return coder.defaultValue();
      }
      /**
       *  Encode the %%values%% as the %%types%% into ABI data.
       *
       *  @returns DataHexstring
       */
    }, {
      key: "encode",
      value: function encode(types, values) {
        var _this2 = this;
        (0, index_js_1.assertArgumentCount)(values.length, types.length, "types/values length mismatch");
        var coders = types.map(function (type) {
          return _assertClassBrand(_AbiCoder_brand, _this2, _getCoder).call(_this2, fragments_js_1.ParamType.from(type));
        });
        var coder = new tuple_js_1.TupleCoder(coders, "_");
        var writer = new abstract_coder_js_1.Writer();
        coder.encode(writer, values);
        return writer.data;
      }
      /**
       *  Decode the ABI %%data%% as the %%types%% into values.
       *
       *  If %%loose%% decoding is enabled, then strict padding is
       *  not enforced. Some older versions of Solidity incorrectly
       *  padded event data emitted from ``external`` functions.
       */
    }, {
      key: "decode",
      value: function decode(types, data, loose) {
        var _this3 = this;
        var coders = types.map(function (type) {
          return _assertClassBrand(_AbiCoder_brand, _this3, _getCoder).call(_this3, fragments_js_1.ParamType.from(type));
        });
        var coder = new tuple_js_1.TupleCoder(coders, "_");
        return coder.decode(new abstract_coder_js_1.Reader(data, loose, defaultMaxInflation));
      }
    }], [{
      key: "_setDefaultMaxInflation",
      value: function _setDefaultMaxInflation(value) {
        (0, index_js_1.assertArgument)(typeof value === "number" && Number.isInteger(value), "invalid defaultMaxInflation factor", "value", value);
        defaultMaxInflation = value;
      }
      /**
       *  Returns the shared singleton instance of a default [[AbiCoder]].
       *
       *  On the first call, the instance is created internally.
       */
    }, {
      key: "defaultAbiCoder",
      value: function defaultAbiCoder() {
        if (defaultCoder == null) {
          defaultCoder = new AbiCoder();
        }
        return defaultCoder;
      }
      /**
       *  Returns an ethers-compatible [[CallExceptionError]] Error for the given
       *  result %%data%% for the [[CallExceptionAction]] %%action%% against
       *  the Transaction %%tx%%.
       */
    }, {
      key: "getBuiltinCallException",
      value: function getBuiltinCallException(action, tx, data) {
        return _getBuiltinCallException(action, tx, data, AbiCoder.defaultAbiCoder());
      }
    }]);
  }();
  function _getCoder(param) {
    var _this4 = this;
    if (param.isArray()) {
      return new array_js_1.ArrayCoder(_assertClassBrand(_AbiCoder_brand, this, _getCoder).call(this, param.arrayChildren), param.arrayLength, param.name);
    }
    if (param.isTuple()) {
      return new tuple_js_1.TupleCoder(param.components.map(function (c) {
        return _assertClassBrand(_AbiCoder_brand, _this4, _getCoder).call(_this4, c);
      }), param.name);
    }
    switch (param.baseType) {
      case "address":
        return new address_js_1.AddressCoder(param.name);
      case "bool":
        return new boolean_js_1.BooleanCoder(param.name);
      case "string":
        return new string_js_1.StringCoder(param.name);
      case "bytes":
        return new bytes_js_1.BytesCoder(param.name);
      case "":
        return new null_js_1.NullCoder(param.name);
    }
    // u?int[0-9]*
    var match = param.type.match(paramTypeNumber);
    if (match) {
      var size = parseInt(match[2] || "256");
      (0, index_js_1.assertArgument)(size !== 0 && size <= 256 && size % 8 === 0, "invalid " + match[1] + " bit length", "param", param);
      return new number_js_1.NumberCoder(size / 8, match[1] === "int", param.name);
    }
    // bytes[0-9]+
    match = param.type.match(paramTypeBytes);
    if (match) {
      var _size = parseInt(match[1]);
      (0, index_js_1.assertArgument)(_size !== 0 && _size <= 32, "invalid bytes length", "param", param);
      return new fixed_bytes_js_1.FixedBytesCoder(_size, param.name);
    }
    (0, index_js_1.assertArgument)(false, "invalid type", "type", param.type);
  }
  abiCoder.AbiCoder = AbiCoder;
  return abiCoder;
}

var bytes32 = {};

var hasRequiredBytes32;
function requireBytes32() {
  if (hasRequiredBytes32) return bytes32;
  hasRequiredBytes32 = 1;
  /**
   *  About bytes32 strings...
   *
   *  @_docloc: api/utils:Bytes32 Strings
   */
  Object.defineProperty(bytes32, "__esModule", {
    value: true
  });
  bytes32.decodeBytes32String = bytes32.encodeBytes32String = void 0;
  var index_js_1 = /*@__PURE__*/requireUtils$3();
  /**
   *  Encodes %%text%% as a Bytes32 string.
   */
  function encodeBytes32String(text) {
    // Get the bytes
    var bytes = (0, index_js_1.toUtf8Bytes)(text);
    // Check we have room for null-termination
    if (bytes.length > 31) {
      throw new Error("bytes32 string must be less than 32 bytes");
    }
    // Zero-pad (implicitly null-terminates)
    return (0, index_js_1.zeroPadBytes)(bytes, 32);
  }
  bytes32.encodeBytes32String = encodeBytes32String;
  /**
   *  Encodes the Bytes32-encoded %%bytes%% into a string.
   */
  function decodeBytes32String(_bytes) {
    var data = (0, index_js_1.getBytes)(_bytes, "bytes");
    // Must be 32 bytes with a null-termination
    if (data.length !== 32) {
      throw new Error("invalid bytes32 - not 32 bytes long");
    }
    if (data[31] !== 0) {
      throw new Error("invalid bytes32 string - no null terminator");
    }
    // Find the null termination
    var length = 31;
    while (data[length - 1] === 0) {
      length--;
    }
    // Determine the string value
    return (0, index_js_1.toUtf8String)(data.slice(0, length));
  }
  bytes32.decodeBytes32String = decodeBytes32String;
  return bytes32;
}

var _interface = {};

var hasRequired_interface;
function require_interface() {
  if (hasRequired_interface) return _interface;
  hasRequired_interface = 1;
  (function (exports) {

    /**
     *  The Interface class is a low-level class that accepts an
     *  ABI and provides all the necessary functionality to encode
     *  and decode paramaters to and results from methods, events
     *  and errors.
     *
     *  It also provides several convenience methods to automatically
     *  search and find matching transactions and events to parse them.
     *
     *  @_subsection api/abi:Interfaces  [interfaces]
     */
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Interface = exports.Indexed = exports.ErrorDescription = exports.TransactionDescription = exports.LogDescription = exports.Result = exports.checkResultErrors = void 0;
    var index_js_1 = /*@__PURE__*/requireCrypto();
    var index_js_2 = /*@__PURE__*/requireHash();
    var index_js_3 = /*@__PURE__*/requireUtils$3();
    var abi_coder_js_1 = /*@__PURE__*/requireAbiCoder();
    var abstract_coder_js_1 = /*@__PURE__*/requireAbstractCoder();
    Object.defineProperty(exports, "checkResultErrors", {
      enumerable: true,
      get: function get() {
        return abstract_coder_js_1.checkResultErrors;
      }
    });
    Object.defineProperty(exports, "Result", {
      enumerable: true,
      get: function get() {
        return abstract_coder_js_1.Result;
      }
    });
    var fragments_js_1 = /*@__PURE__*/requireFragments();
    var typed_js_1 = /*@__PURE__*/requireTyped();
    /**
     *  When using the [[Interface-parseLog]] to automatically match a Log to its event
     *  for parsing, a **LogDescription** is returned.
     */
    var LogDescription = /*#__PURE__*/_createClass(
    /**
     *  @_ignore:
     */
    function LogDescription(fragment, topic, args) {
      _classCallCheck(this, LogDescription);
      /**
       *  The matching fragment for the ``topic0``.
       */
      _defineProperty(this, "fragment", void 0);
      /**
       *  The name of the Event.
       */
      _defineProperty(this, "name", void 0);
      /**
       *  The full Event signature.
       */
      _defineProperty(this, "signature", void 0);
      /**
       *  The topic hash for the Event.
       */
      _defineProperty(this, "topic", void 0);
      /**
       *  The arguments passed into the Event with ``emit``.
       */
      _defineProperty(this, "args", void 0);
      var name = fragment.name,
        signature = fragment.format();
      (0, index_js_3.defineProperties)(this, {
        fragment: fragment,
        name: name,
        signature: signature,
        topic: topic,
        args: args
      });
    });
    exports.LogDescription = LogDescription;
    /**
     *  When using the [[Interface-parseTransaction]] to automatically match
     *  a transaction data to its function for parsing,
     *  a **TransactionDescription** is returned.
     */
    var TransactionDescription = /*#__PURE__*/_createClass(
    /**
     *  @_ignore:
     */
    function TransactionDescription(fragment, selector, args, value) {
      _classCallCheck(this, TransactionDescription);
      /**
       *  The matching fragment from the transaction ``data``.
       */
      _defineProperty(this, "fragment", void 0);
      /**
       *  The name of the Function from the transaction ``data``.
       */
      _defineProperty(this, "name", void 0);
      /**
       *  The arguments passed to the Function from the transaction ``data``.
       */
      _defineProperty(this, "args", void 0);
      /**
       *  The full Function signature from the transaction ``data``.
       */
      _defineProperty(this, "signature", void 0);
      /**
       *  The selector for the Function from the transaction ``data``.
       */
      _defineProperty(this, "selector", void 0);
      /**
       *  The ``value`` (in wei) from the transaction.
       */
      _defineProperty(this, "value", void 0);
      var name = fragment.name,
        signature = fragment.format();
      (0, index_js_3.defineProperties)(this, {
        fragment: fragment,
        name: name,
        args: args,
        signature: signature,
        selector: selector,
        value: value
      });
    });
    exports.TransactionDescription = TransactionDescription;
    /**
     *  When using the [[Interface-parseError]] to automatically match an
     *  error for a call result for parsing, an **ErrorDescription** is returned.
     */
    var ErrorDescription = /*#__PURE__*/_createClass(
    /**
     *  @_ignore:
     */
    function ErrorDescription(fragment, selector, args) {
      _classCallCheck(this, ErrorDescription);
      /**
       *  The matching fragment.
       */
      _defineProperty(this, "fragment", void 0);
      /**
       *  The name of the Error.
       */
      _defineProperty(this, "name", void 0);
      /**
       *  The arguments passed to the Error with ``revert``.
       */
      _defineProperty(this, "args", void 0);
      /**
       *  The full Error signature.
       */
      _defineProperty(this, "signature", void 0);
      /**
       *  The selector for the Error.
       */
      _defineProperty(this, "selector", void 0);
      var name = fragment.name,
        signature = fragment.format();
      (0, index_js_3.defineProperties)(this, {
        fragment: fragment,
        name: name,
        args: args,
        signature: signature,
        selector: selector
      });
    });
    exports.ErrorDescription = ErrorDescription;
    /**
     *  An **Indexed** is used as a value when a value that does not
     *  fit within a topic (i.e. not a fixed-length, 32-byte type). It
     *  is the ``keccak256`` of the value, and used for types such as
     *  arrays, tuples, bytes and strings.
     */
    var Indexed = /*#__PURE__*/function () {
      /**
       *  @_ignore:
       */
      function Indexed(hash) {
        _classCallCheck(this, Indexed);
        /**
         *  The ``keccak256`` of the value logged.
         */
        _defineProperty(this, "hash", void 0);
        /**
         *  @_ignore:
         */
        _defineProperty(this, "_isIndexed", void 0);
        (0, index_js_3.defineProperties)(this, {
          hash: hash,
          _isIndexed: true
        });
      }
      return _createClass(Indexed, null, [{
        key: "isIndexed",
        value:
        /**
         *  Returns ``true`` if %%value%% is an **Indexed**.
         *
         *  This provides a Type Guard for property access.
         */
        function isIndexed(value) {
          return !!(value && value._isIndexed);
        }
      }]);
    }();
    exports.Indexed = Indexed;
    // https://docs.soliditylang.org/en/v0.8.13/control-structures.html?highlight=panic#panic-via-assert-and-error-via-require
    var PanicReasons = {
      "0": "generic panic",
      "1": "assert(false)",
      "17": "arithmetic overflow",
      "18": "division or modulo by zero",
      "33": "enum overflow",
      "34": "invalid encoded storage byte array accessed",
      "49": "out-of-bounds array access; popping on an empty array",
      "50": "out-of-bounds access of an array or bytesN",
      "65": "out of memory",
      "81": "uninitialized function"
    };
    var BuiltinErrors = {
      "0x08c379a0": {
        signature: "Error(string)",
        name: "Error",
        inputs: ["string"],
        reason: function reason(message) {
          return "reverted with reason string ".concat(JSON.stringify(message));
        }
      },
      "0x4e487b71": {
        signature: "Panic(uint256)",
        name: "Panic",
        inputs: ["uint256"],
        reason: function reason(code) {
          var reason = "unknown panic code";
          if (code >= 0 && code <= 0xff && PanicReasons[code.toString()]) {
            reason = PanicReasons[code.toString()];
          }
          return "reverted with panic code 0x".concat(code.toString(16), " (").concat(reason, ")");
        }
      }
    };
    /**
     *  An Interface abstracts many of the low-level details for
     *  encoding and decoding the data on the blockchain.
     *
     *  An ABI provides information on how to encode data to send to
     *  a Contract, how to decode the results and events and how to
     *  interpret revert errors.
     *
     *  The ABI can be specified by [any supported format](InterfaceAbi).
     */
    var _errors = /*#__PURE__*/new WeakMap();
    var _events = /*#__PURE__*/new WeakMap();
    var _functions = /*#__PURE__*/new WeakMap();
    var _abiCoder = /*#__PURE__*/new WeakMap();
    var _Interface_brand = /*#__PURE__*/new WeakSet();
    var Interface = /*#__PURE__*/function () {
      /**
       *  Create a new Interface for the %%fragments%%.
       */
      function Interface(fragments) {
        var _this = this;
        _classCallCheck(this, Interface);
        // Find a function definition by any means necessary (unless it is ambiguous)
        _classPrivateMethodInitSpec(this, _Interface_brand);
        /**
         *  All the Contract ABI members (i.e. methods, events, errors, etc).
         */
        _defineProperty(this, "fragments", void 0);
        /**
         *  The Contract constructor.
         */
        _defineProperty(this, "deploy", void 0);
        /**
         *  The Fallback method, if any.
         */
        _defineProperty(this, "fallback", void 0);
        /**
         *  If receiving ether is supported.
         */
        _defineProperty(this, "receive", void 0);
        _classPrivateFieldInitSpec(this, _errors, void 0);
        _classPrivateFieldInitSpec(this, _events, void 0);
        _classPrivateFieldInitSpec(this, _functions, void 0);
        //    #structs: Map<string, StructFragment>;
        _classPrivateFieldInitSpec(this, _abiCoder, void 0);
        var abi = [];
        if (typeof fragments === "string") {
          abi = JSON.parse(fragments);
        } else {
          abi = fragments;
        }
        _classPrivateFieldSet2(_functions, this, new Map());
        _classPrivateFieldSet2(_errors, this, new Map());
        _classPrivateFieldSet2(_events, this, new Map());
        //        this.#structs = new Map();
        var frags = [];
        var _iterator = _createForOfIteratorHelper(abi),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var a = _step.value;
            try {
              frags.push(fragments_js_1.Fragment.from(a));
            } catch (error) {
              console.log("[Warning] Invalid Fragment ".concat(JSON.stringify(a), ":"), error.message);
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        (0, index_js_3.defineProperties)(this, {
          fragments: Object.freeze(frags)
        });
        var fallback = null;
        var receive = false;
        _classPrivateFieldSet2(_abiCoder, this, this.getAbiCoder());
        // Add all fragments by their signature
        this.fragments.forEach(function (fragment, index) {
          var bucket;
          switch (fragment.type) {
            case "constructor":
              if (_this.deploy) {
                console.log("duplicate definition - constructor");
                return;
              }
              //checkNames(fragment, "input", fragment.inputs);
              (0, index_js_3.defineProperties)(_this, {
                deploy: fragment
              });
              return;
            case "fallback":
              if (fragment.inputs.length === 0) {
                receive = true;
              } else {
                (0, index_js_3.assertArgument)(!fallback || fragment.payable !== fallback.payable, "conflicting fallback fragments", "fragments[".concat(index, "]"), fragment);
                fallback = fragment;
                receive = fallback.payable;
              }
              return;
            case "function":
              //checkNames(fragment, "input", fragment.inputs);
              //checkNames(fragment, "output", (<FunctionFragment>fragment).outputs);
              bucket = _classPrivateFieldGet2(_functions, _this);
              break;
            case "event":
              //checkNames(fragment, "input", fragment.inputs);
              bucket = _classPrivateFieldGet2(_events, _this);
              break;
            case "error":
              bucket = _classPrivateFieldGet2(_errors, _this);
              break;
            default:
              return;
          }
          // Two identical entries; ignore it
          var signature = fragment.format();
          if (bucket.has(signature)) {
            return;
          }
          bucket.set(signature, fragment);
        });
        // If we do not have a constructor add a default
        if (!this.deploy) {
          (0, index_js_3.defineProperties)(this, {
            deploy: fragments_js_1.ConstructorFragment.from("constructor()")
          });
        }
        (0, index_js_3.defineProperties)(this, {
          fallback: fallback,
          receive: receive
        });
      }
      /**
       *  Returns the entire Human-Readable ABI, as an array of
       *  signatures, optionally as %%minimal%% strings, which
       *  removes parameter names and unneceesary spaces.
       */
      return _createClass(Interface, [{
        key: "format",
        value: function format(minimal) {
          var format = minimal ? "minimal" : "full";
          var abi = this.fragments.map(function (f) {
            return f.format(format);
          });
          return abi;
        }
        /**
         *  Return the JSON-encoded ABI. This is the format Solidiy
         *  returns.
         */
      }, {
        key: "formatJson",
        value: function formatJson() {
          var abi = this.fragments.map(function (f) {
            return f.format("json");
          });
          // We need to re-bundle the JSON fragments a bit
          return JSON.stringify(abi.map(function (j) {
            return JSON.parse(j);
          }));
        }
        /**
         *  The ABI coder that will be used to encode and decode binary
         *  data.
         */
      }, {
        key: "getAbiCoder",
        value: function getAbiCoder() {
          return abi_coder_js_1.AbiCoder.defaultAbiCoder();
        }
      }, {
        key: "getFunctionName",
        value:
        /**
         *  Get the function name for %%key%%, which may be a function selector,
         *  function name or function signature that belongs to the ABI.
         */
        function getFunctionName(key) {
          var fragment = _assertClassBrand(_Interface_brand, this, _getFunction).call(this, key, null, false);
          (0, index_js_3.assertArgument)(fragment, "no matching function", "key", key);
          return fragment.name;
        }
        /**
         *  Returns true if %%key%% (a function selector, function name or
         *  function signature) is present in the ABI.
         *
         *  In the case of a function name, the name may be ambiguous, so
         *  accessing the [[FunctionFragment]] may require refinement.
         */
      }, {
        key: "hasFunction",
        value: function hasFunction(key) {
          return !!_assertClassBrand(_Interface_brand, this, _getFunction).call(this, key, null, false);
        }
        /**
         *  Get the [[FunctionFragment]] for %%key%%, which may be a function
         *  selector, function name or function signature that belongs to the ABI.
         *
         *  If %%values%% is provided, it will use the Typed API to handle
         *  ambiguous cases where multiple functions match by name.
         *
         *  If the %%key%% and %%values%% do not refine to a single function in
         *  the ABI, this will throw.
         */
      }, {
        key: "getFunction",
        value: function getFunction(key, values) {
          return _assertClassBrand(_Interface_brand, this, _getFunction).call(this, key, values || null, true);
        }
        /**
         *  Iterate over all functions, calling %%callback%%, sorted by their name.
         */
      }, {
        key: "forEachFunction",
        value: function forEachFunction(callback) {
          var names = Array.from(_classPrivateFieldGet2(_functions, this).keys());
          names.sort(function (a, b) {
            return a.localeCompare(b);
          });
          for (var i = 0; i < names.length; i++) {
            var name = names[i];
            callback(_classPrivateFieldGet2(_functions, this).get(name), i);
          }
        }
        // Find an event definition by any means necessary (unless it is ambiguous)
      }, {
        key: "getEventName",
        value:
        /**
         *  Get the event name for %%key%%, which may be a topic hash,
         *  event name or event signature that belongs to the ABI.
         */
        function getEventName(key) {
          var fragment = _assertClassBrand(_Interface_brand, this, _getEvent).call(this, key, null, false);
          (0, index_js_3.assertArgument)(fragment, "no matching event", "key", key);
          return fragment.name;
        }
        /**
         *  Returns true if %%key%% (an event topic hash, event name or
         *  event signature) is present in the ABI.
         *
         *  In the case of an event name, the name may be ambiguous, so
         *  accessing the [[EventFragment]] may require refinement.
         */
      }, {
        key: "hasEvent",
        value: function hasEvent(key) {
          return !!_assertClassBrand(_Interface_brand, this, _getEvent).call(this, key, null, false);
        }
        /**
         *  Get the [[EventFragment]] for %%key%%, which may be a topic hash,
         *  event name or event signature that belongs to the ABI.
         *
         *  If %%values%% is provided, it will use the Typed API to handle
         *  ambiguous cases where multiple events match by name.
         *
         *  If the %%key%% and %%values%% do not refine to a single event in
         *  the ABI, this will throw.
         */
      }, {
        key: "getEvent",
        value: function getEvent(key, values) {
          return _assertClassBrand(_Interface_brand, this, _getEvent).call(this, key, values || null, true);
        }
        /**
         *  Iterate over all events, calling %%callback%%, sorted by their name.
         */
      }, {
        key: "forEachEvent",
        value: function forEachEvent(callback) {
          var names = Array.from(_classPrivateFieldGet2(_events, this).keys());
          names.sort(function (a, b) {
            return a.localeCompare(b);
          });
          for (var i = 0; i < names.length; i++) {
            var name = names[i];
            callback(_classPrivateFieldGet2(_events, this).get(name), i);
          }
        }
        /**
         *  Get the [[ErrorFragment]] for %%key%%, which may be an error
         *  selector, error name or error signature that belongs to the ABI.
         *
         *  If %%values%% is provided, it will use the Typed API to handle
         *  ambiguous cases where multiple errors match by name.
         *
         *  If the %%key%% and %%values%% do not refine to a single error in
         *  the ABI, this will throw.
         */
      }, {
        key: "getError",
        value: function getError(key, values) {
          if ((0, index_js_3.isHexString)(key)) {
            var selector = key.toLowerCase();
            if (BuiltinErrors[selector]) {
              return fragments_js_1.ErrorFragment.from(BuiltinErrors[selector].signature);
            }
            var _iterator2 = _createForOfIteratorHelper(_classPrivateFieldGet2(_errors, this).values()),
              _step2;
            try {
              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                var fragment = _step2.value;
                if (selector === fragment.selector) {
                  return fragment;
                }
              }
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }
            return null;
          }
          // It is a bare name, look up the function (will return null if ambiguous)
          if (key.indexOf("(") === -1) {
            var matching = [];
            var _iterator3 = _createForOfIteratorHelper(_classPrivateFieldGet2(_errors, this)),
              _step3;
            try {
              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                var _step3$value = _slicedToArray(_step3.value, 2),
                  name = _step3$value[0],
                  _fragment = _step3$value[1];
                if (name.split("(" /* fix:) */)[0] === key) {
                  matching.push(_fragment);
                }
              }
            } catch (err) {
              _iterator3.e(err);
            } finally {
              _iterator3.f();
            }
            if (matching.length === 0) {
              if (key === "Error") {
                return fragments_js_1.ErrorFragment.from("error Error(string)");
              }
              if (key === "Panic") {
                return fragments_js_1.ErrorFragment.from("error Panic(uint256)");
              }
              return null;
            } else if (matching.length > 1) {
              var matchStr = matching.map(function (m) {
                return JSON.stringify(m.format());
              }).join(", ");
              (0, index_js_3.assertArgument)(false, "ambiguous error description (i.e. ".concat(matchStr, ")"), "name", key);
            }
            return matching[0];
          }
          // Normalize the signature and lookup the function
          key = fragments_js_1.ErrorFragment.from(key).format();
          if (key === "Error(string)") {
            return fragments_js_1.ErrorFragment.from("error Error(string)");
          }
          if (key === "Panic(uint256)") {
            return fragments_js_1.ErrorFragment.from("error Panic(uint256)");
          }
          var result = _classPrivateFieldGet2(_errors, this).get(key);
          if (result) {
            return result;
          }
          return null;
        }
        /**
         *  Iterate over all errors, calling %%callback%%, sorted by their name.
         */
      }, {
        key: "forEachError",
        value: function forEachError(callback) {
          var names = Array.from(_classPrivateFieldGet2(_errors, this).keys());
          names.sort(function (a, b) {
            return a.localeCompare(b);
          });
          for (var i = 0; i < names.length; i++) {
            var name = names[i];
            callback(_classPrivateFieldGet2(_errors, this).get(name), i);
          }
        }
        // Get the 4-byte selector used by Solidity to identify a function
        /*
        getSelector(fragment: ErrorFragment | FunctionFragment): string {
        if (typeof(fragment) === "string") {
            const matches: Array<Fragment> = [ ];
             try { matches.push(this.getFunction(fragment)); } catch (error) { }
            try { matches.push(this.getError(<string>fragment)); } catch (_) { }
             if (matches.length === 0) {
                logger.throwArgumentError("unknown fragment", "key", fragment);
            } else if (matches.length > 1) {
                logger.throwArgumentError("ambiguous fragment matches function and error", "key", fragment);
            }
             fragment = matches[0];
        }
         return dataSlice(id(fragment.format()), 0, 4);
        }
        */
        // Get the 32-byte topic hash used by Solidity to identify an event
        /*
        getEventTopic(fragment: EventFragment): string {
            //if (typeof(fragment) === "string") { fragment = this.getEvent(eventFragment); }
            return id(fragment.format());
        }
        */
      }, {
        key: "_decodeParams",
        value: function _decodeParams(params, data) {
          return _classPrivateFieldGet2(_abiCoder, this).decode(params, data);
        }
      }, {
        key: "_encodeParams",
        value: function _encodeParams(params, values) {
          return _classPrivateFieldGet2(_abiCoder, this).encode(params, values);
        }
        /**
         *  Encodes a ``tx.data`` object for deploying the Contract with
         *  the %%values%% as the constructor arguments.
         */
      }, {
        key: "encodeDeploy",
        value: function encodeDeploy(values) {
          return this._encodeParams(this.deploy.inputs, values || []);
        }
        /**
         *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the
         *  specified error (see [[getError]] for valid values for
         *  %%key%%).
         *
         *  Most developers should prefer the [[parseCallResult]] method instead,
         *  which will automatically detect a ``CALL_EXCEPTION`` and throw the
         *  corresponding error.
         */
      }, {
        key: "decodeErrorResult",
        value: function decodeErrorResult(fragment, data) {
          if (typeof fragment === "string") {
            var f = this.getError(fragment);
            (0, index_js_3.assertArgument)(f, "unknown error", "fragment", fragment);
            fragment = f;
          }
          (0, index_js_3.assertArgument)((0, index_js_3.dataSlice)(data, 0, 4) === fragment.selector, "data signature does not match error ".concat(fragment.name, "."), "data", data);
          return this._decodeParams(fragment.inputs, (0, index_js_3.dataSlice)(data, 4));
        }
        /**
         *  Encodes the transaction revert data for a call result that
         *  reverted from the the Contract with the sepcified %%error%%
         *  (see [[getError]] for valid values for %%fragment%%) with the %%values%%.
         *
         *  This is generally not used by most developers, unless trying to mock
         *  a result from a Contract.
         */
      }, {
        key: "encodeErrorResult",
        value: function encodeErrorResult(fragment, values) {
          if (typeof fragment === "string") {
            var f = this.getError(fragment);
            (0, index_js_3.assertArgument)(f, "unknown error", "fragment", fragment);
            fragment = f;
          }
          return (0, index_js_3.concat)([fragment.selector, this._encodeParams(fragment.inputs, values || [])]);
        }
        /**
         *  Decodes the %%data%% from a transaction ``tx.data`` for
         *  the function specified (see [[getFunction]] for valid values
         *  for %%fragment%%).
         *
         *  Most developers should prefer the [[parseTransaction]] method
         *  instead, which will automatically detect the fragment.
         */
      }, {
        key: "decodeFunctionData",
        value: function decodeFunctionData(fragment, data) {
          if (typeof fragment === "string") {
            var f = this.getFunction(fragment);
            (0, index_js_3.assertArgument)(f, "unknown function", "fragment", fragment);
            fragment = f;
          }
          (0, index_js_3.assertArgument)((0, index_js_3.dataSlice)(data, 0, 4) === fragment.selector, "data signature does not match function ".concat(fragment.name, "."), "data", data);
          return this._decodeParams(fragment.inputs, (0, index_js_3.dataSlice)(data, 4));
        }
        /**
         *  Encodes the ``tx.data`` for a transaction that calls the function
         *  specified (see [[getFunction]] for valid values for %%fragment%%) with
         *  the %%values%%.
         */
      }, {
        key: "encodeFunctionData",
        value: function encodeFunctionData(fragment, values) {
          if (typeof fragment === "string") {
            var f = this.getFunction(fragment);
            (0, index_js_3.assertArgument)(f, "unknown function", "fragment", fragment);
            fragment = f;
          }
          return (0, index_js_3.concat)([fragment.selector, this._encodeParams(fragment.inputs, values || [])]);
        }
        /**
         *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the
         *  specified function (see [[getFunction]] for valid values for
         *  %%key%%).
         *
         *  Most developers should prefer the [[parseCallResult]] method instead,
         *  which will automatically detect a ``CALL_EXCEPTION`` and throw the
         *  corresponding error.
         */
      }, {
        key: "decodeFunctionResult",
        value: function decodeFunctionResult(fragment, data) {
          if (typeof fragment === "string") {
            var f = this.getFunction(fragment);
            (0, index_js_3.assertArgument)(f, "unknown function", "fragment", fragment);
            fragment = f;
          }
          var message = "invalid length for result data";
          var bytes = (0, index_js_3.getBytesCopy)(data);
          if (bytes.length % 32 === 0) {
            try {
              return _classPrivateFieldGet2(_abiCoder, this).decode(fragment.outputs, bytes);
            } catch (error) {
              message = "could not decode result data";
            }
          }
          // Call returned data with no error, but the data is junk
          (0, index_js_3.assert)(false, message, "BAD_DATA", {
            value: (0, index_js_3.hexlify)(bytes),
            info: {
              method: fragment.name,
              signature: fragment.format()
            }
          });
        }
      }, {
        key: "makeError",
        value: function makeError(_data, tx) {
          var data = (0, index_js_3.getBytes)(_data, "data");
          var error = abi_coder_js_1.AbiCoder.getBuiltinCallException("call", tx, data);
          // Not a built-in error; try finding a custom error
          var customPrefix = "execution reverted (unknown custom error)";
          if (error.message.startsWith(customPrefix)) {
            var selector = (0, index_js_3.hexlify)(data.slice(0, 4));
            var ef = this.getError(selector);
            if (ef) {
              try {
                var args = _classPrivateFieldGet2(_abiCoder, this).decode(ef.inputs, data.slice(4));
                error.revert = {
                  name: ef.name,
                  signature: ef.format(),
                  args: args
                };
                error.reason = error.revert.signature;
                error.message = "execution reverted: ".concat(error.reason);
              } catch (e) {
                error.message = "execution reverted (coult not decode custom error)";
              }
            }
          }
          // Add the invocation, if available
          var parsed = this.parseTransaction(tx);
          if (parsed) {
            error.invocation = {
              method: parsed.name,
              signature: parsed.signature,
              args: parsed.args
            };
          }
          return error;
        }
        /**
         *  Encodes the result data (e.g. from an ``eth_call``) for the
         *  specified function (see [[getFunction]] for valid values
         *  for %%fragment%%) with %%values%%.
         *
         *  This is generally not used by most developers, unless trying to mock
         *  a result from a Contract.
         */
      }, {
        key: "encodeFunctionResult",
        value: function encodeFunctionResult(fragment, values) {
          if (typeof fragment === "string") {
            var f = this.getFunction(fragment);
            (0, index_js_3.assertArgument)(f, "unknown function", "fragment", fragment);
            fragment = f;
          }
          return (0, index_js_3.hexlify)(_classPrivateFieldGet2(_abiCoder, this).encode(fragment.outputs, values || []));
        }
        /*
            spelunk(inputs: Array<ParamType>, values: ReadonlyArray<any>, processfunc: (type: string, value: any) => Promise<any>): Promise<Array<any>> {
                const promises: Array<Promise<>> = [ ];
                const process = function(type: ParamType, value: any): any {
                    if (type.baseType === "array") {
                        return descend(type.child
                    }
                    if (type. === "address") {
                    }
                };
        
                const descend = function (inputs: Array<ParamType>, values: ReadonlyArray<any>) {
                    if (inputs.length !== values.length) { throw new Error("length mismatch"); }
                    
                };
        
                const result: Array<any> = [ ];
                values.forEach((value, index) => {
                    if (value == null) {
                        topics.push(null);
                    } else if (param.baseType === "array" || param.baseType === "tuple") {
                        logger.throwArgumentError("filtering with tuples or arrays not supported", ("contract." + param.name), value);
                    } else if (Array.isArray(value)) {
                        topics.push(value.map((value) => encodeTopic(param, value)));
                    } else {
                        topics.push(encodeTopic(param, value));
                    }
                });
            }
        */
        // Create the filter for the event with search criteria (e.g. for eth_filterLog)
      }, {
        key: "encodeFilterTopics",
        value: function encodeFilterTopics(fragment, values) {
          var _this2 = this;
          if (typeof fragment === "string") {
            var f = this.getEvent(fragment);
            (0, index_js_3.assertArgument)(f, "unknown event", "eventFragment", fragment);
            fragment = f;
          }
          (0, index_js_3.assert)(values.length <= fragment.inputs.length, "too many arguments for ".concat(fragment.format()), "UNEXPECTED_ARGUMENT", {
            count: values.length,
            expectedCount: fragment.inputs.length
          });
          var topics = [];
          if (!fragment.anonymous) {
            topics.push(fragment.topicHash);
          }
          // @TODO: Use the coders for this; to properly support tuples, etc.
          var encodeTopic = function encodeTopic(param, value) {
            if (param.type === "string") {
              return (0, index_js_2.id)(value);
            } else if (param.type === "bytes") {
              return (0, index_js_1.keccak256)((0, index_js_3.hexlify)(value));
            }
            if (param.type === "bool" && typeof value === "boolean") {
              value = value ? "0x01" : "0x00";
            } else if (param.type.match(/^u?int/)) {
              value = (0, index_js_3.toBeHex)(value); // @TODO: Should this toTwos??
            } else if (param.type.match(/^bytes/)) {
              value = (0, index_js_3.zeroPadBytes)(value, 32);
            } else if (param.type === "address") {
              // Check addresses are valid
              _classPrivateFieldGet2(_abiCoder, _this2).encode(["address"], [value]);
            }
            return (0, index_js_3.zeroPadValue)((0, index_js_3.hexlify)(value), 32);
          };
          values.forEach(function (value, index) {
            var param = fragment.inputs[index];
            if (!param.indexed) {
              (0, index_js_3.assertArgument)(value == null, "cannot filter non-indexed parameters; must be null", "contract." + param.name, value);
              return;
            }
            if (value == null) {
              topics.push(null);
            } else if (param.baseType === "array" || param.baseType === "tuple") {
              (0, index_js_3.assertArgument)(false, "filtering with tuples or arrays not supported", "contract." + param.name, value);
            } else if (Array.isArray(value)) {
              topics.push(value.map(function (value) {
                return encodeTopic(param, value);
              }));
            } else {
              topics.push(encodeTopic(param, value));
            }
          });
          // Trim off trailing nulls
          while (topics.length && topics[topics.length - 1] === null) {
            topics.pop();
          }
          return topics;
        }
      }, {
        key: "encodeEventLog",
        value: function encodeEventLog(fragment, values) {
          var _this3 = this;
          if (typeof fragment === "string") {
            var f = this.getEvent(fragment);
            (0, index_js_3.assertArgument)(f, "unknown event", "eventFragment", fragment);
            fragment = f;
          }
          var topics = [];
          var dataTypes = [];
          var dataValues = [];
          if (!fragment.anonymous) {
            topics.push(fragment.topicHash);
          }
          (0, index_js_3.assertArgument)(values.length === fragment.inputs.length, "event arguments/values mismatch", "values", values);
          fragment.inputs.forEach(function (param, index) {
            var value = values[index];
            if (param.indexed) {
              if (param.type === "string") {
                topics.push((0, index_js_2.id)(value));
              } else if (param.type === "bytes") {
                topics.push((0, index_js_1.keccak256)(value));
              } else if (param.baseType === "tuple" || param.baseType === "array") {
                // @TODO
                throw new Error("not implemented");
              } else {
                topics.push(_classPrivateFieldGet2(_abiCoder, _this3).encode([param.type], [value]));
              }
            } else {
              dataTypes.push(param);
              dataValues.push(value);
            }
          });
          return {
            data: _classPrivateFieldGet2(_abiCoder, this).encode(dataTypes, dataValues),
            topics: topics
          };
        }
        // Decode a filter for the event and the search criteria
      }, {
        key: "decodeEventLog",
        value: function decodeEventLog(fragment, data, topics) {
          if (typeof fragment === "string") {
            var f = this.getEvent(fragment);
            (0, index_js_3.assertArgument)(f, "unknown event", "eventFragment", fragment);
            fragment = f;
          }
          if (topics != null && !fragment.anonymous) {
            var eventTopic = fragment.topicHash;
            (0, index_js_3.assertArgument)((0, index_js_3.isHexString)(topics[0], 32) && topics[0].toLowerCase() === eventTopic, "fragment/topic mismatch", "topics[0]", topics[0]);
            topics = topics.slice(1);
          }
          var indexed = [];
          var nonIndexed = [];
          var dynamic = [];
          fragment.inputs.forEach(function (param, index) {
            if (param.indexed) {
              if (param.type === "string" || param.type === "bytes" || param.baseType === "tuple" || param.baseType === "array") {
                indexed.push(fragments_js_1.ParamType.from({
                  type: "bytes32",
                  name: param.name
                }));
                dynamic.push(true);
              } else {
                indexed.push(param);
                dynamic.push(false);
              }
            } else {
              nonIndexed.push(param);
              dynamic.push(false);
            }
          });
          var resultIndexed = topics != null ? _classPrivateFieldGet2(_abiCoder, this).decode(indexed, (0, index_js_3.concat)(topics)) : null;
          var resultNonIndexed = _classPrivateFieldGet2(_abiCoder, this).decode(nonIndexed, data, true);
          //const result: (Array<any> & { [ key: string ]: any }) = [ ];
          var values = [];
          var keys = [];
          var nonIndexedIndex = 0,
            indexedIndex = 0;
          fragment.inputs.forEach(function (param, index) {
            var value = null;
            if (param.indexed) {
              if (resultIndexed == null) {
                value = new Indexed(null);
              } else if (dynamic[index]) {
                value = new Indexed(resultIndexed[indexedIndex++]);
              } else {
                try {
                  value = resultIndexed[indexedIndex++];
                } catch (error) {
                  value = error;
                }
              }
            } else {
              try {
                value = resultNonIndexed[nonIndexedIndex++];
              } catch (error) {
                value = error;
              }
            }
            values.push(value);
            keys.push(param.name || null);
          });
          return abstract_coder_js_1.Result.fromItems(values, keys);
        }
        /**
         *  Parses a transaction, finding the matching function and extracts
         *  the parameter values along with other useful function details.
         *
         *  If the matching function cannot be found, return null.
         */
      }, {
        key: "parseTransaction",
        value: function parseTransaction(tx) {
          var data = (0, index_js_3.getBytes)(tx.data, "tx.data");
          var value = (0, index_js_3.getBigInt)(tx.value != null ? tx.value : 0, "tx.value");
          var fragment = this.getFunction((0, index_js_3.hexlify)(data.slice(0, 4)));
          if (!fragment) {
            return null;
          }
          var args = _classPrivateFieldGet2(_abiCoder, this).decode(fragment.inputs, data.slice(4));
          return new TransactionDescription(fragment, fragment.selector, args, value);
        }
      }, {
        key: "parseCallResult",
        value: function parseCallResult(data) {
          throw new Error("@TODO");
        }
        /**
         *  Parses a receipt log, finding the matching event and extracts
         *  the parameter values along with other useful event details.
         *
         *  If the matching event cannot be found, returns null.
         */
      }, {
        key: "parseLog",
        value: function parseLog(log) {
          var fragment = this.getEvent(log.topics[0]);
          if (!fragment || fragment.anonymous) {
            return null;
          }
          // @TODO: If anonymous, and the only method, and the input count matches, should we parse?
          //        Probably not, because just because it is the only event in the ABI does
          //        not mean we have the full ABI; maybe just a fragment?
          return new LogDescription(fragment, fragment.topicHash, this.decodeEventLog(fragment, log.data, log.topics));
        }
        /**
         *  Parses a revert data, finding the matching error and extracts
         *  the parameter values along with other useful error details.
         *
         *  If the matching error cannot be found, returns null.
         */
      }, {
        key: "parseError",
        value: function parseError(data) {
          var hexData = (0, index_js_3.hexlify)(data);
          var fragment = this.getError((0, index_js_3.dataSlice)(hexData, 0, 4));
          if (!fragment) {
            return null;
          }
          var args = _classPrivateFieldGet2(_abiCoder, this).decode(fragment.inputs, (0, index_js_3.dataSlice)(hexData, 4));
          return new ErrorDescription(fragment, fragment.selector, args);
        }
        /**
         *  Creates a new [[Interface]] from the ABI %%value%%.
         *
         *  The %%value%% may be provided as an existing [[Interface]] object,
         *  a JSON-encoded ABI or any Human-Readable ABI format.
         */
      }], [{
        key: "from",
        value: function from(value) {
          // Already an Interface, which is immutable
          if (value instanceof Interface) {
            return value;
          }
          // JSON
          if (typeof value === "string") {
            return new Interface(JSON.parse(value));
          }
          // An Interface; possibly from another v6 instance
          if (typeof value.formatJson === "function") {
            return new Interface(value.formatJson());
          }
          // A legacy Interface; from an older version
          if (typeof value.format === "function") {
            return new Interface(value.format("json"));
          }
          // Array of fragments
          return new Interface(value);
        }
      }]);
    }();
    function _getFunction(key, values, forceUnique) {
      // Selector
      if ((0, index_js_3.isHexString)(key)) {
        var selector = key.toLowerCase();
        var _iterator4 = _createForOfIteratorHelper(_classPrivateFieldGet2(_functions, this).values()),
          _step4;
        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
            var fragment = _step4.value;
            if (selector === fragment.selector) {
              return fragment;
            }
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }
        return null;
      }
      // It is a bare name, look up the function (will return null if ambiguous)
      if (key.indexOf("(") === -1) {
        var matching = [];
        var _iterator5 = _createForOfIteratorHelper(_classPrivateFieldGet2(_functions, this)),
          _step5;
        try {
          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
            var _step5$value = _slicedToArray(_step5.value, 2),
              name = _step5$value[0],
              _fragment2 = _step5$value[1];
            if (name.split("(" /* fix:) */)[0] === key) {
              matching.push(_fragment2);
            }
          }
        } catch (err) {
          _iterator5.e(err);
        } finally {
          _iterator5.f();
        }
        if (values) {
          var lastValue = values.length > 0 ? values[values.length - 1] : null;
          var valueLength = values.length;
          var allowOptions = true;
          if (typed_js_1.Typed.isTyped(lastValue) && lastValue.type === "overrides") {
            allowOptions = false;
            valueLength--;
          }
          // Remove all matches that don't have a compatible length. The args
          // may contain an overrides, so the match may have n or n - 1 parameters
          for (var i = matching.length - 1; i >= 0; i--) {
            var inputs = matching[i].inputs.length;
            if (inputs !== valueLength && (!allowOptions || inputs !== valueLength - 1)) {
              matching.splice(i, 1);
            }
          }
          // Remove all matches that don't match the Typed signature
          for (var _i = matching.length - 1; _i >= 0; _i--) {
            var _inputs = matching[_i].inputs;
            for (var j = 0; j < values.length; j++) {
              // Not a typed value
              if (!typed_js_1.Typed.isTyped(values[j])) {
                continue;
              }
              // We are past the inputs
              if (j >= _inputs.length) {
                if (values[j].type === "overrides") {
                  continue;
                }
                matching.splice(_i, 1);
                break;
              }
              // Make sure the value type matches the input type
              if (values[j].type !== _inputs[j].baseType) {
                matching.splice(_i, 1);
                break;
              }
            }
          }
        }
        // We found a single matching signature with an overrides, but the
        // last value is something that cannot possibly be an options
        if (matching.length === 1 && values && values.length !== matching[0].inputs.length) {
          var lastArg = values[values.length - 1];
          if (lastArg == null || Array.isArray(lastArg) || _typeof(lastArg) !== "object") {
            matching.splice(0, 1);
          }
        }
        if (matching.length === 0) {
          return null;
        }
        if (matching.length > 1 && forceUnique) {
          var matchStr = matching.map(function (m) {
            return JSON.stringify(m.format());
          }).join(", ");
          (0, index_js_3.assertArgument)(false, "ambiguous function description (i.e. matches ".concat(matchStr, ")"), "key", key);
        }
        return matching[0];
      }
      // Normalize the signature and lookup the function
      var result = _classPrivateFieldGet2(_functions, this).get(fragments_js_1.FunctionFragment.from(key).format());
      if (result) {
        return result;
      }
      return null;
    }
    function _getEvent(key, values, forceUnique) {
      // EventTopic
      if ((0, index_js_3.isHexString)(key)) {
        var eventTopic = key.toLowerCase();
        var _iterator6 = _createForOfIteratorHelper(_classPrivateFieldGet2(_events, this).values()),
          _step6;
        try {
          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
            var fragment = _step6.value;
            if (eventTopic === fragment.topicHash) {
              return fragment;
            }
          }
        } catch (err) {
          _iterator6.e(err);
        } finally {
          _iterator6.f();
        }
        return null;
      }
      // It is a bare name, look up the function (will return null if ambiguous)
      if (key.indexOf("(") === -1) {
        var matching = [];
        var _iterator7 = _createForOfIteratorHelper(_classPrivateFieldGet2(_events, this)),
          _step7;
        try {
          for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
            var _step7$value = _slicedToArray(_step7.value, 2),
              name = _step7$value[0],
              _fragment3 = _step7$value[1];
            if (name.split("(" /* fix:) */)[0] === key) {
              matching.push(_fragment3);
            }
          }
        } catch (err) {
          _iterator7.e(err);
        } finally {
          _iterator7.f();
        }
        if (values) {
          // Remove all matches that don't have a compatible length.
          for (var i = matching.length - 1; i >= 0; i--) {
            if (matching[i].inputs.length < values.length) {
              matching.splice(i, 1);
            }
          }
          // Remove all matches that don't match the Typed signature
          for (var _i2 = matching.length - 1; _i2 >= 0; _i2--) {
            var inputs = matching[_i2].inputs;
            for (var j = 0; j < values.length; j++) {
              // Not a typed value
              if (!typed_js_1.Typed.isTyped(values[j])) {
                continue;
              }
              // Make sure the value type matches the input type
              if (values[j].type !== inputs[j].baseType) {
                matching.splice(_i2, 1);
                break;
              }
            }
          }
        }
        if (matching.length === 0) {
          return null;
        }
        if (matching.length > 1 && forceUnique) {
          var matchStr = matching.map(function (m) {
            return JSON.stringify(m.format());
          }).join(", ");
          (0, index_js_3.assertArgument)(false, "ambiguous event description (i.e. matches ".concat(matchStr, ")"), "key", key);
        }
        return matching[0];
      }
      // Normalize the signature and lookup the function
      var result = _classPrivateFieldGet2(_events, this).get(fragments_js_1.EventFragment.from(key).format());
      if (result) {
        return result;
      }
      return null;
    }
    exports.Interface = Interface;
  })(_interface);
  return _interface;
}

var hasRequiredAbi;
function requireAbi() {
  if (hasRequiredAbi) return abi;
  hasRequiredAbi = 1;
  (function (exports) {

    /**
     *  The Application Binary Interface (ABI) describes how method input
     *  parameters should be encoded, their results decoded, and how to
     *  decode events and errors.
     *
     *  See [About ABIs](docs-abi) for more details how they are used.
     *
     *  @_section api/abi:Application Binary Interface  [about-abi]
     *  @_navTitle: ABI
     */
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Typed = exports.Result = exports.TransactionDescription = exports.LogDescription = exports.ErrorDescription = exports.Interface = exports.Indexed = exports.checkResultErrors = exports.StructFragment = exports.ParamType = exports.NamedFragment = exports.FunctionFragment = exports.Fragment = exports.FallbackFragment = exports.EventFragment = exports.ErrorFragment = exports.ConstructorFragment = exports.encodeBytes32String = exports.decodeBytes32String = exports.AbiCoder = void 0;
    //////
    var abi_coder_js_1 = /*@__PURE__*/requireAbiCoder();
    Object.defineProperty(exports, "AbiCoder", {
      enumerable: true,
      get: function get() {
        return abi_coder_js_1.AbiCoder;
      }
    });
    var bytes32_js_1 = /*@__PURE__*/requireBytes32();
    Object.defineProperty(exports, "decodeBytes32String", {
      enumerable: true,
      get: function get() {
        return bytes32_js_1.decodeBytes32String;
      }
    });
    Object.defineProperty(exports, "encodeBytes32String", {
      enumerable: true,
      get: function get() {
        return bytes32_js_1.encodeBytes32String;
      }
    });
    var fragments_js_1 = /*@__PURE__*/requireFragments();
    Object.defineProperty(exports, "ConstructorFragment", {
      enumerable: true,
      get: function get() {
        return fragments_js_1.ConstructorFragment;
      }
    });
    Object.defineProperty(exports, "ErrorFragment", {
      enumerable: true,
      get: function get() {
        return fragments_js_1.ErrorFragment;
      }
    });
    Object.defineProperty(exports, "EventFragment", {
      enumerable: true,
      get: function get() {
        return fragments_js_1.EventFragment;
      }
    });
    Object.defineProperty(exports, "FallbackFragment", {
      enumerable: true,
      get: function get() {
        return fragments_js_1.FallbackFragment;
      }
    });
    Object.defineProperty(exports, "Fragment", {
      enumerable: true,
      get: function get() {
        return fragments_js_1.Fragment;
      }
    });
    Object.defineProperty(exports, "FunctionFragment", {
      enumerable: true,
      get: function get() {
        return fragments_js_1.FunctionFragment;
      }
    });
    Object.defineProperty(exports, "NamedFragment", {
      enumerable: true,
      get: function get() {
        return fragments_js_1.NamedFragment;
      }
    });
    Object.defineProperty(exports, "ParamType", {
      enumerable: true,
      get: function get() {
        return fragments_js_1.ParamType;
      }
    });
    Object.defineProperty(exports, "StructFragment", {
      enumerable: true,
      get: function get() {
        return fragments_js_1.StructFragment;
      }
    });
    var interface_js_1 = /*@__PURE__*/require_interface();
    Object.defineProperty(exports, "checkResultErrors", {
      enumerable: true,
      get: function get() {
        return interface_js_1.checkResultErrors;
      }
    });
    Object.defineProperty(exports, "Indexed", {
      enumerable: true,
      get: function get() {
        return interface_js_1.Indexed;
      }
    });
    Object.defineProperty(exports, "Interface", {
      enumerable: true,
      get: function get() {
        return interface_js_1.Interface;
      }
    });
    Object.defineProperty(exports, "ErrorDescription", {
      enumerable: true,
      get: function get() {
        return interface_js_1.ErrorDescription;
      }
    });
    Object.defineProperty(exports, "LogDescription", {
      enumerable: true,
      get: function get() {
        return interface_js_1.LogDescription;
      }
    });
    Object.defineProperty(exports, "TransactionDescription", {
      enumerable: true,
      get: function get() {
        return interface_js_1.TransactionDescription;
      }
    });
    Object.defineProperty(exports, "Result", {
      enumerable: true,
      get: function get() {
        return interface_js_1.Result;
      }
    });
    var typed_js_1 = /*@__PURE__*/requireTyped();
    Object.defineProperty(exports, "Typed", {
      enumerable: true,
      get: function get() {
        return typed_js_1.Typed;
      }
    });
  })(abi);
  return abi;
}

var contract$1 = {};

var contract = {};

var provider = {};

var hasRequiredProvider;
function requireProvider() {
  if (hasRequiredProvider) return provider;
  hasRequiredProvider = 1;
  Object.defineProperty(provider, "__esModule", {
    value: true
  });
  provider.TransactionResponse = provider.TransactionReceipt = provider.Log = provider.Block = provider.copyRequest = provider.FeeData = void 0;
  //import { resolveAddress } from "@ethersproject/address";
  var index_js_1 = /*@__PURE__*/requireUtils$3();
  var index_js_2 = /*@__PURE__*/requireTransaction();
  var BN_0 = BigInt(0);
  // -----------------------
  function getValue(value) {
    if (value == null) {
      return null;
    }
    return value;
  }
  function toJson(value) {
    if (value == null) {
      return null;
    }
    return value.toString();
  }
  // @TODO? <T extends FeeData = { }> implements Required<T>
  /**
   *  A **FeeData** wraps all the fee-related values associated with
   *  the network.
   */
  var FeeData = /*#__PURE__*/function () {
    /**
     *  Creates a new FeeData for %%gasPrice%%, %%maxFeePerGas%% and
     *  %%maxPriorityFeePerGas%%.
     */
    function FeeData(gasPrice, maxFeePerGas, maxPriorityFeePerGas) {
      _classCallCheck(this, FeeData);
      /**
       *  The gas price for legacy networks.
       */
      _defineProperty(this, "gasPrice", void 0);
      /**
       *  The maximum fee to pay per gas.
       *
       *  The base fee per gas is defined by the network and based on
       *  congestion, increasing the cost during times of heavy load
       *  and lowering when less busy.
       *
       *  The actual fee per gas will be the base fee for the block
       *  and the priority fee, up to the max fee per gas.
       *
       *  This will be ``null`` on legacy networks (i.e. [pre-EIP-1559](link-eip-1559))
       */
      _defineProperty(this, "maxFeePerGas", void 0);
      /**
       *  The additional amout to pay per gas to encourage a validator
       *  to include the transaction.
       *
       *  The purpose of this is to compensate the validator for the
       *  adjusted risk for including a given transaction.
       *
       *  This will be ``null`` on legacy networks (i.e. [pre-EIP-1559](link-eip-1559))
       */
      _defineProperty(this, "maxPriorityFeePerGas", void 0);
      (0, index_js_1.defineProperties)(this, {
        gasPrice: getValue(gasPrice),
        maxFeePerGas: getValue(maxFeePerGas),
        maxPriorityFeePerGas: getValue(maxPriorityFeePerGas)
      });
    }
    /**
     *  Returns a JSON-friendly value.
     */
    return _createClass(FeeData, [{
      key: "toJSON",
      value: function toJSON() {
        var gasPrice = this.gasPrice,
          maxFeePerGas = this.maxFeePerGas,
          maxPriorityFeePerGas = this.maxPriorityFeePerGas;
        return {
          _type: "FeeData",
          gasPrice: toJson(gasPrice),
          maxFeePerGas: toJson(maxFeePerGas),
          maxPriorityFeePerGas: toJson(maxPriorityFeePerGas)
        };
      }
    }]);
  }();
  provider.FeeData = FeeData;
  /**
   *  Returns a copy of %%req%% with all properties coerced to their strict
   *  types.
   */
  function copyRequest(req) {
    var result = {};
    // These could be addresses, ENS names or Addressables
    if (req.to) {
      result.to = req.to;
    }
    if (req.from) {
      result.from = req.from;
    }
    if (req.data) {
      result.data = (0, index_js_1.hexlify)(req.data);
    }
    var bigIntKeys = "chainId,gasLimit,gasPrice,maxFeePerBlobGas,maxFeePerGas,maxPriorityFeePerGas,value".split(/,/);
    var _iterator = _createForOfIteratorHelper(bigIntKeys),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var key = _step.value;
        if (!(key in req) || req[key] == null) {
          continue;
        }
        result[key] = (0, index_js_1.getBigInt)(req[key], "request.".concat(key));
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    var numberKeys = "type,nonce".split(/,/);
    var _iterator2 = _createForOfIteratorHelper(numberKeys),
      _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var _key = _step2.value;
        if (!(_key in req) || req[_key] == null) {
          continue;
        }
        result[_key] = (0, index_js_1.getNumber)(req[_key], "request.".concat(_key));
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
    if (req.accessList) {
      result.accessList = (0, index_js_2.accessListify)(req.accessList);
    }
    if ("blockTag" in req) {
      result.blockTag = req.blockTag;
    }
    if ("enableCcipRead" in req) {
      result.enableCcipRead = !!req.enableCcipRead;
    }
    if ("customData" in req) {
      result.customData = req.customData;
    }
    if ("blobVersionedHashes" in req && req.blobVersionedHashes) {
      result.blobVersionedHashes = req.blobVersionedHashes.slice();
    }
    if ("kzg" in req) {
      result.kzg = req.kzg;
    }
    if ("blobs" in req && req.blobs) {
      result.blobs = req.blobs.map(function (b) {
        if ((0, index_js_1.isBytesLike)(b)) {
          return (0, index_js_1.hexlify)(b);
        }
        return Object.assign({}, b);
      });
    }
    return result;
  }
  provider.copyRequest = copyRequest;
  /**
   *  A **Block** represents the data associated with a full block on
   *  Ethereum.
   */
  var _transactions = /*#__PURE__*/new WeakMap();
  var Block = /*#__PURE__*/function () {
    /**
     *  Create a new **Block** object.
     *
     *  This should generally not be necessary as the unless implementing a
     *  low-level library.
     */
    function Block(block, provider) {
      _classCallCheck(this, Block);
      /**
       *  The provider connected to the block used to fetch additional details
       *  if necessary.
       */
      _defineProperty(this, "provider", void 0);
      /**
       *  The block number, sometimes called the block height. This is a
       *  sequential number that is one higher than the parent block.
       */
      _defineProperty(this, "number", void 0);
      /**
       *  The block hash.
       *
       *  This hash includes all properties, so can be safely used to identify
       *  an exact set of block properties.
       */
      _defineProperty(this, "hash", void 0);
      /**
       *  The timestamp for this block, which is the number of seconds since
       *  epoch that this block was included.
       */
      _defineProperty(this, "timestamp", void 0);
      /**
       *  The block hash of the parent block.
       */
      _defineProperty(this, "parentHash", void 0);
      /**
       *  The hash tree root of the parent beacon block for the given
       *  execution block. See [[link-eip-4788]].
       */
      _defineProperty(this, "parentBeaconBlockRoot", void 0);
      /**
       *  The nonce.
       *
       *  On legacy networks, this is the random number inserted which
       *  permitted the difficulty target to be reached.
       */
      _defineProperty(this, "nonce", void 0);
      /**
       *  The difficulty target.
       *
       *  On legacy networks, this is the proof-of-work target required
       *  for a block to meet the protocol rules to be included.
       *
       *  On modern networks, this is a random number arrived at using
       *  randao.  @TODO: Find links?
       */
      _defineProperty(this, "difficulty", void 0);
      /**
       *  The total gas limit for this block.
       */
      _defineProperty(this, "gasLimit", void 0);
      /**
       *  The total gas used in this block.
       */
      _defineProperty(this, "gasUsed", void 0);
      /**
       *  The root hash for the global state after applying changes
       *  in this block.
       */
      _defineProperty(this, "stateRoot", void 0);
      /**
       *  The hash of the transaction receipts trie.
       */
      _defineProperty(this, "receiptsRoot", void 0);
      /**
       *  The total amount of blob gas consumed by the transactions
       *  within the block. See [[link-eip-4844]].
       */
      _defineProperty(this, "blobGasUsed", void 0);
      /**
       *  The running total of blob gas consumed in excess of the
       *  target, prior to the block. See [[link-eip-4844]].
       */
      _defineProperty(this, "excessBlobGas", void 0);
      /**
       *  The miner coinbase address, wihch receives any subsidies for
       *  including this block.
       */
      _defineProperty(this, "miner", void 0);
      /**
       *  The latest RANDAO mix of the post beacon state of
       *  the previous block.
       */
      _defineProperty(this, "prevRandao", void 0);
      /**
       *  Any extra data the validator wished to include.
       */
      _defineProperty(this, "extraData", void 0);
      /**
       *  The base fee per gas that all transactions in this block were
       *  charged.
       *
       *  This adjusts after each block, depending on how congested the network
       *  is.
       */
      _defineProperty(this, "baseFeePerGas", void 0);
      _classPrivateFieldInitSpec(this, _transactions, void 0);
      _classPrivateFieldSet2(_transactions, this, block.transactions.map(function (tx) {
        if (typeof tx !== "string") {
          return new TransactionResponse(tx, provider);
        }
        return tx;
      }));
      (0, index_js_1.defineProperties)(this, {
        provider: provider,
        hash: getValue(block.hash),
        number: block.number,
        timestamp: block.timestamp,
        parentHash: block.parentHash,
        parentBeaconBlockRoot: block.parentBeaconBlockRoot,
        nonce: block.nonce,
        difficulty: block.difficulty,
        gasLimit: block.gasLimit,
        gasUsed: block.gasUsed,
        blobGasUsed: block.blobGasUsed,
        excessBlobGas: block.excessBlobGas,
        miner: block.miner,
        prevRandao: getValue(block.prevRandao),
        extraData: block.extraData,
        baseFeePerGas: getValue(block.baseFeePerGas),
        stateRoot: block.stateRoot,
        receiptsRoot: block.receiptsRoot
      });
    }
    /**
     *  Returns the list of transaction hashes, in the order
     *  they were executed within the block.
     */
    return _createClass(Block, [{
      key: "transactions",
      get: function get() {
        return _classPrivateFieldGet2(_transactions, this).map(function (tx) {
          if (typeof tx === "string") {
            return tx;
          }
          return tx.hash;
        });
      }
      /**
       *  Returns the complete transactions, in the order they
       *  were executed within the block.
       *
       *  This is only available for blocks which prefetched
       *  transactions, by passing ``true`` to %%prefetchTxs%%
       *  into [[Provider-getBlock]].
       */
    }, {
      key: "prefetchedTransactions",
      get: function get() {
        var txs = _classPrivateFieldGet2(_transactions, this).slice();
        // Doesn't matter...
        if (txs.length === 0) {
          return [];
        }
        // Make sure we prefetched the transactions
        (0, index_js_1.assert)(_typeof(txs[0]) === "object", "transactions were not prefetched with block request", "UNSUPPORTED_OPERATION", {
          operation: "transactionResponses()"
        });
        return txs;
      }
      /**
       *  Returns a JSON-friendly value.
       */
    }, {
      key: "toJSON",
      value: function toJSON() {
        var baseFeePerGas = this.baseFeePerGas,
          difficulty = this.difficulty,
          extraData = this.extraData,
          gasLimit = this.gasLimit,
          gasUsed = this.gasUsed,
          hash = this.hash,
          miner = this.miner,
          prevRandao = this.prevRandao,
          nonce = this.nonce,
          number = this.number,
          parentHash = this.parentHash,
          parentBeaconBlockRoot = this.parentBeaconBlockRoot,
          stateRoot = this.stateRoot,
          receiptsRoot = this.receiptsRoot,
          timestamp = this.timestamp,
          transactions = this.transactions;
        return {
          _type: "Block",
          baseFeePerGas: toJson(baseFeePerGas),
          difficulty: toJson(difficulty),
          extraData: extraData,
          gasLimit: toJson(gasLimit),
          gasUsed: toJson(gasUsed),
          blobGasUsed: toJson(this.blobGasUsed),
          excessBlobGas: toJson(this.excessBlobGas),
          hash: hash,
          miner: miner,
          prevRandao: prevRandao,
          nonce: nonce,
          number: number,
          parentHash: parentHash,
          timestamp: timestamp,
          parentBeaconBlockRoot: parentBeaconBlockRoot,
          stateRoot: stateRoot,
          receiptsRoot: receiptsRoot,
          transactions: transactions
        };
      }
    }, {
      key: Symbol.iterator,
      value: function value() {
        var _this = this;
        var index = 0;
        var txs = this.transactions;
        return {
          next: function next() {
            if (index < _this.length) {
              return {
                value: txs[index++],
                done: false
              };
            }
            return {
              value: undefined,
              done: true
            };
          }
        };
      }
      /**
       *  The number of transactions in this block.
       */
    }, {
      key: "length",
      get: function get() {
        return _classPrivateFieldGet2(_transactions, this).length;
      }
      /**
       *  The [[link-js-date]] this block was included at.
       */
    }, {
      key: "date",
      get: function get() {
        if (this.timestamp == null) {
          return null;
        }
        return new Date(this.timestamp * 1000);
      }
      /**
       *  Get the transaction at %%indexe%% within this block.
       */
    }, {
      key: "getTransaction",
      value: (function () {
        var _getTransaction = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(indexOrHash) {
          var tx, hash, _iterator3, _step3, v;
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                // Find the internal value by its index or hash
                tx = undefined;
                if (!(typeof indexOrHash === "number")) {
                  _context.next = 5;
                  break;
                }
                tx = _classPrivateFieldGet2(_transactions, this)[indexOrHash];
                _context.next = 32;
                break;
              case 5:
                hash = indexOrHash.toLowerCase();
                _iterator3 = _createForOfIteratorHelper(_classPrivateFieldGet2(_transactions, this));
                _context.prev = 7;
                _iterator3.s();
              case 9:
                if ((_step3 = _iterator3.n()).done) {
                  _context.next = 24;
                  break;
                }
                v = _step3.value;
                if (!(typeof v === "string")) {
                  _context.next = 18;
                  break;
                }
                if (!(v !== hash)) {
                  _context.next = 14;
                  break;
                }
                return _context.abrupt("continue", 22);
              case 14:
                tx = v;
                return _context.abrupt("break", 24);
              case 18:
                if (!(v.hash === hash)) {
                  _context.next = 20;
                  break;
                }
                return _context.abrupt("continue", 22);
              case 20:
                tx = v;
                return _context.abrupt("break", 24);
              case 22:
                _context.next = 9;
                break;
              case 24:
                _context.next = 29;
                break;
              case 26:
                _context.prev = 26;
                _context.t0 = _context["catch"](7);
                _iterator3.e(_context.t0);
              case 29:
                _context.prev = 29;
                _iterator3.f();
                return _context.finish(29);
              case 32:
                if (!(tx == null)) {
                  _context.next = 34;
                  break;
                }
                throw new Error("no such tx");
              case 34:
                if (!(typeof tx === "string")) {
                  _context.next = 40;
                  break;
                }
                _context.next = 37;
                return this.provider.getTransaction(tx);
              case 37:
                return _context.abrupt("return", _context.sent);
              case 40:
                return _context.abrupt("return", tx);
              case 41:
              case "end":
                return _context.stop();
            }
          }, _callee, this, [[7, 26, 29, 32]]);
        }));
        function getTransaction(_x) {
          return _getTransaction.apply(this, arguments);
        }
        return getTransaction;
      }()
      /**
       *  If a **Block** was fetched with a request to include the transactions
       *  this will allow synchronous access to those transactions.
       *
       *  If the transactions were not prefetched, this will throw.
       */
      )
    }, {
      key: "getPrefetchedTransaction",
      value: function getPrefetchedTransaction(indexOrHash) {
        var txs = this.prefetchedTransactions;
        if (typeof indexOrHash === "number") {
          return txs[indexOrHash];
        }
        indexOrHash = indexOrHash.toLowerCase();
        var _iterator4 = _createForOfIteratorHelper(txs),
          _step4;
        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
            var tx = _step4.value;
            if (tx.hash === indexOrHash) {
              return tx;
            }
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }
        (0, index_js_1.assertArgument)(false, "no matching transaction", "indexOrHash", indexOrHash);
      }
      /**
       *  Returns true if this block been mined. This provides a type guard
       *  for all properties on a [[MinedBlock]].
       */
    }, {
      key: "isMined",
      value: function isMined() {
        return !!this.hash;
      }
      /**
       *  Returns true if this block is an [[link-eip-2930]] block.
       */
    }, {
      key: "isLondon",
      value: function isLondon() {
        return !!this.baseFeePerGas;
      }
      /**
       *  @_ignore:
       */
    }, {
      key: "orphanedEvent",
      value: function orphanedEvent() {
        if (!this.isMined()) {
          throw new Error("");
        }
        return createOrphanedBlockFilter(this);
      }
    }]);
  }();
  provider.Block = Block;
  //////////////////////
  // Log
  /**
   *  A **Log** in Ethereum represents an event that has been included in a
   *  transaction using the ``LOG*`` opcodes, which are most commonly used by
   *  Solidity's emit for announcing events.
   */
  var Log = /*#__PURE__*/function () {
    /**
     *  @_ignore:
     */
    function Log(log, provider) {
      _classCallCheck(this, Log);
      /**
       *  The provider connected to the log used to fetch additional details
       *  if necessary.
       */
      _defineProperty(this, "provider", void 0);
      /**
       *  The transaction hash of the transaction this log occurred in. Use the
       *  [[Log-getTransaction]] to get the [[TransactionResponse]].
       */
      _defineProperty(this, "transactionHash", void 0);
      /**
       *  The block hash of the block this log occurred in. Use the
       *  [[Log-getBlock]] to get the [[Block]].
       */
      _defineProperty(this, "blockHash", void 0);
      /**
       *  The block number of the block this log occurred in. It is preferred
       *  to use the [[Block-hash]] when fetching the related [[Block]],
       *  since in the case of an orphaned block, the block at that height may
       *  have changed.
       */
      _defineProperty(this, "blockNumber", void 0);
      /**
       *  If the **Log** represents a block that was removed due to an orphaned
       *  block, this will be true.
       *
       *  This can only happen within an orphan event listener.
       */
      _defineProperty(this, "removed", void 0);
      /**
       *  The address of the contract that emitted this log.
       */
      _defineProperty(this, "address", void 0);
      /**
       *  The data included in this log when it was emitted.
       */
      _defineProperty(this, "data", void 0);
      /**
       *  The indexed topics included in this log when it was emitted.
       *
       *  All topics are included in the bloom filters, so they can be
       *  efficiently filtered using the [[Provider-getLogs]] method.
       */
      _defineProperty(this, "topics", void 0);
      /**
       *  The index within the block this log occurred at. This is generally
       *  not useful to developers, but can be used with the various roots
       *  to proof inclusion within a block.
       */
      _defineProperty(this, "index", void 0);
      /**
       *  The index within the transaction of this log.
       */
      _defineProperty(this, "transactionIndex", void 0);
      this.provider = provider;
      var topics = Object.freeze(log.topics.slice());
      (0, index_js_1.defineProperties)(this, {
        transactionHash: log.transactionHash,
        blockHash: log.blockHash,
        blockNumber: log.blockNumber,
        removed: log.removed,
        address: log.address,
        data: log.data,
        topics: topics,
        index: log.index,
        transactionIndex: log.transactionIndex
      });
    }
    /**
     *  Returns a JSON-compatible object.
     */
    return _createClass(Log, [{
      key: "toJSON",
      value: function toJSON() {
        var address = this.address,
          blockHash = this.blockHash,
          blockNumber = this.blockNumber,
          data = this.data,
          index = this.index,
          removed = this.removed,
          topics = this.topics,
          transactionHash = this.transactionHash,
          transactionIndex = this.transactionIndex;
        return {
          _type: "log",
          address: address,
          blockHash: blockHash,
          blockNumber: blockNumber,
          data: data,
          index: index,
          removed: removed,
          topics: topics,
          transactionHash: transactionHash,
          transactionIndex: transactionIndex
        };
      }
      /**
       *  Returns the block that this log occurred in.
       */
    }, {
      key: "getBlock",
      value: (function () {
        var _getBlock = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
          var block;
          return _regeneratorRuntime().wrap(function _callee2$(_context2) {
            while (1) switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.provider.getBlock(this.blockHash);
              case 2:
                block = _context2.sent;
                (0, index_js_1.assert)(!!block, "failed to find transaction", "UNKNOWN_ERROR", {});
                return _context2.abrupt("return", block);
              case 5:
              case "end":
                return _context2.stop();
            }
          }, _callee2, this);
        }));
        function getBlock() {
          return _getBlock.apply(this, arguments);
        }
        return getBlock;
      }()
      /**
       *  Returns the transaction that this log occurred in.
       */
      )
    }, {
      key: "getTransaction",
      value: (function () {
        var _getTransaction2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
          var tx;
          return _regeneratorRuntime().wrap(function _callee3$(_context3) {
            while (1) switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.provider.getTransaction(this.transactionHash);
              case 2:
                tx = _context3.sent;
                (0, index_js_1.assert)(!!tx, "failed to find transaction", "UNKNOWN_ERROR", {});
                return _context3.abrupt("return", tx);
              case 5:
              case "end":
                return _context3.stop();
            }
          }, _callee3, this);
        }));
        function getTransaction() {
          return _getTransaction2.apply(this, arguments);
        }
        return getTransaction;
      }()
      /**
       *  Returns the transaction receipt fot the transaction that this
       *  log occurred in.
       */
      )
    }, {
      key: "getTransactionReceipt",
      value: (function () {
        var _getTransactionReceipt = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
          var receipt;
          return _regeneratorRuntime().wrap(function _callee4$(_context4) {
            while (1) switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.provider.getTransactionReceipt(this.transactionHash);
              case 2:
                receipt = _context4.sent;
                (0, index_js_1.assert)(!!receipt, "failed to find transaction receipt", "UNKNOWN_ERROR", {});
                return _context4.abrupt("return", receipt);
              case 5:
              case "end":
                return _context4.stop();
            }
          }, _callee4, this);
        }));
        function getTransactionReceipt() {
          return _getTransactionReceipt.apply(this, arguments);
        }
        return getTransactionReceipt;
      }()
      /**
       *  @_ignore:
       */
      )
    }, {
      key: "removedEvent",
      value: function removedEvent() {
        return createRemovedLogFilter(this);
      }
    }]);
  }();
  provider.Log = Log;
  //////////////////////
  // Transaction Receipt
  /*
  export interface LegacyTransactionReceipt {
      byzantium: false;
      status: null;
      root: string;
  }
  	export interface ByzantiumTransactionReceipt {
      byzantium: true;
      status: number;
      root: null;
  }
  */
  /**
   *  A **TransactionReceipt** includes additional information about a
   *  transaction that is only available after it has been mined.
   */
  var _logs = /*#__PURE__*/new WeakMap();
  var TransactionReceipt = /*#__PURE__*/function () {
    /**
     *  @_ignore:
     */
    function TransactionReceipt(tx, provider) {
      _classCallCheck(this, TransactionReceipt);
      /**
       *  The provider connected to the log used to fetch additional details
       *  if necessary.
       */
      _defineProperty(this, "provider", void 0);
      /**
       *  The address the transaction was sent to.
       */
      _defineProperty(this, "to", void 0);
      /**
       *  The sender of the transaction.
       */
      _defineProperty(this, "from", void 0);
      /**
       *  The address of the contract if the transaction was directly
       *  responsible for deploying one.
       *
       *  This is non-null **only** if the ``to`` is empty and the ``data``
       *  was successfully executed as initcode.
       */
      _defineProperty(this, "contractAddress", void 0);
      /**
       *  The transaction hash.
       */
      _defineProperty(this, "hash", void 0);
      /**
       *  The index of this transaction within the block transactions.
       */
      _defineProperty(this, "index", void 0);
      /**
       *  The block hash of the [[Block]] this transaction was included in.
       */
      _defineProperty(this, "blockHash", void 0);
      /**
       *  The block number of the [[Block]] this transaction was included in.
       */
      _defineProperty(this, "blockNumber", void 0);
      /**
       *  The bloom filter bytes that represent all logs that occurred within
       *  this transaction. This is generally not useful for most developers,
       *  but can be used to validate the included logs.
       */
      _defineProperty(this, "logsBloom", void 0);
      /**
       *  The actual amount of gas used by this transaction.
       *
       *  When creating a transaction, the amount of gas that will be used can
       *  only be approximated, but the sender must pay the gas fee for the
       *  entire gas limit. After the transaction, the difference is refunded.
       */
      _defineProperty(this, "gasUsed", void 0);
      /**
       *  The gas used for BLObs. See [[link-eip-4844]].
       */
      _defineProperty(this, "blobGasUsed", void 0);
      /**
       *  The amount of gas used by all transactions within the block for this
       *  and all transactions with a lower ``index``.
       *
       *  This is generally not useful for developers but can be used to
       *  validate certain aspects of execution.
       */
      _defineProperty(this, "cumulativeGasUsed", void 0);
      /**
       *  The actual gas price used during execution.
       *
       *  Due to the complexity of [[link-eip-1559]] this value can only
       *  be caluclated after the transaction has been mined, snce the base
       *  fee is protocol-enforced.
       */
      _defineProperty(this, "gasPrice", void 0);
      /**
       *  The price paid per BLOB in gas. See [[link-eip-4844]].
       */
      _defineProperty(this, "blobGasPrice", void 0);
      /**
       *  The [[link-eip-2718]] transaction type.
       */
      _defineProperty(this, "type", void 0);
      //readonly byzantium!: boolean;
      /**
       *  The status of this transaction, indicating success (i.e. ``1``) or
       *  a revert (i.e. ``0``).
       *
       *  This is available in post-byzantium blocks, but some backends may
       *  backfill this value.
       */
      _defineProperty(this, "status", void 0);
      /**
       *  The root hash of this transaction.
       *
       *  This is no present and was only included in pre-byzantium blocks, but
       *  could be used to validate certain parts of the receipt.
       */
      _defineProperty(this, "root", void 0);
      _classPrivateFieldInitSpec(this, _logs, void 0);
      _classPrivateFieldSet2(_logs, this, Object.freeze(tx.logs.map(function (log) {
        return new Log(log, provider);
      })));
      var gasPrice = BN_0;
      if (tx.effectiveGasPrice != null) {
        gasPrice = tx.effectiveGasPrice;
      } else if (tx.gasPrice != null) {
        gasPrice = tx.gasPrice;
      }
      (0, index_js_1.defineProperties)(this, {
        provider: provider,
        to: tx.to,
        from: tx.from,
        contractAddress: tx.contractAddress,
        hash: tx.hash,
        index: tx.index,
        blockHash: tx.blockHash,
        blockNumber: tx.blockNumber,
        logsBloom: tx.logsBloom,
        gasUsed: tx.gasUsed,
        cumulativeGasUsed: tx.cumulativeGasUsed,
        blobGasUsed: tx.blobGasUsed,
        gasPrice: gasPrice,
        blobGasPrice: tx.blobGasPrice,
        type: tx.type,
        //byzantium: tx.byzantium,
        status: tx.status,
        root: tx.root
      });
    }
    /**
     *  The logs for this transaction.
     */
    return _createClass(TransactionReceipt, [{
      key: "logs",
      get: function get() {
        return _classPrivateFieldGet2(_logs, this);
      }
      /**
       *  Returns a JSON-compatible representation.
       */
    }, {
      key: "toJSON",
      value: function toJSON() {
        var to = this.to,
          from = this.from,
          contractAddress = this.contractAddress,
          hash = this.hash,
          index = this.index,
          blockHash = this.blockHash,
          blockNumber = this.blockNumber,
          logsBloom = this.logsBloom,
          logs = this.logs,
          status = this.status,
          root = this.root;
        return {
          _type: "TransactionReceipt",
          blockHash: blockHash,
          blockNumber: blockNumber,
          //byzantium, 
          contractAddress: contractAddress,
          cumulativeGasUsed: toJson(this.cumulativeGasUsed),
          from: from,
          gasPrice: toJson(this.gasPrice),
          blobGasUsed: toJson(this.blobGasUsed),
          blobGasPrice: toJson(this.blobGasPrice),
          gasUsed: toJson(this.gasUsed),
          hash: hash,
          index: index,
          logs: logs,
          logsBloom: logsBloom,
          root: root,
          status: status,
          to: to
        };
      }
      /**
       *  @_ignore:
       */
    }, {
      key: "length",
      get: function get() {
        return this.logs.length;
      }
    }, {
      key: Symbol.iterator,
      value: function value() {
        var _this2 = this;
        var index = 0;
        return {
          next: function next() {
            if (index < _this2.length) {
              return {
                value: _this2.logs[index++],
                done: false
              };
            }
            return {
              value: undefined,
              done: true
            };
          }
        };
      }
      /**
       *  The total fee for this transaction, in wei.
       */
    }, {
      key: "fee",
      get: function get() {
        return this.gasUsed * this.gasPrice;
      }
      /**
       *  Resolves to the block this transaction occurred in.
       */
    }, {
      key: "getBlock",
      value: (function () {
        var _getBlock2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
          var block;
          return _regeneratorRuntime().wrap(function _callee5$(_context5) {
            while (1) switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return this.provider.getBlock(this.blockHash);
              case 2:
                block = _context5.sent;
                if (!(block == null)) {
                  _context5.next = 5;
                  break;
                }
                throw new Error("TODO");
              case 5:
                return _context5.abrupt("return", block);
              case 6:
              case "end":
                return _context5.stop();
            }
          }, _callee5, this);
        }));
        function getBlock() {
          return _getBlock2.apply(this, arguments);
        }
        return getBlock;
      }()
      /**
       *  Resolves to the transaction this transaction occurred in.
       */
      )
    }, {
      key: "getTransaction",
      value: (function () {
        var _getTransaction3 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
          var tx;
          return _regeneratorRuntime().wrap(function _callee6$(_context6) {
            while (1) switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return this.provider.getTransaction(this.hash);
              case 2:
                tx = _context6.sent;
                if (!(tx == null)) {
                  _context6.next = 5;
                  break;
                }
                throw new Error("TODO");
              case 5:
                return _context6.abrupt("return", tx);
              case 6:
              case "end":
                return _context6.stop();
            }
          }, _callee6, this);
        }));
        function getTransaction() {
          return _getTransaction3.apply(this, arguments);
        }
        return getTransaction;
      }()
      /**
       *  Resolves to the return value of the execution of this transaction.
       *
       *  Support for this feature is limited, as it requires an archive node
       *  with the ``debug_`` or ``trace_`` API enabled.
       */
      )
    }, {
      key: "getResult",
      value: (function () {
        var _getResult = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {
          return _regeneratorRuntime().wrap(function _callee7$(_context7) {
            while (1) switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return this.provider.getTransactionResult(this.hash);
              case 2:
                return _context7.abrupt("return", _context7.sent);
              case 3:
              case "end":
                return _context7.stop();
            }
          }, _callee7, this);
        }));
        function getResult() {
          return _getResult.apply(this, arguments);
        }
        return getResult;
      }()
      /**
       *  Resolves to the number of confirmations this transaction has.
       */
      )
    }, {
      key: "confirmations",
      value: (function () {
        var _confirmations = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {
          return _regeneratorRuntime().wrap(function _callee8$(_context8) {
            while (1) switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return this.provider.getBlockNumber();
              case 2:
                _context8.t0 = _context8.sent;
                _context8.t1 = this.blockNumber;
                _context8.t2 = _context8.t0 - _context8.t1;
                return _context8.abrupt("return", _context8.t2 + 1);
              case 6:
              case "end":
                return _context8.stop();
            }
          }, _callee8, this);
        }));
        function confirmations() {
          return _confirmations.apply(this, arguments);
        }
        return confirmations;
      }()
      /**
       *  @_ignore:
       */
      )
    }, {
      key: "removedEvent",
      value: function removedEvent() {
        return createRemovedTransactionFilter(this);
      }
      /**
       *  @_ignore:
       */
    }, {
      key: "reorderedEvent",
      value: function reorderedEvent(other) {
        (0, index_js_1.assert)(!other || other.isMined(), "unmined 'other' transction cannot be orphaned", "UNSUPPORTED_OPERATION", {
          operation: "reorderedEvent(other)"
        });
        return createReorderedTransactionFilter(this, other);
      }
    }]);
  }();
  provider.TransactionReceipt = TransactionReceipt;
  /**
   *  A **TransactionResponse** includes all properties about a transaction
   *  that was sent to the network, which may or may not be included in a
   *  block.
   *
   *  The [[TransactionResponse-isMined]] can be used to check if the
   *  transaction has been mined as well as type guard that the otherwise
   *  possibly ``null`` properties are defined.
   */
  var _startBlock = /*#__PURE__*/new WeakMap();
  var TransactionResponse = /*#__PURE__*/function () {
    /**
     *  @_ignore:
     */
    function TransactionResponse(tx, provider) {
      _classCallCheck(this, TransactionResponse);
      /**
       *  The provider this is connected to, which will influence how its
       *  methods will resolve its async inspection methods.
       */
      _defineProperty(this, "provider", void 0);
      /**
       *  The block number of the block that this transaction was included in.
       *
       *  This is ``null`` for pending transactions.
       */
      _defineProperty(this, "blockNumber", void 0);
      /**
       *  The blockHash of the block that this transaction was included in.
       *
       *  This is ``null`` for pending transactions.
       */
      _defineProperty(this, "blockHash", void 0);
      /**
       *  The index within the block that this transaction resides at.
       */
      _defineProperty(this, "index", void 0);
      /**
       *  The transaction hash.
       */
      _defineProperty(this, "hash", void 0);
      /**
       *  The [[link-eip-2718]] transaction envelope type. This is
       *  ``0`` for legacy transactions types.
       */
      _defineProperty(this, "type", void 0);
      /**
       *  The receiver of this transaction.
       *
       *  If ``null``, then the transaction is an initcode transaction.
       *  This means the result of executing the [[data]] will be deployed
       *  as a new contract on chain (assuming it does not revert) and the
       *  address may be computed using [[getCreateAddress]].
       */
      _defineProperty(this, "to", void 0);
      /**
       *  The sender of this transaction. It is implicitly computed
       *  from the transaction pre-image hash (as the digest) and the
       *  [[signature]] using ecrecover.
       */
      _defineProperty(this, "from", void 0);
      /**
       *  The nonce, which is used to prevent replay attacks and offer
       *  a method to ensure transactions from a given sender are explicitly
       *  ordered.
       *
       *  When sending a transaction, this must be equal to the number of
       *  transactions ever sent by [[from]].
       */
      _defineProperty(this, "nonce", void 0);
      /**
       *  The maximum units of gas this transaction can consume. If execution
       *  exceeds this, the entries transaction is reverted and the sender
       *  is charged for the full amount, despite not state changes being made.
       */
      _defineProperty(this, "gasLimit", void 0);
      /**
       *  The gas price can have various values, depending on the network.
       *
       *  In modern networks, for transactions that are included this is
       *  the //effective gas price// (the fee per gas that was actually
       *  charged), while for transactions that have not been included yet
       *  is the [[maxFeePerGas]].
       *
       *  For legacy transactions, or transactions on legacy networks, this
       *  is the fee that will be charged per unit of gas the transaction
       *  consumes.
       */
      _defineProperty(this, "gasPrice", void 0);
      /**
       *  The maximum priority fee (per unit of gas) to allow a
       *  validator to charge the sender. This is inclusive of the
       *  [[maxFeeFeePerGas]].
       */
      _defineProperty(this, "maxPriorityFeePerGas", void 0);
      /**
       *  The maximum fee (per unit of gas) to allow this transaction
       *  to charge the sender.
       */
      _defineProperty(this, "maxFeePerGas", void 0);
      /**
       *  The [[link-eip-4844]] max fee per BLOb gas.
       */
      _defineProperty(this, "maxFeePerBlobGas", void 0);
      /**
       *  The data.
       */
      _defineProperty(this, "data", void 0);
      /**
       *  The value, in wei. Use [[formatEther]] to format this value
       *  as ether.
       */
      _defineProperty(this, "value", void 0);
      /**
       *  The chain ID.
       */
      _defineProperty(this, "chainId", void 0);
      /**
       *  The signature.
       */
      _defineProperty(this, "signature", void 0);
      /**
       *  The [[link-eip-2930]] access list for transaction types that
       *  support it, otherwise ``null``.
       */
      _defineProperty(this, "accessList", void 0);
      /**
       *  The [[link-eip-4844]] BLOb versioned hashes.
       */
      _defineProperty(this, "blobVersionedHashes", void 0);
      _classPrivateFieldInitSpec(this, _startBlock, void 0);
      this.provider = provider;
      this.blockNumber = tx.blockNumber != null ? tx.blockNumber : null;
      this.blockHash = tx.blockHash != null ? tx.blockHash : null;
      this.hash = tx.hash;
      this.index = tx.index;
      this.type = tx.type;
      this.from = tx.from;
      this.to = tx.to || null;
      this.gasLimit = tx.gasLimit;
      this.nonce = tx.nonce;
      this.data = tx.data;
      this.value = tx.value;
      this.gasPrice = tx.gasPrice;
      this.maxPriorityFeePerGas = tx.maxPriorityFeePerGas != null ? tx.maxPriorityFeePerGas : null;
      this.maxFeePerGas = tx.maxFeePerGas != null ? tx.maxFeePerGas : null;
      this.maxFeePerBlobGas = tx.maxFeePerBlobGas != null ? tx.maxFeePerBlobGas : null;
      this.chainId = tx.chainId;
      this.signature = tx.signature;
      this.accessList = tx.accessList != null ? tx.accessList : null;
      this.blobVersionedHashes = tx.blobVersionedHashes != null ? tx.blobVersionedHashes : null;
      _classPrivateFieldSet2(_startBlock, this, -1);
    }
    /**
     *  Returns a JSON-compatible representation of this transaction.
     */
    return _createClass(TransactionResponse, [{
      key: "toJSON",
      value: function toJSON() {
        var blockNumber = this.blockNumber,
          blockHash = this.blockHash,
          index = this.index,
          hash = this.hash,
          type = this.type,
          to = this.to,
          from = this.from,
          nonce = this.nonce,
          data = this.data,
          signature = this.signature,
          accessList = this.accessList,
          blobVersionedHashes = this.blobVersionedHashes;
        return {
          _type: "TransactionResponse",
          accessList: accessList,
          blockNumber: blockNumber,
          blockHash: blockHash,
          blobVersionedHashes: blobVersionedHashes,
          chainId: toJson(this.chainId),
          data: data,
          from: from,
          gasLimit: toJson(this.gasLimit),
          gasPrice: toJson(this.gasPrice),
          hash: hash,
          maxFeePerGas: toJson(this.maxFeePerGas),
          maxPriorityFeePerGas: toJson(this.maxPriorityFeePerGas),
          maxFeePerBlobGas: toJson(this.maxFeePerBlobGas),
          nonce: nonce,
          signature: signature,
          to: to,
          index: index,
          type: type,
          value: toJson(this.value)
        };
      }
      /**
       *  Resolves to the Block that this transaction was included in.
       *
       *  This will return null if the transaction has not been included yet.
       */
    }, {
      key: "getBlock",
      value: (function () {
        var _getBlock3 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {
          var blockNumber, tx, block;
          return _regeneratorRuntime().wrap(function _callee9$(_context9) {
            while (1) switch (_context9.prev = _context9.next) {
              case 0:
                blockNumber = this.blockNumber;
                if (!(blockNumber == null)) {
                  _context9.next = 6;
                  break;
                }
                _context9.next = 4;
                return this.getTransaction();
              case 4:
                tx = _context9.sent;
                if (tx) {
                  blockNumber = tx.blockNumber;
                }
              case 6:
                if (!(blockNumber == null)) {
                  _context9.next = 8;
                  break;
                }
                return _context9.abrupt("return", null);
              case 8:
                block = this.provider.getBlock(blockNumber);
                if (!(block == null)) {
                  _context9.next = 11;
                  break;
                }
                throw new Error("TODO");
              case 11:
                return _context9.abrupt("return", block);
              case 12:
              case "end":
                return _context9.stop();
            }
          }, _callee9, this);
        }));
        function getBlock() {
          return _getBlock3.apply(this, arguments);
        }
        return getBlock;
      }()
      /**
       *  Resolves to this transaction being re-requested from the
       *  provider. This can be used if you have an unmined transaction
       *  and wish to get an up-to-date populated instance.
       */
      )
    }, {
      key: "getTransaction",
      value: (function () {
        var _getTransaction4 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {
          return _regeneratorRuntime().wrap(function _callee10$(_context10) {
            while (1) switch (_context10.prev = _context10.next) {
              case 0:
                return _context10.abrupt("return", this.provider.getTransaction(this.hash));
              case 1:
              case "end":
                return _context10.stop();
            }
          }, _callee10, this);
        }));
        function getTransaction() {
          return _getTransaction4.apply(this, arguments);
        }
        return getTransaction;
      }()
      /**
       *  Resolve to the number of confirmations this transaction has.
       */
      )
    }, {
      key: "confirmations",
      value: (function () {
        var _confirmations2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {
          var _yield, tx, _blockNumber, blockNumber;
          return _regeneratorRuntime().wrap(function _callee11$(_context11) {
            while (1) switch (_context11.prev = _context11.next) {
              case 0:
                if (!(this.blockNumber == null)) {
                  _context11.next = 9;
                  break;
                }
                _context11.next = 3;
                return (0, index_js_1.resolveProperties)({
                  tx: this.getTransaction(),
                  blockNumber: this.provider.getBlockNumber()
                });
              case 3:
                _yield = _context11.sent;
                tx = _yield.tx;
                _blockNumber = _yield.blockNumber;
                if (!(tx == null || tx.blockNumber == null)) {
                  _context11.next = 8;
                  break;
                }
                return _context11.abrupt("return", 0);
              case 8:
                return _context11.abrupt("return", _blockNumber - tx.blockNumber + 1);
              case 9:
                _context11.next = 11;
                return this.provider.getBlockNumber();
              case 11:
                blockNumber = _context11.sent;
                return _context11.abrupt("return", blockNumber - this.blockNumber + 1);
              case 13:
              case "end":
                return _context11.stop();
            }
          }, _callee11, this);
        }));
        function confirmations() {
          return _confirmations2.apply(this, arguments);
        }
        return confirmations;
      }()
      /**
       *  Resolves once this transaction has been mined and has
       *  %%confirms%% blocks including it (default: ``1``) with an
       *  optional %%timeout%%.
       *
       *  This can resolve to ``null`` only if %%confirms%% is ``0``
       *  and the transaction has not been mined, otherwise this will
       *  wait until enough confirmations have completed.
       */
      )
    }, {
      key: "wait",
      value: (function () {
        var _wait = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee15(_confirms, _timeout) {
          var _this3 = this;
          var confirms, timeout, startBlock, nextScan, stopScanning, checkReplacement, checkReceipt, receipt, waiter;
          return _regeneratorRuntime().wrap(function _callee15$(_context15) {
            while (1) switch (_context15.prev = _context15.next) {
              case 0:
                confirms = _confirms == null ? 1 : _confirms;
                timeout = _timeout == null ? 0 : _timeout;
                startBlock = _classPrivateFieldGet2(_startBlock, this);
                nextScan = -1;
                stopScanning = startBlock === -1 ? true : false;
                checkReplacement = /*#__PURE__*/function () {
                  var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {
                    var _yield2, blockNumber, nonce, mined, block, _iterator5, _step5, hash, i, tx, _receipt, reason;
                    return _regeneratorRuntime().wrap(function _callee12$(_context12) {
                      while (1) switch (_context12.prev = _context12.next) {
                        case 0:
                          if (!stopScanning) {
                            _context12.next = 2;
                            break;
                          }
                          return _context12.abrupt("return", null);
                        case 2:
                          _context12.next = 4;
                          return (0, index_js_1.resolveProperties)({
                            blockNumber: _this3.provider.getBlockNumber(),
                            nonce: _this3.provider.getTransactionCount(_this3.from)
                          });
                        case 4:
                          _yield2 = _context12.sent;
                          blockNumber = _yield2.blockNumber;
                          nonce = _yield2.nonce;
                          if (!(nonce < _this3.nonce)) {
                            _context12.next = 10;
                            break;
                          }
                          startBlock = blockNumber;
                          return _context12.abrupt("return");
                        case 10:
                          if (!stopScanning) {
                            _context12.next = 12;
                            break;
                          }
                          return _context12.abrupt("return", null);
                        case 12:
                          _context12.next = 14;
                          return _this3.getTransaction();
                        case 14:
                          mined = _context12.sent;
                          if (!(mined && mined.blockNumber != null)) {
                            _context12.next = 17;
                            break;
                          }
                          return _context12.abrupt("return");
                        case 17:
                          // We were replaced; start scanning for that transaction
                          // Starting to scan; look back a few extra blocks for safety
                          if (nextScan === -1) {
                            nextScan = startBlock - 3;
                            if (nextScan < _classPrivateFieldGet2(_startBlock, _this3)) {
                              nextScan = _classPrivateFieldGet2(_startBlock, _this3);
                            }
                          }
                        case 18:
                          if (!(nextScan <= blockNumber)) {
                            _context12.next = 67;
                            break;
                          }
                          if (!stopScanning) {
                            _context12.next = 21;
                            break;
                          }
                          return _context12.abrupt("return", null);
                        case 21:
                          _context12.next = 23;
                          return _this3.provider.getBlock(nextScan, true);
                        case 23:
                          block = _context12.sent;
                          if (!(block == null)) {
                            _context12.next = 26;
                            break;
                          }
                          return _context12.abrupt("return");
                        case 26:
                          // We were mined; no replacement
                          _iterator5 = _createForOfIteratorHelper(block);
                          _context12.prev = 27;
                          _iterator5.s();
                        case 29:
                          if ((_step5 = _iterator5.n()).done) {
                            _context12.next = 35;
                            break;
                          }
                          hash = _step5.value;
                          if (!(hash === _this3.hash)) {
                            _context12.next = 33;
                            break;
                          }
                          return _context12.abrupt("return");
                        case 33:
                          _context12.next = 29;
                          break;
                        case 35:
                          _context12.next = 40;
                          break;
                        case 37:
                          _context12.prev = 37;
                          _context12.t0 = _context12["catch"](27);
                          _iterator5.e(_context12.t0);
                        case 40:
                          _context12.prev = 40;
                          _iterator5.f();
                          return _context12.finish(40);
                        case 43:
                          i = 0;
                        case 44:
                          if (!(i < block.length)) {
                            _context12.next = 64;
                            break;
                          }
                          _context12.next = 47;
                          return block.getTransaction(i);
                        case 47:
                          tx = _context12.sent;
                          if (!(tx.from === _this3.from && tx.nonce === _this3.nonce)) {
                            _context12.next = 61;
                            break;
                          }
                          if (!stopScanning) {
                            _context12.next = 51;
                            break;
                          }
                          return _context12.abrupt("return", null);
                        case 51:
                          _context12.next = 53;
                          return _this3.provider.getTransactionReceipt(tx.hash);
                        case 53:
                          _receipt = _context12.sent;
                          if (!(_receipt == null)) {
                            _context12.next = 56;
                            break;
                          }
                          return _context12.abrupt("return");
                        case 56:
                          if (!(blockNumber - _receipt.blockNumber + 1 < confirms)) {
                            _context12.next = 58;
                            break;
                          }
                          return _context12.abrupt("return");
                        case 58:
                          // The reason we were replaced
                          reason = "replaced";
                          if (tx.data === _this3.data && tx.to === _this3.to && tx.value === _this3.value) {
                            reason = "repriced";
                          } else if (tx.data === "0x" && tx.from === tx.to && tx.value === BN_0) {
                            reason = "cancelled";
                          }
                          (0, index_js_1.assert)(false, "transaction was replaced", "TRANSACTION_REPLACED", {
                            cancelled: reason === "replaced" || reason === "cancelled",
                            reason: reason,
                            replacement: tx.replaceableTransaction(startBlock),
                            hash: tx.hash,
                            receipt: _receipt
                          });
                        case 61:
                          i++;
                          _context12.next = 44;
                          break;
                        case 64:
                          nextScan++;
                          _context12.next = 18;
                          break;
                        case 67:
                          return _context12.abrupt("return");
                        case 68:
                        case "end":
                          return _context12.stop();
                      }
                    }, _callee12, null, [[27, 37, 40, 43]]);
                  }));
                  return function checkReplacement() {
                    return _ref.apply(this, arguments);
                  };
                }();
                checkReceipt = function checkReceipt(receipt) {
                  if (receipt == null || receipt.status !== 0) {
                    return receipt;
                  }
                  (0, index_js_1.assert)(false, "transaction execution reverted", "CALL_EXCEPTION", {
                    action: "sendTransaction",
                    data: null,
                    reason: null,
                    invocation: null,
                    revert: null,
                    transaction: {
                      to: receipt.to,
                      from: receipt.from,
                      data: "" // @TODO: in v7, split out sendTransaction properties
                    },
                    receipt: receipt
                  });
                };
                _context15.next = 9;
                return this.provider.getTransactionReceipt(this.hash);
              case 9:
                receipt = _context15.sent;
                if (!(confirms === 0)) {
                  _context15.next = 12;
                  break;
                }
                return _context15.abrupt("return", checkReceipt(receipt));
              case 12:
                if (!receipt) {
                  _context15.next = 21;
                  break;
                }
                _context15.next = 15;
                return receipt.confirmations();
              case 15:
                _context15.t0 = _context15.sent;
                _context15.t1 = confirms;
                if (!(_context15.t0 >= _context15.t1)) {
                  _context15.next = 19;
                  break;
                }
                return _context15.abrupt("return", checkReceipt(receipt));
              case 19:
                _context15.next = 25;
                break;
              case 21:
                _context15.next = 23;
                return checkReplacement();
              case 23:
                if (!(confirms === 0)) {
                  _context15.next = 25;
                  break;
                }
                return _context15.abrupt("return", null);
              case 25:
                waiter = new Promise(function (resolve, reject) {
                  // List of things to cancel when we have a result (one way or the other)
                  var cancellers = [];
                  var cancel = function cancel() {
                    cancellers.forEach(function (c) {
                      return c();
                    });
                  };
                  // On cancel, stop scanning for replacements
                  cancellers.push(function () {
                    stopScanning = true;
                  });
                  // Set up any timeout requested
                  if (timeout > 0) {
                    var timer = setTimeout(function () {
                      cancel();
                      reject((0, index_js_1.makeError)("wait for transaction timeout", "TIMEOUT"));
                    }, timeout);
                    cancellers.push(function () {
                      clearTimeout(timer);
                    });
                  }
                  var txListener = /*#__PURE__*/function () {
                    var _ref2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee13(receipt) {
                      return _regeneratorRuntime().wrap(function _callee13$(_context13) {
                        while (1) switch (_context13.prev = _context13.next) {
                          case 0:
                            _context13.next = 2;
                            return receipt.confirmations();
                          case 2:
                            _context13.t0 = _context13.sent;
                            _context13.t1 = confirms;
                            if (!(_context13.t0 >= _context13.t1)) {
                              _context13.next = 7;
                              break;
                            }
                            cancel();
                            try {
                              resolve(checkReceipt(receipt));
                            } catch (error) {
                              reject(error);
                            }
                          case 7:
                          case "end":
                            return _context13.stop();
                        }
                      }, _callee13);
                    }));
                    return function txListener(_x4) {
                      return _ref2.apply(this, arguments);
                    };
                  }();
                  cancellers.push(function () {
                    _this3.provider.off(_this3.hash, txListener);
                  });
                  _this3.provider.on(_this3.hash, txListener);
                  // We support replacement detection; start checking
                  if (startBlock >= 0) {
                    var _replaceListener = /*#__PURE__*/function () {
                      var _ref3 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee14() {
                        return _regeneratorRuntime().wrap(function _callee14$(_context14) {
                          while (1) switch (_context14.prev = _context14.next) {
                            case 0:
                              _context14.prev = 0;
                              _context14.next = 3;
                              return checkReplacement();
                            case 3:
                              _context14.next = 11;
                              break;
                            case 5:
                              _context14.prev = 5;
                              _context14.t0 = _context14["catch"](0);
                              if (!(0, index_js_1.isError)(_context14.t0, "TRANSACTION_REPLACED")) {
                                _context14.next = 11;
                                break;
                              }
                              cancel();
                              reject(_context14.t0);
                              return _context14.abrupt("return");
                            case 11:
                              // Rescheudle a check on the next block
                              if (!stopScanning) {
                                _this3.provider.once("block", _replaceListener);
                              }
                            case 12:
                            case "end":
                              return _context14.stop();
                          }
                        }, _callee14, null, [[0, 5]]);
                      }));
                      return function replaceListener() {
                        return _ref3.apply(this, arguments);
                      };
                    }();
                    cancellers.push(function () {
                      _this3.provider.off("block", _replaceListener);
                    });
                    _this3.provider.once("block", _replaceListener);
                  }
                });
                _context15.next = 28;
                return waiter;
              case 28:
                return _context15.abrupt("return", _context15.sent);
              case 29:
              case "end":
                return _context15.stop();
            }
          }, _callee15, this);
        }));
        function wait(_x2, _x3) {
          return _wait.apply(this, arguments);
        }
        return wait;
      }()
      /**
       *  Returns ``true`` if this transaction has been included.
       *
       *  This is effective only as of the time the TransactionResponse
       *  was instantiated. To get up-to-date information, use
       *  [[getTransaction]].
       *
       *  This provides a Type Guard that this transaction will have
       *  non-null property values for properties that are null for
       *  unmined transactions.
       */
      )
    }, {
      key: "isMined",
      value: function isMined() {
        return this.blockHash != null;
      }
      /**
       *  Returns true if the transaction is a legacy (i.e. ``type == 0``)
       *  transaction.
       *
       *  This provides a Type Guard that this transaction will have
       *  the ``null``-ness for hardfork-specific properties set correctly.
       */
    }, {
      key: "isLegacy",
      value: function isLegacy() {
        return this.type === 0;
      }
      /**
       *  Returns true if the transaction is a Berlin (i.e. ``type == 1``)
       *  transaction. See [[link-eip-2070]].
       *
       *  This provides a Type Guard that this transaction will have
       *  the ``null``-ness for hardfork-specific properties set correctly.
       */
    }, {
      key: "isBerlin",
      value: function isBerlin() {
        return this.type === 1;
      }
      /**
       *  Returns true if the transaction is a London (i.e. ``type == 2``)
       *  transaction. See [[link-eip-1559]].
       *
       *  This provides a Type Guard that this transaction will have
       *  the ``null``-ness for hardfork-specific properties set correctly.
       */
    }, {
      key: "isLondon",
      value: function isLondon() {
        return this.type === 2;
      }
      /**
       *  Returns true if hte transaction is a Cancun (i.e. ``type == 3``)
       *  transaction. See [[link-eip-4844]].
       */
    }, {
      key: "isCancun",
      value: function isCancun() {
        return this.type === 3;
      }
      /**
       *  Returns a filter which can be used to listen for orphan events
       *  that evict this transaction.
       */
    }, {
      key: "removedEvent",
      value: function removedEvent() {
        (0, index_js_1.assert)(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", {
          operation: "removeEvent()"
        });
        return createRemovedTransactionFilter(this);
      }
      /**
       *  Returns a filter which can be used to listen for orphan events
       *  that re-order this event against %%other%%.
       */
    }, {
      key: "reorderedEvent",
      value: function reorderedEvent(other) {
        (0, index_js_1.assert)(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", {
          operation: "removeEvent()"
        });
        (0, index_js_1.assert)(!other || other.isMined(), "unmined 'other' transaction canot be orphaned", "UNSUPPORTED_OPERATION", {
          operation: "removeEvent()"
        });
        return createReorderedTransactionFilter(this, other);
      }
      /**
       *  Returns a new TransactionResponse instance which has the ability to
       *  detect (and throw an error) if the transaction is replaced, which
       *  will begin scanning at %%startBlock%%.
       *
       *  This should generally not be used by developers and is intended
       *  primarily for internal use. Setting an incorrect %%startBlock%% can
       *  have devastating performance consequences if used incorrectly.
       */
    }, {
      key: "replaceableTransaction",
      value: function replaceableTransaction(startBlock) {
        (0, index_js_1.assertArgument)(Number.isInteger(startBlock) && startBlock >= 0, "invalid startBlock", "startBlock", startBlock);
        var tx = new TransactionResponse(this, this.provider);
        _classPrivateFieldSet2(_startBlock, tx, startBlock);
        return tx;
      }
    }]);
  }();
  provider.TransactionResponse = TransactionResponse;
  function createOrphanedBlockFilter(block) {
    return {
      orphan: "drop-block",
      hash: block.hash,
      number: block.number
    };
  }
  function createReorderedTransactionFilter(tx, other) {
    return {
      orphan: "reorder-transaction",
      tx: tx,
      other: other
    };
  }
  function createRemovedTransactionFilter(tx) {
    return {
      orphan: "drop-transaction",
      tx: tx
    };
  }
  function createRemovedLogFilter(log) {
    return {
      orphan: "drop-log",
      log: {
        transactionHash: log.transactionHash,
        blockHash: log.blockHash,
        blockNumber: log.blockNumber,
        address: log.address,
        data: log.data,
        topics: Object.freeze(log.topics.slice()),
        index: log.index
      }
    };
  }
  return provider;
}

var wrappers = {};

var hasRequiredWrappers;
function requireWrappers() {
  if (hasRequiredWrappers) return wrappers;
  hasRequiredWrappers = 1;
  Object.defineProperty(wrappers, "__esModule", {
    value: true
  });
  wrappers.ContractEventPayload = wrappers.ContractUnknownEventPayload = wrappers.ContractTransactionResponse = wrappers.ContractTransactionReceipt = wrappers.UndecodedEventLog = wrappers.EventLog = void 0;
  // import from provider.ts instead of index.ts to prevent circular dep
  // from EtherscanProvider
  var provider_js_1 = /*@__PURE__*/requireProvider();
  var index_js_1 = /*@__PURE__*/requireUtils$3();
  /**
   *  An **EventLog** contains additional properties parsed from the [[Log]].
   */
  var EventLog = /*#__PURE__*/function (_provider_js_1$Log) {
    /**
     * @_ignore:
     */
    function EventLog(log, iface, fragment) {
      var _this;
      _classCallCheck(this, EventLog);
      _this = _callSuper(this, EventLog, [log, log.provider]);
      /**
       *  The Contract Interface.
       */
      _defineProperty(_this, "interface", void 0);
      /**
       *  The matching event.
       */
      _defineProperty(_this, "fragment", void 0);
      /**
       *  The parsed arguments passed to the event by ``emit``.
       */
      _defineProperty(_this, "args", void 0);
      var args = iface.decodeEventLog(fragment, log.data, log.topics);
      (0, index_js_1.defineProperties)(_this, {
        args: args,
        fragment: fragment,
        "interface": iface
      });
      return _this;
    }
    /**
     *  The name of the event.
     */
    _inherits(EventLog, _provider_js_1$Log);
    return _createClass(EventLog, [{
      key: "eventName",
      get: function get() {
        return this.fragment.name;
      }
      /**
       *  The signature of the event.
       */
    }, {
      key: "eventSignature",
      get: function get() {
        return this.fragment.format();
      }
    }]);
  }(provider_js_1.Log);
  wrappers.EventLog = EventLog;
  /**
   *  An **EventLog** contains additional properties parsed from the [[Log]].
   */
  var UndecodedEventLog = /*#__PURE__*/function (_provider_js_1$Log2) {
    /**
     * @_ignore:
     */
    function UndecodedEventLog(log, error) {
      var _this2;
      _classCallCheck(this, UndecodedEventLog);
      _this2 = _callSuper(this, UndecodedEventLog, [log, log.provider]);
      /**
       *  The error encounted when trying to decode the log.
       */
      _defineProperty(_this2, "error", void 0);
      (0, index_js_1.defineProperties)(_this2, {
        error: error
      });
      return _this2;
    }
    _inherits(UndecodedEventLog, _provider_js_1$Log2);
    return _createClass(UndecodedEventLog);
  }(provider_js_1.Log);
  wrappers.UndecodedEventLog = UndecodedEventLog;
  /**
   *  A **ContractTransactionReceipt** includes the parsed logs from a
   *  [[TransactionReceipt]].
   */
  var _iface = /*#__PURE__*/new WeakMap();
  var ContractTransactionReceipt = /*#__PURE__*/function (_provider_js_1$Transa) {
    /**
     *  @_ignore:
     */
    function ContractTransactionReceipt(iface, provider, tx) {
      var _this3;
      _classCallCheck(this, ContractTransactionReceipt);
      _this3 = _callSuper(this, ContractTransactionReceipt, [tx, provider]);
      _classPrivateFieldInitSpec(_this3, _iface, void 0);
      _classPrivateFieldSet2(_iface, _this3, iface);
      return _this3;
    }
    /**
     *  The parsed logs for any [[Log]] which has a matching event in the
     *  Contract ABI.
     */
    _inherits(ContractTransactionReceipt, _provider_js_1$Transa);
    return _createClass(ContractTransactionReceipt, [{
      key: "logs",
      get: function get() {
        var _this4 = this;
        return _superPropGet(ContractTransactionReceipt, "logs", this, 1).map(function (log) {
          var fragment = log.topics.length ? _classPrivateFieldGet2(_iface, _this4).getEvent(log.topics[0]) : null;
          if (fragment) {
            try {
              return new EventLog(log, _classPrivateFieldGet2(_iface, _this4), fragment);
            } catch (error) {
              return new UndecodedEventLog(log, error);
            }
          }
          return log;
        });
      }
    }]);
  }(provider_js_1.TransactionReceipt);
  wrappers.ContractTransactionReceipt = ContractTransactionReceipt;
  /**
   *  A **ContractTransactionResponse** will return a
   *  [[ContractTransactionReceipt]] when waited on.
   */
  var _iface2 = /*#__PURE__*/new WeakMap();
  var ContractTransactionResponse = /*#__PURE__*/function (_provider_js_1$Transa2) {
    /**
     *  @_ignore:
     */
    function ContractTransactionResponse(iface, provider, tx) {
      var _this5;
      _classCallCheck(this, ContractTransactionResponse);
      _this5 = _callSuper(this, ContractTransactionResponse, [tx, provider]);
      _classPrivateFieldInitSpec(_this5, _iface2, void 0);
      _classPrivateFieldSet2(_iface2, _this5, iface);
      return _this5;
    }
    /**
     *  Resolves once this transaction has been mined and has
     *  %%confirms%% blocks including it (default: ``1``) with an
     *  optional %%timeout%%.
     *
     *  This can resolve to ``null`` only if %%confirms%% is ``0``
     *  and the transaction has not been mined, otherwise this will
     *  wait until enough confirmations have completed.
     */
    _inherits(ContractTransactionResponse, _provider_js_1$Transa2);
    return _createClass(ContractTransactionResponse, [{
      key: "wait",
      value: (function () {
        var _wait = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(confirms, timeout) {
          var receipt;
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return _superPropGet(ContractTransactionResponse, "wait", this, 3)([confirms, timeout]);
              case 2:
                receipt = _context.sent;
                if (!(receipt == null)) {
                  _context.next = 5;
                  break;
                }
                return _context.abrupt("return", null);
              case 5:
                return _context.abrupt("return", new ContractTransactionReceipt(_classPrivateFieldGet2(_iface2, this), this.provider, receipt));
              case 6:
              case "end":
                return _context.stop();
            }
          }, _callee, this);
        }));
        function wait(_x, _x2) {
          return _wait.apply(this, arguments);
        }
        return wait;
      }())
    }]);
  }(provider_js_1.TransactionResponse);
  wrappers.ContractTransactionResponse = ContractTransactionResponse;
  /**
   *  A **ContractUnknownEventPayload** is included as the last parameter to
   *  Contract Events when the event does not match any events in the ABI.
   */
  var ContractUnknownEventPayload = /*#__PURE__*/function (_index_js_1$EventPayl) {
    /**
     *  @_event:
     */
    function ContractUnknownEventPayload(contract, listener, filter, log) {
      var _this6;
      _classCallCheck(this, ContractUnknownEventPayload);
      _this6 = _callSuper(this, ContractUnknownEventPayload, [contract, listener, filter]);
      /**
       *  The log with no matching events.
       */
      _defineProperty(_this6, "log", void 0);
      (0, index_js_1.defineProperties)(_this6, {
        log: log
      });
      return _this6;
    }
    /**
     *  Resolves to the block the event occured in.
     */
    _inherits(ContractUnknownEventPayload, _index_js_1$EventPayl);
    return _createClass(ContractUnknownEventPayload, [{
      key: "getBlock",
      value: (function () {
        var _getBlock = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
          return _regeneratorRuntime().wrap(function _callee2$(_context2) {
            while (1) switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.log.getBlock();
              case 2:
                return _context2.abrupt("return", _context2.sent);
              case 3:
              case "end":
                return _context2.stop();
            }
          }, _callee2, this);
        }));
        function getBlock() {
          return _getBlock.apply(this, arguments);
        }
        return getBlock;
      }()
      /**
       *  Resolves to the transaction the event occured in.
       */
      )
    }, {
      key: "getTransaction",
      value: (function () {
        var _getTransaction = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
          return _regeneratorRuntime().wrap(function _callee3$(_context3) {
            while (1) switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.log.getTransaction();
              case 2:
                return _context3.abrupt("return", _context3.sent);
              case 3:
              case "end":
                return _context3.stop();
            }
          }, _callee3, this);
        }));
        function getTransaction() {
          return _getTransaction.apply(this, arguments);
        }
        return getTransaction;
      }()
      /**
       *  Resolves to the transaction receipt the event occured in.
       */
      )
    }, {
      key: "getTransactionReceipt",
      value: (function () {
        var _getTransactionReceipt = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
          return _regeneratorRuntime().wrap(function _callee4$(_context4) {
            while (1) switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.log.getTransactionReceipt();
              case 2:
                return _context4.abrupt("return", _context4.sent);
              case 3:
              case "end":
                return _context4.stop();
            }
          }, _callee4, this);
        }));
        function getTransactionReceipt() {
          return _getTransactionReceipt.apply(this, arguments);
        }
        return getTransactionReceipt;
      }())
    }]);
  }(index_js_1.EventPayload);
  wrappers.ContractUnknownEventPayload = ContractUnknownEventPayload;
  /**
   *  A **ContractEventPayload** is included as the last parameter to
   *  Contract Events when the event is known.
   */
  var ContractEventPayload = /*#__PURE__*/function (_ContractUnknownEvent) {
    /**
     *  @_ignore:
     */
    function ContractEventPayload(contract, listener, filter, fragment, _log) {
      var _this7;
      _classCallCheck(this, ContractEventPayload);
      _this7 = _callSuper(this, ContractEventPayload, [contract, listener, filter, new EventLog(_log, contract["interface"], fragment)]);
      var args = contract["interface"].decodeEventLog(fragment, _this7.log.data, _this7.log.topics);
      (0, index_js_1.defineProperties)(_this7, {
        args: args,
        fragment: fragment
      });
      return _this7;
    }
    /**
     *  The event name.
     */
    _inherits(ContractEventPayload, _ContractUnknownEvent);
    return _createClass(ContractEventPayload, [{
      key: "eventName",
      get: function get() {
        return this.fragment.name;
      }
      /**
       *  The event signature.
       */
    }, {
      key: "eventSignature",
      get: function get() {
        return this.fragment.format();
      }
    }]);
  }(ContractUnknownEventPayload);
  wrappers.ContractEventPayload = ContractEventPayload;
  return wrappers;
}

var hasRequiredContract$1;
function requireContract$1() {
  if (hasRequiredContract$1) return contract;
  hasRequiredContract$1 = 1;
  Object.defineProperty(contract, "__esModule", {
    value: true
  });
  contract.Contract = contract.BaseContract = contract.resolveArgs = contract.copyOverrides = void 0;
  var index_js_1 = /*@__PURE__*/requireAbi();
  var index_js_2 = /*@__PURE__*/requireAddress$2();
  // import from provider.ts instead of index.ts to prevent circular dep
  // from EtherscanProvider
  var provider_js_1 = /*@__PURE__*/requireProvider();
  var index_js_3 = /*@__PURE__*/requireUtils$3();
  var wrappers_js_1 = /*@__PURE__*/requireWrappers();
  var BN_0 = BigInt(0);
  function canCall(value) {
    return value && typeof value.call === "function";
  }
  function canEstimate(value) {
    return value && typeof value.estimateGas === "function";
  }
  function canResolve(value) {
    return value && typeof value.resolveName === "function";
  }
  function canSend(value) {
    return value && typeof value.sendTransaction === "function";
  }
  function getResolver(value) {
    if (value != null) {
      if (canResolve(value)) {
        return value;
      }
      if (value.provider) {
        return value.provider;
      }
    }
    return undefined;
  }
  var _filter = /*#__PURE__*/new WeakMap();
  var PreparedTopicFilter = /*#__PURE__*/function () {
    function PreparedTopicFilter(contract, fragment, args) {
      _classCallCheck(this, PreparedTopicFilter);
      _classPrivateFieldInitSpec(this, _filter, void 0);
      _defineProperty(this, "fragment", void 0);
      (0, index_js_3.defineProperties)(this, {
        fragment: fragment
      });
      if (fragment.inputs.length < args.length) {
        throw new Error("too many arguments");
      }
      // Recursively descend into args and resolve any addresses
      var runner = getRunner(contract.runner, "resolveName");
      var resolver = canResolve(runner) ? runner : null;
      _classPrivateFieldSet2(_filter, this, _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var resolvedArgs;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return Promise.all(fragment.inputs.map(function (param, index) {
                var arg = args[index];
                if (arg == null) {
                  return null;
                }
                return param.walkAsync(args[index], function (type, value) {
                  if (type === "address") {
                    if (Array.isArray(value)) {
                      return Promise.all(value.map(function (v) {
                        return (0, index_js_2.resolveAddress)(v, resolver);
                      }));
                    }
                    return (0, index_js_2.resolveAddress)(value, resolver);
                  }
                  return value;
                });
              }));
            case 2:
              resolvedArgs = _context.sent;
              return _context.abrupt("return", contract["interface"].encodeFilterTopics(fragment, resolvedArgs));
            case 4:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }))());
    }
    return _createClass(PreparedTopicFilter, [{
      key: "getTopicFilter",
      value: function getTopicFilter() {
        return _classPrivateFieldGet2(_filter, this);
      }
    }]);
  }(); // A = Arguments passed in as a tuple
  // R = The result type of the call (i.e. if only one return type,
  //     the qualified type, otherwise Result)
  // D = The type the default call will return (i.e. R for view/pure,
  //     TransactionResponse otherwise)
  //export interface ContractMethod<A extends Array<any> = Array<any>, R = any, D extends R | ContractTransactionResponse = ContractTransactionResponse> {
  function getRunner(value, feature) {
    if (value == null) {
      return null;
    }
    if (typeof value[feature] === "function") {
      return value;
    }
    if (value.provider && typeof value.provider[feature] === "function") {
      return value.provider;
    }
    return null;
  }
  function getProvider(value) {
    if (value == null) {
      return null;
    }
    return value.provider || null;
  }
  /**
   *  @_ignore:
   */
  function copyOverrides(_x, _x2) {
    return _copyOverrides.apply(this, arguments);
  }
  function _copyOverrides() {
    _copyOverrides = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee28(arg, allowed) {
      var _overrides, overrides;
      return _regeneratorRuntime().wrap(function _callee28$(_context28) {
        while (1) switch (_context28.prev = _context28.next) {
          case 0:
            // Make sure the overrides passed in are a valid overrides object
            _overrides = index_js_1.Typed.dereference(arg, "overrides");
            (0, index_js_3.assertArgument)(_typeof(_overrides) === "object", "invalid overrides parameter", "overrides", arg);
            // Create a shallow copy (we'll deep-ify anything needed during normalizing)
            overrides = (0, provider_js_1.copyRequest)(_overrides);
            (0, index_js_3.assertArgument)(overrides.to == null || (allowed || []).indexOf("to") >= 0, "cannot override to", "overrides.to", overrides.to);
            (0, index_js_3.assertArgument)(overrides.data == null || (allowed || []).indexOf("data") >= 0, "cannot override data", "overrides.data", overrides.data);
            // Resolve any from
            if (overrides.from) {
              overrides.from = overrides.from;
            }
            return _context28.abrupt("return", overrides);
          case 7:
          case "end":
            return _context28.stop();
        }
      }, _callee28);
    }));
    return _copyOverrides.apply(this, arguments);
  }
  contract.copyOverrides = copyOverrides;
  /**
   *  @_ignore:
   */
  function resolveArgs(_x3, _x4, _x5) {
    return _resolveArgs.apply(this, arguments);
  }
  function _resolveArgs() {
    _resolveArgs = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee29(_runner, inputs, args) {
      var runner, resolver;
      return _regeneratorRuntime().wrap(function _callee29$(_context29) {
        while (1) switch (_context29.prev = _context29.next) {
          case 0:
            // Recursively descend into args and resolve any addresses
            runner = getRunner(_runner, "resolveName");
            resolver = canResolve(runner) ? runner : null;
            _context29.next = 4;
            return Promise.all(inputs.map(function (param, index) {
              return param.walkAsync(args[index], function (type, value) {
                value = index_js_1.Typed.dereference(value, type);
                if (type === "address") {
                  return (0, index_js_2.resolveAddress)(value, resolver);
                }
                return value;
              });
            }));
          case 4:
            return _context29.abrupt("return", _context29.sent);
          case 5:
          case "end":
            return _context29.stop();
        }
      }, _callee29);
    }));
    return _resolveArgs.apply(this, arguments);
  }
  contract.resolveArgs = resolveArgs;
  function buildWrappedFallback(contract) {
    var populateTransaction = /*#__PURE__*/function () {
      var _ref2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(overrides) {
        var tx, iface, noValue, noData, payable;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return copyOverrides(overrides, ["data"]);
            case 2:
              tx = _context2.sent;
              _context2.next = 5;
              return contract.getAddress();
            case 5:
              tx.to = _context2.sent;
              if (!tx.from) {
                _context2.next = 10;
                break;
              }
              _context2.next = 9;
              return (0, index_js_2.resolveAddress)(tx.from, getResolver(contract.runner));
            case 9:
              tx.from = _context2.sent;
            case 10:
              iface = contract["interface"];
              noValue = (0, index_js_3.getBigInt)(tx.value || BN_0, "overrides.value") === BN_0;
              noData = (tx.data || "0x") === "0x";
              if (iface.fallback && !iface.fallback.payable && iface.receive && !noData && !noValue) {
                (0, index_js_3.assertArgument)(false, "cannot send data to receive or send value to non-payable fallback", "overrides", overrides);
              }
              (0, index_js_3.assertArgument)(iface.fallback || noData, "cannot send data to receive-only contract", "overrides.data", tx.data);
              // Only allow payable contracts to set non-zero value
              payable = iface.receive || iface.fallback && iface.fallback.payable;
              (0, index_js_3.assertArgument)(payable || noValue, "cannot send value to non-payable fallback", "overrides.value", tx.value);
              // Only allow fallback contracts to set non-empty data
              (0, index_js_3.assertArgument)(iface.fallback || noData, "cannot send data to receive-only contract", "overrides.data", tx.data);
              return _context2.abrupt("return", tx);
            case 19:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      }));
      return function populateTransaction(_x6) {
        return _ref2.apply(this, arguments);
      };
    }();
    var staticCall = /*#__PURE__*/function () {
      var _ref3 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(overrides) {
        var runner, tx;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              runner = getRunner(contract.runner, "call");
              (0, index_js_3.assert)(canCall(runner), "contract runner does not support calling", "UNSUPPORTED_OPERATION", {
                operation: "call"
              });
              _context3.next = 4;
              return populateTransaction(overrides);
            case 4:
              tx = _context3.sent;
              _context3.prev = 5;
              _context3.next = 8;
              return runner.call(tx);
            case 8:
              return _context3.abrupt("return", _context3.sent);
            case 11:
              _context3.prev = 11;
              _context3.t0 = _context3["catch"](5);
              if (!((0, index_js_3.isCallException)(_context3.t0) && _context3.t0.data)) {
                _context3.next = 15;
                break;
              }
              throw contract["interface"].makeError(_context3.t0.data, tx);
            case 15:
              throw _context3.t0;
            case 16:
            case "end":
              return _context3.stop();
          }
        }, _callee3, null, [[5, 11]]);
      }));
      return function staticCall(_x7) {
        return _ref3.apply(this, arguments);
      };
    }();
    var send = /*#__PURE__*/function () {
      var _ref4 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4(overrides) {
        var runner, tx, provider;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              runner = contract.runner;
              (0, index_js_3.assert)(canSend(runner), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", {
                operation: "sendTransaction"
              });
              _context4.t0 = runner;
              _context4.next = 5;
              return populateTransaction(overrides);
            case 5:
              _context4.t1 = _context4.sent;
              _context4.next = 8;
              return _context4.t0.sendTransaction.call(_context4.t0, _context4.t1);
            case 8:
              tx = _context4.sent;
              provider = getProvider(contract.runner); // @TODO: the provider can be null; make a custom dummy provider that will throw a
              // meaningful error
              return _context4.abrupt("return", new wrappers_js_1.ContractTransactionResponse(contract["interface"], provider, tx));
            case 11:
            case "end":
              return _context4.stop();
          }
        }, _callee4);
      }));
      return function send(_x8) {
        return _ref4.apply(this, arguments);
      };
    }();
    var estimateGas = /*#__PURE__*/function () {
      var _ref5 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee5(overrides) {
        var runner;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              runner = getRunner(contract.runner, "estimateGas");
              (0, index_js_3.assert)(canEstimate(runner), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", {
                operation: "estimateGas"
              });
              _context5.t0 = runner;
              _context5.next = 5;
              return populateTransaction(overrides);
            case 5:
              _context5.t1 = _context5.sent;
              _context5.next = 8;
              return _context5.t0.estimateGas.call(_context5.t0, _context5.t1);
            case 8:
              return _context5.abrupt("return", _context5.sent);
            case 9:
            case "end":
              return _context5.stop();
          }
        }, _callee5);
      }));
      return function estimateGas(_x9) {
        return _ref5.apply(this, arguments);
      };
    }();
    var method = /*#__PURE__*/function () {
      var _ref6 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee6(overrides) {
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              _context6.next = 2;
              return send(overrides);
            case 2:
              return _context6.abrupt("return", _context6.sent);
            case 3:
            case "end":
              return _context6.stop();
          }
        }, _callee6);
      }));
      return function method(_x10) {
        return _ref6.apply(this, arguments);
      };
    }();
    (0, index_js_3.defineProperties)(method, {
      _contract: contract,
      estimateGas: estimateGas,
      populateTransaction: populateTransaction,
      send: send,
      staticCall: staticCall
    });
    return method;
  }
  function buildWrappedMethod(contract, key) {
    var getFragment = function getFragment() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      var fragment = contract["interface"].getFunction(key, args);
      (0, index_js_3.assert)(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
        operation: "fragment",
        info: {
          key: key,
          args: args
        }
      });
      return fragment;
    };
    var populateTransaction = /*#__PURE__*/function () {
      var _ref7 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {
        var _len2,
          args,
          _key2,
          fragment,
          overrides,
          resolvedArgs,
          _args7 = arguments;
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              for (_len2 = _args7.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                args[_key2] = _args7[_key2];
              }
              fragment = getFragment.apply(void 0, args); // If an overrides was passed in, copy it and normalize the values
              overrides = {};
              if (!(fragment.inputs.length + 1 === args.length)) {
                _context7.next = 11;
                break;
              }
              _context7.next = 6;
              return copyOverrides(args.pop());
            case 6:
              overrides = _context7.sent;
              if (!overrides.from) {
                _context7.next = 11;
                break;
              }
              _context7.next = 10;
              return (0, index_js_2.resolveAddress)(overrides.from, getResolver(contract.runner));
            case 10:
              overrides.from = _context7.sent;
            case 11:
              if (!(fragment.inputs.length !== args.length)) {
                _context7.next = 13;
                break;
              }
              throw new Error("internal error: fragment inputs doesn't match arguments; should not happen");
            case 13:
              _context7.next = 15;
              return resolveArgs(contract.runner, fragment.inputs, args);
            case 15:
              resolvedArgs = _context7.sent;
              _context7.t0 = Object;
              _context7.t1 = {};
              _context7.t2 = overrides;
              _context7.next = 21;
              return (0, index_js_3.resolveProperties)({
                to: contract.getAddress(),
                data: contract["interface"].encodeFunctionData(fragment, resolvedArgs)
              });
            case 21:
              _context7.t3 = _context7.sent;
              return _context7.abrupt("return", _context7.t0.assign.call(_context7.t0, _context7.t1, _context7.t2, _context7.t3));
            case 23:
            case "end":
              return _context7.stop();
          }
        }, _callee7);
      }));
      return function populateTransaction() {
        return _ref7.apply(this, arguments);
      };
    }();
    var staticCall = /*#__PURE__*/function () {
      var _ref8 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {
        var result,
          _args8 = arguments;
        return _regeneratorRuntime().wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              _context8.next = 2;
              return staticCallResult.apply(void 0, _args8);
            case 2:
              result = _context8.sent;
              if (!(result.length === 1)) {
                _context8.next = 5;
                break;
              }
              return _context8.abrupt("return", result[0]);
            case 5:
              return _context8.abrupt("return", result);
            case 6:
            case "end":
              return _context8.stop();
          }
        }, _callee8);
      }));
      return function staticCall() {
        return _ref8.apply(this, arguments);
      };
    }();
    var send = /*#__PURE__*/function () {
      var _ref9 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {
        var runner,
          tx,
          provider,
          _args9 = arguments;
        return _regeneratorRuntime().wrap(function _callee9$(_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
              runner = contract.runner;
              (0, index_js_3.assert)(canSend(runner), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", {
                operation: "sendTransaction"
              });
              _context9.t0 = runner;
              _context9.next = 5;
              return populateTransaction.apply(void 0, _args9);
            case 5:
              _context9.t1 = _context9.sent;
              _context9.next = 8;
              return _context9.t0.sendTransaction.call(_context9.t0, _context9.t1);
            case 8:
              tx = _context9.sent;
              provider = getProvider(contract.runner); // @TODO: the provider can be null; make a custom dummy provider that will throw a
              // meaningful error
              return _context9.abrupt("return", new wrappers_js_1.ContractTransactionResponse(contract["interface"], provider, tx));
            case 11:
            case "end":
              return _context9.stop();
          }
        }, _callee9);
      }));
      return function send() {
        return _ref9.apply(this, arguments);
      };
    }();
    var estimateGas = /*#__PURE__*/function () {
      var _ref10 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {
        var runner,
          _args10 = arguments;
        return _regeneratorRuntime().wrap(function _callee10$(_context10) {
          while (1) switch (_context10.prev = _context10.next) {
            case 0:
              runner = getRunner(contract.runner, "estimateGas");
              (0, index_js_3.assert)(canEstimate(runner), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", {
                operation: "estimateGas"
              });
              _context10.t0 = runner;
              _context10.next = 5;
              return populateTransaction.apply(void 0, _args10);
            case 5:
              _context10.t1 = _context10.sent;
              _context10.next = 8;
              return _context10.t0.estimateGas.call(_context10.t0, _context10.t1);
            case 8:
              return _context10.abrupt("return", _context10.sent);
            case 9:
            case "end":
              return _context10.stop();
          }
        }, _callee10);
      }));
      return function estimateGas() {
        return _ref10.apply(this, arguments);
      };
    }();
    var staticCallResult = /*#__PURE__*/function () {
      var _ref11 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {
        var runner,
          tx,
          result,
          fragment,
          _args11 = arguments;
        return _regeneratorRuntime().wrap(function _callee11$(_context11) {
          while (1) switch (_context11.prev = _context11.next) {
            case 0:
              runner = getRunner(contract.runner, "call");
              (0, index_js_3.assert)(canCall(runner), "contract runner does not support calling", "UNSUPPORTED_OPERATION", {
                operation: "call"
              });
              _context11.next = 4;
              return populateTransaction.apply(void 0, _args11);
            case 4:
              tx = _context11.sent;
              result = "0x";
              _context11.prev = 6;
              _context11.next = 9;
              return runner.call(tx);
            case 9:
              result = _context11.sent;
              _context11.next = 17;
              break;
            case 12:
              _context11.prev = 12;
              _context11.t0 = _context11["catch"](6);
              if (!((0, index_js_3.isCallException)(_context11.t0) && _context11.t0.data)) {
                _context11.next = 16;
                break;
              }
              throw contract["interface"].makeError(_context11.t0.data, tx);
            case 16:
              throw _context11.t0;
            case 17:
              fragment = getFragment.apply(void 0, _args11);
              return _context11.abrupt("return", contract["interface"].decodeFunctionResult(fragment, result));
            case 19:
            case "end":
              return _context11.stop();
          }
        }, _callee11, null, [[6, 12]]);
      }));
      return function staticCallResult() {
        return _ref11.apply(this, arguments);
      };
    }();
    var method = /*#__PURE__*/function () {
      var _ref12 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {
        var fragment,
          _args12 = arguments;
        return _regeneratorRuntime().wrap(function _callee12$(_context12) {
          while (1) switch (_context12.prev = _context12.next) {
            case 0:
              fragment = getFragment.apply(void 0, _args12);
              if (!fragment.constant) {
                _context12.next = 5;
                break;
              }
              _context12.next = 4;
              return staticCall.apply(void 0, _args12);
            case 4:
              return _context12.abrupt("return", _context12.sent);
            case 5:
              _context12.next = 7;
              return send.apply(void 0, _args12);
            case 7:
              return _context12.abrupt("return", _context12.sent);
            case 8:
            case "end":
              return _context12.stop();
          }
        }, _callee12);
      }));
      return function method() {
        return _ref12.apply(this, arguments);
      };
    }();
    (0, index_js_3.defineProperties)(method, {
      name: contract["interface"].getFunctionName(key),
      _contract: contract,
      _key: key,
      getFragment: getFragment,
      estimateGas: estimateGas,
      populateTransaction: populateTransaction,
      send: send,
      staticCall: staticCall,
      staticCallResult: staticCallResult
    });
    // Only works on non-ambiguous keys (refined fragment is always non-ambiguous)
    Object.defineProperty(method, "fragment", {
      configurable: false,
      enumerable: true,
      get: function get() {
        var fragment = contract["interface"].getFunction(key);
        (0, index_js_3.assert)(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
          operation: "fragment",
          info: {
            key: key
          }
        });
        return fragment;
      }
    });
    return method;
  }
  function buildWrappedEvent(contract, key) {
    var getFragment = function getFragment() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      var fragment = contract["interface"].getEvent(key, args);
      (0, index_js_3.assert)(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
        operation: "fragment",
        info: {
          key: key,
          args: args
        }
      });
      return fragment;
    };
    var method = function method() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      return new PreparedTopicFilter(contract, getFragment.apply(void 0, args), args);
    };
    (0, index_js_3.defineProperties)(method, {
      name: contract["interface"].getEventName(key),
      _contract: contract,
      _key: key,
      getFragment: getFragment
    });
    // Only works on non-ambiguous keys (refined fragment is always non-ambiguous)
    Object.defineProperty(method, "fragment", {
      configurable: false,
      enumerable: true,
      get: function get() {
        var fragment = contract["interface"].getEvent(key);
        (0, index_js_3.assert)(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
          operation: "fragment",
          info: {
            key: key
          }
        });
        return fragment;
      }
    });
    return method;
  }
  // The combination of TypeScrype, Private Fields and Proxies makes
  // the world go boom; so we hide variables with some trickery keeping
  // a symbol attached to each BaseContract which its sub-class (even
  // via a Proxy) can reach and use to look up its internal values.
  var internal = Symbol["for"]("_ethersInternal_contract");
  var internalValues = new WeakMap();
  function setInternal(contract, values) {
    internalValues.set(contract[internal], values);
  }
  function getInternal(contract) {
    return internalValues.get(contract[internal]);
  }
  function isDeferred(value) {
    return value && _typeof(value) === "object" && "getTopicFilter" in value && typeof value.getTopicFilter === "function" && value.fragment;
  }
  function getSubInfo(_x11, _x12) {
    return _getSubInfo.apply(this, arguments);
  }
  function _getSubInfo() {
    _getSubInfo = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee30(contract, event) {
      var topics, fragment, topicHashify, tag;
      return _regeneratorRuntime().wrap(function _callee30$(_context30) {
        while (1) switch (_context30.prev = _context30.next) {
          case 0:
            fragment = null; // Convert named events to topicHash and get the fragment for
            // events which need deconstructing.
            if (!Array.isArray(event)) {
              _context30.next = 6;
              break;
            }
            topicHashify = function topicHashify(name) {
              if ((0, index_js_3.isHexString)(name, 32)) {
                return name;
              }
              var fragment = contract["interface"].getEvent(name);
              (0, index_js_3.assertArgument)(fragment, "unknown fragment", "name", name);
              return fragment.topicHash;
            }; // Array of Topics and Names; e.g. `[ "0x1234...89ab", "Transfer(address)" ]`
            topics = event.map(function (e) {
              if (e == null) {
                return null;
              }
              if (Array.isArray(e)) {
                return e.map(topicHashify);
              }
              return topicHashify(e);
            });
            _context30.next = 21;
            break;
          case 6:
            if (!(event === "*")) {
              _context30.next = 10;
              break;
            }
            topics = [null];
            _context30.next = 21;
            break;
          case 10:
            if (!(typeof event === "string")) {
              _context30.next = 14;
              break;
            }
            if ((0, index_js_3.isHexString)(event, 32)) {
              // Topic Hash
              topics = [event];
            } else {
              // Name or Signature; e.g. `"Transfer", `"Transfer(address)"`
              fragment = contract["interface"].getEvent(event);
              (0, index_js_3.assertArgument)(fragment, "unknown fragment", "event", event);
              topics = [fragment.topicHash];
            }
            _context30.next = 21;
            break;
          case 14:
            if (!isDeferred(event)) {
              _context30.next = 20;
              break;
            }
            _context30.next = 17;
            return event.getTopicFilter();
          case 17:
            topics = _context30.sent;
            _context30.next = 21;
            break;
          case 20:
            if ("fragment" in event) {
              // ContractEvent; e.g. `contract.filter.Transfer`
              fragment = event.fragment;
              topics = [fragment.topicHash];
            } else {
              (0, index_js_3.assertArgument)(false, "unknown event name", "event", event);
            }
          case 21:
            // Normalize topics and sort TopicSets
            topics = topics.map(function (t) {
              if (t == null) {
                return null;
              }
              if (Array.isArray(t)) {
                var items = Array.from(new Set(t.map(function (t) {
                  return t.toLowerCase();
                })).values());
                if (items.length === 1) {
                  return items[0];
                }
                items.sort();
                return items;
              }
              return t.toLowerCase();
            });
            tag = topics.map(function (t) {
              if (t == null) {
                return "null";
              }
              if (Array.isArray(t)) {
                return t.join("|");
              }
              return t;
            }).join("&");
            return _context30.abrupt("return", {
              fragment: fragment,
              tag: tag,
              topics: topics
            });
          case 24:
          case "end":
            return _context30.stop();
        }
      }, _callee30);
    }));
    return _getSubInfo.apply(this, arguments);
  }
  function hasSub(_x13, _x14) {
    return _hasSub.apply(this, arguments);
  }
  function _hasSub() {
    _hasSub = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee31(contract, event) {
      var _getInternal5, subs;
      return _regeneratorRuntime().wrap(function _callee31$(_context31) {
        while (1) switch (_context31.prev = _context31.next) {
          case 0:
            _getInternal5 = getInternal(contract), subs = _getInternal5.subs;
            _context31.t1 = subs;
            _context31.next = 4;
            return getSubInfo(contract, event);
          case 4:
            _context31.t2 = _context31.sent.tag;
            _context31.t0 = _context31.t1.get.call(_context31.t1, _context31.t2);
            if (_context31.t0) {
              _context31.next = 8;
              break;
            }
            _context31.t0 = null;
          case 8:
            return _context31.abrupt("return", _context31.t0);
          case 9:
          case "end":
            return _context31.stop();
        }
      }, _callee31);
    }));
    return _hasSub.apply(this, arguments);
  }
  function getSub(_x15, _x16, _x17) {
    return _getSub.apply(this, arguments);
  } // We use this to ensure one emit resolves before firing the next to
  // ensure correct ordering (note this cannot throw and just adds the
  // notice to the event queu using setTimeout).
  function _getSub() {
    _getSub = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee33(contract, operation, event) {
      var provider, _yield$getSubInfo2, fragment, tag, topics, _getInternal6, addr, subs, sub, address, filter, listener, starting, start, stop;
      return _regeneratorRuntime().wrap(function _callee33$(_context33) {
        while (1) switch (_context33.prev = _context33.next) {
          case 0:
            // Make sure our runner can actually subscribe to events
            provider = getProvider(contract.runner);
            (0, index_js_3.assert)(provider, "contract runner does not support subscribing", "UNSUPPORTED_OPERATION", {
              operation: operation
            });
            _context33.next = 4;
            return getSubInfo(contract, event);
          case 4:
            _yield$getSubInfo2 = _context33.sent;
            fragment = _yield$getSubInfo2.fragment;
            tag = _yield$getSubInfo2.tag;
            topics = _yield$getSubInfo2.topics;
            _getInternal6 = getInternal(contract), addr = _getInternal6.addr, subs = _getInternal6.subs;
            sub = subs.get(tag);
            if (!sub) {
              address = addr ? addr : contract;
              filter = {
                address: address,
                topics: topics
              };
              listener = function listener(log) {
                var foundFragment = fragment;
                if (foundFragment == null) {
                  try {
                    foundFragment = contract["interface"].getEvent(log.topics[0]);
                  } catch (error) {}
                }
                // If fragment is null, we do not deconstruct the args to emit
                if (foundFragment) {
                  var _foundFragment = foundFragment;
                  var _args32 = fragment ? contract["interface"].decodeEventLog(fragment, log.data, log.topics) : [];
                  _emit4(contract, event, _args32, function (listener) {
                    return new wrappers_js_1.ContractEventPayload(contract, listener, event, _foundFragment, log);
                  });
                } else {
                  _emit4(contract, event, [], function (listener) {
                    return new wrappers_js_1.ContractUnknownEventPayload(contract, listener, event, log);
                  });
                }
              };
              starting = [];
              start = function start() {
                if (starting.length) {
                  return;
                }
                starting.push(provider.on(filter, listener));
              };
              stop = /*#__PURE__*/function () {
                var _ref17 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee32() {
                  var started;
                  return _regeneratorRuntime().wrap(function _callee32$(_context32) {
                    while (1) switch (_context32.prev = _context32.next) {
                      case 0:
                        if (!(starting.length == 0)) {
                          _context32.next = 2;
                          break;
                        }
                        return _context32.abrupt("return");
                      case 2:
                        started = starting;
                        starting = [];
                        _context32.next = 6;
                        return Promise.all(started);
                      case 6:
                        provider.off(filter, listener);
                      case 7:
                      case "end":
                        return _context32.stop();
                    }
                  }, _callee32);
                }));
                return function stop() {
                  return _ref17.apply(this, arguments);
                };
              }();
              sub = {
                tag: tag,
                listeners: [],
                start: start,
                stop: stop
              };
              subs.set(tag, sub);
            }
            return _context33.abrupt("return", sub);
          case 12:
          case "end":
            return _context33.stop();
        }
      }, _callee33);
    }));
    return _getSub.apply(this, arguments);
  }
  var lastEmit = Promise.resolve();
  function _emit(_x18, _x19, _x20, _x21) {
    return _emit2.apply(this, arguments);
  }
  function _emit2() {
    _emit2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee34(contract, event, args, payloadFunc) {
      var sub, count;
      return _regeneratorRuntime().wrap(function _callee34$(_context34) {
        while (1) switch (_context34.prev = _context34.next) {
          case 0:
            _context34.next = 2;
            return lastEmit;
          case 2:
            _context34.next = 4;
            return hasSub(contract, event);
          case 4:
            sub = _context34.sent;
            if (sub) {
              _context34.next = 7;
              break;
            }
            return _context34.abrupt("return", false);
          case 7:
            count = sub.listeners.length;
            sub.listeners = sub.listeners.filter(function (_ref18) {
              var listener = _ref18.listener,
                once = _ref18.once;
              var passArgs = Array.from(args);
              if (payloadFunc) {
                passArgs.push(payloadFunc(once ? null : listener));
              }
              try {
                listener.call.apply(listener, [contract].concat(passArgs));
              } catch (error) {}
              return !once;
            });
            if (sub.listeners.length === 0) {
              sub.stop();
              getInternal(contract).subs["delete"](sub.tag);
            }
            return _context34.abrupt("return", count > 0);
          case 11:
          case "end":
            return _context34.stop();
        }
      }, _callee34);
    }));
    return _emit2.apply(this, arguments);
  }
  function _emit4(_x22, _x23, _x24, _x25) {
    return _emit3.apply(this, arguments);
  }
  function _emit3() {
    _emit3 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee35(contract, event, args, payloadFunc) {
      var resultPromise;
      return _regeneratorRuntime().wrap(function _callee35$(_context35) {
        while (1) switch (_context35.prev = _context35.next) {
          case 0:
            _context35.prev = 0;
            _context35.next = 3;
            return lastEmit;
          case 3:
            _context35.next = 7;
            break;
          case 5:
            _context35.prev = 5;
            _context35.t0 = _context35["catch"](0);
          case 7:
            resultPromise = _emit(contract, event, args, payloadFunc);
            lastEmit = resultPromise;
            _context35.next = 11;
            return resultPromise;
          case 11:
            return _context35.abrupt("return", _context35.sent);
          case 12:
          case "end":
            return _context35.stop();
        }
      }, _callee35, null, [[0, 5]]);
    }));
    return _emit3.apply(this, arguments);
  }
  var passProperties = ["then"];
  var BaseContract = /*#__PURE__*/function () {
    /**
     *  Creates a new contract connected to %%target%% with the %%abi%% and
     *  optionally connected to a %%runner%% to perform operations on behalf
     *  of.
     */
    function BaseContract(target, abi, runner, _deployTx) {
      var _this = this;
      _classCallCheck(this, BaseContract);
      /**
       *  The target to connect to.
       *
       *  This can be an address, ENS name or any [[Addressable]], such as
       *  another contract. To get the resovled address, use the ``getAddress``
       *  method.
       */
      _defineProperty(this, "target", void 0);
      /**
       *  The contract Interface.
       */
      _defineProperty(this, "interface", void 0);
      /**
       *  The connected runner. This is generally a [[Provider]] or a
       *  [[Signer]], which dictates what operations are supported.
       *
       *  For example, a **Contract** connected to a [[Provider]] may
       *  only execute read-only operations.
       */
      _defineProperty(this, "runner", void 0);
      /**
       *  All the Events available on this contract.
       */
      _defineProperty(this, "filters", void 0);
      /**
       *  @_ignore:
       */
      _defineProperty(this, internal, void 0);
      /**
       *  The fallback or receive function if any.
       */
      _defineProperty(this, "fallback", void 0);
      (0, index_js_3.assertArgument)(typeof target === "string" || (0, index_js_2.isAddressable)(target), "invalid value for Contract target", "target", target);
      if (runner == null) {
        runner = null;
      }
      var iface = index_js_1.Interface.from(abi);
      (0, index_js_3.defineProperties)(this, {
        target: target,
        runner: runner,
        "interface": iface
      });
      Object.defineProperty(this, internal, {
        value: {}
      });
      var addrPromise;
      var addr = null;
      var deployTx = null;
      if (_deployTx) {
        var provider = getProvider(runner);
        // @TODO: the provider can be null; make a custom dummy provider that will throw a
        // meaningful error
        deployTx = new wrappers_js_1.ContractTransactionResponse(this["interface"], provider, _deployTx);
      }
      var subs = new Map();
      // Resolve the target as the address
      if (typeof target === "string") {
        if ((0, index_js_3.isHexString)(target)) {
          addr = target;
          addrPromise = Promise.resolve(target);
        } else {
          var resolver = getRunner(runner, "resolveName");
          if (!canResolve(resolver)) {
            throw (0, index_js_3.makeError)("contract runner does not support name resolution", "UNSUPPORTED_OPERATION", {
              operation: "resolveName"
            });
          }
          addrPromise = resolver.resolveName(target).then(function (addr) {
            if (addr == null) {
              throw (0, index_js_3.makeError)("an ENS name used for a contract target must be correctly configured", "UNCONFIGURED_NAME", {
                value: target
              });
            }
            getInternal(_this).addr = addr;
            return addr;
          });
        }
      } else {
        addrPromise = target.getAddress().then(function (addr) {
          if (addr == null) {
            throw new Error("TODO");
          }
          getInternal(_this).addr = addr;
          return addr;
        });
      }
      // Set our private values
      setInternal(this, {
        addrPromise: addrPromise,
        addr: addr,
        deployTx: deployTx,
        subs: subs
      });
      // Add the event filters
      var filters = new Proxy({}, {
        get: function get(target, prop, receiver) {
          // Pass important checks (like `then` for Promise) through
          if (_typeof(prop) === "symbol" || passProperties.indexOf(prop) >= 0) {
            return Reflect.get(target, prop, receiver);
          }
          try {
            return _this.getEvent(prop);
          } catch (error) {
            if (!(0, index_js_3.isError)(error, "INVALID_ARGUMENT") || error.argument !== "key") {
              throw error;
            }
          }
          return undefined;
        },
        has: function has(target, prop) {
          // Pass important checks (like `then` for Promise) through
          if (passProperties.indexOf(prop) >= 0) {
            return Reflect.has(target, prop);
          }
          return Reflect.has(target, prop) || _this["interface"].hasEvent(String(prop));
        }
      });
      (0, index_js_3.defineProperties)(this, {
        filters: filters
      });
      (0, index_js_3.defineProperties)(this, {
        fallback: iface.receive || iface.fallback ? buildWrappedFallback(this) : null
      });
      // Return a Proxy that will respond to functions
      return new Proxy(this, {
        get: function get(target, prop, receiver) {
          if (_typeof(prop) === "symbol" || prop in target || passProperties.indexOf(prop) >= 0) {
            return Reflect.get(target, prop, receiver);
          }
          // Undefined properties should return undefined
          try {
            return target.getFunction(prop);
          } catch (error) {
            if (!(0, index_js_3.isError)(error, "INVALID_ARGUMENT") || error.argument !== "key") {
              throw error;
            }
          }
          return undefined;
        },
        has: function has(target, prop) {
          if (_typeof(prop) === "symbol" || prop in target || passProperties.indexOf(prop) >= 0) {
            return Reflect.has(target, prop);
          }
          return target["interface"].hasFunction(prop);
        }
      });
    }
    /**
     *  Return a new Contract instance with the same target and ABI, but
     *  a different %%runner%%.
     */
    return _createClass(BaseContract, [{
      key: "connect",
      value: function connect(runner) {
        return new BaseContract(this.target, this["interface"], runner);
      }
      /**
       *  Return a new Contract instance with the same ABI and runner, but
       *  a different %%target%%.
       */
    }, {
      key: "attach",
      value: function attach(target) {
        return new BaseContract(target, this["interface"], this.runner);
      }
      /**
       *  Return the resolved address of this Contract.
       */
    }, {
      key: "getAddress",
      value: (function () {
        var _getAddress = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee13() {
          return _regeneratorRuntime().wrap(function _callee13$(_context13) {
            while (1) switch (_context13.prev = _context13.next) {
              case 0:
                _context13.next = 2;
                return getInternal(this).addrPromise;
              case 2:
                return _context13.abrupt("return", _context13.sent);
              case 3:
              case "end":
                return _context13.stop();
            }
          }, _callee13, this);
        }));
        function getAddress() {
          return _getAddress.apply(this, arguments);
        }
        return getAddress;
      }()
      /**
       *  Return the deployed bytecode or null if no bytecode is found.
       */
      )
    }, {
      key: "getDeployedCode",
      value: (function () {
        var _getDeployedCode = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee14() {
          var provider, code;
          return _regeneratorRuntime().wrap(function _callee14$(_context14) {
            while (1) switch (_context14.prev = _context14.next) {
              case 0:
                provider = getProvider(this.runner);
                (0, index_js_3.assert)(provider, "runner does not support .provider", "UNSUPPORTED_OPERATION", {
                  operation: "getDeployedCode"
                });
                _context14.t0 = provider;
                _context14.next = 5;
                return this.getAddress();
              case 5:
                _context14.t1 = _context14.sent;
                _context14.next = 8;
                return _context14.t0.getCode.call(_context14.t0, _context14.t1);
              case 8:
                code = _context14.sent;
                if (!(code === "0x")) {
                  _context14.next = 11;
                  break;
                }
                return _context14.abrupt("return", null);
              case 11:
                return _context14.abrupt("return", code);
              case 12:
              case "end":
                return _context14.stop();
            }
          }, _callee14, this);
        }));
        function getDeployedCode() {
          return _getDeployedCode.apply(this, arguments);
        }
        return getDeployedCode;
      }()
      /**
       *  Resolve to this Contract once the bytecode has been deployed, or
       *  resolve immediately if already deployed.
       */
      )
    }, {
      key: "waitForDeployment",
      value: (function () {
        var _waitForDeployment = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee16() {
          var _this2 = this;
          var deployTx, code, provider;
          return _regeneratorRuntime().wrap(function _callee16$(_context16) {
            while (1) switch (_context16.prev = _context16.next) {
              case 0:
                // We have the deployement transaction; just use that (throws if deployement fails)
                deployTx = this.deploymentTransaction();
                if (!deployTx) {
                  _context16.next = 5;
                  break;
                }
                _context16.next = 4;
                return deployTx.wait();
              case 4:
                return _context16.abrupt("return", this);
              case 5:
                _context16.next = 7;
                return this.getDeployedCode();
              case 7:
                code = _context16.sent;
                if (!(code != null)) {
                  _context16.next = 10;
                  break;
                }
                return _context16.abrupt("return", this);
              case 10:
                // Make sure we can subscribe to a provider event
                provider = getProvider(this.runner);
                (0, index_js_3.assert)(provider != null, "contract runner does not support .provider", "UNSUPPORTED_OPERATION", {
                  operation: "waitForDeployment"
                });
                return _context16.abrupt("return", new Promise(function (resolve, reject) {
                  var _checkCode = /*#__PURE__*/function () {
                    var _ref13 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee15() {
                      var _code;
                      return _regeneratorRuntime().wrap(function _callee15$(_context15) {
                        while (1) switch (_context15.prev = _context15.next) {
                          case 0:
                            _context15.prev = 0;
                            _context15.next = 3;
                            return _this2.getDeployedCode();
                          case 3:
                            _code = _context15.sent;
                            if (!(_code != null)) {
                              _context15.next = 6;
                              break;
                            }
                            return _context15.abrupt("return", resolve(_this2));
                          case 6:
                            provider.once("block", _checkCode);
                            _context15.next = 12;
                            break;
                          case 9:
                            _context15.prev = 9;
                            _context15.t0 = _context15["catch"](0);
                            reject(_context15.t0);
                          case 12:
                          case "end":
                            return _context15.stop();
                        }
                      }, _callee15, null, [[0, 9]]);
                    }));
                    return function checkCode() {
                      return _ref13.apply(this, arguments);
                    };
                  }();
                  _checkCode();
                }));
              case 13:
              case "end":
                return _context16.stop();
            }
          }, _callee16, this);
        }));
        function waitForDeployment() {
          return _waitForDeployment.apply(this, arguments);
        }
        return waitForDeployment;
      }()
      /**
       *  Return the transaction used to deploy this contract.
       *
       *  This is only available if this instance was returned from a
       *  [[ContractFactory]].
       */
      )
    }, {
      key: "deploymentTransaction",
      value: function deploymentTransaction() {
        return getInternal(this).deployTx;
      }
      /**
       *  Return the function for a given name. This is useful when a contract
       *  method name conflicts with a JavaScript name such as ``prototype`` or
       *  when using a Contract programatically.
       */
    }, {
      key: "getFunction",
      value: function getFunction(key) {
        if (typeof key !== "string") {
          key = key.format();
        }
        var func = buildWrappedMethod(this, key);
        return func;
      }
      /**
       *  Return the event for a given name. This is useful when a contract
       *  event name conflicts with a JavaScript name such as ``prototype`` or
       *  when using a Contract programatically.
       */
    }, {
      key: "getEvent",
      value: function getEvent(key) {
        if (typeof key !== "string") {
          key = key.format();
        }
        return buildWrappedEvent(this, key);
      }
      /**
       *  @_ignore:
       */
    }, {
      key: "queryTransaction",
      value: (function () {
        var _queryTransaction = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee17(hash) {
          return _regeneratorRuntime().wrap(function _callee17$(_context17) {
            while (1) switch (_context17.prev = _context17.next) {
              case 0:
                throw new Error("@TODO");
              case 1:
              case "end":
                return _context17.stop();
            }
          }, _callee17);
        }));
        function queryTransaction(_x26) {
          return _queryTransaction.apply(this, arguments);
        }
        return queryTransaction;
      }()
      /*
      // @TODO: this is a non-backwards compatible change, but will be added
      //        in v7 and in a potential SmartContract class in an upcoming
      //        v6 release
      async getTransactionReceipt(hash: string): Promise<null | ContractTransactionReceipt> {
          const provider = getProvider(this.runner);
          assert(provider, "contract runner does not have a provider",
              "UNSUPPORTED_OPERATION", { operation: "queryTransaction" });
           const receipt = await provider.getTransactionReceipt(hash);
          if (receipt == null) { return null; }
           return new ContractTransactionReceipt(this.interface, provider, receipt);
      }
      */
      /**
       *  Provide historic access to event data for %%event%% in the range
       *  %%fromBlock%% (default: ``0``) to %%toBlock%% (default: ``"latest"``)
       *  inclusive.
       */
      )
    }, {
      key: "queryFilter",
      value: (function () {
        var _queryFilter = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee18(event, fromBlock, toBlock) {
          var _this3 = this;
          var _getInternal, addr, addrPromise, address, _yield$getSubInfo, fragment, topics, filter, provider;
          return _regeneratorRuntime().wrap(function _callee18$(_context18) {
            while (1) switch (_context18.prev = _context18.next) {
              case 0:
                if (fromBlock == null) {
                  fromBlock = 0;
                }
                if (toBlock == null) {
                  toBlock = "latest";
                }
                _getInternal = getInternal(this), addr = _getInternal.addr, addrPromise = _getInternal.addrPromise;
                if (!addr) {
                  _context18.next = 7;
                  break;
                }
                _context18.t0 = addr;
                _context18.next = 10;
                break;
              case 7:
                _context18.next = 9;
                return addrPromise;
              case 9:
                _context18.t0 = _context18.sent;
              case 10:
                address = _context18.t0;
                _context18.next = 13;
                return getSubInfo(this, event);
              case 13:
                _yield$getSubInfo = _context18.sent;
                fragment = _yield$getSubInfo.fragment;
                topics = _yield$getSubInfo.topics;
                filter = {
                  address: address,
                  topics: topics,
                  fromBlock: fromBlock,
                  toBlock: toBlock
                };
                provider = getProvider(this.runner);
                (0, index_js_3.assert)(provider, "contract runner does not have a provider", "UNSUPPORTED_OPERATION", {
                  operation: "queryFilter"
                });
                _context18.next = 21;
                return provider.getLogs(filter);
              case 21:
                return _context18.abrupt("return", _context18.sent.map(function (log) {
                  var foundFragment = fragment;
                  if (foundFragment == null) {
                    try {
                      foundFragment = _this3["interface"].getEvent(log.topics[0]);
                    } catch (error) {}
                  }
                  if (foundFragment) {
                    try {
                      return new wrappers_js_1.EventLog(log, _this3["interface"], foundFragment);
                    } catch (error) {
                      return new wrappers_js_1.UndecodedEventLog(log, error);
                    }
                  }
                  return new provider_js_1.Log(log, provider);
                }));
              case 22:
              case "end":
                return _context18.stop();
            }
          }, _callee18, this);
        }));
        function queryFilter(_x27, _x28, _x29) {
          return _queryFilter.apply(this, arguments);
        }
        return queryFilter;
      }()
      /**
       *  Add an event %%listener%% for the %%event%%.
       */
      )
    }, {
      key: "on",
      value: (function () {
        var _on = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee19(event, listener) {
          var sub;
          return _regeneratorRuntime().wrap(function _callee19$(_context19) {
            while (1) switch (_context19.prev = _context19.next) {
              case 0:
                _context19.next = 2;
                return getSub(this, "on", event);
              case 2:
                sub = _context19.sent;
                sub.listeners.push({
                  listener: listener,
                  once: false
                });
                sub.start();
                return _context19.abrupt("return", this);
              case 6:
              case "end":
                return _context19.stop();
            }
          }, _callee19, this);
        }));
        function on(_x30, _x31) {
          return _on.apply(this, arguments);
        }
        return on;
      }()
      /**
       *  Add an event %%listener%% for the %%event%%, but remove the listener
       *  after it is fired once.
       */
      )
    }, {
      key: "once",
      value: (function () {
        var _once = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee20(event, listener) {
          var sub;
          return _regeneratorRuntime().wrap(function _callee20$(_context20) {
            while (1) switch (_context20.prev = _context20.next) {
              case 0:
                _context20.next = 2;
                return getSub(this, "once", event);
              case 2:
                sub = _context20.sent;
                sub.listeners.push({
                  listener: listener,
                  once: true
                });
                sub.start();
                return _context20.abrupt("return", this);
              case 6:
              case "end":
                return _context20.stop();
            }
          }, _callee20, this);
        }));
        function once(_x32, _x33) {
          return _once.apply(this, arguments);
        }
        return once;
      }()
      /**
       *  Emit an %%event%% calling all listeners with %%args%%.
       *
       *  Resolves to ``true`` if any listeners were called.
       */
      )
    }, {
      key: "emit",
      value: (function () {
        var _emit5 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee21(event) {
          var _len5,
            args,
            _key5,
            _args21 = arguments;
          return _regeneratorRuntime().wrap(function _callee21$(_context21) {
            while (1) switch (_context21.prev = _context21.next) {
              case 0:
                for (_len5 = _args21.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
                  args[_key5 - 1] = _args21[_key5];
                }
                _context21.next = 3;
                return _emit4(this, event, args, null);
              case 3:
                return _context21.abrupt("return", _context21.sent);
              case 4:
              case "end":
                return _context21.stop();
            }
          }, _callee21, this);
        }));
        function emit(_x34) {
          return _emit5.apply(this, arguments);
        }
        return emit;
      }()
      /**
       *  Resolves to the number of listeners of %%event%% or the total number
       *  of listeners if unspecified.
       */
      )
    }, {
      key: "listenerCount",
      value: (function () {
        var _listenerCount = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee22(event) {
          var sub, _getInternal2, subs, total, _iterator, _step, listeners;
          return _regeneratorRuntime().wrap(function _callee22$(_context22) {
            while (1) switch (_context22.prev = _context22.next) {
              case 0:
                if (!event) {
                  _context22.next = 7;
                  break;
                }
                _context22.next = 3;
                return hasSub(this, event);
              case 3:
                sub = _context22.sent;
                if (sub) {
                  _context22.next = 6;
                  break;
                }
                return _context22.abrupt("return", 0);
              case 6:
                return _context22.abrupt("return", sub.listeners.length);
              case 7:
                _getInternal2 = getInternal(this), subs = _getInternal2.subs;
                total = 0;
                _iterator = _createForOfIteratorHelper(subs.values());
                try {
                  for (_iterator.s(); !(_step = _iterator.n()).done;) {
                    listeners = _step.value.listeners;
                    total += listeners.length;
                  }
                } catch (err) {
                  _iterator.e(err);
                } finally {
                  _iterator.f();
                }
                return _context22.abrupt("return", total);
              case 12:
              case "end":
                return _context22.stop();
            }
          }, _callee22, this);
        }));
        function listenerCount(_x35) {
          return _listenerCount.apply(this, arguments);
        }
        return listenerCount;
      }()
      /**
       *  Resolves to the listeners subscribed to %%event%% or all listeners
       *  if unspecified.
       */
      )
    }, {
      key: "listeners",
      value: (function () {
        var _listeners = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee23(event) {
          var sub, _getInternal3, subs, result, _iterator2, _step2, _listeners2;
          return _regeneratorRuntime().wrap(function _callee23$(_context23) {
            while (1) switch (_context23.prev = _context23.next) {
              case 0:
                if (!event) {
                  _context23.next = 7;
                  break;
                }
                _context23.next = 3;
                return hasSub(this, event);
              case 3:
                sub = _context23.sent;
                if (sub) {
                  _context23.next = 6;
                  break;
                }
                return _context23.abrupt("return", []);
              case 6:
                return _context23.abrupt("return", sub.listeners.map(function (_ref14) {
                  var listener = _ref14.listener;
                  return listener;
                }));
              case 7:
                _getInternal3 = getInternal(this), subs = _getInternal3.subs;
                result = [];
                _iterator2 = _createForOfIteratorHelper(subs.values());
                try {
                  for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                    _listeners2 = _step2.value.listeners;
                    result = result.concat(_listeners2.map(function (_ref15) {
                      var listener = _ref15.listener;
                      return listener;
                    }));
                  }
                } catch (err) {
                  _iterator2.e(err);
                } finally {
                  _iterator2.f();
                }
                return _context23.abrupt("return", result);
              case 12:
              case "end":
                return _context23.stop();
            }
          }, _callee23, this);
        }));
        function listeners(_x36) {
          return _listeners.apply(this, arguments);
        }
        return listeners;
      }()
      /**
       *  Remove the %%listener%% from the listeners for %%event%% or remove
       *  all listeners if unspecified.
       */
      )
    }, {
      key: "off",
      value: (function () {
        var _off = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee24(event, listener) {
          var sub, index;
          return _regeneratorRuntime().wrap(function _callee24$(_context24) {
            while (1) switch (_context24.prev = _context24.next) {
              case 0:
                _context24.next = 2;
                return hasSub(this, event);
              case 2:
                sub = _context24.sent;
                if (sub) {
                  _context24.next = 5;
                  break;
                }
                return _context24.abrupt("return", this);
              case 5:
                if (listener) {
                  index = sub.listeners.map(function (_ref16) {
                    var listener = _ref16.listener;
                    return listener;
                  }).indexOf(listener);
                  if (index >= 0) {
                    sub.listeners.splice(index, 1);
                  }
                }
                if (listener == null || sub.listeners.length === 0) {
                  sub.stop();
                  getInternal(this).subs["delete"](sub.tag);
                }
                return _context24.abrupt("return", this);
              case 8:
              case "end":
                return _context24.stop();
            }
          }, _callee24, this);
        }));
        function off(_x37, _x38) {
          return _off.apply(this, arguments);
        }
        return off;
      }()
      /**
       *  Remove all the listeners for %%event%% or remove all listeners if
       *  unspecified.
       */
      )
    }, {
      key: "removeAllListeners",
      value: (function () {
        var _removeAllListeners = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee25(event) {
          var sub, _getInternal4, subs, _iterator3, _step3, _step3$value, tag, stop;
          return _regeneratorRuntime().wrap(function _callee25$(_context25) {
            while (1) switch (_context25.prev = _context25.next) {
              case 0:
                if (!event) {
                  _context25.next = 10;
                  break;
                }
                _context25.next = 3;
                return hasSub(this, event);
              case 3:
                sub = _context25.sent;
                if (sub) {
                  _context25.next = 6;
                  break;
                }
                return _context25.abrupt("return", this);
              case 6:
                sub.stop();
                getInternal(this).subs["delete"](sub.tag);
                _context25.next = 13;
                break;
              case 10:
                _getInternal4 = getInternal(this), subs = _getInternal4.subs;
                _iterator3 = _createForOfIteratorHelper(subs.values());
                try {
                  for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                    _step3$value = _step3.value, tag = _step3$value.tag, stop = _step3$value.stop;
                    stop();
                    subs["delete"](tag);
                  }
                } catch (err) {
                  _iterator3.e(err);
                } finally {
                  _iterator3.f();
                }
              case 13:
                return _context25.abrupt("return", this);
              case 14:
              case "end":
                return _context25.stop();
            }
          }, _callee25, this);
        }));
        function removeAllListeners(_x39) {
          return _removeAllListeners.apply(this, arguments);
        }
        return removeAllListeners;
      }()
      /**
       *  Alias for [on].
       */
      )
    }, {
      key: "addListener",
      value: (function () {
        var _addListener = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee26(event, listener) {
          return _regeneratorRuntime().wrap(function _callee26$(_context26) {
            while (1) switch (_context26.prev = _context26.next) {
              case 0:
                _context26.next = 2;
                return this.on(event, listener);
              case 2:
                return _context26.abrupt("return", _context26.sent);
              case 3:
              case "end":
                return _context26.stop();
            }
          }, _callee26, this);
        }));
        function addListener(_x40, _x41) {
          return _addListener.apply(this, arguments);
        }
        return addListener;
      }()
      /**
       *  Alias for [off].
       */
      )
    }, {
      key: "removeListener",
      value: (function () {
        var _removeListener = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee27(event, listener) {
          return _regeneratorRuntime().wrap(function _callee27$(_context27) {
            while (1) switch (_context27.prev = _context27.next) {
              case 0:
                _context27.next = 2;
                return this.off(event, listener);
              case 2:
                return _context27.abrupt("return", _context27.sent);
              case 3:
              case "end":
                return _context27.stop();
            }
          }, _callee27, this);
        }));
        function removeListener(_x42, _x43) {
          return _removeListener.apply(this, arguments);
        }
        return removeListener;
      }()
      /**
       *  Create a new Class for the %%abi%%.
       */
      )
    }], [{
      key: "buildClass",
      value: function buildClass(abi) {
        var CustomContract = /*#__PURE__*/function (_BaseContract2) {
          function CustomContract(address) {
            var runner = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            _classCallCheck(this, CustomContract);
            return _callSuper(this, CustomContract, [address, abi, runner]);
          }
          _inherits(CustomContract, _BaseContract2);
          return _createClass(CustomContract);
        }(BaseContract);
        return CustomContract;
      }
    }, {
      key: "from",
      value:
      /**
       *  Create a new BaseContract with a specified Interface.
       */
      function from(target, abi, runner) {
        if (runner == null) {
          runner = null;
        }
        var contract = new this(target, abi, runner);
        return contract;
      }
    }]);
  }();
  contract.BaseContract = BaseContract;
  function _ContractBase() {
    return BaseContract;
  }
  /**
   *  A [[BaseContract]] with no type guards on its methods or events.
   */
  var Contract = /*#__PURE__*/function (_ContractBase2) {
    function Contract() {
      _classCallCheck(this, Contract);
      return _callSuper(this, Contract, arguments);
    }
    _inherits(Contract, _ContractBase2);
    return _createClass(Contract);
  }(_ContractBase());
  contract.Contract = Contract;
  return contract;
}

var factory = {};

var hasRequiredFactory;
function requireFactory() {
  if (hasRequiredFactory) return factory;
  hasRequiredFactory = 1;
  Object.defineProperty(factory, "__esModule", {
    value: true
  });
  factory.ContractFactory = void 0;
  var index_js_1 = /*@__PURE__*/requireAbi();
  var index_js_2 = /*@__PURE__*/requireAddress$2();
  var index_js_3 = /*@__PURE__*/requireUtils$3();
  var contract_js_1 = /*@__PURE__*/requireContract$1();
  // A = Arguments to the constructor
  // I = Interface of deployed contracts
  /**
   *  A **ContractFactory** is used to deploy a Contract to the blockchain.
   */
  var ContractFactory = /*#__PURE__*/function () {
    /**
     *  Create a new **ContractFactory** with %%abi%% and %%bytecode%%,
     *  optionally connected to %%runner%%.
     *
     *  The %%bytecode%% may be the ``bytecode`` property within the
     *  standard Solidity JSON output.
     */
    function ContractFactory(abi, bytecode, runner) {
      _classCallCheck(this, ContractFactory);
      /**
       *  The Contract Interface.
       */
      _defineProperty(this, "interface", void 0);
      /**
       *  The Contract deployment bytecode. Often called the initcode.
       */
      _defineProperty(this, "bytecode", void 0);
      /**
       *  The ContractRunner to deploy the Contract as.
       */
      _defineProperty(this, "runner", void 0);
      var iface = index_js_1.Interface.from(abi);
      // Dereference Solidity bytecode objects and allow a missing `0x`-prefix
      if (bytecode instanceof Uint8Array) {
        bytecode = (0, index_js_3.hexlify)((0, index_js_3.getBytes)(bytecode));
      } else {
        if (_typeof(bytecode) === "object") {
          bytecode = bytecode.object;
        }
        if (!bytecode.startsWith("0x")) {
          bytecode = "0x" + bytecode;
        }
        bytecode = (0, index_js_3.hexlify)((0, index_js_3.getBytes)(bytecode));
      }
      (0, index_js_3.defineProperties)(this, {
        bytecode: bytecode,
        "interface": iface,
        runner: runner || null
      });
    }
    return _createClass(ContractFactory, [{
      key: "attach",
      value: function attach(target) {
        return new contract_js_1.BaseContract(target, this["interface"], this.runner);
      }
      /**
       *  Resolves to the transaction to deploy the contract, passing %%args%%
       *  into the constructor.
       */
    }, {
      key: "getDeployTransaction",
      value: (function () {
        var _getDeployTransaction = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
          var overrides,
            fragment,
            _len,
            args,
            _key,
            resolvedArgs,
            data,
            _args = arguments;
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                overrides = {};
                fragment = this["interface"].deploy;
                for (_len = _args.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = _args[_key];
                }
                if (!(fragment.inputs.length + 1 === args.length)) {
                  _context.next = 7;
                  break;
                }
                _context.next = 6;
                return (0, contract_js_1.copyOverrides)(args.pop());
              case 6:
                overrides = _context.sent;
              case 7:
                if (!(fragment.inputs.length !== args.length)) {
                  _context.next = 9;
                  break;
                }
                throw new Error("incorrect number of arguments to constructor");
              case 9:
                _context.next = 11;
                return (0, contract_js_1.resolveArgs)(this.runner, fragment.inputs, args);
              case 11:
                resolvedArgs = _context.sent;
                data = (0, index_js_3.concat)([this.bytecode, this["interface"].encodeDeploy(resolvedArgs)]);
                return _context.abrupt("return", Object.assign({}, overrides, {
                  data: data
                }));
              case 14:
              case "end":
                return _context.stop();
            }
          }, _callee, this);
        }));
        function getDeployTransaction() {
          return _getDeployTransaction.apply(this, arguments);
        }
        return getDeployTransaction;
      }()
      /**
       *  Resolves to the Contract deployed by passing %%args%% into the
       *  constructor.
       *
       *  This will resolve to the Contract before it has been deployed to the
       *  network, so the [[BaseContract-waitForDeployment]] should be used before
       *  sending any transactions to it.
       */
      )
    }, {
      key: "deploy",
      value: (function () {
        var _deploy = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
          var tx,
            sentTx,
            address,
            _args2 = arguments;
          return _regeneratorRuntime().wrap(function _callee2$(_context2) {
            while (1) switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.getDeployTransaction.apply(this, _args2);
              case 2:
                tx = _context2.sent;
                (0, index_js_3.assert)(this.runner && typeof this.runner.sendTransaction === "function", "factory runner does not support sending transactions", "UNSUPPORTED_OPERATION", {
                  operation: "sendTransaction"
                });
                _context2.next = 6;
                return this.runner.sendTransaction(tx);
              case 6:
                sentTx = _context2.sent;
                address = (0, index_js_2.getCreateAddress)(sentTx);
                return _context2.abrupt("return", new contract_js_1.BaseContract(address, this["interface"], this.runner, sentTx));
              case 9:
              case "end":
                return _context2.stop();
            }
          }, _callee2, this);
        }));
        function deploy() {
          return _deploy.apply(this, arguments);
        }
        return deploy;
      }()
      /**
       *  Return a new **ContractFactory** with the same ABI and bytecode,
       *  but connected to %%runner%%.
       */
      )
    }, {
      key: "connect",
      value: function connect(runner) {
        return new ContractFactory(this["interface"], this.bytecode, runner);
      }
      /**
       *  Create a new **ContractFactory** from the standard Solidity JSON output.
       */
    }], [{
      key: "fromSolidity",
      value: function fromSolidity(output, runner) {
        (0, index_js_3.assertArgument)(output != null, "bad compiler output", "output", output);
        if (typeof output === "string") {
          output = JSON.parse(output);
        }
        var abi = output.abi;
        var bytecode = "";
        if (output.bytecode) {
          bytecode = output.bytecode;
        } else if (output.evm && output.evm.bytecode) {
          bytecode = output.evm.bytecode;
        }
        return new this(abi, bytecode, runner);
      }
    }]);
  }();
  factory.ContractFactory = ContractFactory;
  return factory;
}

var hasRequiredContract;
function requireContract() {
  if (hasRequiredContract) return contract$1;
  hasRequiredContract = 1;
  (function (exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.UndecodedEventLog = exports.EventLog = exports.ContractTransactionResponse = exports.ContractTransactionReceipt = exports.ContractUnknownEventPayload = exports.ContractEventPayload = exports.ContractFactory = exports.Contract = exports.BaseContract = void 0;
    /**
     *  A **Contract** object is a meta-class (a class whose definition is
     *  defined at runtime), which communicates with a deployed smart contract
     *  on the blockchain and provides a simple JavaScript interface to call
     *  methods, send transaction, query historic logs and listen for its events.
     *
     *  @_section: api/contract:Contracts  [about-contracts]
     */
    var contract_js_1 = /*@__PURE__*/requireContract$1();
    Object.defineProperty(exports, "BaseContract", {
      enumerable: true,
      get: function get() {
        return contract_js_1.BaseContract;
      }
    });
    Object.defineProperty(exports, "Contract", {
      enumerable: true,
      get: function get() {
        return contract_js_1.Contract;
      }
    });
    var factory_js_1 = /*@__PURE__*/requireFactory();
    Object.defineProperty(exports, "ContractFactory", {
      enumerable: true,
      get: function get() {
        return factory_js_1.ContractFactory;
      }
    });
    var wrappers_js_1 = /*@__PURE__*/requireWrappers();
    Object.defineProperty(exports, "ContractEventPayload", {
      enumerable: true,
      get: function get() {
        return wrappers_js_1.ContractEventPayload;
      }
    });
    Object.defineProperty(exports, "ContractUnknownEventPayload", {
      enumerable: true,
      get: function get() {
        return wrappers_js_1.ContractUnknownEventPayload;
      }
    });
    Object.defineProperty(exports, "ContractTransactionReceipt", {
      enumerable: true,
      get: function get() {
        return wrappers_js_1.ContractTransactionReceipt;
      }
    });
    Object.defineProperty(exports, "ContractTransactionResponse", {
      enumerable: true,
      get: function get() {
        return wrappers_js_1.ContractTransactionResponse;
      }
    });
    Object.defineProperty(exports, "EventLog", {
      enumerable: true,
      get: function get() {
        return wrappers_js_1.EventLog;
      }
    });
    Object.defineProperty(exports, "UndecodedEventLog", {
      enumerable: true,
      get: function get() {
        return wrappers_js_1.UndecodedEventLog;
      }
    });
  })(contract$1);
  return contract$1;
}

var providers = {};

var abstractProvider = {};

var ensResolver = {};

var hasRequiredEnsResolver;
function requireEnsResolver() {
  var _EnsResolver;
  if (hasRequiredEnsResolver) return ensResolver;
  hasRequiredEnsResolver = 1;
  /**
   *  ENS is a service which allows easy-to-remember names to map to
   *  network addresses.
   *
   *  @_section: api/providers/ens-resolver:ENS Resolver  [about-ens-rsolver]
   */
  Object.defineProperty(ensResolver, "__esModule", {
    value: true
  });
  ensResolver.EnsResolver = ensResolver.BasicMulticoinProviderPlugin = ensResolver.MulticoinProviderPlugin = void 0;
  var index_js_1 = /*@__PURE__*/requireAddress$2();
  var index_js_2 = /*@__PURE__*/requireConstants$1();
  var index_js_3 = /*@__PURE__*/requireContract();
  var index_js_4 = /*@__PURE__*/requireHash();
  var index_js_5 = /*@__PURE__*/requireUtils$3();
  // @TODO: This should use the fetch-data:ipfs gateway
  // Trim off the ipfs:// prefix and return the default gateway URL
  function getIpfsLink(link) {
    if (link.match(/^ipfs:\/\/ipfs\//i)) {
      link = link.substring(12);
    } else if (link.match(/^ipfs:\/\//i)) {
      link = link.substring(7);
    } else {
      (0, index_js_5.assertArgument)(false, "unsupported IPFS format", "link", link);
    }
    return "https://gateway.ipfs.io/ipfs/".concat(link);
  }
  /**
   *  A provider plugin super-class for processing multicoin address types.
   */
  var MulticoinProviderPlugin = /*#__PURE__*/function () {
    /**
     *  Creates a new **MulticoinProviderPluing** for %%name%%.
     */
    function MulticoinProviderPlugin(name) {
      _classCallCheck(this, MulticoinProviderPlugin);
      /**
       *  The name.
       */
      _defineProperty(this, "name", void 0);
      (0, index_js_5.defineProperties)(this, {
        name: name
      });
    }
    return _createClass(MulticoinProviderPlugin, [{
      key: "connect",
      value: function connect(proivder) {
        return this;
      }
      /**
       *  Returns ``true`` if %%coinType%% is supported by this plugin.
       */
    }, {
      key: "supportsCoinType",
      value: function supportsCoinType(coinType) {
        return false;
      }
      /**
       *  Resolves to the encoded %%address%% for %%coinType%%.
       */
    }, {
      key: "encodeAddress",
      value: (function () {
        var _encodeAddress = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(coinType, address) {
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                throw new Error("unsupported coin");
              case 1:
              case "end":
                return _context.stop();
            }
          }, _callee);
        }));
        function encodeAddress(_x, _x2) {
          return _encodeAddress.apply(this, arguments);
        }
        return encodeAddress;
      }()
      /**
       *  Resolves to the decoded %%data%% for %%coinType%%.
       */
      )
    }, {
      key: "decodeAddress",
      value: (function () {
        var _decodeAddress = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(coinType, data) {
          return _regeneratorRuntime().wrap(function _callee2$(_context2) {
            while (1) switch (_context2.prev = _context2.next) {
              case 0:
                throw new Error("unsupported coin");
              case 1:
              case "end":
                return _context2.stop();
            }
          }, _callee2);
        }));
        function decodeAddress(_x3, _x4) {
          return _decodeAddress.apply(this, arguments);
        }
        return decodeAddress;
      }())
    }]);
  }();
  ensResolver.MulticoinProviderPlugin = MulticoinProviderPlugin;
  var BasicMulticoinPluginId = "org.ethers.plugins.provider.BasicMulticoin";
  /**
   *  A **BasicMulticoinProviderPlugin** provides service for common
   *  coin types, which do not require additional libraries to encode or
   *  decode.
   */
  var BasicMulticoinProviderPlugin = /*#__PURE__*/function (_MulticoinProviderPlu) {
    /**
     *  Creates a new **BasicMulticoinProviderPlugin**.
     */
    function BasicMulticoinProviderPlugin() {
      _classCallCheck(this, BasicMulticoinProviderPlugin);
      return _callSuper(this, BasicMulticoinProviderPlugin, [BasicMulticoinPluginId]);
    }
    _inherits(BasicMulticoinProviderPlugin, _MulticoinProviderPlu);
    return _createClass(BasicMulticoinProviderPlugin);
  }(MulticoinProviderPlugin);
  ensResolver.BasicMulticoinProviderPlugin = BasicMulticoinProviderPlugin;
  var matcherIpfs = new RegExp("^(ipfs):/\/(.*)$", "i");
  var matchers = [new RegExp("^(https):/\/(.*)$", "i"), new RegExp("^(data):(.*)$", "i"), matcherIpfs, new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")];
  /**
   *  A connected object to a resolved ENS name resolver, which can be
   *  used to query additional details.
   */
  var _supports = /*#__PURE__*/new WeakMap();
  var _resolver = /*#__PURE__*/new WeakMap();
  var _EnsResolver_brand = /*#__PURE__*/new WeakSet();
  var EnsResolver = /*#__PURE__*/function () {
    function EnsResolver(provider, address, name) {
      _classCallCheck(this, EnsResolver);
      _classPrivateMethodInitSpec(this, _EnsResolver_brand);
      /**
       *  The connected provider.
       */
      _defineProperty(this, "provider", void 0);
      /**
       *  The address of the resolver.
       */
      _defineProperty(this, "address", void 0);
      /**
       *  The name this resolver was resolved against.
       */
      _defineProperty(this, "name", void 0);
      // For EIP-2544 names, the ancestor that provided the resolver
      _classPrivateFieldInitSpec(this, _supports, void 0);
      _classPrivateFieldInitSpec(this, _resolver, void 0);
      (0, index_js_5.defineProperties)(this, {
        provider: provider,
        address: address,
        name: name
      });
      _classPrivateFieldSet2(_supports, this, null);
      _classPrivateFieldSet2(_resolver, this, new index_js_3.Contract(address, ["function supportsInterface(bytes4) view returns (bool)", "function resolve(bytes, bytes) view returns (bytes)", "function addr(bytes32) view returns (address)", "function addr(bytes32, uint) view returns (bytes)", "function text(bytes32, string) view returns (string)", "function contenthash(bytes32) view returns (bytes)"], provider));
    }
    /**
     *  Resolves to true if the resolver supports wildcard resolution.
     */
    return _createClass(EnsResolver, [{
      key: "supportsWildcard",
      value: (function () {
        var _supportsWildcard = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
          var _this = this;
          return _regeneratorRuntime().wrap(function _callee4$(_context4) {
            while (1) switch (_context4.prev = _context4.next) {
              case 0:
                if (_classPrivateFieldGet2(_supports, this) == null) {
                  _classPrivateFieldSet2(_supports, this, _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
                    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
                      while (1) switch (_context3.prev = _context3.next) {
                        case 0:
                          _context3.prev = 0;
                          _context3.next = 3;
                          return _classPrivateFieldGet2(_resolver, _this).supportsInterface("0x9061b923");
                        case 3:
                          return _context3.abrupt("return", _context3.sent);
                        case 6:
                          _context3.prev = 6;
                          _context3.t0 = _context3["catch"](0);
                          if (!(0, index_js_5.isError)(_context3.t0, "CALL_EXCEPTION")) {
                            _context3.next = 10;
                            break;
                          }
                          return _context3.abrupt("return", false);
                        case 10:
                          // Let future attempts try again...
                          _classPrivateFieldSet2(_supports, _this, null);
                          throw _context3.t0;
                        case 12:
                        case "end":
                          return _context3.stop();
                      }
                    }, _callee3, null, [[0, 6]]);
                  }))());
                }
                _context4.next = 3;
                return _classPrivateFieldGet2(_supports, this);
              case 3:
                return _context4.abrupt("return", _context4.sent);
              case 4:
              case "end":
                return _context4.stop();
            }
          }, _callee4, this);
        }));
        function supportsWildcard() {
          return _supportsWildcard.apply(this, arguments);
        }
        return supportsWildcard;
      }())
    }, {
      key: "getAddress",
      value: (
      /**
       *  Resolves to the address for %%coinType%% or null if the
       *  provided %%coinType%% has not been configured.
       */
      function () {
        var _getAddress = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee5(coinType) {
          var result, ethCoinType, _data, coinPlugin, _iterator, _step, plugin, data, address;
          return _regeneratorRuntime().wrap(function _callee5$(_context5) {
            while (1) switch (_context5.prev = _context5.next) {
              case 0:
                if (coinType == null) {
                  coinType = 60;
                }
                if (!(coinType === 60)) {
                  _context5.next = 16;
                  break;
                }
                _context5.prev = 2;
                _context5.next = 5;
                return _assertClassBrand(_EnsResolver_brand, this, _fetch).call(this, "addr(bytes32)");
              case 5:
                result = _context5.sent;
                if (!(result == null || result === index_js_2.ZeroAddress)) {
                  _context5.next = 8;
                  break;
                }
                return _context5.abrupt("return", null);
              case 8:
                return _context5.abrupt("return", result);
              case 11:
                _context5.prev = 11;
                _context5.t0 = _context5["catch"](2);
                if (!(0, index_js_5.isError)(_context5.t0, "CALL_EXCEPTION")) {
                  _context5.next = 15;
                  break;
                }
                return _context5.abrupt("return", null);
              case 15:
                throw _context5.t0;
              case 16:
                if (!(coinType >= 0 && coinType < 0x80000000)) {
                  _context5.next = 23;
                  break;
                }
                ethCoinType = coinType + 0x80000000;
                _context5.next = 20;
                return _assertClassBrand(_EnsResolver_brand, this, _fetch).call(this, "addr(bytes32,uint)", [ethCoinType]);
              case 20:
                _data = _context5.sent;
                if (!(0, index_js_5.isHexString)(_data, 20)) {
                  _context5.next = 23;
                  break;
                }
                return _context5.abrupt("return", (0, index_js_1.getAddress)(_data));
              case 23:
                coinPlugin = null;
                _iterator = _createForOfIteratorHelper(this.provider.plugins);
                _context5.prev = 25;
                _iterator.s();
              case 27:
                if ((_step = _iterator.n()).done) {
                  _context5.next = 36;
                  break;
                }
                plugin = _step.value;
                if (plugin instanceof MulticoinProviderPlugin) {
                  _context5.next = 31;
                  break;
                }
                return _context5.abrupt("continue", 34);
              case 31:
                if (!plugin.supportsCoinType(coinType)) {
                  _context5.next = 34;
                  break;
                }
                coinPlugin = plugin;
                return _context5.abrupt("break", 36);
              case 34:
                _context5.next = 27;
                break;
              case 36:
                _context5.next = 41;
                break;
              case 38:
                _context5.prev = 38;
                _context5.t1 = _context5["catch"](25);
                _iterator.e(_context5.t1);
              case 41:
                _context5.prev = 41;
                _iterator.f();
                return _context5.finish(41);
              case 44:
                if (!(coinPlugin == null)) {
                  _context5.next = 46;
                  break;
                }
                return _context5.abrupt("return", null);
              case 46:
                _context5.next = 48;
                return _assertClassBrand(_EnsResolver_brand, this, _fetch).call(this, "addr(bytes32,uint)", [coinType]);
              case 48:
                data = _context5.sent;
                if (!(data == null || data === "0x")) {
                  _context5.next = 51;
                  break;
                }
                return _context5.abrupt("return", null);
              case 51:
                _context5.next = 53;
                return coinPlugin.decodeAddress(coinType, data);
              case 53:
                address = _context5.sent;
                if (!(address != null)) {
                  _context5.next = 56;
                  break;
                }
                return _context5.abrupt("return", address);
              case 56:
                (0, index_js_5.assert)(false, "invalid coin data", "UNSUPPORTED_OPERATION", {
                  operation: "getAddress(".concat(coinType, ")"),
                  info: {
                    coinType: coinType,
                    data: data
                  }
                });
              case 57:
              case "end":
                return _context5.stop();
            }
          }, _callee5, this, [[2, 11], [25, 38, 41, 44]]);
        }));
        function getAddress(_x5) {
          return _getAddress.apply(this, arguments);
        }
        return getAddress;
      }()
      /**
       *  Resolves to the EIP-634 text record for %%key%%, or ``null``
       *  if unconfigured.
       */
      )
    }, {
      key: "getText",
      value: (function () {
        var _getText = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee6(key) {
          var data;
          return _regeneratorRuntime().wrap(function _callee6$(_context6) {
            while (1) switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return _assertClassBrand(_EnsResolver_brand, this, _fetch).call(this, "text(bytes32,string)", [key]);
              case 2:
                data = _context6.sent;
                if (!(data == null || data === "0x")) {
                  _context6.next = 5;
                  break;
                }
                return _context6.abrupt("return", null);
              case 5:
                return _context6.abrupt("return", data);
              case 6:
              case "end":
                return _context6.stop();
            }
          }, _callee6, this);
        }));
        function getText(_x6) {
          return _getText.apply(this, arguments);
        }
        return getText;
      }()
      /**
       *  Rsolves to the content-hash or ``null`` if unconfigured.
       */
      )
    }, {
      key: "getContentHash",
      value: (function () {
        var _getContentHash = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {
          var data, ipfs, scheme, length, swarm;
          return _regeneratorRuntime().wrap(function _callee7$(_context7) {
            while (1) switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return _assertClassBrand(_EnsResolver_brand, this, _fetch).call(this, "contenthash(bytes32)");
              case 2:
                data = _context7.sent;
                if (!(data == null || data === "0x")) {
                  _context7.next = 5;
                  break;
                }
                return _context7.abrupt("return", null);
              case 5:
                // IPFS (CID: 1, Type: 70=DAG-PB, 72=libp2p-key)
                ipfs = data.match(/^0x(e3010170|e5010172)(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
                if (!ipfs) {
                  _context7.next = 11;
                  break;
                }
                scheme = ipfs[1] === "e3010170" ? "ipfs" : "ipns";
                length = parseInt(ipfs[4], 16);
                if (!(ipfs[5].length === length * 2)) {
                  _context7.next = 11;
                  break;
                }
                return _context7.abrupt("return", "".concat(scheme, "://").concat((0, index_js_5.encodeBase58)("0x" + ipfs[2])));
              case 11:
                // Swarm (CID: 1, Type: swarm-manifest; hash/length hard-coded to keccak256/32)
                swarm = data.match(/^0xe40101fa011b20([0-9a-f]*)$/);
                if (!(swarm && swarm[1].length === 64)) {
                  _context7.next = 14;
                  break;
                }
                return _context7.abrupt("return", "bzz://".concat(swarm[1]));
              case 14:
                (0, index_js_5.assert)(false, "invalid or unsupported content hash data", "UNSUPPORTED_OPERATION", {
                  operation: "getContentHash()",
                  info: {
                    data: data
                  }
                });
              case 15:
              case "end":
                return _context7.stop();
            }
          }, _callee7, this);
        }));
        function getContentHash() {
          return _getContentHash.apply(this, arguments);
        }
        return getContentHash;
      }()
      /**
       *  Resolves to the avatar url or ``null`` if the avatar is either
       *  unconfigured or incorrectly configured (e.g. references an NFT
       *  not owned by the address).
       *
       *  If diagnosing issues with configurations, the [[_getAvatar]]
       *  method may be useful.
       */
      )
    }, {
      key: "getAvatar",
      value: (function () {
        var _getAvatar2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {
          var avatar;
          return _regeneratorRuntime().wrap(function _callee8$(_context8) {
            while (1) switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return this._getAvatar();
              case 2:
                avatar = _context8.sent;
                return _context8.abrupt("return", avatar.url);
              case 4:
              case "end":
                return _context8.stop();
            }
          }, _callee8, this);
        }));
        function getAvatar() {
          return _getAvatar2.apply(this, arguments);
        }
        return getAvatar;
      }()
      /**
       *  When resolving an avatar, there are many steps involved, such
       *  fetching metadata and possibly validating ownership of an
       *  NFT.
       *
       *  This method can be used to examine each step and the value it
       *  was working from.
       */
      )
    }, {
      key: "_getAvatar",
      value: (function () {
        var _getAvatar3 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {
          var linkage, avatar, i, match, scheme, url, selector, owner, comps, tokenId, contract, tokenOwner, balance, metadataUrl, metadata, response, bytes, imageUrl, ipfs;
          return _regeneratorRuntime().wrap(function _callee9$(_context9) {
            while (1) switch (_context9.prev = _context9.next) {
              case 0:
                linkage = [{
                  type: "name",
                  value: this.name
                }];
                _context9.prev = 1;
                _context9.next = 4;
                return this.getText("avatar");
              case 4:
                avatar = _context9.sent;
                if (!(avatar == null)) {
                  _context9.next = 8;
                  break;
                }
                linkage.push({
                  type: "!avatar",
                  value: ""
                });
                return _context9.abrupt("return", {
                  url: null,
                  linkage: linkage
                });
              case 8:
                linkage.push({
                  type: "avatar",
                  value: avatar
                });
                i = 0;
              case 10:
                if (!(i < matchers.length)) {
                  _context9.next = 109;
                  break;
                }
                match = avatar.match(matchers[i]);
                if (!(match == null)) {
                  _context9.next = 14;
                  break;
                }
                return _context9.abrupt("continue", 106);
              case 14:
                scheme = match[1].toLowerCase();
                _context9.t0 = scheme;
                _context9.next = _context9.t0 === "https" ? 18 : _context9.t0 === "data" ? 18 : _context9.t0 === "ipfs" ? 20 : _context9.t0 === "erc721" ? 24 : _context9.t0 === "erc1155" ? 24 : 106;
                break;
              case 18:
                linkage.push({
                  type: "url",
                  value: avatar
                });
                return _context9.abrupt("return", {
                  linkage: linkage,
                  url: avatar
                });
              case 20:
                url = getIpfsLink(avatar);
                linkage.push({
                  type: "ipfs",
                  value: avatar
                });
                linkage.push({
                  type: "url",
                  value: url
                });
                return _context9.abrupt("return", {
                  linkage: linkage,
                  url: url
                });
              case 24:
                // Depending on the ERC type, use tokenURI(uint256) or url(uint256)
                selector = scheme === "erc721" ? "tokenURI(uint256)" : "uri(uint256)";
                linkage.push({
                  type: scheme,
                  value: avatar
                });
                // The owner of this name
                _context9.next = 28;
                return this.getAddress();
              case 28:
                owner = _context9.sent;
                if (!(owner == null)) {
                  _context9.next = 32;
                  break;
                }
                linkage.push({
                  type: "!owner",
                  value: ""
                });
                return _context9.abrupt("return", {
                  url: null,
                  linkage: linkage
                });
              case 32:
                comps = (match[2] || "").split("/");
                if (!(comps.length !== 2)) {
                  _context9.next = 36;
                  break;
                }
                linkage.push({
                  type: "!".concat(scheme, "caip"),
                  value: match[2] || ""
                });
                return _context9.abrupt("return", {
                  url: null,
                  linkage: linkage
                });
              case 36:
                tokenId = comps[1];
                contract = new index_js_3.Contract(comps[0], [
                // ERC-721
                "function tokenURI(uint) view returns (string)", "function ownerOf(uint) view returns (address)",
                // ERC-1155
                "function uri(uint) view returns (string)", "function balanceOf(address, uint256) view returns (uint)"], this.provider); // Check that this account owns the token
                if (!(scheme === "erc721")) {
                  _context9.next = 48;
                  break;
                }
                _context9.next = 41;
                return contract.ownerOf(tokenId);
              case 41:
                tokenOwner = _context9.sent;
                if (!(owner !== tokenOwner)) {
                  _context9.next = 45;
                  break;
                }
                linkage.push({
                  type: "!owner",
                  value: tokenOwner
                });
                return _context9.abrupt("return", {
                  url: null,
                  linkage: linkage
                });
              case 45:
                linkage.push({
                  type: "owner",
                  value: tokenOwner
                });
                _context9.next = 56;
                break;
              case 48:
                if (!(scheme === "erc1155")) {
                  _context9.next = 56;
                  break;
                }
                _context9.next = 51;
                return contract.balanceOf(owner, tokenId);
              case 51:
                balance = _context9.sent;
                if (balance) {
                  _context9.next = 55;
                  break;
                }
                linkage.push({
                  type: "!balance",
                  value: "0"
                });
                return _context9.abrupt("return", {
                  url: null,
                  linkage: linkage
                });
              case 55:
                linkage.push({
                  type: "balance",
                  value: balance.toString()
                });
              case 56:
                _context9.next = 58;
                return contract[selector](tokenId);
              case 58:
                metadataUrl = _context9.sent;
                if (!(metadataUrl == null || metadataUrl === "0x")) {
                  _context9.next = 62;
                  break;
                }
                linkage.push({
                  type: "!metadata-url",
                  value: ""
                });
                return _context9.abrupt("return", {
                  url: null,
                  linkage: linkage
                });
              case 62:
                linkage.push({
                  type: "metadata-url-base",
                  value: metadataUrl
                });
                // ERC-1155 allows a generic {id} in the URL
                if (scheme === "erc1155") {
                  metadataUrl = metadataUrl.replace("{id}", (0, index_js_5.toBeHex)(tokenId, 32).substring(2));
                  linkage.push({
                    type: "metadata-url-expanded",
                    value: metadataUrl
                  });
                }
                // Transform IPFS metadata links
                if (metadataUrl.match(/^ipfs:/i)) {
                  metadataUrl = getIpfsLink(metadataUrl);
                }
                linkage.push({
                  type: "metadata-url",
                  value: metadataUrl
                });
                // Get the token metadata
                metadata = {};
                _context9.next = 69;
                return new index_js_5.FetchRequest(metadataUrl).send();
              case 69:
                response = _context9.sent;
                response.assertOk();
                _context9.prev = 71;
                metadata = response.bodyJson;
                _context9.next = 87;
                break;
              case 75:
                _context9.prev = 75;
                _context9.t1 = _context9["catch"](71);
                _context9.prev = 77;
                linkage.push({
                  type: "!metadata",
                  value: response.bodyText
                });
                _context9.next = 86;
                break;
              case 81:
                _context9.prev = 81;
                _context9.t2 = _context9["catch"](77);
                bytes = response.body;
                if (bytes) {
                  linkage.push({
                    type: "!metadata",
                    value: (0, index_js_5.hexlify)(bytes)
                  });
                }
                return _context9.abrupt("return", {
                  url: null,
                  linkage: linkage
                });
              case 86:
                return _context9.abrupt("return", {
                  url: null,
                  linkage: linkage
                });
              case 87:
                if (metadata) {
                  _context9.next = 90;
                  break;
                }
                linkage.push({
                  type: "!metadata",
                  value: ""
                });
                return _context9.abrupt("return", {
                  url: null,
                  linkage: linkage
                });
              case 90:
                linkage.push({
                  type: "metadata",
                  value: JSON.stringify(metadata)
                });
                // Pull the image URL out
                imageUrl = metadata.image;
                if (!(typeof imageUrl !== "string")) {
                  _context9.next = 95;
                  break;
                }
                linkage.push({
                  type: "!imageUrl",
                  value: ""
                });
                return _context9.abrupt("return", {
                  url: null,
                  linkage: linkage
                });
              case 95:
                if (!imageUrl.match(/^(https:\/\/|data:)/i)) {
                  _context9.next = 98;
                  break;
                }
                _context9.next = 104;
                break;
              case 98:
                // Transform IPFS link to gateway
                ipfs = imageUrl.match(matcherIpfs);
                if (!(ipfs == null)) {
                  _context9.next = 102;
                  break;
                }
                linkage.push({
                  type: "!imageUrl-ipfs",
                  value: imageUrl
                });
                return _context9.abrupt("return", {
                  url: null,
                  linkage: linkage
                });
              case 102:
                linkage.push({
                  type: "imageUrl-ipfs",
                  value: imageUrl
                });
                imageUrl = getIpfsLink(imageUrl);
              case 104:
                linkage.push({
                  type: "url",
                  value: imageUrl
                });
                return _context9.abrupt("return", {
                  linkage: linkage,
                  url: imageUrl
                });
              case 106:
                i++;
                _context9.next = 10;
                break;
              case 109:
                _context9.next = 113;
                break;
              case 111:
                _context9.prev = 111;
                _context9.t3 = _context9["catch"](1);
              case 113:
                return _context9.abrupt("return", {
                  linkage: linkage,
                  url: null
                });
              case 114:
              case "end":
                return _context9.stop();
            }
          }, _callee9, this, [[1, 111], [71, 75], [77, 81]]);
        }));
        function _getAvatar() {
          return _getAvatar3.apply(this, arguments);
        }
        return _getAvatar;
      }())
    }], [{
      key: "getEnsAddress",
      value: function () {
        var _getEnsAddress = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee10(provider) {
          var network, ensPlugin;
          return _regeneratorRuntime().wrap(function _callee10$(_context10) {
            while (1) switch (_context10.prev = _context10.next) {
              case 0:
                _context10.next = 2;
                return provider.getNetwork();
              case 2:
                network = _context10.sent;
                ensPlugin = network.getPlugin("org.ethers.plugins.network.Ens"); // No ENS...
                (0, index_js_5.assert)(ensPlugin, "network does not support ENS", "UNSUPPORTED_OPERATION", {
                  operation: "getEnsAddress",
                  info: {
                    network: network
                  }
                });
                return _context10.abrupt("return", ensPlugin.address);
              case 6:
              case "end":
                return _context10.stop();
            }
          }, _callee10);
        }));
        function getEnsAddress(_x7) {
          return _getEnsAddress.apply(this, arguments);
        }
        return getEnsAddress;
      }()
    }, {
      key: "fromName",
      value: (
      /**
       *  Resolve to the ENS resolver for %%name%% using %%provider%% or
       *  ``null`` if unconfigured.
       */
      function () {
        var _fromName = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee11(provider, name) {
          var currentName, addr, resolver;
          return _regeneratorRuntime().wrap(function _callee11$(_context11) {
            while (1) switch (_context11.prev = _context11.next) {
              case 0:
                currentName = name;
              case 1:
                if (!(currentName === "" || currentName === ".")) {
                  _context11.next = 4;
                  break;
                }
                return _context11.abrupt("return", null);
              case 4:
                if (!(name !== "eth" && currentName === "eth")) {
                  _context11.next = 6;
                  break;
                }
                return _context11.abrupt("return", null);
              case 6:
                _context11.next = 8;
                return _getResolver.call(EnsResolver, provider, currentName);
              case 8:
                addr = _context11.sent;
                if (!(addr != null)) {
                  _context11.next = 19;
                  break;
                }
                resolver = new EnsResolver(provider, addr, name); // Legacy resolver found, using EIP-2544 so it isn't safe to use
                _context11.t0 = currentName !== name;
                if (!_context11.t0) {
                  _context11.next = 16;
                  break;
                }
                _context11.next = 15;
                return resolver.supportsWildcard();
              case 15:
                _context11.t0 = !_context11.sent;
              case 16:
                if (!_context11.t0) {
                  _context11.next = 18;
                  break;
                }
                return _context11.abrupt("return", null);
              case 18:
                return _context11.abrupt("return", resolver);
              case 19:
                // Get the parent node
                currentName = currentName.split(".").slice(1).join(".");
                _context11.next = 1;
                break;
              case 22:
              case "end":
                return _context11.stop();
            }
          }, _callee11);
        }));
        function fromName(_x8, _x9) {
          return _fromName.apply(this, arguments);
        }
        return fromName;
      }())
    }]);
  }();
  _EnsResolver = EnsResolver;
  function _fetch(_x10, _x11) {
    return _fetch2.apply(this, arguments);
  }
  function _fetch2() {
    _fetch2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee12(funcName, params) {
      var iface, fragment, _classPrivateFieldGet2$1, result;
      return _regeneratorRuntime().wrap(function _callee12$(_context12) {
        while (1) switch (_context12.prev = _context12.next) {
          case 0:
            params = (params || []).slice();
            iface = _classPrivateFieldGet2(_resolver, this)["interface"]; // The first parameters is always the nodehash
            params.unshift((0, index_js_4.namehash)(this.name));
            fragment = null;
            _context12.next = 6;
            return this.supportsWildcard();
          case 6:
            if (!_context12.sent) {
              _context12.next = 11;
              break;
            }
            fragment = iface.getFunction(funcName);
            (0, index_js_5.assert)(fragment, "missing fragment", "UNKNOWN_ERROR", {
              info: {
                funcName: funcName
              }
            });
            params = [(0, index_js_4.dnsEncode)(this.name, 255), iface.encodeFunctionData(fragment, params)];
            funcName = "resolve(bytes,bytes)";
          case 11:
            params.push({
              enableCcipRead: true
            });
            _context12.prev = 12;
            _context12.next = 15;
            return (_classPrivateFieldGet2$1 = _classPrivateFieldGet2(_resolver, this))[funcName].apply(_classPrivateFieldGet2$1, _toConsumableArray(params));
          case 15:
            result = _context12.sent;
            if (!fragment) {
              _context12.next = 18;
              break;
            }
            return _context12.abrupt("return", iface.decodeFunctionResult(fragment, result)[0]);
          case 18:
            return _context12.abrupt("return", result);
          case 21:
            _context12.prev = 21;
            _context12.t0 = _context12["catch"](12);
            if ((0, index_js_5.isError)(_context12.t0, "CALL_EXCEPTION")) {
              _context12.next = 25;
              break;
            }
            throw _context12.t0;
          case 25:
            return _context12.abrupt("return", null);
          case 26:
          case "end":
            return _context12.stop();
        }
      }, _callee12, this, [[12, 21]]);
    }));
    return _fetch2.apply(this, arguments);
  }
  function _getResolver(_x12, _x13) {
    return _getResolver3.apply(this, arguments);
  }
  function _getResolver3() {
    _getResolver3 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee13(provider, name) {
      var ensAddr, contract, addr;
      return _regeneratorRuntime().wrap(function _callee13$(_context13) {
        while (1) switch (_context13.prev = _context13.next) {
          case 0:
            _context13.next = 2;
            return _EnsResolver.getEnsAddress(provider);
          case 2:
            ensAddr = _context13.sent;
            _context13.prev = 3;
            contract = new index_js_3.Contract(ensAddr, ["function resolver(bytes32) view returns (address)"], provider);
            _context13.next = 7;
            return contract.resolver((0, index_js_4.namehash)(name), {
              enableCcipRead: true
            });
          case 7:
            addr = _context13.sent;
            if (!(addr === index_js_2.ZeroAddress)) {
              _context13.next = 10;
              break;
            }
            return _context13.abrupt("return", null);
          case 10:
            return _context13.abrupt("return", addr);
          case 13:
            _context13.prev = 13;
            _context13.t0 = _context13["catch"](3);
            throw _context13.t0;
          case 16:
            return _context13.abrupt("return", null);
          case 17:
          case "end":
            return _context13.stop();
        }
      }, _callee13, null, [[3, 13]]);
    }));
    return _getResolver3.apply(this, arguments);
  }
  ensResolver.EnsResolver = EnsResolver;
  return ensResolver;
}

var format = {};

var hasRequiredFormat;
function requireFormat() {
  if (hasRequiredFormat) return format;
  hasRequiredFormat = 1;
  Object.defineProperty(format, "__esModule", {
    value: true
  });
  format.formatTransactionResponse = format.formatTransactionReceipt = format.formatReceiptLog = format.formatBlock = format.formatLog = format.formatUint256 = format.formatHash = format.formatData = format.formatBoolean = format.object = format.arrayOf = format.allowNull = void 0;
  /**
   *  @_ignore
   */
  var index_js_1 = /*@__PURE__*/requireAddress$2();
  var index_js_2 = /*@__PURE__*/requireCrypto();
  var index_js_3 = /*@__PURE__*/requireTransaction();
  var index_js_4 = /*@__PURE__*/requireUtils$3();
  var BN_0 = BigInt(0);
  function allowNull(format, nullValue) {
    return function (value) {
      if (value == null) {
        return nullValue;
      }
      return format(value);
    };
  }
  format.allowNull = allowNull;
  function arrayOf(format, allowNull) {
    return function (array) {
      if (allowNull && array == null) {
        return null;
      }
      if (!Array.isArray(array)) {
        throw new Error("not an array");
      }
      return array.map(function (i) {
        return format(i);
      });
    };
  }
  format.arrayOf = arrayOf;
  // Requires an object which matches a fleet of other formatters
  // Any FormatFunc may return `undefined` to have the value omitted
  // from the result object. Calls preserve `this`.
  function object(format, altNames) {
    return function (value) {
      var result = {};
      for (var key in format) {
        var srcKey = key;
        if (altNames && key in altNames && !(srcKey in value)) {
          var _iterator = _createForOfIteratorHelper(altNames[key]),
            _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var altKey = _step.value;
              if (altKey in value) {
                srcKey = altKey;
                break;
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }
        try {
          var nv = format[key](value[srcKey]);
          if (nv !== undefined) {
            result[key] = nv;
          }
        } catch (error) {
          var message = error instanceof Error ? error.message : "not-an-error";
          (0, index_js_4.assert)(false, "invalid value for value.".concat(key, " (").concat(message, ")"), "BAD_DATA", {
            value: value
          });
        }
      }
      return result;
    };
  }
  format.object = object;
  function formatBoolean(value) {
    switch (value) {
      case true:
      case "true":
        return true;
      case false:
      case "false":
        return false;
    }
    (0, index_js_4.assertArgument)(false, "invalid boolean; ".concat(JSON.stringify(value)), "value", value);
  }
  format.formatBoolean = formatBoolean;
  function formatData(value) {
    (0, index_js_4.assertArgument)((0, index_js_4.isHexString)(value, true), "invalid data", "value", value);
    return value;
  }
  format.formatData = formatData;
  function formatHash(value) {
    (0, index_js_4.assertArgument)((0, index_js_4.isHexString)(value, 32), "invalid hash", "value", value);
    return value;
  }
  format.formatHash = formatHash;
  function formatUint256(value) {
    if (!(0, index_js_4.isHexString)(value)) {
      throw new Error("invalid uint256");
    }
    return (0, index_js_4.zeroPadValue)(value, 32);
  }
  format.formatUint256 = formatUint256;
  var _formatLog = object({
    address: index_js_1.getAddress,
    blockHash: formatHash,
    blockNumber: index_js_4.getNumber,
    data: formatData,
    index: index_js_4.getNumber,
    removed: allowNull(formatBoolean, false),
    topics: arrayOf(formatHash),
    transactionHash: formatHash,
    transactionIndex: index_js_4.getNumber
  }, {
    index: ["logIndex"]
  });
  function formatLog(value) {
    return _formatLog(value);
  }
  format.formatLog = formatLog;
  var _formatBlock = object({
    hash: allowNull(formatHash),
    parentHash: formatHash,
    parentBeaconBlockRoot: allowNull(formatHash, null),
    number: index_js_4.getNumber,
    timestamp: index_js_4.getNumber,
    nonce: allowNull(formatData),
    difficulty: index_js_4.getBigInt,
    gasLimit: index_js_4.getBigInt,
    gasUsed: index_js_4.getBigInt,
    stateRoot: allowNull(formatHash, null),
    receiptsRoot: allowNull(formatHash, null),
    blobGasUsed: allowNull(index_js_4.getBigInt, null),
    excessBlobGas: allowNull(index_js_4.getBigInt, null),
    miner: allowNull(index_js_1.getAddress),
    prevRandao: allowNull(formatHash, null),
    extraData: formatData,
    baseFeePerGas: allowNull(index_js_4.getBigInt)
  }, {
    prevRandao: ["mixHash"]
  });
  function formatBlock(value) {
    var result = _formatBlock(value);
    result.transactions = value.transactions.map(function (tx) {
      if (typeof tx === "string") {
        return tx;
      }
      return formatTransactionResponse(tx);
    });
    return result;
  }
  format.formatBlock = formatBlock;
  var _formatReceiptLog = object({
    transactionIndex: index_js_4.getNumber,
    blockNumber: index_js_4.getNumber,
    transactionHash: formatHash,
    address: index_js_1.getAddress,
    topics: arrayOf(formatHash),
    data: formatData,
    index: index_js_4.getNumber,
    blockHash: formatHash
  }, {
    index: ["logIndex"]
  });
  function formatReceiptLog(value) {
    return _formatReceiptLog(value);
  }
  format.formatReceiptLog = formatReceiptLog;
  var _formatTransactionReceipt = object({
    to: allowNull(index_js_1.getAddress, null),
    from: allowNull(index_js_1.getAddress, null),
    contractAddress: allowNull(index_js_1.getAddress, null),
    // should be allowNull(hash), but broken-EIP-658 support is handled in receipt
    index: index_js_4.getNumber,
    root: allowNull(index_js_4.hexlify),
    gasUsed: index_js_4.getBigInt,
    blobGasUsed: allowNull(index_js_4.getBigInt, null),
    logsBloom: allowNull(formatData),
    blockHash: formatHash,
    hash: formatHash,
    logs: arrayOf(formatReceiptLog),
    blockNumber: index_js_4.getNumber,
    //confirmations: allowNull(getNumber, null),
    cumulativeGasUsed: index_js_4.getBigInt,
    effectiveGasPrice: allowNull(index_js_4.getBigInt),
    blobGasPrice: allowNull(index_js_4.getBigInt, null),
    status: allowNull(index_js_4.getNumber),
    type: allowNull(index_js_4.getNumber, 0)
  }, {
    effectiveGasPrice: ["gasPrice"],
    hash: ["transactionHash"],
    index: ["transactionIndex"]
  });
  function formatTransactionReceipt(value) {
    return _formatTransactionReceipt(value);
  }
  format.formatTransactionReceipt = formatTransactionReceipt;
  function formatTransactionResponse(value) {
    // Some clients (TestRPC) do strange things like return 0x0 for the
    // 0 address; correct this to be a real address
    if (value.to && (0, index_js_4.getBigInt)(value.to) === BN_0) {
      value.to = "0x0000000000000000000000000000000000000000";
    }
    var result = object({
      hash: formatHash,
      // Some nodes do not return this, usually test nodes (like Ganache)
      index: allowNull(index_js_4.getNumber, undefined),
      type: function type(value) {
        if (value === "0x" || value == null) {
          return 0;
        }
        return (0, index_js_4.getNumber)(value);
      },
      accessList: allowNull(index_js_3.accessListify, null),
      blobVersionedHashes: allowNull(arrayOf(formatHash, true), null),
      blockHash: allowNull(formatHash, null),
      blockNumber: allowNull(index_js_4.getNumber, null),
      transactionIndex: allowNull(index_js_4.getNumber, null),
      from: index_js_1.getAddress,
      // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas) must be set
      gasPrice: allowNull(index_js_4.getBigInt),
      maxPriorityFeePerGas: allowNull(index_js_4.getBigInt),
      maxFeePerGas: allowNull(index_js_4.getBigInt),
      maxFeePerBlobGas: allowNull(index_js_4.getBigInt, null),
      gasLimit: index_js_4.getBigInt,
      to: allowNull(index_js_1.getAddress, null),
      value: index_js_4.getBigInt,
      nonce: index_js_4.getNumber,
      data: formatData,
      creates: allowNull(index_js_1.getAddress, null),
      chainId: allowNull(index_js_4.getBigInt, null)
    }, {
      data: ["input"],
      gasLimit: ["gas"],
      index: ["transactionIndex"]
    })(value);
    // If to and creates are empty, populate the creates from the value
    if (result.to == null && result.creates == null) {
      result.creates = (0, index_js_1.getCreateAddress)(result);
    }
    // @TODO: Check fee data
    // Add an access list to supported transaction types
    if ((value.type === 1 || value.type === 2) && value.accessList == null) {
      result.accessList = [];
    }
    // Compute the signature
    if (value.signature) {
      result.signature = index_js_2.Signature.from(value.signature);
    } else {
      result.signature = index_js_2.Signature.from(value);
    }
    // Some backends omit ChainId on legacy transactions, but we can compute it
    if (result.chainId == null) {
      var chainId = result.signature.legacyChainId;
      if (chainId != null) {
        result.chainId = chainId;
      }
    }
    // @TODO: check chainID
    /*
    if (value.chainId != null) {
        let chainId = value.chainId;
         if (isHexString(chainId)) {
            chainId = BigNumber.from(chainId).toNumber();
        }
         result.chainId = chainId;
     } else {
        let chainId = value.networkId;
         // geth-etc returns chainId
        if (chainId == null && result.v == null) {
            chainId = value.chainId;
        }
         if (isHexString(chainId)) {
            chainId = BigNumber.from(chainId).toNumber();
        }
         if (typeof(chainId) !== "number" && result.v != null) {
            chainId = (result.v - 35) / 2;
            if (chainId < 0) { chainId = 0; }
            chainId = parseInt(chainId);
        }
         if (typeof(chainId) !== "number") { chainId = 0; }
         result.chainId = chainId;
    }
    */
    // 0x0000... should actually be null
    if (result.blockHash && (0, index_js_4.getBigInt)(result.blockHash) === BN_0) {
      result.blockHash = null;
    }
    return result;
  }
  format.formatTransactionResponse = formatTransactionResponse;
  return format;
}

var network = {};

var pluginsNetwork = {};

var hasRequiredPluginsNetwork;
function requirePluginsNetwork() {
  if (hasRequiredPluginsNetwork) return pluginsNetwork;
  hasRequiredPluginsNetwork = 1;
  Object.defineProperty(pluginsNetwork, "__esModule", {
    value: true
  });
  pluginsNetwork.FetchUrlFeeDataNetworkPlugin = pluginsNetwork.FeeDataNetworkPlugin = pluginsNetwork.EnsPlugin = pluginsNetwork.GasCostPlugin = pluginsNetwork.NetworkPlugin = void 0;
  var properties_js_1 = /*@__PURE__*/requireProperties();
  var index_js_1 = /*@__PURE__*/requireUtils$3();
  var EnsAddress = "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e";
  /**
   *  A **NetworkPlugin** provides additional functionality on a [[Network]].
   */
  var NetworkPlugin = /*#__PURE__*/function () {
    /**
     *  Creates a new **NetworkPlugin**.
     */
    function NetworkPlugin(name) {
      _classCallCheck(this, NetworkPlugin);
      /**
       *  The name of the plugin.
       *
       *  It is recommended to use reverse-domain-notation, which permits
       *  unique names with a known authority as well as hierarchal entries.
       */
      _defineProperty(this, "name", void 0);
      (0, properties_js_1.defineProperties)(this, {
        name: name
      });
    }
    /**
     *  Creates a copy of this plugin.
     */
    return _createClass(NetworkPlugin, [{
      key: "clone",
      value: function clone() {
        return new NetworkPlugin(this.name);
      }
    }]);
  }();
  pluginsNetwork.NetworkPlugin = NetworkPlugin;
  /**
   *  A **GasCostPlugin** allows a network to provide alternative values when
   *  computing the intrinsic gas required for a transaction.
   */
  var GasCostPlugin = /*#__PURE__*/function (_NetworkPlugin2) {
    /**
     *  Creates a new GasCostPlugin from %%effectiveBlock%% until the
     *  latest block or another GasCostPlugin supercedes that block number,
     *  with the associated %%costs%%.
     */
    function GasCostPlugin(effectiveBlock, costs) {
      var _this;
      _classCallCheck(this, GasCostPlugin);
      if (effectiveBlock == null) {
        effectiveBlock = 0;
      }
      _this = _callSuper(this, GasCostPlugin, ["org.ethers.network.plugins.GasCost#".concat(effectiveBlock || 0)]);
      /**
       *  The block number to treat these values as valid from.
       *
       *  This allows a hardfork to have updated values included as well as
       *  mulutiple hardforks to be supported.
       */
      _defineProperty(_this, "effectiveBlock", void 0);
      /**
       *  The transactions base fee.
       */
      _defineProperty(_this, "txBase", void 0);
      /**
       *  The fee for creating a new account.
       */
      _defineProperty(_this, "txCreate", void 0);
      /**
       *  The fee per zero-byte in the data.
       */
      _defineProperty(_this, "txDataZero", void 0);
      /**
       *  The fee per non-zero-byte in the data.
       */
      _defineProperty(_this, "txDataNonzero", void 0);
      /**
       *  The fee per storage key in the [[link-eip-2930]] access list.
       */
      _defineProperty(_this, "txAccessListStorageKey", void 0);
      /**
       *  The fee per address in the [[link-eip-2930]] access list.
       */
      _defineProperty(_this, "txAccessListAddress", void 0);
      var props = {
        effectiveBlock: effectiveBlock
      };
      function set(name, nullish) {
        var value = (costs || {})[name];
        if (value == null) {
          value = nullish;
        }
        (0, index_js_1.assertArgument)(typeof value === "number", "invalud value for ".concat(name), "costs", costs);
        props[name] = value;
      }
      set("txBase", 21000);
      set("txCreate", 32000);
      set("txDataZero", 4);
      set("txDataNonzero", 16);
      set("txAccessListStorageKey", 1900);
      set("txAccessListAddress", 2400);
      (0, properties_js_1.defineProperties)(_this, props);
      return _this;
    }
    _inherits(GasCostPlugin, _NetworkPlugin2);
    return _createClass(GasCostPlugin, [{
      key: "clone",
      value: function clone() {
        return new GasCostPlugin(this.effectiveBlock, this);
      }
    }]);
  }(NetworkPlugin);
  pluginsNetwork.GasCostPlugin = GasCostPlugin;
  /**
   *  An **EnsPlugin** allows a [[Network]] to specify the ENS Registry
   *  Contract address and the target network to use when using that
   *  contract.
   *
   *  Various testnets have their own instance of the contract to use, but
   *  in general, the mainnet instance supports multi-chain addresses and
   *  should be used.
   */
  var EnsPlugin = /*#__PURE__*/function (_NetworkPlugin3) {
    /**
     *  Creates a new **EnsPlugin** connected to %%address%% on the
     *  %%targetNetwork%%. The default ENS address and mainnet is used
     *  if unspecified.
     */
    function EnsPlugin(address, targetNetwork) {
      var _this2;
      _classCallCheck(this, EnsPlugin);
      _this2 = _callSuper(this, EnsPlugin, ["org.ethers.plugins.network.Ens"]);
      /**
       *  The ENS Registrty Contract address.
       */
      _defineProperty(_this2, "address", void 0);
      /**
       *  The chain ID that the ENS contract lives on.
       */
      _defineProperty(_this2, "targetNetwork", void 0);
      (0, properties_js_1.defineProperties)(_this2, {
        address: address || EnsAddress,
        targetNetwork: targetNetwork == null ? 1 : targetNetwork
      });
      return _this2;
    }
    _inherits(EnsPlugin, _NetworkPlugin3);
    return _createClass(EnsPlugin, [{
      key: "clone",
      value: function clone() {
        return new EnsPlugin(this.address, this.targetNetwork);
      }
    }]);
  }(NetworkPlugin);
  pluginsNetwork.EnsPlugin = EnsPlugin;
  /**
   *  A **FeeDataNetworkPlugin** allows a network to provide and alternate
   *  means to specify its fee data.
   *
   *  For example, a network which does not support [[link-eip-1559]] may
   *  choose to use a Gas Station site to approximate the gas price.
   */
  var _feeDataFunc = /*#__PURE__*/new WeakMap();
  var FeeDataNetworkPlugin = /*#__PURE__*/function (_NetworkPlugin4) {
    /**
     *  Creates a new **FeeDataNetworkPlugin**.
     */
    function FeeDataNetworkPlugin(feeDataFunc) {
      var _this3;
      _classCallCheck(this, FeeDataNetworkPlugin);
      _this3 = _callSuper(this, FeeDataNetworkPlugin, ["org.ethers.plugins.network.FeeData"]);
      _classPrivateFieldInitSpec(_this3, _feeDataFunc, void 0);
      _classPrivateFieldSet2(_feeDataFunc, _this3, feeDataFunc);
      return _this3;
    }
    /**
     *  Resolves to the fee data.
     */
    _inherits(FeeDataNetworkPlugin, _NetworkPlugin4);
    return _createClass(FeeDataNetworkPlugin, [{
      key: "feeDataFunc",
      get:
      /**
       *  The fee data function provided to the constructor.
       */
      function get() {
        return _classPrivateFieldGet2(_feeDataFunc, this);
      }
    }, {
      key: "getFeeData",
      value: (function () {
        var _getFeeData = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(provider) {
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return _classPrivateFieldGet2(_feeDataFunc, this).call(this, provider);
              case 2:
                return _context.abrupt("return", _context.sent);
              case 3:
              case "end":
                return _context.stop();
            }
          }, _callee, this);
        }));
        function getFeeData(_x) {
          return _getFeeData.apply(this, arguments);
        }
        return getFeeData;
      }())
    }, {
      key: "clone",
      value: function clone() {
        return new FeeDataNetworkPlugin(_classPrivateFieldGet2(_feeDataFunc, this));
      }
    }]);
  }(NetworkPlugin);
  pluginsNetwork.FeeDataNetworkPlugin = FeeDataNetworkPlugin;
  var _url = /*#__PURE__*/new WeakMap();
  var _processFunc = /*#__PURE__*/new WeakMap();
  var FetchUrlFeeDataNetworkPlugin = /*#__PURE__*/function (_NetworkPlugin5) {
    /**
     *  Creates a new **FetchUrlFeeDataNetworkPlugin** which will
     *  be used when computing the fee data for the network.
     */
    function FetchUrlFeeDataNetworkPlugin(url, processFunc) {
      var _this4;
      _classCallCheck(this, FetchUrlFeeDataNetworkPlugin);
      _this4 = _callSuper(this, FetchUrlFeeDataNetworkPlugin, ["org.ethers.plugins.network.FetchUrlFeeDataPlugin"]);
      _classPrivateFieldInitSpec(_this4, _url, void 0);
      _classPrivateFieldInitSpec(_this4, _processFunc, void 0);
      _classPrivateFieldSet2(_url, _this4, url);
      _classPrivateFieldSet2(_processFunc, _this4, processFunc);
      return _this4;
    }
    // We are immutable, so we can serve as our own clone
    _inherits(FetchUrlFeeDataNetworkPlugin, _NetworkPlugin5);
    return _createClass(FetchUrlFeeDataNetworkPlugin, [{
      key: "url",
      get:
      /**
       *  The URL to initialize the FetchRequest with in %%processFunc%%.
       */
      function get() {
        return _classPrivateFieldGet2(_url, this);
      }
      /**
       *  The callback to use when computing the FeeData.
       */
    }, {
      key: "processFunc",
      get: function get() {
        return _classPrivateFieldGet2(_processFunc, this);
      }
    }, {
      key: "clone",
      value: function clone() {
        return this;
      }
    }]);
  }(NetworkPlugin);
  pluginsNetwork.FetchUrlFeeDataNetworkPlugin = FetchUrlFeeDataNetworkPlugin;
  /*
  export class CustomBlockNetworkPlugin extends NetworkPlugin {
      readonly #blockFunc: (provider: Provider, block: BlockParams<string>) => Block<string>;
      readonly #blockWithTxsFunc: (provider: Provider, block: BlockParams<TransactionResponseParams>) => Block<TransactionResponse>;
  	    constructor(blockFunc: (provider: Provider, block: BlockParams<string>) => Block<string>, blockWithTxsFunc: (provider: Provider, block: BlockParams<TransactionResponseParams>) => Block<TransactionResponse>) {
          super("org.ethers.network-plugins.custom-block");
          this.#blockFunc = blockFunc;
          this.#blockWithTxsFunc = blockWithTxsFunc;
      }
  	    async getBlock(provider: Provider, block: BlockParams<string>): Promise<Block<string>> {
          return await this.#blockFunc(provider, block);
      }
  	    async getBlockions(provider: Provider, block: BlockParams<TransactionResponseParams>): Promise<Block<TransactionResponse>> {
          return await this.#blockWithTxsFunc(provider, block);
      }
  	    clone(): CustomBlockNetworkPlugin {
          return new CustomBlockNetworkPlugin(this.#blockFunc, this.#blockWithTxsFunc);
      }
  }
  */

  return pluginsNetwork;
}

var hasRequiredNetwork;
function requireNetwork() {
  if (hasRequiredNetwork) return network;
  hasRequiredNetwork = 1;
  /**
   *  A **Network** encapsulates the various properties required to
   *  interact with a specific chain.
   *
   *  @_subsection: api/providers:Networks  [networks]
   */
  Object.defineProperty(network, "__esModule", {
    value: true
  });
  network.Network = void 0;
  var index_js_1 = /*@__PURE__*/requireTransaction();
  var index_js_2 = /*@__PURE__*/requireUtils$3();
  var plugins_network_js_1 = /*@__PURE__*/requirePluginsNetwork();
  /* * * *
  // Networks which operation against an L2 can use this plugin to
  // specify how to access L1, for the purpose of resolving ENS,
  // for example.
  export class LayerOneConnectionPlugin extends NetworkPlugin {
      readonly provider!: Provider;
  // @TODO: Rename to ChainAccess and allow for connecting to any chain
      constructor(provider: Provider) {
          super("org.ethers.plugins.layer-one-connection");
          defineProperties<LayerOneConnectionPlugin>(this, { provider });
      }
  	    clone(): LayerOneConnectionPlugin {
          return new LayerOneConnectionPlugin(this.provider);
      }
  }
  */
  var Networks = new Map();
  /**
   *  A **Network** provides access to a chain's properties and allows
   *  for plug-ins to extend functionality.
   */
  var _name = /*#__PURE__*/new WeakMap();
  var _chainId = /*#__PURE__*/new WeakMap();
  var _plugins = /*#__PURE__*/new WeakMap();
  var Network = /*#__PURE__*/function () {
    /**
     *  Creates a new **Network** for %%name%% and %%chainId%%.
     */
    function Network(name, chainId) {
      _classCallCheck(this, Network);
      _classPrivateFieldInitSpec(this, _name, void 0);
      _classPrivateFieldInitSpec(this, _chainId, void 0);
      _classPrivateFieldInitSpec(this, _plugins, void 0);
      _classPrivateFieldSet2(_name, this, name);
      _classPrivateFieldSet2(_chainId, this, (0, index_js_2.getBigInt)(chainId));
      _classPrivateFieldSet2(_plugins, this, new Map());
    }
    /**
     *  Returns a JSON-compatible representation of a Network.
     */
    return _createClass(Network, [{
      key: "toJSON",
      value: function toJSON() {
        return {
          name: this.name,
          chainId: String(this.chainId)
        };
      }
      /**
       *  The network common name.
       *
       *  This is the canonical name, as networks migh have multiple
       *  names.
       */
    }, {
      key: "name",
      get: function get() {
        return _classPrivateFieldGet2(_name, this);
      },
      set: function set(value) {
        _classPrivateFieldSet2(_name, this, value);
      }
      /**
       *  The network chain ID.
       */
    }, {
      key: "chainId",
      get: function get() {
        return _classPrivateFieldGet2(_chainId, this);
      },
      set: function set(value) {
        _classPrivateFieldSet2(_chainId, this, (0, index_js_2.getBigInt)(value, "chainId"));
      }
      /**
       *  Returns true if %%other%% matches this network. Any chain ID
       *  must match, and if no chain ID is present, the name must match.
       *
       *  This method does not currently check for additional properties,
       *  such as ENS address or plug-in compatibility.
       */
    }, {
      key: "matches",
      value: function matches(other) {
        if (other == null) {
          return false;
        }
        if (typeof other === "string") {
          try {
            return this.chainId === (0, index_js_2.getBigInt)(other);
          } catch (error) {}
          return this.name === other;
        }
        if (typeof other === "number" || typeof other === "bigint") {
          try {
            return this.chainId === (0, index_js_2.getBigInt)(other);
          } catch (error) {}
          return false;
        }
        if (_typeof(other) === "object") {
          if (other.chainId != null) {
            try {
              return this.chainId === (0, index_js_2.getBigInt)(other.chainId);
            } catch (error) {}
            return false;
          }
          if (other.name != null) {
            return this.name === other.name;
          }
          return false;
        }
        return false;
      }
      /**
       *  Returns the list of plugins currently attached to this Network.
       */
    }, {
      key: "plugins",
      get: function get() {
        return Array.from(_classPrivateFieldGet2(_plugins, this).values());
      }
      /**
       *  Attach a new %%plugin%% to this Network. The network name
       *  must be unique, excluding any fragment.
       */
    }, {
      key: "attachPlugin",
      value: function attachPlugin(plugin) {
        if (_classPrivateFieldGet2(_plugins, this).get(plugin.name)) {
          throw new Error("cannot replace existing plugin: ".concat(plugin.name, " "));
        }
        _classPrivateFieldGet2(_plugins, this).set(plugin.name, plugin.clone());
        return this;
      }
      /**
       *  Return the plugin, if any, matching %%name%% exactly. Plugins
       *  with fragments will not be returned unless %%name%% includes
       *  a fragment.
       */
    }, {
      key: "getPlugin",
      value: function getPlugin(name) {
        return _classPrivateFieldGet2(_plugins, this).get(name) || null;
      }
      /**
       *  Gets a list of all plugins that match %%name%%, with otr without
       *  a fragment.
       */
    }, {
      key: "getPlugins",
      value: function getPlugins(basename) {
        return this.plugins.filter(function (p) {
          return p.name.split("#")[0] === basename;
        });
      }
      /**
       *  Create a copy of this Network.
       */
    }, {
      key: "clone",
      value: function clone() {
        var clone = new Network(this.name, this.chainId);
        this.plugins.forEach(function (plugin) {
          clone.attachPlugin(plugin.clone());
        });
        return clone;
      }
      /**
       *  Compute the intrinsic gas required for a transaction.
       *
       *  A GasCostPlugin can be attached to override the default
       *  values.
       */
    }, {
      key: "computeIntrinsicGas",
      value: function computeIntrinsicGas(tx) {
        var costs = this.getPlugin("org.ethers.plugins.network.GasCost") || new plugins_network_js_1.GasCostPlugin();
        var gas = costs.txBase;
        if (tx.to == null) {
          gas += costs.txCreate;
        }
        if (tx.data) {
          for (var i = 2; i < tx.data.length; i += 2) {
            if (tx.data.substring(i, i + 2) === "00") {
              gas += costs.txDataZero;
            } else {
              gas += costs.txDataNonzero;
            }
          }
        }
        if (tx.accessList) {
          var accessList = (0, index_js_1.accessListify)(tx.accessList);
          for (var addr in accessList) {
            gas += costs.txAccessListAddress + costs.txAccessListStorageKey * accessList[addr].storageKeys.length;
          }
        }
        return gas;
      }
      /**
       *  Returns a new Network for the %%network%% name or chainId.
       */
    }], [{
      key: "from",
      value: function from(network) {
        injectCommonNetworks();
        // Default network
        if (network == null) {
          return Network.from("mainnet");
        }
        // Canonical name or chain ID
        if (typeof network === "number") {
          network = BigInt(network);
        }
        if (typeof network === "string" || typeof network === "bigint") {
          var networkFunc = Networks.get(network);
          if (networkFunc) {
            return networkFunc();
          }
          if (typeof network === "bigint") {
            return new Network("unknown", network);
          }
          (0, index_js_2.assertArgument)(false, "unknown network", "network", network);
        }
        // Clonable with network-like abilities
        if (typeof network.clone === "function") {
          var clone = network.clone();
          //if (typeof(network.name) !== "string" || typeof(network.chainId) !== "number") {
          //}
          return clone;
        }
        // Networkish
        if (_typeof(network) === "object") {
          (0, index_js_2.assertArgument)(typeof network.name === "string" && typeof network.chainId === "number", "invalid network object name or chainId", "network", network);
          var custom = new Network(network.name, network.chainId);
          if (network.ensAddress || network.ensNetwork != null) {
            custom.attachPlugin(new plugins_network_js_1.EnsPlugin(network.ensAddress, network.ensNetwork));
          }
          //if ((<any>network).layerOneConnection) {
          //    custom.attachPlugin(new LayerOneConnectionPlugin((<any>network).layerOneConnection));
          //}
          return custom;
        }
        (0, index_js_2.assertArgument)(false, "invalid network", "network", network);
      }
      /**
       *  Register %%nameOrChainId%% with a function which returns
       *  an instance of a Network representing that chain.
       */
    }, {
      key: "register",
      value: function register(nameOrChainId, networkFunc) {
        if (typeof nameOrChainId === "number") {
          nameOrChainId = BigInt(nameOrChainId);
        }
        var existing = Networks.get(nameOrChainId);
        if (existing) {
          (0, index_js_2.assertArgument)(false, "conflicting network for ".concat(JSON.stringify(existing.name)), "nameOrChainId", nameOrChainId);
        }
        Networks.set(nameOrChainId, networkFunc);
      }
    }]);
  }();
  network.Network = Network;
  // We don't want to bring in formatUnits because it is backed by
  // FixedNumber and we want to keep Networks tiny. The values
  // included by the Gas Stations are also IEEE 754 with lots of
  // rounding issues and exceed the strict checks formatUnits has.
  function parseUnits(_value, decimals) {
    var value = String(_value);
    if (!value.match(/^[0-9.]+$/)) {
      throw new Error("invalid gwei value: ".concat(_value));
    }
    // Break into [ whole, fraction ]
    var comps = value.split(".");
    if (comps.length === 1) {
      comps.push("");
    }
    // More than 1 decimal point or too many fractional positions
    if (comps.length !== 2) {
      throw new Error("invalid gwei value: ".concat(_value));
    }
    // Pad the fraction to 9 decimalplaces
    while (comps[1].length < decimals) {
      comps[1] += "0";
    }
    // Too many decimals and some non-zero ending, take the ceiling
    if (comps[1].length > 9) {
      var frac = BigInt(comps[1].substring(0, 9));
      if (!comps[1].substring(9).match(/^0+$/)) {
        frac++;
      }
      comps[1] = frac.toString();
    }
    return BigInt(comps[0] + comps[1]);
  }
  // Used by Polygon to use a gas station for fee data
  function getGasStationPlugin(url) {
    return new plugins_network_js_1.FetchUrlFeeDataNetworkPlugin(url, /*#__PURE__*/function () {
      var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(fetchFeeData, provider, request) {
        var response, _yield$Promise$all, _yield$Promise$all2, _response, _feeData, payload, feeData;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              // Prevent Cloudflare from blocking our request in node.js
              request.setHeader("User-Agent", "ethers");
              _context.prev = 1;
              _context.next = 4;
              return Promise.all([request.send(), fetchFeeData()]);
            case 4:
              _yield$Promise$all = _context.sent;
              _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);
              _response = _yield$Promise$all2[0];
              _feeData = _yield$Promise$all2[1];
              response = _response;
              payload = response.bodyJson.standard;
              feeData = {
                gasPrice: _feeData.gasPrice,
                maxFeePerGas: parseUnits(payload.maxFee, 9),
                maxPriorityFeePerGas: parseUnits(payload.maxPriorityFee, 9)
              };
              return _context.abrupt("return", feeData);
            case 14:
              _context.prev = 14;
              _context.t0 = _context["catch"](1);
              (0, index_js_2.assert)(false, "error encountered with polygon gas station (".concat(JSON.stringify(request.url), ")"), "SERVER_ERROR", {
                request: request,
                response: response,
                error: _context.t0
              });
            case 17:
            case "end":
              return _context.stop();
          }
        }, _callee, null, [[1, 14]]);
      }));
      return function (_x, _x2, _x3) {
        return _ref.apply(this, arguments);
      };
    }());
  }
  // See: https://chainlist.org
  var injected = false;
  function injectCommonNetworks() {
    if (injected) {
      return;
    }
    injected = true;
    /// Register popular Ethereum networks
    function registerEth(name, chainId, options) {
      var func = function func() {
        var network = new Network(name, chainId);
        // We use 0 to disable ENS
        if (options.ensNetwork != null) {
          network.attachPlugin(new plugins_network_js_1.EnsPlugin(null, options.ensNetwork));
        }
        network.attachPlugin(new plugins_network_js_1.GasCostPlugin());
        (options.plugins || []).forEach(function (plugin) {
          network.attachPlugin(plugin);
        });
        return network;
      };
      // Register the network by name and chain ID
      Network.register(name, func);
      Network.register(chainId, func);
      if (options.altNames) {
        options.altNames.forEach(function (name) {
          Network.register(name, func);
        });
      }
    }
    registerEth("mainnet", 1, {
      ensNetwork: 1,
      altNames: ["homestead"]
    });
    registerEth("ropsten", 3, {
      ensNetwork: 3
    });
    registerEth("rinkeby", 4, {
      ensNetwork: 4
    });
    registerEth("goerli", 5, {
      ensNetwork: 5
    });
    registerEth("kovan", 42, {
      ensNetwork: 42
    });
    registerEth("sepolia", 11155111, {
      ensNetwork: 11155111
    });
    registerEth("holesky", 17000, {
      ensNetwork: 17000
    });
    registerEth("classic", 61, {});
    registerEth("classicKotti", 6, {});
    registerEth("arbitrum", 42161, {
      ensNetwork: 1
    });
    registerEth("arbitrum-goerli", 421613, {});
    registerEth("arbitrum-sepolia", 421614, {});
    registerEth("base", 8453, {
      ensNetwork: 1
    });
    registerEth("base-goerli", 84531, {});
    registerEth("base-sepolia", 84532, {});
    registerEth("bnb", 56, {
      ensNetwork: 1
    });
    registerEth("bnbt", 97, {});
    registerEth("linea", 59144, {
      ensNetwork: 1
    });
    registerEth("linea-goerli", 59140, {});
    registerEth("linea-sepolia", 59141, {});
    registerEth("matic", 137, {
      ensNetwork: 1,
      plugins: [getGasStationPlugin("https:/\/gasstation.polygon.technology/v2")]
    });
    registerEth("matic-amoy", 80002, {});
    registerEth("matic-mumbai", 80001, {
      altNames: ["maticMumbai", "maticmum"],
      plugins: [getGasStationPlugin("https:/\/gasstation-testnet.polygon.technology/v2")]
    });
    registerEth("optimism", 10, {
      ensNetwork: 1,
      plugins: []
    });
    registerEth("optimism-goerli", 420, {});
    registerEth("optimism-sepolia", 11155420, {});
    registerEth("xdai", 100, {
      ensNetwork: 1
    });
  }
  return network;
}

var subscriberPolling = {};

var hasRequiredSubscriberPolling;
function requireSubscriberPolling() {
  if (hasRequiredSubscriberPolling) return subscriberPolling;
  hasRequiredSubscriberPolling = 1;
  Object.defineProperty(subscriberPolling, "__esModule", {
    value: true
  });
  subscriberPolling.PollingEventSubscriber = subscriberPolling.PollingTransactionSubscriber = subscriberPolling.PollingOrphanSubscriber = subscriberPolling.PollingBlockTagSubscriber = subscriberPolling.OnBlockSubscriber = subscriberPolling.PollingBlockSubscriber = subscriberPolling.getPollingSubscriber = void 0;
  var index_js_1 = /*@__PURE__*/requireUtils$3();
  function copy(obj) {
    return JSON.parse(JSON.stringify(obj));
  }
  /**
   *  Return the polling subscriber for common events.
   *
   *  @_docloc: api/providers/abstract-provider
   */
  function getPollingSubscriber(provider, event) {
    if (event === "block") {
      return new PollingBlockSubscriber(provider);
    }
    if ((0, index_js_1.isHexString)(event, 32)) {
      return new PollingTransactionSubscriber(provider, event);
    }
    (0, index_js_1.assert)(false, "unsupported polling event", "UNSUPPORTED_OPERATION", {
      operation: "getPollingSubscriber",
      info: {
        event: event
      }
    });
  }
  subscriberPolling.getPollingSubscriber = getPollingSubscriber;
  // @TODO: refactor this
  /**
   *  A **PollingBlockSubscriber** polls at a regular interval for a change
   *  in the block number.
   *
   *  @_docloc: api/providers/abstract-provider
   */
  var _provider = /*#__PURE__*/new WeakMap();
  var _poller = /*#__PURE__*/new WeakMap();
  var _interval = /*#__PURE__*/new WeakMap();
  var _blockNumber = /*#__PURE__*/new WeakMap();
  var _PollingBlockSubscriber_brand = /*#__PURE__*/new WeakSet();
  var PollingBlockSubscriber = /*#__PURE__*/function () {
    /**
     *  Create a new **PollingBlockSubscriber** attached to %%provider%%.
     */
    function PollingBlockSubscriber(provider) {
      _classCallCheck(this, PollingBlockSubscriber);
      _classPrivateMethodInitSpec(this, _PollingBlockSubscriber_brand);
      _classPrivateFieldInitSpec(this, _provider, void 0);
      _classPrivateFieldInitSpec(this, _poller, void 0);
      _classPrivateFieldInitSpec(this, _interval, void 0);
      // The most recent block we have scanned for events. The value -2
      // indicates we still need to fetch an initial block number
      _classPrivateFieldInitSpec(this, _blockNumber, void 0);
      _classPrivateFieldSet2(_provider, this, provider);
      _classPrivateFieldSet2(_poller, this, null);
      _classPrivateFieldSet2(_interval, this, 4000);
      _classPrivateFieldSet2(_blockNumber, this, -2);
    }
    /**
     *  The polling interval.
     */
    return _createClass(PollingBlockSubscriber, [{
      key: "pollingInterval",
      get: function get() {
        return _classPrivateFieldGet2(_interval, this);
      },
      set: function set(value) {
        _classPrivateFieldSet2(_interval, this, value);
      }
    }, {
      key: "start",
      value: function start() {
        if (_classPrivateFieldGet2(_poller, this)) {
          return;
        }
        _classPrivateFieldSet2(_poller, this, _classPrivateFieldGet2(_provider, this)._setTimeout(_assertClassBrand(_PollingBlockSubscriber_brand, this, _poll).bind(this), _classPrivateFieldGet2(_interval, this)));
        _assertClassBrand(_PollingBlockSubscriber_brand, this, _poll).call(this);
      }
    }, {
      key: "stop",
      value: function stop() {
        if (!_classPrivateFieldGet2(_poller, this)) {
          return;
        }
        _classPrivateFieldGet2(_provider, this)._clearTimeout(_classPrivateFieldGet2(_poller, this));
        _classPrivateFieldSet2(_poller, this, null);
      }
    }, {
      key: "pause",
      value: function pause(dropWhilePaused) {
        this.stop();
        if (dropWhilePaused) {
          _classPrivateFieldSet2(_blockNumber, this, -2);
        }
      }
    }, {
      key: "resume",
      value: function resume() {
        this.start();
      }
    }]);
  }();
  function _poll() {
    return _poll8.apply(this, arguments);
  }
  function _poll8() {
    _poll8 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
      var blockNumber, b;
      return _regeneratorRuntime().wrap(function _callee5$(_context5) {
        while (1) switch (_context5.prev = _context5.next) {
          case 0:
            _context5.prev = 0;
            _context5.next = 3;
            return _classPrivateFieldGet2(_provider, this).getBlockNumber();
          case 3:
            blockNumber = _context5.sent;
            if (!(_classPrivateFieldGet2(_blockNumber, this) === -2)) {
              _context5.next = 7;
              break;
            }
            _classPrivateFieldSet2(_blockNumber, this, blockNumber);
            return _context5.abrupt("return");
          case 7:
            if (!(blockNumber !== _classPrivateFieldGet2(_blockNumber, this))) {
              _context5.next = 18;
              break;
            }
            b = _classPrivateFieldGet2(_blockNumber, this) + 1;
          case 9:
            if (!(b <= blockNumber)) {
              _context5.next = 17;
              break;
            }
            if (!(_classPrivateFieldGet2(_poller, this) == null)) {
              _context5.next = 12;
              break;
            }
            return _context5.abrupt("return");
          case 12:
            _context5.next = 14;
            return _classPrivateFieldGet2(_provider, this).emit("block", b);
          case 14:
            b++;
            _context5.next = 9;
            break;
          case 17:
            _classPrivateFieldSet2(_blockNumber, this, blockNumber);
          case 18:
            _context5.next = 22;
            break;
          case 20:
            _context5.prev = 20;
            _context5.t0 = _context5["catch"](0);
          case 22:
            if (!(_classPrivateFieldGet2(_poller, this) == null)) {
              _context5.next = 24;
              break;
            }
            return _context5.abrupt("return");
          case 24:
            _classPrivateFieldSet2(_poller, this, _classPrivateFieldGet2(_provider, this)._setTimeout(_assertClassBrand(_PollingBlockSubscriber_brand, this, _poll).bind(this), _classPrivateFieldGet2(_interval, this)));
          case 25:
          case "end":
            return _context5.stop();
        }
      }, _callee5, this, [[0, 20]]);
    }));
    return _poll8.apply(this, arguments);
  }
  subscriberPolling.PollingBlockSubscriber = PollingBlockSubscriber;
  /**
   *  An **OnBlockSubscriber** can be sub-classed, with a [[_poll]]
   *  implmentation which will be called on every new block.
   *
   *  @_docloc: api/providers/abstract-provider
   */
  var _provider2 = /*#__PURE__*/new WeakMap();
  var _poll2 = /*#__PURE__*/new WeakMap();
  var _running = /*#__PURE__*/new WeakMap();
  var OnBlockSubscriber = /*#__PURE__*/function () {
    /**
     *  Create a new **OnBlockSubscriber** attached to %%provider%%.
     */
    function OnBlockSubscriber(provider) {
      var _this = this;
      _classCallCheck(this, OnBlockSubscriber);
      _classPrivateFieldInitSpec(this, _provider2, void 0);
      _classPrivateFieldInitSpec(this, _poll2, void 0);
      _classPrivateFieldInitSpec(this, _running, void 0);
      _classPrivateFieldSet2(_provider2, this, provider);
      _classPrivateFieldSet2(_running, this, false);
      _classPrivateFieldSet2(_poll2, this, function (blockNumber) {
        _this._poll(blockNumber, _classPrivateFieldGet2(_provider2, _this));
      });
    }
    /**
     *  Called on every new block.
     */
    return _createClass(OnBlockSubscriber, [{
      key: "_poll",
      value: (function () {
        var _poll3 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(blockNumber, provider) {
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                throw new Error("sub-classes must override this");
              case 1:
              case "end":
                return _context.stop();
            }
          }, _callee);
        }));
        function _poll(_x, _x2) {
          return _poll3.apply(this, arguments);
        }
        return _poll;
      }())
    }, {
      key: "start",
      value: function start() {
        if (_classPrivateFieldGet2(_running, this)) {
          return;
        }
        _classPrivateFieldSet2(_running, this, true);
        _classPrivateFieldGet2(_poll2, this).call(this, -2);
        _classPrivateFieldGet2(_provider2, this).on("block", _classPrivateFieldGet2(_poll2, this));
      }
    }, {
      key: "stop",
      value: function stop() {
        if (!_classPrivateFieldGet2(_running, this)) {
          return;
        }
        _classPrivateFieldSet2(_running, this, false);
        _classPrivateFieldGet2(_provider2, this).off("block", _classPrivateFieldGet2(_poll2, this));
      }
    }, {
      key: "pause",
      value: function pause(dropWhilePaused) {
        this.stop();
      }
    }, {
      key: "resume",
      value: function resume() {
        this.start();
      }
    }]);
  }();
  subscriberPolling.OnBlockSubscriber = OnBlockSubscriber;
  var _tag = /*#__PURE__*/new WeakMap();
  var _lastBlock = /*#__PURE__*/new WeakMap();
  var PollingBlockTagSubscriber = /*#__PURE__*/function (_OnBlockSubscriber2) {
    function PollingBlockTagSubscriber(provider, tag) {
      var _this2;
      _classCallCheck(this, PollingBlockTagSubscriber);
      _this2 = _callSuper(this, PollingBlockTagSubscriber, [provider]);
      _classPrivateFieldInitSpec(_this2, _tag, void 0);
      _classPrivateFieldInitSpec(_this2, _lastBlock, void 0);
      _classPrivateFieldSet2(_tag, _this2, tag);
      _classPrivateFieldSet2(_lastBlock, _this2, -2);
      return _this2;
    }
    _inherits(PollingBlockTagSubscriber, _OnBlockSubscriber2);
    return _createClass(PollingBlockTagSubscriber, [{
      key: "pause",
      value: function pause(dropWhilePaused) {
        if (dropWhilePaused) {
          _classPrivateFieldSet2(_lastBlock, this, -2);
        }
        _superPropGet(PollingBlockTagSubscriber, "pause", this, 3)([dropWhilePaused]);
      }
    }, {
      key: "_poll",
      value: function () {
        var _poll4 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(blockNumber, provider) {
          var block;
          return _regeneratorRuntime().wrap(function _callee2$(_context2) {
            while (1) switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return provider.getBlock(_classPrivateFieldGet2(_tag, this));
              case 2:
                block = _context2.sent;
                if (!(block == null)) {
                  _context2.next = 5;
                  break;
                }
                return _context2.abrupt("return");
              case 5:
                if (_classPrivateFieldGet2(_lastBlock, this) === -2) {
                  _classPrivateFieldSet2(_lastBlock, this, block.number);
                } else if (block.number > _classPrivateFieldGet2(_lastBlock, this)) {
                  provider.emit(_classPrivateFieldGet2(_tag, this), block.number);
                  _classPrivateFieldSet2(_lastBlock, this, block.number);
                }
              case 6:
              case "end":
                return _context2.stop();
            }
          }, _callee2, this);
        }));
        function _poll(_x3, _x4) {
          return _poll4.apply(this, arguments);
        }
        return _poll;
      }()
    }]);
  }(OnBlockSubscriber);
  subscriberPolling.PollingBlockTagSubscriber = PollingBlockTagSubscriber;
  /**
   *  @_ignore:
   *
   *  @_docloc: api/providers/abstract-provider
   */
  var _filter = /*#__PURE__*/new WeakMap();
  var PollingOrphanSubscriber = /*#__PURE__*/function (_OnBlockSubscriber3) {
    function PollingOrphanSubscriber(provider, filter) {
      var _this3;
      _classCallCheck(this, PollingOrphanSubscriber);
      _this3 = _callSuper(this, PollingOrphanSubscriber, [provider]);
      _classPrivateFieldInitSpec(_this3, _filter, void 0);
      _classPrivateFieldSet2(_filter, _this3, copy(filter));
      return _this3;
    }
    _inherits(PollingOrphanSubscriber, _OnBlockSubscriber3);
    return _createClass(PollingOrphanSubscriber, [{
      key: "_poll",
      value: function () {
        var _poll5 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(blockNumber, provider) {
          return _regeneratorRuntime().wrap(function _callee3$(_context3) {
            while (1) switch (_context3.prev = _context3.next) {
              case 0:
                throw new Error("@TODO");
              case 2:
              case "end":
                return _context3.stop();
            }
          }, _callee3, this);
        }));
        function _poll(_x5, _x6) {
          return _poll5.apply(this, arguments);
        }
        return _poll;
      }()
    }]);
  }(OnBlockSubscriber);
  subscriberPolling.PollingOrphanSubscriber = PollingOrphanSubscriber;
  /**
   *  A **PollingTransactionSubscriber** will poll for a given transaction
   *  hash for its receipt.
   *
   *  @_docloc: api/providers/abstract-provider
   */
  var _hash = /*#__PURE__*/new WeakMap();
  var PollingTransactionSubscriber = /*#__PURE__*/function (_OnBlockSubscriber4) {
    /**
     *  Create a new **PollingTransactionSubscriber** attached to
     *  %%provider%%, listening for %%hash%%.
     */
    function PollingTransactionSubscriber(provider, hash) {
      var _this4;
      _classCallCheck(this, PollingTransactionSubscriber);
      _this4 = _callSuper(this, PollingTransactionSubscriber, [provider]);
      _classPrivateFieldInitSpec(_this4, _hash, void 0);
      _classPrivateFieldSet2(_hash, _this4, hash);
      return _this4;
    }
    _inherits(PollingTransactionSubscriber, _OnBlockSubscriber4);
    return _createClass(PollingTransactionSubscriber, [{
      key: "_poll",
      value: function () {
        var _poll6 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4(blockNumber, provider) {
          var tx;
          return _regeneratorRuntime().wrap(function _callee4$(_context4) {
            while (1) switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return provider.getTransactionReceipt(_classPrivateFieldGet2(_hash, this));
              case 2:
                tx = _context4.sent;
                if (tx) {
                  provider.emit(_classPrivateFieldGet2(_hash, this), tx);
                }
              case 4:
              case "end":
                return _context4.stop();
            }
          }, _callee4, this);
        }));
        function _poll(_x7, _x8) {
          return _poll6.apply(this, arguments);
        }
        return _poll;
      }()
    }]);
  }(OnBlockSubscriber);
  subscriberPolling.PollingTransactionSubscriber = PollingTransactionSubscriber;
  /**
   *  A **PollingEventSubscriber** will poll for a given filter for its logs.
   *
   *  @_docloc: api/providers/abstract-provider
   */
  var _provider3 = /*#__PURE__*/new WeakMap();
  var _filter2 = /*#__PURE__*/new WeakMap();
  var _poller2 = /*#__PURE__*/new WeakMap();
  var _running2 = /*#__PURE__*/new WeakMap();
  var _blockNumber2 = /*#__PURE__*/new WeakMap();
  var _PollingEventSubscriber_brand = /*#__PURE__*/new WeakSet();
  var PollingEventSubscriber = /*#__PURE__*/function () {
    /**
     *  Create a new **PollingTransactionSubscriber** attached to
     *  %%provider%%, listening for %%filter%%.
     */
    function PollingEventSubscriber(provider, _filter3) {
      _classCallCheck(this, PollingEventSubscriber);
      _classPrivateMethodInitSpec(this, _PollingEventSubscriber_brand);
      _classPrivateFieldInitSpec(this, _provider3, void 0);
      _classPrivateFieldInitSpec(this, _filter2, void 0);
      _classPrivateFieldInitSpec(this, _poller2, void 0);
      _classPrivateFieldInitSpec(this, _running2, void 0);
      // The most recent block we have scanned for events. The value -2
      // indicates we still need to fetch an initial block number
      _classPrivateFieldInitSpec(this, _blockNumber2, void 0);
      _classPrivateFieldSet2(_provider3, this, provider);
      _classPrivateFieldSet2(_filter2, this, copy(_filter3));
      _classPrivateFieldSet2(_poller2, this, _assertClassBrand(_PollingEventSubscriber_brand, this, _poll7).bind(this));
      _classPrivateFieldSet2(_running2, this, false);
      _classPrivateFieldSet2(_blockNumber2, this, -2);
    }
    return _createClass(PollingEventSubscriber, [{
      key: "start",
      value: function start() {
        var _this5 = this;
        if (_classPrivateFieldGet2(_running2, this)) {
          return;
        }
        _classPrivateFieldSet2(_running2, this, true);
        if (_classPrivateFieldGet2(_blockNumber2, this) === -2) {
          _classPrivateFieldGet2(_provider3, this).getBlockNumber().then(function (blockNumber) {
            _classPrivateFieldSet2(_blockNumber2, _this5, blockNumber);
          });
        }
        _classPrivateFieldGet2(_provider3, this).on("block", _classPrivateFieldGet2(_poller2, this));
      }
    }, {
      key: "stop",
      value: function stop() {
        if (!_classPrivateFieldGet2(_running2, this)) {
          return;
        }
        _classPrivateFieldSet2(_running2, this, false);
        _classPrivateFieldGet2(_provider3, this).off("block", _classPrivateFieldGet2(_poller2, this));
      }
    }, {
      key: "pause",
      value: function pause(dropWhilePaused) {
        this.stop();
        if (dropWhilePaused) {
          _classPrivateFieldSet2(_blockNumber2, this, -2);
        }
      }
    }, {
      key: "resume",
      value: function resume() {
        this.start();
      }
    }]);
  }();
  function _poll7(_x9) {
    return _poll9.apply(this, arguments);
  }
  function _poll9() {
    _poll9 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee6(blockNumber) {
      var filter, logs, _iterator, _step, log;
      return _regeneratorRuntime().wrap(function _callee6$(_context6) {
        while (1) switch (_context6.prev = _context6.next) {
          case 0:
            if (!(_classPrivateFieldGet2(_blockNumber2, this) === -2)) {
              _context6.next = 2;
              break;
            }
            return _context6.abrupt("return");
          case 2:
            filter = copy(_classPrivateFieldGet2(_filter2, this));
            filter.fromBlock = _classPrivateFieldGet2(_blockNumber2, this) + 1;
            filter.toBlock = blockNumber;
            _context6.next = 7;
            return _classPrivateFieldGet2(_provider3, this).getLogs(filter);
          case 7:
            logs = _context6.sent;
            if (!(logs.length === 0)) {
              _context6.next = 11;
              break;
            }
            if (_classPrivateFieldGet2(_blockNumber2, this) < blockNumber - 60) {
              _classPrivateFieldSet2(_blockNumber2, this, blockNumber - 60);
            }
            return _context6.abrupt("return");
          case 11:
            _iterator = _createForOfIteratorHelper(logs);
            try {
              for (_iterator.s(); !(_step = _iterator.n()).done;) {
                log = _step.value;
                _classPrivateFieldGet2(_provider3, this).emit(_classPrivateFieldGet2(_filter2, this), log);
                // Only advance the block number when logs were found to
                // account for networks (like BNB and Polygon) which may
                // sacrifice event consistency for block event speed
                _classPrivateFieldSet2(_blockNumber2, this, log.blockNumber);
              }
            } catch (err) {
              _iterator.e(err);
            } finally {
              _iterator.f();
            }
          case 13:
          case "end":
            return _context6.stop();
        }
      }, _callee6, this);
    }));
    return _poll9.apply(this, arguments);
  }
  subscriberPolling.PollingEventSubscriber = PollingEventSubscriber;
  return subscriberPolling;
}

var hasRequiredAbstractProvider;
function requireAbstractProvider() {
  if (hasRequiredAbstractProvider) return abstractProvider;
  hasRequiredAbstractProvider = 1;
  /**
   *  The available providers should suffice for most developers purposes,
   *  but the [[AbstractProvider]] class has many features which enable
   *  sub-classing it for specific purposes.
   *
   *  @_section: api/providers/abstract-provider: Subclassing Provider  [abstract-provider]
   */
  Object.defineProperty(abstractProvider, "__esModule", {
    value: true
  });
  abstractProvider.AbstractProvider = abstractProvider.UnmanagedSubscriber = void 0;
  // @TODO
  // Event coalescence
  //   When we register an event with an async value (e.g. address is a Signer
  //   or ENS name), we need to add it immeidately for the Event API, but also
  //   need time to resolve the address. Upon resolving the address, we need to
  //   migrate the listener to the static event. We also need to maintain a map
  //   of Signer/ENS name to address so we can sync respond to listenerCount.
  var index_js_1 = /*@__PURE__*/requireAddress$2();
  var index_js_2 = /*@__PURE__*/requireConstants$1();
  var index_js_3 = /*@__PURE__*/requireContract();
  var index_js_4 = /*@__PURE__*/requireHash();
  var index_js_5 = /*@__PURE__*/requireTransaction();
  var index_js_6 = /*@__PURE__*/requireUtils$3();
  var ens_resolver_js_1 = /*@__PURE__*/requireEnsResolver();
  var format_js_1 = /*@__PURE__*/requireFormat();
  var network_js_1 = /*@__PURE__*/requireNetwork();
  var provider_js_1 = /*@__PURE__*/requireProvider();
  var subscriber_polling_js_1 = /*@__PURE__*/requireSubscriberPolling();
  // Constants
  var BN_2 = BigInt(2);
  var MAX_CCIP_REDIRECTS = 10;
  function isPromise(value) {
    return value && typeof value.then === "function";
  }
  function getTag(prefix, value) {
    return prefix + ":" + JSON.stringify(value, function (k, v) {
      if (v == null) {
        return "null";
      }
      if (typeof v === "bigint") {
        return "bigint:".concat(v.toString());
      }
      if (typeof v === "string") {
        return v.toLowerCase();
      }
      // Sort object keys
      if (_typeof(v) === "object" && !Array.isArray(v)) {
        var keys = Object.keys(v);
        keys.sort();
        return keys.reduce(function (accum, key) {
          accum[key] = v[key];
          return accum;
        }, {});
      }
      return v;
    });
  }
  /**
   *  An **UnmanagedSubscriber** is useful for events which do not require
   *  any additional management, such as ``"debug"`` which only requires
   *  emit in synchronous event loop triggered calls.
   */
  var UnmanagedSubscriber = /*#__PURE__*/function () {
    /**
     *  Create a new UnmanagedSubscriber with %%name%%.
     */
    function UnmanagedSubscriber(name) {
      _classCallCheck(this, UnmanagedSubscriber);
      /**
       *  The name fof the event.
       */
      _defineProperty(this, "name", void 0);
      (0, index_js_6.defineProperties)(this, {
        name: name
      });
    }
    return _createClass(UnmanagedSubscriber, [{
      key: "start",
      value: function start() {}
    }, {
      key: "stop",
      value: function stop() {}
    }, {
      key: "pause",
      value: function pause(dropWhilePaused) {}
    }, {
      key: "resume",
      value: function resume() {}
    }]);
  }();
  abstractProvider.UnmanagedSubscriber = UnmanagedSubscriber;
  function copy(value) {
    return JSON.parse(JSON.stringify(value));
  }
  function concisify(items) {
    items = Array.from(new Set(items).values());
    items.sort();
    return items;
  }
  function getSubscription(_x, _x2) {
    return _getSubscription.apply(this, arguments);
  }
  function _getSubscription() {
    _getSubscription = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee43(_event, provider) {
      var hash, event, _event2, filter, addresses, promises, addAddress;
      return _regeneratorRuntime().wrap(function _callee43$(_context43) {
        while (1) switch (_context43.prev = _context43.next) {
          case 0:
            if (!(_event == null)) {
              _context43.next = 2;
              break;
            }
            throw new Error("invalid event");
          case 2:
            // Normalize topic array info an EventFilter
            if (Array.isArray(_event)) {
              _event = {
                topics: _event
              };
            }
            if (!(typeof _event === "string")) {
              _context43.next = 8;
              break;
            }
            _context43.t0 = _event;
            _context43.next = _context43.t0 === "block" ? 7 : _context43.t0 === "debug" ? 7 : _context43.t0 === "error" ? 7 : _context43.t0 === "finalized" ? 7 : _context43.t0 === "network" ? 7 : _context43.t0 === "pending" ? 7 : _context43.t0 === "safe" ? 7 : 8;
            break;
          case 7:
            return _context43.abrupt("return", {
              type: _event,
              tag: _event
            });
          case 8:
            if (!(0, index_js_6.isHexString)(_event, 32)) {
              _context43.next = 11;
              break;
            }
            hash = _event.toLowerCase();
            return _context43.abrupt("return", {
              type: "transaction",
              tag: getTag("tx", {
                hash: hash
              }),
              hash: hash
            });
          case 11:
            if (!_event.orphan) {
              _context43.next = 14;
              break;
            }
            event = _event; // @TODO: Should lowercase and whatnot things here instead of copy...
            return _context43.abrupt("return", {
              type: "orphan",
              tag: getTag("orphan", event),
              filter: copy(event)
            });
          case 14:
            if (!(_event.address || _event.topics)) {
              _context43.next = 27;
              break;
            }
            _event2 = _event;
            filter = {
              topics: (_event2.topics || []).map(function (t) {
                if (t == null) {
                  return null;
                }
                if (Array.isArray(t)) {
                  return concisify(t.map(function (t) {
                    return t.toLowerCase();
                  }));
                }
                return t.toLowerCase();
              })
            };
            if (!_event2.address) {
              _context43.next = 26;
              break;
            }
            addresses = [];
            promises = [];
            addAddress = function addAddress(addr) {
              if ((0, index_js_6.isHexString)(addr)) {
                addresses.push(addr);
              } else {
                promises.push(_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee42() {
                  return _regeneratorRuntime().wrap(function _callee42$(_context42) {
                    while (1) switch (_context42.prev = _context42.next) {
                      case 0:
                        _context42.t0 = addresses;
                        _context42.next = 3;
                        return (0, index_js_1.resolveAddress)(addr, provider);
                      case 3:
                        _context42.t1 = _context42.sent;
                        _context42.t0.push.call(_context42.t0, _context42.t1);
                      case 5:
                      case "end":
                        return _context42.stop();
                    }
                  }, _callee42);
                }))());
              }
            };
            if (Array.isArray(_event2.address)) {
              _event2.address.forEach(addAddress);
            } else {
              addAddress(_event2.address);
            }
            if (!promises.length) {
              _context43.next = 25;
              break;
            }
            _context43.next = 25;
            return Promise.all(promises);
          case 25:
            filter.address = concisify(addresses.map(function (a) {
              return a.toLowerCase();
            }));
          case 26:
            return _context43.abrupt("return", {
              filter: filter,
              tag: getTag("event", filter),
              type: "event"
            });
          case 27:
            (0, index_js_6.assertArgument)(false, "unknown ProviderEvent", "event", _event);
          case 28:
          case "end":
            return _context43.stop();
        }
      }, _callee43);
    }));
    return _getSubscription.apply(this, arguments);
  }
  function getTime() {
    return new Date().getTime();
  }
  var defaultOptions = {
    cacheTimeout: 250,
    pollingInterval: 4000
  };
  /**
   *  An **AbstractProvider** provides a base class for other sub-classes to
   *  implement the [[Provider]] API by normalizing input arguments and
   *  formatting output results as well as tracking events for consistent
   *  behaviour on an eventually-consistent network.
   */
  var _subs = /*#__PURE__*/new WeakMap();
  var _plugins = /*#__PURE__*/new WeakMap();
  var _pausedState = /*#__PURE__*/new WeakMap();
  var _destroyed = /*#__PURE__*/new WeakMap();
  var _networkPromise = /*#__PURE__*/new WeakMap();
  var _anyNetwork = /*#__PURE__*/new WeakMap();
  var _performCache = /*#__PURE__*/new WeakMap();
  var _lastBlockNumber = /*#__PURE__*/new WeakMap();
  var _nextTimer = /*#__PURE__*/new WeakMap();
  var _timers = /*#__PURE__*/new WeakMap();
  var _disableCcipRead = /*#__PURE__*/new WeakMap();
  var _options = /*#__PURE__*/new WeakMap();
  var _AbstractProvider_brand = /*#__PURE__*/new WeakSet();
  var AbstractProvider = /*#__PURE__*/function () {
    /**
     *  Create a new **AbstractProvider** connected to %%network%%, or
     *  use the various network detection capabilities to discover the
     *  [[Network]] if necessary.
     */
    function AbstractProvider(_network, options) {
      var _this = this;
      _classCallCheck(this, AbstractProvider);
      // Shares multiple identical requests made during the same 250ms
      _classPrivateMethodInitSpec(this, _AbstractProvider_brand);
      _classPrivateFieldInitSpec(this, _subs, void 0);
      _classPrivateFieldInitSpec(this, _plugins, void 0);
      // null=unpaused, true=paused+dropWhilePaused, false=paused
      _classPrivateFieldInitSpec(this, _pausedState, void 0);
      _classPrivateFieldInitSpec(this, _destroyed, void 0);
      _classPrivateFieldInitSpec(this, _networkPromise, void 0);
      _classPrivateFieldInitSpec(this, _anyNetwork, void 0);
      _classPrivateFieldInitSpec(this, _performCache, void 0);
      // The most recent block number if running an event or -1 if no "block" event
      _classPrivateFieldInitSpec(this, _lastBlockNumber, void 0);
      _classPrivateFieldInitSpec(this, _nextTimer, void 0);
      _classPrivateFieldInitSpec(this, _timers, void 0);
      _classPrivateFieldInitSpec(this, _disableCcipRead, void 0);
      _classPrivateFieldInitSpec(this, _options, void 0);
      _classPrivateFieldSet2(_options, this, Object.assign({}, defaultOptions, options || {}));
      if (_network === "any") {
        _classPrivateFieldSet2(_anyNetwork, this, true);
        _classPrivateFieldSet2(_networkPromise, this, null);
      } else if (_network) {
        var network = network_js_1.Network.from(_network);
        _classPrivateFieldSet2(_anyNetwork, this, false);
        _classPrivateFieldSet2(_networkPromise, this, Promise.resolve(network));
        setTimeout(function () {
          _this.emit("network", network, null);
        }, 0);
      } else {
        _classPrivateFieldSet2(_anyNetwork, this, false);
        _classPrivateFieldSet2(_networkPromise, this, null);
      }
      _classPrivateFieldSet2(_lastBlockNumber, this, -1);
      _classPrivateFieldSet2(_performCache, this, new Map());
      _classPrivateFieldSet2(_subs, this, new Map());
      _classPrivateFieldSet2(_plugins, this, new Map());
      _classPrivateFieldSet2(_pausedState, this, null);
      _classPrivateFieldSet2(_destroyed, this, false);
      _classPrivateFieldSet2(_nextTimer, this, 1);
      _classPrivateFieldSet2(_timers, this, new Map());
      _classPrivateFieldSet2(_disableCcipRead, this, false);
    }
    return _createClass(AbstractProvider, [{
      key: "pollingInterval",
      get: function get() {
        return _classPrivateFieldGet2(_options, this).pollingInterval;
      }
      /**
       *  Returns ``this``, to allow an **AbstractProvider** to implement
       *  the [[ContractRunner]] interface.
       */
    }, {
      key: "provider",
      get: function get() {
        return this;
      }
      /**
       *  Returns all the registered plug-ins.
       */
    }, {
      key: "plugins",
      get: function get() {
        return Array.from(_classPrivateFieldGet2(_plugins, this).values());
      }
      /**
       *  Attach a new plug-in.
       */
    }, {
      key: "attachPlugin",
      value: function attachPlugin(plugin) {
        if (_classPrivateFieldGet2(_plugins, this).get(plugin.name)) {
          throw new Error("cannot replace existing plugin: ".concat(plugin.name, " "));
        }
        _classPrivateFieldGet2(_plugins, this).set(plugin.name, plugin.connect(this));
        return this;
      }
      /**
       *  Get a plugin by name.
       */
    }, {
      key: "getPlugin",
      value: function getPlugin(name) {
        return _classPrivateFieldGet2(_plugins, this).get(name) || null;
      }
      /**
       *  Prevent any CCIP-read operation, regardless of whether requested
       *  in a [[call]] using ``enableCcipRead``.
       */
    }, {
      key: "disableCcipRead",
      get: function get() {
        return _classPrivateFieldGet2(_disableCcipRead, this);
      },
      set: function set(value) {
        _classPrivateFieldSet2(_disableCcipRead, this, !!value);
      }
    }, {
      key: "ccipReadFetch",
      value: (
      /**
       *  Resolves to the data for executing the CCIP-read operations.
       */
      function () {
        var _ccipReadFetch = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(tx, calldata, urls) {
          var sender, data, errorMessages, i, url, href, request, errorMessage, resp, result;
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                if (!(this.disableCcipRead || urls.length === 0 || tx.to == null)) {
                  _context.next = 2;
                  break;
                }
                return _context.abrupt("return", null);
              case 2:
                sender = tx.to.toLowerCase();
                data = calldata.toLowerCase();
                errorMessages = [];
                i = 0;
              case 6:
                if (!(i < urls.length)) {
                  _context.next = 41;
                  break;
                }
                url = urls[i]; // URL expansion
                href = url.replace("{sender}", sender).replace("{data}", data); // If no {data} is present, use POST; otherwise GET
                //const json: string | null = (url.indexOf("{data}") >= 0) ? null: JSON.stringify({ data, sender });
                //const result = await fetchJson({ url: href, errorPassThrough: true }, json, (value, response) => {
                //    value.status = response.statusCode;
                //    return value;
                //});
                request = new index_js_6.FetchRequest(href);
                if (url.indexOf("{data}") === -1) {
                  request.body = {
                    data: data,
                    sender: sender
                  };
                }
                this.emit("debug", {
                  action: "sendCcipReadFetchRequest",
                  request: request,
                  index: i,
                  urls: urls
                });
                errorMessage = "unknown error"; // Fetch the resource...
                resp = void 0;
                _context.prev = 14;
                _context.next = 17;
                return request.send();
              case 17:
                resp = _context.sent;
                _context.next = 25;
                break;
              case 20:
                _context.prev = 20;
                _context.t0 = _context["catch"](14);
                // ...low-level fetch error (missing host, bad SSL, etc.),
                // so try next URL
                errorMessages.push(_context.t0.message);
                this.emit("debug", {
                  action: "receiveCcipReadFetchError",
                  request: request,
                  result: {
                    error: _context.t0
                  }
                });
                return _context.abrupt("continue", 38);
              case 25:
                _context.prev = 25;
                result = resp.bodyJson;
                if (!result.data) {
                  _context.next = 30;
                  break;
                }
                this.emit("debug", {
                  action: "receiveCcipReadFetchResult",
                  request: request,
                  result: result
                });
                return _context.abrupt("return", result.data);
              case 30:
                if (result.message) {
                  errorMessage = result.message;
                }
                this.emit("debug", {
                  action: "receiveCcipReadFetchError",
                  request: request,
                  result: result
                });
                _context.next = 36;
                break;
              case 34:
                _context.prev = 34;
                _context.t1 = _context["catch"](25);
              case 36:
                // 4xx indicates the result is not present; stop
                (0, index_js_6.assert)(resp.statusCode < 400 || resp.statusCode >= 500, "response not found during CCIP fetch: ".concat(errorMessage), "OFFCHAIN_FAULT", {
                  reason: "404_MISSING_RESOURCE",
                  transaction: tx,
                  info: {
                    url: url,
                    errorMessage: errorMessage
                  }
                });
                // 5xx indicates server issue; try the next url
                errorMessages.push(errorMessage);
              case 38:
                i++;
                _context.next = 6;
                break;
              case 41:
                (0, index_js_6.assert)(false, "error encountered during CCIP fetch: ".concat(errorMessages.map(function (m) {
                  return JSON.stringify(m);
                }).join(", ")), "OFFCHAIN_FAULT", {
                  reason: "500_SERVER_ERROR",
                  transaction: tx,
                  info: {
                    urls: urls,
                    errorMessages: errorMessages
                  }
                });
              case 42:
              case "end":
                return _context.stop();
            }
          }, _callee, this, [[14, 20], [25, 34]]);
        }));
        function ccipReadFetch(_x3, _x4, _x5) {
          return _ccipReadFetch.apply(this, arguments);
        }
        return ccipReadFetch;
      }()
      /**
       *  Provides the opportunity for a sub-class to wrap a block before
       *  returning it, to add additional properties or an alternate
       *  sub-class of [[Block]].
       */
      )
    }, {
      key: "_wrapBlock",
      value: function _wrapBlock(value, network) {
        return new provider_js_1.Block((0, format_js_1.formatBlock)(value), this);
      }
      /**
       *  Provides the opportunity for a sub-class to wrap a log before
       *  returning it, to add additional properties or an alternate
       *  sub-class of [[Log]].
       */
    }, {
      key: "_wrapLog",
      value: function _wrapLog(value, network) {
        return new provider_js_1.Log((0, format_js_1.formatLog)(value), this);
      }
      /**
       *  Provides the opportunity for a sub-class to wrap a transaction
       *  receipt before returning it, to add additional properties or an
       *  alternate sub-class of [[TransactionReceipt]].
       */
    }, {
      key: "_wrapTransactionReceipt",
      value: function _wrapTransactionReceipt(value, network) {
        return new provider_js_1.TransactionReceipt((0, format_js_1.formatTransactionReceipt)(value), this);
      }
      /**
       *  Provides the opportunity for a sub-class to wrap a transaction
       *  response before returning it, to add additional properties or an
       *  alternate sub-class of [[TransactionResponse]].
       */
    }, {
      key: "_wrapTransactionResponse",
      value: function _wrapTransactionResponse(tx, network) {
        return new provider_js_1.TransactionResponse((0, format_js_1.formatTransactionResponse)(tx), this);
      }
      /**
       *  Resolves to the Network, forcing a network detection using whatever
       *  technique the sub-class requires.
       *
       *  Sub-classes **must** override this.
       */
    }, {
      key: "_detectNetwork",
      value: function _detectNetwork() {
        (0, index_js_6.assert)(false, "sub-classes must implement this", "UNSUPPORTED_OPERATION", {
          operation: "_detectNetwork"
        });
      }
      /**
       *  Sub-classes should use this to perform all built-in operations. All
       *  methods sanitizes and normalizes the values passed into this.
       *
       *  Sub-classes **must** override this.
       */
    }, {
      key: "_perform",
      value: (function () {
        var _perform2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(req) {
          return _regeneratorRuntime().wrap(function _callee2$(_context2) {
            while (1) switch (_context2.prev = _context2.next) {
              case 0:
                (0, index_js_6.assert)(false, "unsupported method: ".concat(req.method), "UNSUPPORTED_OPERATION", {
                  operation: req.method,
                  info: req
                });
              case 1:
              case "end":
                return _context2.stop();
            }
          }, _callee2);
        }));
        function _perform(_x6) {
          return _perform2.apply(this, arguments);
        }
        return _perform;
      }() // State
      )
    }, {
      key: "getBlockNumber",
      value: function () {
        var _getBlockNumber = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
          var blockNumber;
          return _regeneratorRuntime().wrap(function _callee3$(_context3) {
            while (1) switch (_context3.prev = _context3.next) {
              case 0:
                _context3.t0 = (index_js_6.getNumber);
                _context3.next = 3;
                return _assertClassBrand(_AbstractProvider_brand, this, _perform).call(this, {
                  method: "getBlockNumber"
                });
              case 3:
                _context3.t1 = _context3.sent;
                blockNumber = (0, _context3.t0)(_context3.t1, "%response");
                if (_classPrivateFieldGet2(_lastBlockNumber, this) >= 0) {
                  _classPrivateFieldSet2(_lastBlockNumber, this, blockNumber);
                }
                return _context3.abrupt("return", blockNumber);
              case 7:
              case "end":
                return _context3.stop();
            }
          }, _callee3, this);
        }));
        function getBlockNumber() {
          return _getBlockNumber.apply(this, arguments);
        }
        return getBlockNumber;
      }()
      /**
       *  Returns or resolves to the address for %%address%%, resolving ENS
       *  names and [[Addressable]] objects and returning if already an
       *  address.
       */
    }, {
      key: "_getAddress",
      value: function _getAddress(address) {
        return (0, index_js_1.resolveAddress)(address, this);
      }
      /**
       *  Returns or resolves to a valid block tag for %%blockTag%%, resolving
       *  negative values and returning if already a valid block tag.
       */
    }, {
      key: "_getBlockTag",
      value: function _getBlockTag(blockTag) {
        if (blockTag == null) {
          return "latest";
        }
        switch (blockTag) {
          case "earliest":
            return "0x0";
          case "finalized":
          case "latest":
          case "pending":
          case "safe":
            return blockTag;
        }
        if ((0, index_js_6.isHexString)(blockTag)) {
          if ((0, index_js_6.isHexString)(blockTag, 32)) {
            return blockTag;
          }
          return (0, index_js_6.toQuantity)(blockTag);
        }
        if (typeof blockTag === "bigint") {
          blockTag = (0, index_js_6.getNumber)(blockTag, "blockTag");
        }
        if (typeof blockTag === "number") {
          if (blockTag >= 0) {
            return (0, index_js_6.toQuantity)(blockTag);
          }
          if (_classPrivateFieldGet2(_lastBlockNumber, this) >= 0) {
            return (0, index_js_6.toQuantity)(_classPrivateFieldGet2(_lastBlockNumber, this) + blockTag);
          }
          return this.getBlockNumber().then(function (b) {
            return (0, index_js_6.toQuantity)(b + blockTag);
          });
        }
        (0, index_js_6.assertArgument)(false, "invalid blockTag", "blockTag", blockTag);
      }
      /**
       *  Returns or resolves to a filter for %%filter%%, resolving any ENS
       *  names or [[Addressable]] object and returning if already a valid
       *  filter.
       */
    }, {
      key: "_getFilter",
      value: function _getFilter(filter) {
        // Create a canonical representation of the topics
        var topics = (filter.topics || []).map(function (t) {
          if (t == null) {
            return null;
          }
          if (Array.isArray(t)) {
            return concisify(t.map(function (t) {
              return t.toLowerCase();
            }));
          }
          return t.toLowerCase();
        });
        var blockHash = "blockHash" in filter ? filter.blockHash : undefined;
        var resolve = function resolve(_address, fromBlock, toBlock) {
          var address = undefined;
          switch (_address.length) {
            case 0:
              break;
            case 1:
              address = _address[0];
              break;
            default:
              _address.sort();
              address = _address;
          }
          if (blockHash) {
            if (fromBlock != null || toBlock != null) {
              throw new Error("invalid filter");
            }
          }
          var filter = {};
          if (address) {
            filter.address = address;
          }
          if (topics.length) {
            filter.topics = topics;
          }
          if (fromBlock) {
            filter.fromBlock = fromBlock;
          }
          if (toBlock) {
            filter.toBlock = toBlock;
          }
          if (blockHash) {
            filter.blockHash = blockHash;
          }
          return filter;
        };
        // Addresses could be async (ENS names or Addressables)
        var address = [];
        if (filter.address) {
          if (Array.isArray(filter.address)) {
            var _iterator = _createForOfIteratorHelper(filter.address),
              _step;
            try {
              for (_iterator.s(); !(_step = _iterator.n()).done;) {
                var addr = _step.value;
                address.push(this._getAddress(addr));
              }
            } catch (err) {
              _iterator.e(err);
            } finally {
              _iterator.f();
            }
          } else {
            address.push(this._getAddress(filter.address));
          }
        }
        var fromBlock = undefined;
        if ("fromBlock" in filter) {
          fromBlock = this._getBlockTag(filter.fromBlock);
        }
        var toBlock = undefined;
        if ("toBlock" in filter) {
          toBlock = this._getBlockTag(filter.toBlock);
        }
        if (address.filter(function (a) {
          return typeof a !== "string";
        }).length || fromBlock != null && typeof fromBlock !== "string" || toBlock != null && typeof toBlock !== "string") {
          return Promise.all([Promise.all(address), fromBlock, toBlock]).then(function (result) {
            return resolve(result[0], result[1], result[2]);
          });
        }
        return resolve(address, fromBlock, toBlock);
      }
      /**
       *  Returns or resolves to a transaction for %%request%%, resolving
       *  any ENS names or [[Addressable]] and returning if already a valid
       *  transaction.
       */
    }, {
      key: "_getTransactionRequest",
      value: function _getTransactionRequest(_request) {
        var _this2 = this;
        var request = (0, provider_js_1.copyRequest)(_request);
        var promises = [];
        ["to", "from"].forEach(function (key) {
          if (request[key] == null) {
            return;
          }
          var addr = (0, index_js_1.resolveAddress)(request[key], _this2);
          if (isPromise(addr)) {
            promises.push(_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
              return _regeneratorRuntime().wrap(function _callee4$(_context4) {
                while (1) switch (_context4.prev = _context4.next) {
                  case 0:
                    _context4.next = 2;
                    return addr;
                  case 2:
                    request[key] = _context4.sent;
                  case 3:
                  case "end":
                    return _context4.stop();
                }
              }, _callee4);
            }))());
          } else {
            request[key] = addr;
          }
        });
        if (request.blockTag != null) {
          var blockTag = this._getBlockTag(request.blockTag);
          if (isPromise(blockTag)) {
            promises.push(_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
              return _regeneratorRuntime().wrap(function _callee5$(_context5) {
                while (1) switch (_context5.prev = _context5.next) {
                  case 0:
                    _context5.next = 2;
                    return blockTag;
                  case 2:
                    request.blockTag = _context5.sent;
                  case 3:
                  case "end":
                    return _context5.stop();
                }
              }, _callee5);
            }))());
          } else {
            request.blockTag = blockTag;
          }
        }
        if (promises.length) {
          return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
            return _regeneratorRuntime().wrap(function _callee6$(_context6) {
              while (1) switch (_context6.prev = _context6.next) {
                case 0:
                  _context6.next = 2;
                  return Promise.all(promises);
                case 2:
                  return _context6.abrupt("return", request);
                case 3:
                case "end":
                  return _context6.stop();
              }
            }, _callee6);
          }))();
        }
        return request;
      }
    }, {
      key: "getNetwork",
      value: function () {
        var _getNetwork = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {
          var _this3 = this;
          var detectNetwork, networkPromise, _yield$Promise$all, _yield$Promise$all2, expected, actual;
          return _regeneratorRuntime().wrap(function _callee8$(_context8) {
            while (1) switch (_context8.prev = _context8.next) {
              case 0:
                if (!(_classPrivateFieldGet2(_networkPromise, this) == null)) {
                  _context8.next = 6;
                  break;
                }
                // Detect the current network (shared with all calls)
                detectNetwork = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {
                  var network;
                  return _regeneratorRuntime().wrap(function _callee7$(_context7) {
                    while (1) switch (_context7.prev = _context7.next) {
                      case 0:
                        _context7.prev = 0;
                        _context7.next = 3;
                        return _this3._detectNetwork();
                      case 3:
                        network = _context7.sent;
                        _this3.emit("network", network, null);
                        return _context7.abrupt("return", network);
                      case 8:
                        _context7.prev = 8;
                        _context7.t0 = _context7["catch"](0);
                        if (_classPrivateFieldGet2(_networkPromise, _this3) === detectNetwork) {
                          _classPrivateFieldSet2(_networkPromise, _this3, null);
                        }
                        throw _context7.t0;
                      case 12:
                      case "end":
                        return _context7.stop();
                    }
                  }, _callee7, null, [[0, 8]]);
                }))();
                _classPrivateFieldSet2(_networkPromise, this, detectNetwork);
                _context8.next = 5;
                return detectNetwork;
              case 5:
                return _context8.abrupt("return", _context8.sent.clone());
              case 6:
                networkPromise = _classPrivateFieldGet2(_networkPromise, this);
                _context8.next = 9;
                return Promise.all([networkPromise, this._detectNetwork() // The actual connected network
                ]);
              case 9:
                _yield$Promise$all = _context8.sent;
                _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);
                expected = _yield$Promise$all2[0];
                actual = _yield$Promise$all2[1];
                if (expected.chainId !== actual.chainId) {
                  if (_classPrivateFieldGet2(_anyNetwork, this)) {
                    // The "any" network can change, so notify listeners
                    this.emit("network", actual, expected);
                    // Update the network if something else hasn't already changed it
                    if (_classPrivateFieldGet2(_networkPromise, this) === networkPromise) {
                      _classPrivateFieldSet2(_networkPromise, this, Promise.resolve(actual));
                    }
                  } else {
                    // Otherwise, we do not allow changes to the underlying network
                    (0, index_js_6.assert)(false, "network changed: ".concat(expected.chainId, " => ").concat(actual.chainId, " "), "NETWORK_ERROR", {
                      event: "changed"
                    });
                  }
                }
                return _context8.abrupt("return", expected.clone());
              case 15:
              case "end":
                return _context8.stop();
            }
          }, _callee8, this);
        }));
        function getNetwork() {
          return _getNetwork.apply(this, arguments);
        }
        return getNetwork;
      }()
    }, {
      key: "getFeeData",
      value: function () {
        var _getFeeData = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {
          var _this4 = this;
          var network, getFeeDataFunc, plugin, req, feeData;
          return _regeneratorRuntime().wrap(function _callee12$(_context12) {
            while (1) switch (_context12.prev = _context12.next) {
              case 0:
                _context12.next = 2;
                return this.getNetwork();
              case 2:
                network = _context12.sent;
                getFeeDataFunc = /*#__PURE__*/function () {
                  var _ref5 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {
                    var _yield, _block, gasPrice, priorityFee, maxFeePerGas, maxPriorityFeePerGas, block;
                    return _regeneratorRuntime().wrap(function _callee11$(_context11) {
                      while (1) switch (_context11.prev = _context11.next) {
                        case 0:
                          _context11.next = 2;
                          return (0, index_js_6.resolveProperties)({
                            _block: _assertClassBrand(_AbstractProvider_brand, _this4, _getBlock).call(_this4, "latest", false),
                            gasPrice: _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {
                              var value;
                              return _regeneratorRuntime().wrap(function _callee9$(_context9) {
                                while (1) switch (_context9.prev = _context9.next) {
                                  case 0:
                                    _context9.prev = 0;
                                    _context9.next = 3;
                                    return _assertClassBrand(_AbstractProvider_brand, _this4, _perform).call(_this4, {
                                      method: "getGasPrice"
                                    });
                                  case 3:
                                    value = _context9.sent;
                                    return _context9.abrupt("return", (0, index_js_6.getBigInt)(value, "%response"));
                                  case 7:
                                    _context9.prev = 7;
                                    _context9.t0 = _context9["catch"](0);
                                  case 9:
                                    return _context9.abrupt("return", null);
                                  case 10:
                                  case "end":
                                    return _context9.stop();
                                }
                              }, _callee9, null, [[0, 7]]);
                            }))(),
                            priorityFee: _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {
                              var value;
                              return _regeneratorRuntime().wrap(function _callee10$(_context10) {
                                while (1) switch (_context10.prev = _context10.next) {
                                  case 0:
                                    _context10.prev = 0;
                                    _context10.next = 3;
                                    return _assertClassBrand(_AbstractProvider_brand, _this4, _perform).call(_this4, {
                                      method: "getPriorityFee"
                                    });
                                  case 3:
                                    value = _context10.sent;
                                    return _context10.abrupt("return", (0, index_js_6.getBigInt)(value, "%response"));
                                  case 7:
                                    _context10.prev = 7;
                                    _context10.t0 = _context10["catch"](0);
                                  case 9:
                                    return _context10.abrupt("return", null);
                                  case 10:
                                  case "end":
                                    return _context10.stop();
                                }
                              }, _callee10, null, [[0, 7]]);
                            }))()
                          });
                        case 2:
                          _yield = _context11.sent;
                          _block = _yield._block;
                          gasPrice = _yield.gasPrice;
                          priorityFee = _yield.priorityFee;
                          maxFeePerGas = null;
                          maxPriorityFeePerGas = null; // These are the recommended EIP-1559 heuristics for fee data
                          block = _this4._wrapBlock(_block, network);
                          if (block && block.baseFeePerGas) {
                            maxPriorityFeePerGas = priorityFee != null ? priorityFee : BigInt("1000000000");
                            maxFeePerGas = block.baseFeePerGas * BN_2 + maxPriorityFeePerGas;
                          }
                          return _context11.abrupt("return", new provider_js_1.FeeData(gasPrice, maxFeePerGas, maxPriorityFeePerGas));
                        case 11:
                        case "end":
                          return _context11.stop();
                      }
                    }, _callee11);
                  }));
                  return function getFeeDataFunc() {
                    return _ref5.apply(this, arguments);
                  };
                }(); // Check for a FeeDataNetWorkPlugin
                plugin = network.getPlugin("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
                if (!plugin) {
                  _context12.next = 11;
                  break;
                }
                req = new index_js_6.FetchRequest(plugin.url);
                _context12.next = 9;
                return plugin.processFunc(getFeeDataFunc, this, req);
              case 9:
                feeData = _context12.sent;
                return _context12.abrupt("return", new provider_js_1.FeeData(feeData.gasPrice, feeData.maxFeePerGas, feeData.maxPriorityFeePerGas));
              case 11:
                _context12.next = 13;
                return getFeeDataFunc();
              case 13:
                return _context12.abrupt("return", _context12.sent);
              case 14:
              case "end":
                return _context12.stop();
            }
          }, _callee12, this);
        }));
        function getFeeData() {
          return _getFeeData.apply(this, arguments);
        }
        return getFeeData;
      }()
    }, {
      key: "estimateGas",
      value: function () {
        var _estimateGas = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee13(_tx) {
          var tx;
          return _regeneratorRuntime().wrap(function _callee13$(_context13) {
            while (1) switch (_context13.prev = _context13.next) {
              case 0:
                tx = this._getTransactionRequest(_tx);
                if (!isPromise(tx)) {
                  _context13.next = 5;
                  break;
                }
                _context13.next = 4;
                return tx;
              case 4:
                tx = _context13.sent;
              case 5:
                _context13.t0 = (index_js_6.getBigInt);
                _context13.next = 8;
                return _assertClassBrand(_AbstractProvider_brand, this, _perform).call(this, {
                  method: "estimateGas",
                  transaction: tx
                });
              case 8:
                _context13.t1 = _context13.sent;
                return _context13.abrupt("return", (0, _context13.t0)(_context13.t1, "%response"));
              case 10:
              case "end":
                return _context13.stop();
            }
          }, _callee13, this);
        }));
        function estimateGas(_x7) {
          return _estimateGas.apply(this, arguments);
        }
        return estimateGas;
      }()
    }, {
      key: "call",
      value: function () {
        var _call2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee14(_tx) {
          var _yield2, tx, blockTag;
          return _regeneratorRuntime().wrap(function _callee14$(_context14) {
            while (1) switch (_context14.prev = _context14.next) {
              case 0:
                _context14.next = 2;
                return (0, index_js_6.resolveProperties)({
                  tx: this._getTransactionRequest(_tx),
                  blockTag: this._getBlockTag(_tx.blockTag)
                });
              case 2:
                _yield2 = _context14.sent;
                tx = _yield2.tx;
                blockTag = _yield2.blockTag;
                _context14.next = 7;
                return _assertClassBrand(_AbstractProvider_brand, this, _checkNetwork).call(this, _assertClassBrand(_AbstractProvider_brand, this, _call).call(this, tx, blockTag, _tx.enableCcipRead ? 0 : -1));
              case 7:
                return _context14.abrupt("return", _context14.sent);
              case 8:
              case "end":
                return _context14.stop();
            }
          }, _callee14, this);
        }));
        function call(_x8) {
          return _call2.apply(this, arguments);
        }
        return call;
      }() // Account
    }, {
      key: "getBalance",
      value: function () {
        var _getBalance = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee15(address, blockTag) {
          return _regeneratorRuntime().wrap(function _callee15$(_context15) {
            while (1) switch (_context15.prev = _context15.next) {
              case 0:
                _context15.t0 = (index_js_6.getBigInt);
                _context15.next = 3;
                return _assertClassBrand(_AbstractProvider_brand, this, _getAccountValue).call(this, {
                  method: "getBalance"
                }, address, blockTag);
              case 3:
                _context15.t1 = _context15.sent;
                return _context15.abrupt("return", (0, _context15.t0)(_context15.t1, "%response"));
              case 5:
              case "end":
                return _context15.stop();
            }
          }, _callee15, this);
        }));
        function getBalance(_x9, _x10) {
          return _getBalance.apply(this, arguments);
        }
        return getBalance;
      }()
    }, {
      key: "getTransactionCount",
      value: function () {
        var _getTransactionCount = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee16(address, blockTag) {
          return _regeneratorRuntime().wrap(function _callee16$(_context16) {
            while (1) switch (_context16.prev = _context16.next) {
              case 0:
                _context16.t0 = (index_js_6.getNumber);
                _context16.next = 3;
                return _assertClassBrand(_AbstractProvider_brand, this, _getAccountValue).call(this, {
                  method: "getTransactionCount"
                }, address, blockTag);
              case 3:
                _context16.t1 = _context16.sent;
                return _context16.abrupt("return", (0, _context16.t0)(_context16.t1, "%response"));
              case 5:
              case "end":
                return _context16.stop();
            }
          }, _callee16, this);
        }));
        function getTransactionCount(_x11, _x12) {
          return _getTransactionCount.apply(this, arguments);
        }
        return getTransactionCount;
      }()
    }, {
      key: "getCode",
      value: function () {
        var _getCode = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee17(address, blockTag) {
          return _regeneratorRuntime().wrap(function _callee17$(_context17) {
            while (1) switch (_context17.prev = _context17.next) {
              case 0:
                _context17.t0 = (index_js_6.hexlify);
                _context17.next = 3;
                return _assertClassBrand(_AbstractProvider_brand, this, _getAccountValue).call(this, {
                  method: "getCode"
                }, address, blockTag);
              case 3:
                _context17.t1 = _context17.sent;
                return _context17.abrupt("return", (0, _context17.t0)(_context17.t1));
              case 5:
              case "end":
                return _context17.stop();
            }
          }, _callee17, this);
        }));
        function getCode(_x13, _x14) {
          return _getCode.apply(this, arguments);
        }
        return getCode;
      }()
    }, {
      key: "getStorage",
      value: function () {
        var _getStorage = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee18(address, _position, blockTag) {
          var position;
          return _regeneratorRuntime().wrap(function _callee18$(_context18) {
            while (1) switch (_context18.prev = _context18.next) {
              case 0:
                position = (0, index_js_6.getBigInt)(_position, "position");
                _context18.t0 = (index_js_6.hexlify);
                _context18.next = 4;
                return _assertClassBrand(_AbstractProvider_brand, this, _getAccountValue).call(this, {
                  method: "getStorage",
                  position: position
                }, address, blockTag);
              case 4:
                _context18.t1 = _context18.sent;
                return _context18.abrupt("return", (0, _context18.t0)(_context18.t1));
              case 6:
              case "end":
                return _context18.stop();
            }
          }, _callee18, this);
        }));
        function getStorage(_x15, _x16, _x17) {
          return _getStorage.apply(this, arguments);
        }
        return getStorage;
      }() // Write
    }, {
      key: "broadcastTransaction",
      value: function () {
        var _broadcastTransaction = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee19(signedTx) {
          var _yield3, blockNumber, hash, network, tx;
          return _regeneratorRuntime().wrap(function _callee19$(_context19) {
            while (1) switch (_context19.prev = _context19.next) {
              case 0:
                _context19.next = 2;
                return (0, index_js_6.resolveProperties)({
                  blockNumber: this.getBlockNumber(),
                  hash: this._perform({
                    method: "broadcastTransaction",
                    signedTransaction: signedTx
                  }),
                  network: this.getNetwork()
                });
              case 2:
                _yield3 = _context19.sent;
                blockNumber = _yield3.blockNumber;
                hash = _yield3.hash;
                network = _yield3.network;
                tx = index_js_5.Transaction.from(signedTx);
                if (!(tx.hash !== hash)) {
                  _context19.next = 9;
                  break;
                }
                throw new Error("@TODO: the returned hash did not match");
              case 9:
                return _context19.abrupt("return", this._wrapTransactionResponse(tx, network).replaceableTransaction(blockNumber));
              case 10:
              case "end":
                return _context19.stop();
            }
          }, _callee19, this);
        }));
        function broadcastTransaction(_x18) {
          return _broadcastTransaction.apply(this, arguments);
        }
        return broadcastTransaction;
      }()
    }, {
      key: "getBlock",
      value: // Queries
      function () {
        var _getBlock2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee20(block, prefetchTxs) {
          var _yield4, network, params;
          return _regeneratorRuntime().wrap(function _callee20$(_context20) {
            while (1) switch (_context20.prev = _context20.next) {
              case 0:
                _context20.next = 2;
                return (0, index_js_6.resolveProperties)({
                  network: this.getNetwork(),
                  params: _assertClassBrand(_AbstractProvider_brand, this, _getBlock).call(this, block, !!prefetchTxs)
                });
              case 2:
                _yield4 = _context20.sent;
                network = _yield4.network;
                params = _yield4.params;
                if (!(params == null)) {
                  _context20.next = 7;
                  break;
                }
                return _context20.abrupt("return", null);
              case 7:
                return _context20.abrupt("return", this._wrapBlock(params, network));
              case 8:
              case "end":
                return _context20.stop();
            }
          }, _callee20, this);
        }));
        function getBlock(_x19, _x20) {
          return _getBlock2.apply(this, arguments);
        }
        return getBlock;
      }()
    }, {
      key: "getTransaction",
      value: function () {
        var _getTransaction = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee21(hash) {
          var _yield5, network, params;
          return _regeneratorRuntime().wrap(function _callee21$(_context21) {
            while (1) switch (_context21.prev = _context21.next) {
              case 0:
                _context21.next = 2;
                return (0, index_js_6.resolveProperties)({
                  network: this.getNetwork(),
                  params: _assertClassBrand(_AbstractProvider_brand, this, _perform).call(this, {
                    method: "getTransaction",
                    hash: hash
                  })
                });
              case 2:
                _yield5 = _context21.sent;
                network = _yield5.network;
                params = _yield5.params;
                if (!(params == null)) {
                  _context21.next = 7;
                  break;
                }
                return _context21.abrupt("return", null);
              case 7:
                return _context21.abrupt("return", this._wrapTransactionResponse(params, network));
              case 8:
              case "end":
                return _context21.stop();
            }
          }, _callee21, this);
        }));
        function getTransaction(_x21) {
          return _getTransaction.apply(this, arguments);
        }
        return getTransaction;
      }()
    }, {
      key: "getTransactionReceipt",
      value: function () {
        var _getTransactionReceipt = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee22(hash) {
          var _yield6, network, params, tx;
          return _regeneratorRuntime().wrap(function _callee22$(_context22) {
            while (1) switch (_context22.prev = _context22.next) {
              case 0:
                _context22.next = 2;
                return (0, index_js_6.resolveProperties)({
                  network: this.getNetwork(),
                  params: _assertClassBrand(_AbstractProvider_brand, this, _perform).call(this, {
                    method: "getTransactionReceipt",
                    hash: hash
                  })
                });
              case 2:
                _yield6 = _context22.sent;
                network = _yield6.network;
                params = _yield6.params;
                if (!(params == null)) {
                  _context22.next = 7;
                  break;
                }
                return _context22.abrupt("return", null);
              case 7:
                if (!(params.gasPrice == null && params.effectiveGasPrice == null)) {
                  _context22.next = 14;
                  break;
                }
                _context22.next = 10;
                return _assertClassBrand(_AbstractProvider_brand, this, _perform).call(this, {
                  method: "getTransaction",
                  hash: hash
                });
              case 10:
                tx = _context22.sent;
                if (!(tx == null)) {
                  _context22.next = 13;
                  break;
                }
                throw new Error("report this; could not find tx or effectiveGasPrice");
              case 13:
                params.effectiveGasPrice = tx.gasPrice;
              case 14:
                return _context22.abrupt("return", this._wrapTransactionReceipt(params, network));
              case 15:
              case "end":
                return _context22.stop();
            }
          }, _callee22, this);
        }));
        function getTransactionReceipt(_x22) {
          return _getTransactionReceipt.apply(this, arguments);
        }
        return getTransactionReceipt;
      }()
    }, {
      key: "getTransactionResult",
      value: function () {
        var _getTransactionResult = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee23(hash) {
          var _yield7, result;
          return _regeneratorRuntime().wrap(function _callee23$(_context23) {
            while (1) switch (_context23.prev = _context23.next) {
              case 0:
                _context23.next = 2;
                return (0, index_js_6.resolveProperties)({
                  network: this.getNetwork(),
                  result: _assertClassBrand(_AbstractProvider_brand, this, _perform).call(this, {
                    method: "getTransactionResult",
                    hash: hash
                  })
                });
              case 2:
                _yield7 = _context23.sent;
                result = _yield7.result;
                if (!(result == null)) {
                  _context23.next = 6;
                  break;
                }
                return _context23.abrupt("return", null);
              case 6:
                return _context23.abrupt("return", (0, index_js_6.hexlify)(result));
              case 7:
              case "end":
                return _context23.stop();
            }
          }, _callee23, this);
        }));
        function getTransactionResult(_x23) {
          return _getTransactionResult.apply(this, arguments);
        }
        return getTransactionResult;
      }() // Bloom-filter Queries
    }, {
      key: "getLogs",
      value: function () {
        var _getLogs = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee24(_filter) {
          var _this5 = this;
          var filter, _yield8, network, params;
          return _regeneratorRuntime().wrap(function _callee24$(_context24) {
            while (1) switch (_context24.prev = _context24.next) {
              case 0:
                filter = this._getFilter(_filter);
                if (!isPromise(filter)) {
                  _context24.next = 5;
                  break;
                }
                _context24.next = 4;
                return filter;
              case 4:
                filter = _context24.sent;
              case 5:
                _context24.next = 7;
                return (0, index_js_6.resolveProperties)({
                  network: this.getNetwork(),
                  params: _assertClassBrand(_AbstractProvider_brand, this, _perform).call(this, {
                    method: "getLogs",
                    filter: filter
                  })
                });
              case 7:
                _yield8 = _context24.sent;
                network = _yield8.network;
                params = _yield8.params;
                return _context24.abrupt("return", params.map(function (p) {
                  return _this5._wrapLog(p, network);
                }));
              case 11:
              case "end":
                return _context24.stop();
            }
          }, _callee24, this);
        }));
        function getLogs(_x24) {
          return _getLogs.apply(this, arguments);
        }
        return getLogs;
      }() // ENS
    }, {
      key: "_getProvider",
      value: function _getProvider(chainId) {
        (0, index_js_6.assert)(false, "provider cannot connect to target network", "UNSUPPORTED_OPERATION", {
          operation: "_getProvider()"
        });
      }
    }, {
      key: "getResolver",
      value: function () {
        var _getResolver = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee25(name) {
          return _regeneratorRuntime().wrap(function _callee25$(_context25) {
            while (1) switch (_context25.prev = _context25.next) {
              case 0:
                _context25.next = 2;
                return ens_resolver_js_1.EnsResolver.fromName(this, name);
              case 2:
                return _context25.abrupt("return", _context25.sent);
              case 3:
              case "end":
                return _context25.stop();
            }
          }, _callee25, this);
        }));
        function getResolver(_x25) {
          return _getResolver.apply(this, arguments);
        }
        return getResolver;
      }()
    }, {
      key: "getAvatar",
      value: function () {
        var _getAvatar = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee26(name) {
          var resolver;
          return _regeneratorRuntime().wrap(function _callee26$(_context26) {
            while (1) switch (_context26.prev = _context26.next) {
              case 0:
                _context26.next = 2;
                return this.getResolver(name);
              case 2:
                resolver = _context26.sent;
                if (!resolver) {
                  _context26.next = 7;
                  break;
                }
                _context26.next = 6;
                return resolver.getAvatar();
              case 6:
                return _context26.abrupt("return", _context26.sent);
              case 7:
                return _context26.abrupt("return", null);
              case 8:
              case "end":
                return _context26.stop();
            }
          }, _callee26, this);
        }));
        function getAvatar(_x26) {
          return _getAvatar.apply(this, arguments);
        }
        return getAvatar;
      }()
    }, {
      key: "resolveName",
      value: function () {
        var _resolveName = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee27(name) {
          var resolver;
          return _regeneratorRuntime().wrap(function _callee27$(_context27) {
            while (1) switch (_context27.prev = _context27.next) {
              case 0:
                _context27.next = 2;
                return this.getResolver(name);
              case 2:
                resolver = _context27.sent;
                if (!resolver) {
                  _context27.next = 7;
                  break;
                }
                _context27.next = 6;
                return resolver.getAddress();
              case 6:
                return _context27.abrupt("return", _context27.sent);
              case 7:
                return _context27.abrupt("return", null);
              case 8:
              case "end":
                return _context27.stop();
            }
          }, _callee27, this);
        }));
        function resolveName(_x27) {
          return _resolveName.apply(this, arguments);
        }
        return resolveName;
      }()
    }, {
      key: "lookupAddress",
      value: function () {
        var _lookupAddress = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee28(address) {
          var node, ensAddr, ensContract, resolver, resolverContract, name, check;
          return _regeneratorRuntime().wrap(function _callee28$(_context28) {
            while (1) switch (_context28.prev = _context28.next) {
              case 0:
                address = (0, index_js_1.getAddress)(address);
                node = (0, index_js_4.namehash)(address.substring(2).toLowerCase() + ".addr.reverse");
                _context28.prev = 2;
                _context28.next = 5;
                return ens_resolver_js_1.EnsResolver.getEnsAddress(this);
              case 5:
                ensAddr = _context28.sent;
                ensContract = new index_js_3.Contract(ensAddr, ["function resolver(bytes32) view returns (address)"], this);
                _context28.next = 9;
                return ensContract.resolver(node);
              case 9:
                resolver = _context28.sent;
                if (!(resolver == null || resolver === index_js_2.ZeroAddress)) {
                  _context28.next = 12;
                  break;
                }
                return _context28.abrupt("return", null);
              case 12:
                resolverContract = new index_js_3.Contract(resolver, ["function name(bytes32) view returns (string)"], this);
                _context28.next = 15;
                return resolverContract.name(node);
              case 15:
                name = _context28.sent;
                _context28.next = 18;
                return this.resolveName(name);
              case 18:
                check = _context28.sent;
                if (!(check !== address)) {
                  _context28.next = 21;
                  break;
                }
                return _context28.abrupt("return", null);
              case 21:
                return _context28.abrupt("return", name);
              case 24:
                _context28.prev = 24;
                _context28.t0 = _context28["catch"](2);
                if (!((0, index_js_6.isError)(_context28.t0, "BAD_DATA") && _context28.t0.value === "0x")) {
                  _context28.next = 28;
                  break;
                }
                return _context28.abrupt("return", null);
              case 28:
                if (!(0, index_js_6.isError)(_context28.t0, "CALL_EXCEPTION")) {
                  _context28.next = 30;
                  break;
                }
                return _context28.abrupt("return", null);
              case 30:
                throw _context28.t0;
              case 31:
                return _context28.abrupt("return", null);
              case 32:
              case "end":
                return _context28.stop();
            }
          }, _callee28, this, [[2, 24]]);
        }));
        function lookupAddress(_x28) {
          return _lookupAddress.apply(this, arguments);
        }
        return lookupAddress;
      }()
    }, {
      key: "waitForTransaction",
      value: function () {
        var _waitForTransaction = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee31(hash, _confirms, timeout) {
          var _this6 = this;
          var confirms;
          return _regeneratorRuntime().wrap(function _callee31$(_context31) {
            while (1) switch (_context31.prev = _context31.next) {
              case 0:
                confirms = _confirms != null ? _confirms : 1;
                if (!(confirms === 0)) {
                  _context31.next = 3;
                  break;
                }
                return _context31.abrupt("return", this.getTransactionReceipt(hash));
              case 3:
                return _context31.abrupt("return", new Promise(/*#__PURE__*/function () {
                  var _ref8 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee30(resolve, reject) {
                    var timer, _listener;
                    return _regeneratorRuntime().wrap(function _callee30$(_context30) {
                      while (1) switch (_context30.prev = _context30.next) {
                        case 0:
                          timer = null;
                          _listener = /*#__PURE__*/function () {
                            var _ref9 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee29(blockNumber) {
                              var receipt;
                              return _regeneratorRuntime().wrap(function _callee29$(_context29) {
                                while (1) switch (_context29.prev = _context29.next) {
                                  case 0:
                                    _context29.prev = 0;
                                    _context29.next = 3;
                                    return _this6.getTransactionReceipt(hash);
                                  case 3:
                                    receipt = _context29.sent;
                                    if (!(receipt != null)) {
                                      _context29.next = 9;
                                      break;
                                    }
                                    if (!(blockNumber - receipt.blockNumber + 1 >= confirms)) {
                                      _context29.next = 9;
                                      break;
                                    }
                                    resolve(receipt);
                                    //this.off("block", listener);
                                    if (timer) {
                                      clearTimeout(timer);
                                      timer = null;
                                    }
                                    return _context29.abrupt("return");
                                  case 9:
                                    _context29.next = 14;
                                    break;
                                  case 11:
                                    _context29.prev = 11;
                                    _context29.t0 = _context29["catch"](0);
                                    console.log("EEE", _context29.t0);
                                  case 14:
                                    _this6.once("block", _listener);
                                  case 15:
                                  case "end":
                                    return _context29.stop();
                                }
                              }, _callee29, null, [[0, 11]]);
                            }));
                            return function listener(_x34) {
                              return _ref9.apply(this, arguments);
                            };
                          }();
                          if (timeout != null) {
                            timer = setTimeout(function () {
                              if (timer == null) {
                                return;
                              }
                              timer = null;
                              _this6.off("block", _listener);
                              reject((0, index_js_6.makeError)("timeout", "TIMEOUT", {
                                reason: "timeout"
                              }));
                            }, timeout);
                          }
                          _context30.t0 = _listener;
                          _context30.next = 6;
                          return _this6.getBlockNumber();
                        case 6:
                          _context30.t1 = _context30.sent;
                          (0, _context30.t0)(_context30.t1);
                        case 8:
                        case "end":
                          return _context30.stop();
                      }
                    }, _callee30);
                  }));
                  return function (_x32, _x33) {
                    return _ref8.apply(this, arguments);
                  };
                }()));
              case 4:
              case "end":
                return _context31.stop();
            }
          }, _callee31, this);
        }));
        function waitForTransaction(_x29, _x30, _x31) {
          return _waitForTransaction.apply(this, arguments);
        }
        return waitForTransaction;
      }()
    }, {
      key: "waitForBlock",
      value: function () {
        var _waitForBlock = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee32(blockTag) {
          return _regeneratorRuntime().wrap(function _callee32$(_context32) {
            while (1) switch (_context32.prev = _context32.next) {
              case 0:
                (0, index_js_6.assert)(false, "not implemented yet", "NOT_IMPLEMENTED", {
                  operation: "waitForBlock"
                });
              case 1:
              case "end":
                return _context32.stop();
            }
          }, _callee32);
        }));
        function waitForBlock(_x35) {
          return _waitForBlock.apply(this, arguments);
        }
        return waitForBlock;
      }()
      /**
       *  Clear a timer created using the [[_setTimeout]] method.
       */
    }, {
      key: "_clearTimeout",
      value: function _clearTimeout(timerId) {
        var timer = _classPrivateFieldGet2(_timers, this).get(timerId);
        if (!timer) {
          return;
        }
        if (timer.timer) {
          clearTimeout(timer.timer);
        }
        _classPrivateFieldGet2(_timers, this)["delete"](timerId);
      }
      /**
       *  Create a timer that will execute %%func%% after at least %%timeout%%
       *  (in ms). If %%timeout%% is unspecified, then %%func%% will execute
       *  in the next event loop.
       *
       *  [Pausing](AbstractProvider-paused) the provider will pause any
       *  associated timers.
       */
    }, {
      key: "_setTimeout",
      value: function _setTimeout(_func, timeout) {
        var _this$nextTimer,
          _this$nextTimer2,
          _this7 = this;
        if (timeout == null) {
          timeout = 0;
        }
        var timerId = (_classPrivateFieldSet2(_nextTimer, this, (_this$nextTimer = _classPrivateFieldGet2(_nextTimer, this), _this$nextTimer2 = _this$nextTimer++, _this$nextTimer)), _this$nextTimer2);
        var func = function func() {
          _classPrivateFieldGet2(_timers, _this7)["delete"](timerId);
          _func();
        };
        if (this.paused) {
          _classPrivateFieldGet2(_timers, this).set(timerId, {
            timer: null,
            func: func,
            time: timeout
          });
        } else {
          var timer = setTimeout(func, timeout);
          _classPrivateFieldGet2(_timers, this).set(timerId, {
            timer: timer,
            func: func,
            time: getTime()
          });
        }
        return timerId;
      }
      /**
       *  Perform %%func%% on each subscriber.
       */
    }, {
      key: "_forEachSubscriber",
      value: function _forEachSubscriber(func) {
        var _iterator2 = _createForOfIteratorHelper(_classPrivateFieldGet2(_subs, this).values()),
          _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var sub = _step2.value;
            func(sub.subscriber);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      }
      /**
       *  Sub-classes may override this to customize subscription
       *  implementations.
       */
    }, {
      key: "_getSubscriber",
      value: function _getSubscriber(sub) {
        switch (sub.type) {
          case "debug":
          case "error":
          case "network":
            return new UnmanagedSubscriber(sub.type);
          case "block":
            {
              var subscriber = new subscriber_polling_js_1.PollingBlockSubscriber(this);
              subscriber.pollingInterval = this.pollingInterval;
              return subscriber;
            }
          case "safe":
          case "finalized":
            return new subscriber_polling_js_1.PollingBlockTagSubscriber(this, sub.type);
          case "event":
            return new subscriber_polling_js_1.PollingEventSubscriber(this, sub.filter);
          case "transaction":
            return new subscriber_polling_js_1.PollingTransactionSubscriber(this, sub.hash);
          case "orphan":
            return new subscriber_polling_js_1.PollingOrphanSubscriber(this, sub.filter);
        }
        throw new Error("unsupported event: ".concat(sub.type));
      }
      /**
       *  If a [[Subscriber]] fails and needs to replace itself, this
       *  method may be used.
       *
       *  For example, this is used for providers when using the
       *  ``eth_getFilterChanges`` method, which can return null if state
       *  filters are not supported by the backend, allowing the Subscriber
       *  to swap in a [[PollingEventSubscriber]].
       */
    }, {
      key: "_recoverSubscriber",
      value: function _recoverSubscriber(oldSub, newSub) {
        var _iterator3 = _createForOfIteratorHelper(_classPrivateFieldGet2(_subs, this).values()),
          _step3;
        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var sub = _step3.value;
            if (sub.subscriber === oldSub) {
              if (sub.started) {
                sub.subscriber.stop();
              }
              sub.subscriber = newSub;
              if (sub.started) {
                newSub.start();
              }
              if (_classPrivateFieldGet2(_pausedState, this) != null) {
                newSub.pause(_classPrivateFieldGet2(_pausedState, this));
              }
              break;
            }
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
      }
    }, {
      key: "on",
      value: function () {
        var _on = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee33(event, listener) {
          var sub;
          return _regeneratorRuntime().wrap(function _callee33$(_context33) {
            while (1) switch (_context33.prev = _context33.next) {
              case 0:
                _context33.next = 2;
                return _assertClassBrand(_AbstractProvider_brand, this, _getSub).call(this, event);
              case 2:
                sub = _context33.sent;
                sub.listeners.push({
                  listener: listener,
                  once: false
                });
                if (!sub.started) {
                  sub.subscriber.start();
                  sub.started = true;
                  if (_classPrivateFieldGet2(_pausedState, this) != null) {
                    sub.subscriber.pause(_classPrivateFieldGet2(_pausedState, this));
                  }
                }
                return _context33.abrupt("return", this);
              case 6:
              case "end":
                return _context33.stop();
            }
          }, _callee33, this);
        }));
        function on(_x36, _x37) {
          return _on.apply(this, arguments);
        }
        return on;
      }()
    }, {
      key: "once",
      value: function () {
        var _once = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee34(event, listener) {
          var sub;
          return _regeneratorRuntime().wrap(function _callee34$(_context34) {
            while (1) switch (_context34.prev = _context34.next) {
              case 0:
                _context34.next = 2;
                return _assertClassBrand(_AbstractProvider_brand, this, _getSub).call(this, event);
              case 2:
                sub = _context34.sent;
                sub.listeners.push({
                  listener: listener,
                  once: true
                });
                if (!sub.started) {
                  sub.subscriber.start();
                  sub.started = true;
                  if (_classPrivateFieldGet2(_pausedState, this) != null) {
                    sub.subscriber.pause(_classPrivateFieldGet2(_pausedState, this));
                  }
                }
                return _context34.abrupt("return", this);
              case 6:
              case "end":
                return _context34.stop();
            }
          }, _callee34, this);
        }));
        function once(_x38, _x39) {
          return _once.apply(this, arguments);
        }
        return once;
      }()
    }, {
      key: "emit",
      value: function () {
        var _emit = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee35(event) {
          var _this8 = this;
          var _len,
            args,
            _key,
            sub,
            count,
            _args35 = arguments;
          return _regeneratorRuntime().wrap(function _callee35$(_context35) {
            while (1) switch (_context35.prev = _context35.next) {
              case 0:
                for (_len = _args35.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                  args[_key - 1] = _args35[_key];
                }
                _context35.next = 3;
                return _assertClassBrand(_AbstractProvider_brand, this, _hasSub).call(this, event, args);
              case 3:
                sub = _context35.sent;
                if (!(!sub || sub.listeners.length === 0)) {
                  _context35.next = 6;
                  break;
                }
                return _context35.abrupt("return", false);
              case 6:
                count = sub.listeners.length;
                sub.listeners = sub.listeners.filter(function (_ref10) {
                  var listener = _ref10.listener,
                    once = _ref10.once;
                  var payload = new index_js_6.EventPayload(_this8, once ? null : listener, event);
                  try {
                    listener.call.apply(listener, [_this8].concat(args, [payload]));
                  } catch (error) {}
                  return !once;
                });
                if (sub.listeners.length === 0) {
                  if (sub.started) {
                    sub.subscriber.stop();
                  }
                  _classPrivateFieldGet2(_subs, this)["delete"](sub.tag);
                }
                return _context35.abrupt("return", count > 0);
              case 11:
              case "end":
                return _context35.stop();
            }
          }, _callee35, this);
        }));
        function emit(_x40) {
          return _emit.apply(this, arguments);
        }
        return emit;
      }()
    }, {
      key: "listenerCount",
      value: function () {
        var _listenerCount = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee36(event) {
          var sub, total, _iterator4, _step4, listeners;
          return _regeneratorRuntime().wrap(function _callee36$(_context36) {
            while (1) switch (_context36.prev = _context36.next) {
              case 0:
                if (!event) {
                  _context36.next = 7;
                  break;
                }
                _context36.next = 3;
                return _assertClassBrand(_AbstractProvider_brand, this, _hasSub).call(this, event);
              case 3:
                sub = _context36.sent;
                if (sub) {
                  _context36.next = 6;
                  break;
                }
                return _context36.abrupt("return", 0);
              case 6:
                return _context36.abrupt("return", sub.listeners.length);
              case 7:
                total = 0;
                _iterator4 = _createForOfIteratorHelper(_classPrivateFieldGet2(_subs, this).values());
                try {
                  for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                    listeners = _step4.value.listeners;
                    total += listeners.length;
                  }
                } catch (err) {
                  _iterator4.e(err);
                } finally {
                  _iterator4.f();
                }
                return _context36.abrupt("return", total);
              case 11:
              case "end":
                return _context36.stop();
            }
          }, _callee36, this);
        }));
        function listenerCount(_x41) {
          return _listenerCount.apply(this, arguments);
        }
        return listenerCount;
      }()
    }, {
      key: "listeners",
      value: function () {
        var _listeners = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee37(event) {
          var sub, result, _iterator5, _step5, _listeners2;
          return _regeneratorRuntime().wrap(function _callee37$(_context37) {
            while (1) switch (_context37.prev = _context37.next) {
              case 0:
                if (!event) {
                  _context37.next = 7;
                  break;
                }
                _context37.next = 3;
                return _assertClassBrand(_AbstractProvider_brand, this, _hasSub).call(this, event);
              case 3:
                sub = _context37.sent;
                if (sub) {
                  _context37.next = 6;
                  break;
                }
                return _context37.abrupt("return", []);
              case 6:
                return _context37.abrupt("return", sub.listeners.map(function (_ref11) {
                  var listener = _ref11.listener;
                  return listener;
                }));
              case 7:
                result = [];
                _iterator5 = _createForOfIteratorHelper(_classPrivateFieldGet2(_subs, this).values());
                try {
                  for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
                    _listeners2 = _step5.value.listeners;
                    result = result.concat(_listeners2.map(function (_ref12) {
                      var listener = _ref12.listener;
                      return listener;
                    }));
                  }
                } catch (err) {
                  _iterator5.e(err);
                } finally {
                  _iterator5.f();
                }
                return _context37.abrupt("return", result);
              case 11:
              case "end":
                return _context37.stop();
            }
          }, _callee37, this);
        }));
        function listeners(_x42) {
          return _listeners.apply(this, arguments);
        }
        return listeners;
      }()
    }, {
      key: "off",
      value: function () {
        var _off = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee38(event, listener) {
          var sub, index;
          return _regeneratorRuntime().wrap(function _callee38$(_context38) {
            while (1) switch (_context38.prev = _context38.next) {
              case 0:
                _context38.next = 2;
                return _assertClassBrand(_AbstractProvider_brand, this, _hasSub).call(this, event);
              case 2:
                sub = _context38.sent;
                if (sub) {
                  _context38.next = 5;
                  break;
                }
                return _context38.abrupt("return", this);
              case 5:
                if (listener) {
                  index = sub.listeners.map(function (_ref13) {
                    var listener = _ref13.listener;
                    return listener;
                  }).indexOf(listener);
                  if (index >= 0) {
                    sub.listeners.splice(index, 1);
                  }
                }
                if (!listener || sub.listeners.length === 0) {
                  if (sub.started) {
                    sub.subscriber.stop();
                  }
                  _classPrivateFieldGet2(_subs, this)["delete"](sub.tag);
                }
                return _context38.abrupt("return", this);
              case 8:
              case "end":
                return _context38.stop();
            }
          }, _callee38, this);
        }));
        function off(_x43, _x44) {
          return _off.apply(this, arguments);
        }
        return off;
      }()
    }, {
      key: "removeAllListeners",
      value: function () {
        var _removeAllListeners = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee39(event) {
          var _yield$_assertClassBr, tag, started, subscriber, _iterator6, _step6, _step6$value, _tag, _step6$value$, _started, _subscriber;
          return _regeneratorRuntime().wrap(function _callee39$(_context39) {
            while (1) switch (_context39.prev = _context39.next) {
              case 0:
                if (!event) {
                  _context39.next = 11;
                  break;
                }
                _context39.next = 3;
                return _assertClassBrand(_AbstractProvider_brand, this, _getSub).call(this, event);
              case 3:
                _yield$_assertClassBr = _context39.sent;
                tag = _yield$_assertClassBr.tag;
                started = _yield$_assertClassBr.started;
                subscriber = _yield$_assertClassBr.subscriber;
                if (started) {
                  subscriber.stop();
                }
                _classPrivateFieldGet2(_subs, this)["delete"](tag);
                _context39.next = 13;
                break;
              case 11:
                _iterator6 = _createForOfIteratorHelper(_classPrivateFieldGet2(_subs, this));
                try {
                  for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
                    _step6$value = _slicedToArray(_step6.value, 2), _tag = _step6$value[0], _step6$value$ = _step6$value[1], _started = _step6$value$.started, _subscriber = _step6$value$.subscriber;
                    if (_started) {
                      _subscriber.stop();
                    }
                    _classPrivateFieldGet2(_subs, this)["delete"](_tag);
                  }
                } catch (err) {
                  _iterator6.e(err);
                } finally {
                  _iterator6.f();
                }
              case 13:
                return _context39.abrupt("return", this);
              case 14:
              case "end":
                return _context39.stop();
            }
          }, _callee39, this);
        }));
        function removeAllListeners(_x45) {
          return _removeAllListeners.apply(this, arguments);
        }
        return removeAllListeners;
      }() // Alias for "on"
    }, {
      key: "addListener",
      value: function () {
        var _addListener = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee40(event, listener) {
          return _regeneratorRuntime().wrap(function _callee40$(_context40) {
            while (1) switch (_context40.prev = _context40.next) {
              case 0:
                _context40.next = 2;
                return this.on(event, listener);
              case 2:
                return _context40.abrupt("return", _context40.sent);
              case 3:
              case "end":
                return _context40.stop();
            }
          }, _callee40, this);
        }));
        function addListener(_x46, _x47) {
          return _addListener.apply(this, arguments);
        }
        return addListener;
      }() // Alias for "off"
    }, {
      key: "removeListener",
      value: function () {
        var _removeListener = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee41(event, listener) {
          return _regeneratorRuntime().wrap(function _callee41$(_context41) {
            while (1) switch (_context41.prev = _context41.next) {
              case 0:
                return _context41.abrupt("return", this.off(event, listener));
              case 1:
              case "end":
                return _context41.stop();
            }
          }, _callee41, this);
        }));
        function removeListener(_x48, _x49) {
          return _removeListener.apply(this, arguments);
        }
        return removeListener;
      }()
      /**
       *  If this provider has been destroyed using the [[destroy]] method.
       *
       *  Once destroyed, all resources are reclaimed, internal event loops
       *  and timers are cleaned up and no further requests may be sent to
       *  the provider.
       */
    }, {
      key: "destroyed",
      get: function get() {
        return _classPrivateFieldGet2(_destroyed, this);
      }
      /**
       *  Sub-classes may use this to shutdown any sockets or release their
       *  resources and reject any pending requests.
       *
       *  Sub-classes **must** call ``super.destroy()``.
       */
    }, {
      key: "destroy",
      value: function destroy() {
        // Stop all listeners
        this.removeAllListeners();
        // Shut down all tiemrs
        var _iterator7 = _createForOfIteratorHelper(_classPrivateFieldGet2(_timers, this).keys()),
          _step7;
        try {
          for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
            var timerId = _step7.value;
            this._clearTimeout(timerId);
          }
        } catch (err) {
          _iterator7.e(err);
        } finally {
          _iterator7.f();
        }
        _classPrivateFieldSet2(_destroyed, this, true);
      }
      /**
       *  Whether the provider is currently paused.
       *
       *  A paused provider will not emit any events, and generally should
       *  not make any requests to the network, but that is up to sub-classes
       *  to manage.
       *
       *  Setting ``paused = true`` is identical to calling ``.pause(false)``,
       *  which will buffer any events that occur while paused until the
       *  provider is unpaused.
       */
    }, {
      key: "paused",
      get: function get() {
        return _classPrivateFieldGet2(_pausedState, this) != null;
      },
      set: function set(pause) {
        if (!!pause === this.paused) {
          return;
        }
        if (this.paused) {
          this.resume();
        } else {
          this.pause(false);
        }
      }
      /**
       *  Pause the provider. If %%dropWhilePaused%%, any events that occur
       *  while paused are dropped, otherwise all events will be emitted once
       *  the provider is unpaused.
       */
    }, {
      key: "pause",
      value: function pause(dropWhilePaused) {
        _classPrivateFieldSet2(_lastBlockNumber, this, -1);
        if (_classPrivateFieldGet2(_pausedState, this) != null) {
          if (_classPrivateFieldGet2(_pausedState, this) == !!dropWhilePaused) {
            return;
          }
          (0, index_js_6.assert)(false, "cannot change pause type; resume first", "UNSUPPORTED_OPERATION", {
            operation: "pause"
          });
        }
        this._forEachSubscriber(function (s) {
          return s.pause(dropWhilePaused);
        });
        _classPrivateFieldSet2(_pausedState, this, !!dropWhilePaused);
        var _iterator8 = _createForOfIteratorHelper(_classPrivateFieldGet2(_timers, this).values()),
          _step8;
        try {
          for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
            var timer = _step8.value;
            // Clear the timer
            if (timer.timer) {
              clearTimeout(timer.timer);
            }
            // Remaining time needed for when we become unpaused
            timer.time = getTime() - timer.time;
          }
        } catch (err) {
          _iterator8.e(err);
        } finally {
          _iterator8.f();
        }
      }
      /**
       *  Resume the provider.
       */
    }, {
      key: "resume",
      value: function resume() {
        if (_classPrivateFieldGet2(_pausedState, this) == null) {
          return;
        }
        this._forEachSubscriber(function (s) {
          return s.resume();
        });
        _classPrivateFieldSet2(_pausedState, this, null);
        var _iterator9 = _createForOfIteratorHelper(_classPrivateFieldGet2(_timers, this).values()),
          _step9;
        try {
          for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
            var timer = _step9.value;
            // Remaining time when we were paused
            var timeout = timer.time;
            if (timeout < 0) {
              timeout = 0;
            }
            // Start time (in cause paused, so we con compute remaininf time)
            timer.time = getTime();
            // Start the timer
            setTimeout(timer.func, timeout);
          }
        } catch (err) {
          _iterator9.e(err);
        } finally {
          _iterator9.f();
        }
      }
    }]);
  }();
  function _perform(_x50) {
    return _perform3.apply(this, arguments);
  }
  function _perform3() {
    _perform3 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee44(req) {
      var _this9 = this;
      var timeout, tag, perform;
      return _regeneratorRuntime().wrap(function _callee44$(_context44) {
        while (1) switch (_context44.prev = _context44.next) {
          case 0:
            timeout = _classPrivateFieldGet2(_options, this).cacheTimeout; // Caching disabled
            if (!(timeout < 0)) {
              _context44.next = 5;
              break;
            }
            _context44.next = 4;
            return this._perform(req);
          case 4:
            return _context44.abrupt("return", _context44.sent);
          case 5:
            // Create a tag
            tag = getTag(req.method, req);
            perform = _classPrivateFieldGet2(_performCache, this).get(tag);
            if (!perform) {
              perform = this._perform(req);
              _classPrivateFieldGet2(_performCache, this).set(tag, perform);
              setTimeout(function () {
                if (_classPrivateFieldGet2(_performCache, _this9).get(tag) === perform) {
                  _classPrivateFieldGet2(_performCache, _this9)["delete"](tag);
                }
              }, timeout);
            }
            _context44.next = 10;
            return perform;
          case 10:
            return _context44.abrupt("return", _context44.sent);
          case 11:
          case "end":
            return _context44.stop();
        }
      }, _callee44, this);
    }));
    return _perform3.apply(this, arguments);
  }
  function _call(_x51, _x52, _x53) {
    return _call3.apply(this, arguments);
  }
  function _call3() {
    _call3 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee45(tx, blockTag, attempt) {
      var transaction, data, txSender, ccipArgs, ccipResult, _tx2, result;
      return _regeneratorRuntime().wrap(function _callee45$(_context45) {
        while (1) switch (_context45.prev = _context45.next) {
          case 0:
            (0, index_js_6.assert)(attempt < MAX_CCIP_REDIRECTS, "CCIP read exceeded maximum redirections", "OFFCHAIN_FAULT", {
              reason: "TOO_MANY_REDIRECTS",
              transaction: Object.assign({}, tx, {
                blockTag: blockTag,
                enableCcipRead: true
              })
            });
            // This came in as a PerformActionTransaction, so to/from are safe; we can cast
            transaction = (0, provider_js_1.copyRequest)(tx);
            _context45.prev = 2;
            _context45.t0 = (index_js_6.hexlify);
            _context45.next = 6;
            return this._perform({
              method: "call",
              transaction: transaction,
              blockTag: blockTag
            });
          case 6:
            _context45.t1 = _context45.sent;
            return _context45.abrupt("return", (0, _context45.t0)(_context45.t1));
          case 10:
            _context45.prev = 10;
            _context45.t2 = _context45["catch"](2);
            if (!(!this.disableCcipRead && (0, index_js_6.isCallException)(_context45.t2) && _context45.t2.data && attempt >= 0 && blockTag === "latest" && transaction.to != null && (0, index_js_6.dataSlice)(_context45.t2.data, 0, 4) === "0x556f1830")) {
              _context45.next = 37;
              break;
            }
            data = _context45.t2.data;
            _context45.next = 16;
            return (0, index_js_1.resolveAddress)(transaction.to, this);
          case 16:
            txSender = _context45.sent;
            try {
              ccipArgs = parseOffchainLookup((0, index_js_6.dataSlice)(_context45.t2.data, 4));
            } catch (error) {
              (0, index_js_6.assert)(false, error.message, "OFFCHAIN_FAULT", {
                reason: "BAD_DATA",
                transaction: transaction,
                info: {
                  data: data
                }
              });
            }
            // Check the sender of the OffchainLookup matches the transaction
            (0, index_js_6.assert)(ccipArgs.sender.toLowerCase() === txSender.toLowerCase(), "CCIP Read sender mismatch", "CALL_EXCEPTION", {
              action: "call",
              data: data,
              reason: "OffchainLookup",
              transaction: transaction,
              invocation: null,
              revert: {
                signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                name: "OffchainLookup",
                args: ccipArgs.errorArgs
              }
            });
            _context45.next = 21;
            return this.ccipReadFetch(transaction, ccipArgs.calldata, ccipArgs.urls);
          case 21:
            ccipResult = _context45.sent;
            (0, index_js_6.assert)(ccipResult != null, "CCIP Read failed to fetch data", "OFFCHAIN_FAULT", {
              reason: "FETCH_FAILED",
              transaction: transaction,
              info: {
                data: _context45.t2.data,
                errorArgs: ccipArgs.errorArgs
              }
            });
            _tx2 = {
              to: txSender,
              data: (0, index_js_6.concat)([ccipArgs.selector, encodeBytes([ccipResult, ccipArgs.extraData])])
            };
            this.emit("debug", {
              action: "sendCcipReadCall",
              transaction: _tx2
            });
            _context45.prev = 25;
            _context45.next = 28;
            return _assertClassBrand(_AbstractProvider_brand, this, _call).call(this, _tx2, blockTag, attempt + 1);
          case 28:
            result = _context45.sent;
            this.emit("debug", {
              action: "receiveCcipReadCallResult",
              transaction: Object.assign({}, _tx2),
              result: result
            });
            return _context45.abrupt("return", result);
          case 33:
            _context45.prev = 33;
            _context45.t3 = _context45["catch"](25);
            this.emit("debug", {
              action: "receiveCcipReadCallError",
              transaction: Object.assign({}, _tx2),
              error: _context45.t3
            });
            throw _context45.t3;
          case 37:
            throw _context45.t2;
          case 38:
          case "end":
            return _context45.stop();
        }
      }, _callee45, this, [[2, 10], [25, 33]]);
    }));
    return _call3.apply(this, arguments);
  }
  function _checkNetwork(_x54) {
    return _checkNetwork2.apply(this, arguments);
  }
  function _checkNetwork2() {
    _checkNetwork2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee46(promise) {
      var _yield9, value;
      return _regeneratorRuntime().wrap(function _callee46$(_context46) {
        while (1) switch (_context46.prev = _context46.next) {
          case 0:
            _context46.next = 2;
            return (0, index_js_6.resolveProperties)({
              network: this.getNetwork(),
              value: promise
            });
          case 2:
            _yield9 = _context46.sent;
            value = _yield9.value;
            return _context46.abrupt("return", value);
          case 5:
          case "end":
            return _context46.stop();
        }
      }, _callee46, this);
    }));
    return _checkNetwork2.apply(this, arguments);
  }
  function _getAccountValue(_x55, _x56, _x57) {
    return _getAccountValue2.apply(this, arguments);
  }
  function _getAccountValue2() {
    _getAccountValue2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee47(request, _address, _blockTag) {
      var address, blockTag, _yield$Promise$all3, _yield$Promise$all4;
      return _regeneratorRuntime().wrap(function _callee47$(_context47) {
        while (1) switch (_context47.prev = _context47.next) {
          case 0:
            address = this._getAddress(_address);
            blockTag = this._getBlockTag(_blockTag);
            if (!(typeof address !== "string" || typeof blockTag !== "string")) {
              _context47.next = 9;
              break;
            }
            _context47.next = 5;
            return Promise.all([address, blockTag]);
          case 5:
            _yield$Promise$all3 = _context47.sent;
            _yield$Promise$all4 = _slicedToArray(_yield$Promise$all3, 2);
            address = _yield$Promise$all4[0];
            blockTag = _yield$Promise$all4[1];
          case 9:
            _context47.next = 11;
            return _assertClassBrand(_AbstractProvider_brand, this, _checkNetwork).call(this, _assertClassBrand(_AbstractProvider_brand, this, _perform).call(this, Object.assign(request, {
              address: address,
              blockTag: blockTag
            })));
          case 11:
            return _context47.abrupt("return", _context47.sent);
          case 12:
          case "end":
            return _context47.stop();
        }
      }, _callee47, this);
    }));
    return _getAccountValue2.apply(this, arguments);
  }
  function _getBlock(_x58, _x59) {
    return _getBlock3.apply(this, arguments);
  }
  function _getBlock3() {
    _getBlock3 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee48(block, includeTransactions) {
      var blockTag;
      return _regeneratorRuntime().wrap(function _callee48$(_context48) {
        while (1) switch (_context48.prev = _context48.next) {
          case 0:
            if (!(0, index_js_6.isHexString)(block, 32)) {
              _context48.next = 4;
              break;
            }
            _context48.next = 3;
            return _assertClassBrand(_AbstractProvider_brand, this, _perform).call(this, {
              method: "getBlock",
              blockHash: block,
              includeTransactions: includeTransactions
            });
          case 3:
            return _context48.abrupt("return", _context48.sent);
          case 4:
            blockTag = this._getBlockTag(block);
            if (!(typeof blockTag !== "string")) {
              _context48.next = 9;
              break;
            }
            _context48.next = 8;
            return blockTag;
          case 8:
            blockTag = _context48.sent;
          case 9:
            _context48.next = 11;
            return _assertClassBrand(_AbstractProvider_brand, this, _perform).call(this, {
              method: "getBlock",
              blockTag: blockTag,
              includeTransactions: includeTransactions
            });
          case 11:
            return _context48.abrupt("return", _context48.sent);
          case 12:
          case "end":
            return _context48.stop();
        }
      }, _callee48, this);
    }));
    return _getBlock3.apply(this, arguments);
  }
  function _hasSub(_x60, _x61) {
    return _hasSub2.apply(this, arguments);
  }
  function _hasSub2() {
    _hasSub2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee49(event, emitArgs) {
      var sub;
      return _regeneratorRuntime().wrap(function _callee49$(_context49) {
        while (1) switch (_context49.prev = _context49.next) {
          case 0:
            _context49.next = 2;
            return getSubscription(event, this);
          case 2:
            sub = _context49.sent;
            if (!(sub.type === "event" && emitArgs && emitArgs.length > 0 && emitArgs[0].removed === true)) {
              _context49.next = 7;
              break;
            }
            _context49.next = 6;
            return getSubscription({
              orphan: "drop-log",
              log: emitArgs[0]
            }, this);
          case 6:
            sub = _context49.sent;
          case 7:
            return _context49.abrupt("return", _classPrivateFieldGet2(_subs, this).get(sub.tag) || null);
          case 8:
          case "end":
            return _context49.stop();
        }
      }, _callee49, this);
    }));
    return _hasSub2.apply(this, arguments);
  }
  function _getSub(_x62) {
    return _getSub2.apply(this, arguments);
  }
  function _getSub2() {
    _getSub2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee50(event) {
      var subscription, tag, sub, subscriber, addressableMap, nameMap;
      return _regeneratorRuntime().wrap(function _callee50$(_context50) {
        while (1) switch (_context50.prev = _context50.next) {
          case 0:
            _context50.next = 2;
            return getSubscription(event, this);
          case 2:
            subscription = _context50.sent;
            // Prevent tampering with our tag in any subclass' _getSubscriber
            tag = subscription.tag;
            sub = _classPrivateFieldGet2(_subs, this).get(tag);
            if (!sub) {
              subscriber = this._getSubscriber(subscription);
              addressableMap = new WeakMap();
              nameMap = new Map();
              sub = {
                subscriber: subscriber,
                tag: tag,
                addressableMap: addressableMap,
                nameMap: nameMap,
                started: false,
                listeners: []
              };
              _classPrivateFieldGet2(_subs, this).set(tag, sub);
            }
            return _context50.abrupt("return", sub);
          case 7:
          case "end":
            return _context50.stop();
        }
      }, _callee50, this);
    }));
    return _getSub2.apply(this, arguments);
  }
  abstractProvider.AbstractProvider = AbstractProvider;
  function _parseString(result, start) {
    try {
      var bytes = _parseBytes(result, start);
      if (bytes) {
        return (0, index_js_6.toUtf8String)(bytes);
      }
    } catch (error) {}
    return null;
  }
  function _parseBytes(result, start) {
    if (result === "0x") {
      return null;
    }
    try {
      var offset = (0, index_js_6.getNumber)((0, index_js_6.dataSlice)(result, start, start + 32));
      var length = (0, index_js_6.getNumber)((0, index_js_6.dataSlice)(result, offset, offset + 32));
      return (0, index_js_6.dataSlice)(result, offset + 32, offset + 32 + length);
    } catch (error) {}
    return null;
  }
  function numPad(value) {
    var result = (0, index_js_6.toBeArray)(value);
    if (result.length > 32) {
      throw new Error("internal; should not happen");
    }
    var padded = new Uint8Array(32);
    padded.set(result, 32 - result.length);
    return padded;
  }
  function bytesPad(value) {
    if (value.length % 32 === 0) {
      return value;
    }
    var result = new Uint8Array(Math.ceil(value.length / 32) * 32);
    result.set(value);
    return result;
  }
  var empty = new Uint8Array([]);
  // ABI Encodes a series of (bytes, bytes, ...)
  function encodeBytes(datas) {
    var result = [];
    var byteCount = 0;
    // Add place-holders for pointers as we add items
    for (var i = 0; i < datas.length; i++) {
      result.push(empty);
      byteCount += 32;
    }
    for (var _i = 0; _i < datas.length; _i++) {
      var data = (0, index_js_6.getBytes)(datas[_i]);
      // Update the bytes offset
      result[_i] = numPad(byteCount);
      // The length and padded value of data
      result.push(numPad(data.length));
      result.push(bytesPad(data));
      byteCount += 32 + Math.ceil(data.length / 32) * 32;
    }
    return (0, index_js_6.concat)(result);
  }
  var zeros = "0x0000000000000000000000000000000000000000000000000000000000000000";
  function parseOffchainLookup(data) {
    var result = {
      sender: "",
      urls: [],
      calldata: "",
      selector: "",
      extraData: "",
      errorArgs: []
    };
    (0, index_js_6.assert)((0, index_js_6.dataLength)(data) >= 5 * 32, "insufficient OffchainLookup data", "OFFCHAIN_FAULT", {
      reason: "insufficient OffchainLookup data"
    });
    var sender = (0, index_js_6.dataSlice)(data, 0, 32);
    (0, index_js_6.assert)((0, index_js_6.dataSlice)(sender, 0, 12) === (0, index_js_6.dataSlice)(zeros, 0, 12), "corrupt OffchainLookup sender", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup sender"
    });
    result.sender = (0, index_js_6.dataSlice)(sender, 12);
    // Read the URLs from the response
    try {
      var urls = [];
      var urlsOffset = (0, index_js_6.getNumber)((0, index_js_6.dataSlice)(data, 32, 64));
      var urlsLength = (0, index_js_6.getNumber)((0, index_js_6.dataSlice)(data, urlsOffset, urlsOffset + 32));
      var urlsData = (0, index_js_6.dataSlice)(data, urlsOffset + 32);
      for (var u = 0; u < urlsLength; u++) {
        var url = _parseString(urlsData, u * 32);
        if (url == null) {
          throw new Error("abort");
        }
        urls.push(url);
      }
      result.urls = urls;
    } catch (error) {
      (0, index_js_6.assert)(false, "corrupt OffchainLookup urls", "OFFCHAIN_FAULT", {
        reason: "corrupt OffchainLookup urls"
      });
    }
    // Get the CCIP calldata to forward
    try {
      var calldata = _parseBytes(data, 64);
      if (calldata == null) {
        throw new Error("abort");
      }
      result.calldata = calldata;
    } catch (error) {
      (0, index_js_6.assert)(false, "corrupt OffchainLookup calldata", "OFFCHAIN_FAULT", {
        reason: "corrupt OffchainLookup calldata"
      });
    }
    // Get the callbackSelector (bytes4)
    (0, index_js_6.assert)((0, index_js_6.dataSlice)(data, 100, 128) === (0, index_js_6.dataSlice)(zeros, 0, 28), "corrupt OffchainLookup callbaackSelector", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup callbaackSelector"
    });
    result.selector = (0, index_js_6.dataSlice)(data, 96, 100);
    // Get the extra data to send back to the contract as context
    try {
      var extraData = _parseBytes(data, 128);
      if (extraData == null) {
        throw new Error("abort");
      }
      result.extraData = extraData;
    } catch (error) {
      (0, index_js_6.assert)(false, "corrupt OffchainLookup extraData", "OFFCHAIN_FAULT", {
        reason: "corrupt OffchainLookup extraData"
      });
    }
    result.errorArgs = "sender,urls,calldata,selector,extraData".split(/,/).map(function (k) {
      return result[k];
    });
    return result;
  }
  return abstractProvider;
}

var abstractSigner = {};

var hasRequiredAbstractSigner;
function requireAbstractSigner() {
  if (hasRequiredAbstractSigner) return abstractSigner;
  hasRequiredAbstractSigner = 1;
  Object.defineProperty(abstractSigner, "__esModule", {
    value: true
  });
  abstractSigner.VoidSigner = abstractSigner.AbstractSigner = void 0;
  /**
   *  Generally the [[Wallet]] and [[JsonRpcSigner]] and their sub-classes
   *  are sufficent for most developers, but this is provided to
   *  fascilitate more complex Signers.
   *
   *  @_section: api/providers/abstract-signer: Subclassing Signer [abstract-signer]
   */
  var index_js_1 = /*@__PURE__*/requireAddress$2();
  var index_js_2 = /*@__PURE__*/requireTransaction();
  var index_js_3 = /*@__PURE__*/requireUtils$3();
  var provider_js_1 = /*@__PURE__*/requireProvider();
  function checkProvider(signer, operation) {
    if (signer.provider) {
      return signer.provider;
    }
    (0, index_js_3.assert)(false, "missing provider", "UNSUPPORTED_OPERATION", {
      operation: operation
    });
  }
  function populate(_x, _x2) {
    return _populate.apply(this, arguments);
  }
  /**
   *  An **AbstractSigner** includes most of teh functionality required
   *  to get a [[Signer]] working as expected, but requires a few
   *  Signer-specific methods be overridden.
   *
   */
  function _populate() {
    _populate = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee12(signer, tx) {
      var pop, from;
      return _regeneratorRuntime().wrap(function _callee12$(_context12) {
        while (1) switch (_context12.prev = _context12.next) {
          case 0:
            pop = (0, provider_js_1.copyRequest)(tx);
            if (pop.to != null) {
              pop.to = (0, index_js_1.resolveAddress)(pop.to, signer);
            }
            if (pop.from != null) {
              from = pop.from;
              pop.from = Promise.all([signer.getAddress(), (0, index_js_1.resolveAddress)(from, signer)]).then(function (_ref) {
                var _ref2 = _slicedToArray(_ref, 2),
                  address = _ref2[0],
                  from = _ref2[1];
                (0, index_js_3.assertArgument)(address.toLowerCase() === from.toLowerCase(), "transaction from mismatch", "tx.from", from);
                return address;
              });
            } else {
              pop.from = signer.getAddress();
            }
            _context12.next = 5;
            return (0, index_js_3.resolveProperties)(pop);
          case 5:
            return _context12.abrupt("return", _context12.sent);
          case 6:
          case "end":
            return _context12.stop();
        }
      }, _callee12);
    }));
    return _populate.apply(this, arguments);
  }
  var AbstractSigner = /*#__PURE__*/function () {
    /**
     *  Creates a new Signer connected to %%provider%%.
     */
    function AbstractSigner(provider) {
      _classCallCheck(this, AbstractSigner);
      /**
       *  The provider this signer is connected to.
       */
      _defineProperty(this, "provider", void 0);
      (0, index_js_3.defineProperties)(this, {
        provider: provider || null
      });
    }
    return _createClass(AbstractSigner, [{
      key: "getNonce",
      value: function () {
        var _getNonce = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(blockTag) {
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                _context.t0 = checkProvider(this, "getTransactionCount");
                _context.next = 3;
                return this.getAddress();
              case 3:
                _context.t1 = _context.sent;
                _context.t2 = blockTag;
                return _context.abrupt("return", _context.t0.getTransactionCount.call(_context.t0, _context.t1, _context.t2));
              case 6:
              case "end":
                return _context.stop();
            }
          }, _callee, this);
        }));
        function getNonce(_x3) {
          return _getNonce.apply(this, arguments);
        }
        return getNonce;
      }()
    }, {
      key: "populateCall",
      value: function () {
        var _populateCall = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(tx) {
          var pop;
          return _regeneratorRuntime().wrap(function _callee2$(_context2) {
            while (1) switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return populate(this, tx);
              case 2:
                pop = _context2.sent;
                return _context2.abrupt("return", pop);
              case 4:
              case "end":
                return _context2.stop();
            }
          }, _callee2, this);
        }));
        function populateCall(_x4) {
          return _populateCall.apply(this, arguments);
        }
        return populateCall;
      }()
    }, {
      key: "populateTransaction",
      value: function () {
        var _populateTransaction = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(tx) {
          var provider, pop, network, chainId, hasEip1559, feeData, _feeData, gasPrice;
          return _regeneratorRuntime().wrap(function _callee3$(_context3) {
            while (1) switch (_context3.prev = _context3.next) {
              case 0:
                provider = checkProvider(this, "populateTransaction");
                _context3.next = 3;
                return populate(this, tx);
              case 3:
                pop = _context3.sent;
                if (!(pop.nonce == null)) {
                  _context3.next = 8;
                  break;
                }
                _context3.next = 7;
                return this.getNonce("pending");
              case 7:
                pop.nonce = _context3.sent;
              case 8:
                if (!(pop.gasLimit == null)) {
                  _context3.next = 12;
                  break;
                }
                _context3.next = 11;
                return this.estimateGas(pop);
              case 11:
                pop.gasLimit = _context3.sent;
              case 12:
                _context3.next = 14;
                return this.provider.getNetwork();
              case 14:
                network = _context3.sent;
                if (pop.chainId != null) {
                  chainId = (0, index_js_3.getBigInt)(pop.chainId);
                  (0, index_js_3.assertArgument)(chainId === network.chainId, "transaction chainId mismatch", "tx.chainId", tx.chainId);
                } else {
                  pop.chainId = network.chainId;
                }
                // Do not allow mixing pre-eip-1559 and eip-1559 properties
                hasEip1559 = pop.maxFeePerGas != null || pop.maxPriorityFeePerGas != null;
                if (pop.gasPrice != null && (pop.type === 2 || hasEip1559)) {
                  (0, index_js_3.assertArgument)(false, "eip-1559 transaction do not support gasPrice", "tx", tx);
                } else if ((pop.type === 0 || pop.type === 1) && hasEip1559) {
                  (0, index_js_3.assertArgument)(false, "pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "tx", tx);
                }
                if (!((pop.type === 2 || pop.type == null) && pop.maxFeePerGas != null && pop.maxPriorityFeePerGas != null)) {
                  _context3.next = 22;
                  break;
                }
                // Fully-formed EIP-1559 transaction (skip getFeeData)
                pop.type = 2;
                _context3.next = 34;
                break;
              case 22:
                if (!(pop.type === 0 || pop.type === 1)) {
                  _context3.next = 30;
                  break;
                }
                _context3.next = 25;
                return provider.getFeeData();
              case 25:
                feeData = _context3.sent;
                (0, index_js_3.assert)(feeData.gasPrice != null, "network does not support gasPrice", "UNSUPPORTED_OPERATION", {
                  operation: "getGasPrice"
                });
                // Populate missing gasPrice
                if (pop.gasPrice == null) {
                  pop.gasPrice = feeData.gasPrice;
                }
                _context3.next = 34;
                break;
              case 30:
                _context3.next = 32;
                return provider.getFeeData();
              case 32:
                _feeData = _context3.sent;
                if (pop.type == null) {
                  // We need to auto-detect the intended type of this transaction...
                  if (_feeData.maxFeePerGas != null && _feeData.maxPriorityFeePerGas != null) {
                    // The network supports EIP-1559!
                    // Upgrade transaction from null to eip-1559
                    pop.type = 2;
                    if (pop.gasPrice != null) {
                      // Using legacy gasPrice property on an eip-1559 network,
                      // so use gasPrice as both fee properties
                      gasPrice = pop.gasPrice;
                      delete pop.gasPrice;
                      pop.maxFeePerGas = gasPrice;
                      pop.maxPriorityFeePerGas = gasPrice;
                    } else {
                      // Populate missing fee data
                      if (pop.maxFeePerGas == null) {
                        pop.maxFeePerGas = _feeData.maxFeePerGas;
                      }
                      if (pop.maxPriorityFeePerGas == null) {
                        pop.maxPriorityFeePerGas = _feeData.maxPriorityFeePerGas;
                      }
                    }
                  } else if (_feeData.gasPrice != null) {
                    // Network doesn't support EIP-1559...
                    // ...but they are trying to use EIP-1559 properties
                    (0, index_js_3.assert)(!hasEip1559, "network does not support EIP-1559", "UNSUPPORTED_OPERATION", {
                      operation: "populateTransaction"
                    });
                    // Populate missing fee data
                    if (pop.gasPrice == null) {
                      pop.gasPrice = _feeData.gasPrice;
                    }
                    // Explicitly set untyped transaction to legacy
                    // @TODO: Maybe this shold allow type 1?
                    pop.type = 0;
                  } else {
                    // getFeeData has failed us.
                    (0, index_js_3.assert)(false, "failed to get consistent fee data", "UNSUPPORTED_OPERATION", {
                      operation: "signer.getFeeData"
                    });
                  }
                } else if (pop.type === 2 || pop.type === 3) {
                  // Explicitly using EIP-1559 or EIP-4844
                  // Populate missing fee data
                  if (pop.maxFeePerGas == null) {
                    pop.maxFeePerGas = _feeData.maxFeePerGas;
                  }
                  if (pop.maxPriorityFeePerGas == null) {
                    pop.maxPriorityFeePerGas = _feeData.maxPriorityFeePerGas;
                  }
                }
              case 34:
                _context3.next = 36;
                return (0, index_js_3.resolveProperties)(pop);
              case 36:
                return _context3.abrupt("return", _context3.sent);
              case 37:
              case "end":
                return _context3.stop();
            }
          }, _callee3, this);
        }));
        function populateTransaction(_x5) {
          return _populateTransaction.apply(this, arguments);
        }
        return populateTransaction;
      }()
    }, {
      key: "estimateGas",
      value: function () {
        var _estimateGas = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4(tx) {
          return _regeneratorRuntime().wrap(function _callee4$(_context4) {
            while (1) switch (_context4.prev = _context4.next) {
              case 0:
                _context4.t0 = checkProvider(this, "estimateGas");
                _context4.next = 3;
                return this.populateCall(tx);
              case 3:
                _context4.t1 = _context4.sent;
                return _context4.abrupt("return", _context4.t0.estimateGas.call(_context4.t0, _context4.t1));
              case 5:
              case "end":
                return _context4.stop();
            }
          }, _callee4, this);
        }));
        function estimateGas(_x6) {
          return _estimateGas.apply(this, arguments);
        }
        return estimateGas;
      }()
    }, {
      key: "call",
      value: function () {
        var _call = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee5(tx) {
          return _regeneratorRuntime().wrap(function _callee5$(_context5) {
            while (1) switch (_context5.prev = _context5.next) {
              case 0:
                _context5.t0 = checkProvider(this, "call");
                _context5.next = 3;
                return this.populateCall(tx);
              case 3:
                _context5.t1 = _context5.sent;
                return _context5.abrupt("return", _context5.t0.call.call(_context5.t0, _context5.t1));
              case 5:
              case "end":
                return _context5.stop();
            }
          }, _callee5, this);
        }));
        function call(_x7) {
          return _call.apply(this, arguments);
        }
        return call;
      }()
    }, {
      key: "resolveName",
      value: function () {
        var _resolveName = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee6(name) {
          var provider;
          return _regeneratorRuntime().wrap(function _callee6$(_context6) {
            while (1) switch (_context6.prev = _context6.next) {
              case 0:
                provider = checkProvider(this, "resolveName");
                _context6.next = 3;
                return provider.resolveName(name);
              case 3:
                return _context6.abrupt("return", _context6.sent);
              case 4:
              case "end":
                return _context6.stop();
            }
          }, _callee6, this);
        }));
        function resolveName(_x8) {
          return _resolveName.apply(this, arguments);
        }
        return resolveName;
      }()
    }, {
      key: "sendTransaction",
      value: function () {
        var _sendTransaction = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee7(tx) {
          var provider, pop, txObj;
          return _regeneratorRuntime().wrap(function _callee7$(_context7) {
            while (1) switch (_context7.prev = _context7.next) {
              case 0:
                provider = checkProvider(this, "sendTransaction");
                _context7.next = 3;
                return this.populateTransaction(tx);
              case 3:
                pop = _context7.sent;
                delete pop.from;
                txObj = index_js_2.Transaction.from(pop);
                _context7.t0 = provider;
                _context7.next = 9;
                return this.signTransaction(txObj);
              case 9:
                _context7.t1 = _context7.sent;
                _context7.next = 12;
                return _context7.t0.broadcastTransaction.call(_context7.t0, _context7.t1);
              case 12:
                return _context7.abrupt("return", _context7.sent);
              case 13:
              case "end":
                return _context7.stop();
            }
          }, _callee7, this);
        }));
        function sendTransaction(_x9) {
          return _sendTransaction.apply(this, arguments);
        }
        return sendTransaction;
      }()
    }]);
  }();
  abstractSigner.AbstractSigner = AbstractSigner;
  /**
   *  A **VoidSigner** is a class deisgned to allow an address to be used
   *  in any API which accepts a Signer, but for which there are no
   *  credentials available to perform any actual signing.
   *
   *  This for example allow impersonating an account for the purpose of
   *  static calls or estimating gas, but does not allow sending transactions.
   */
  var _VoidSigner_brand = /*#__PURE__*/new WeakSet();
  var VoidSigner = /*#__PURE__*/function (_AbstractSigner2) {
    /**
     *  Creates a new **VoidSigner** with %%address%% attached to
     *  %%provider%%.
     */
    function VoidSigner(address, provider) {
      var _this;
      _classCallCheck(this, VoidSigner);
      _this = _callSuper(this, VoidSigner, [provider]);
      _classPrivateMethodInitSpec(_this, _VoidSigner_brand);
      /**
       *  The signer address.
       */
      _defineProperty(_this, "address", void 0);
      (0, index_js_3.defineProperties)(_this, {
        address: address
      });
      return _this;
    }
    _inherits(VoidSigner, _AbstractSigner2);
    return _createClass(VoidSigner, [{
      key: "getAddress",
      value: function () {
        var _getAddress = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {
          return _regeneratorRuntime().wrap(function _callee8$(_context8) {
            while (1) switch (_context8.prev = _context8.next) {
              case 0:
                return _context8.abrupt("return", this.address);
              case 1:
              case "end":
                return _context8.stop();
            }
          }, _callee8, this);
        }));
        function getAddress() {
          return _getAddress.apply(this, arguments);
        }
        return getAddress;
      }()
    }, {
      key: "connect",
      value: function connect(provider) {
        return new VoidSigner(this.address, provider);
      }
    }, {
      key: "signTransaction",
      value: function () {
        var _signTransaction = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee9(tx) {
          return _regeneratorRuntime().wrap(function _callee9$(_context9) {
            while (1) switch (_context9.prev = _context9.next) {
              case 0:
                _assertClassBrand(_VoidSigner_brand, this, _throwUnsupported).call(this, "transactions", "signTransaction");
              case 1:
              case "end":
                return _context9.stop();
            }
          }, _callee9, this);
        }));
        function signTransaction(_x10) {
          return _signTransaction.apply(this, arguments);
        }
        return signTransaction;
      }()
    }, {
      key: "signMessage",
      value: function () {
        var _signMessage = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee10(message) {
          return _regeneratorRuntime().wrap(function _callee10$(_context10) {
            while (1) switch (_context10.prev = _context10.next) {
              case 0:
                _assertClassBrand(_VoidSigner_brand, this, _throwUnsupported).call(this, "messages", "signMessage");
              case 1:
              case "end":
                return _context10.stop();
            }
          }, _callee10, this);
        }));
        function signMessage(_x11) {
          return _signMessage.apply(this, arguments);
        }
        return signMessage;
      }()
    }, {
      key: "signTypedData",
      value: function () {
        var _signTypedData = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee11(domain, types, value) {
          return _regeneratorRuntime().wrap(function _callee11$(_context11) {
            while (1) switch (_context11.prev = _context11.next) {
              case 0:
                _assertClassBrand(_VoidSigner_brand, this, _throwUnsupported).call(this, "typed-data", "signTypedData");
              case 1:
              case "end":
                return _context11.stop();
            }
          }, _callee11, this);
        }));
        function signTypedData(_x12, _x13, _x14) {
          return _signTypedData.apply(this, arguments);
        }
        return signTypedData;
      }()
    }]);
  }(AbstractSigner);
  function _throwUnsupported(suffix, operation) {
    (0, index_js_3.assert)(false, "VoidSigner cannot sign ".concat(suffix), "UNSUPPORTED_OPERATION", {
      operation: operation
    });
  }
  abstractSigner.VoidSigner = VoidSigner;
  return abstractSigner;
}

var community = {};

var hasRequiredCommunity;
function requireCommunity() {
  if (hasRequiredCommunity) return community;
  hasRequiredCommunity = 1;
  /**
   *  There are many awesome community services that provide Ethereum
   *  nodes both for developers just starting out and for large-scale
   *  communities.
   *
   *  @_section: api/providers/thirdparty: Community Providers  [thirdparty]
   */
  Object.defineProperty(community, "__esModule", {
    value: true
  });
  community.showThrottleMessage = void 0;
  // Show the throttle message only once per service
  var shown = new Set();
  /**
   *  Displays a warning in tht console when the community resource is
   *  being used too heavily by the app, recommending the developer
   *  acquire their own credentials instead of using the community
   *  credentials.
   *
   *  The notification will only occur once per service.
   */
  function showThrottleMessage(service) {
    if (shown.has(service)) {
      return;
    }
    shown.add(service);
    console.log("========= NOTICE =========");
    console.log("Request-Rate Exceeded for ".concat(service, " (this message will not be repeated)"));
    console.log("");
    console.log("The default API keys for each service are provided as a highly-throttled,");
    console.log("community resource for low-traffic projects and early prototyping.");
    console.log("");
    console.log("While your application will continue to function, we highly recommended");
    console.log("signing up for your own API keys to improve performance, increase your");
    console.log("request rate/limit and enable other perks, such as metrics and advanced APIs.");
    console.log("");
    console.log("For more details: https:/\/docs.ethers.org/api-keys/");
    console.log("==========================");
  }
  community.showThrottleMessage = showThrottleMessage;
  return community;
}

var defaultProvider = {};

var providerAnkr = {};

var providerJsonrpc = {};

var subscriberFilterid = {};

var hasRequiredSubscriberFilterid;
function requireSubscriberFilterid() {
  if (hasRequiredSubscriberFilterid) return subscriberFilterid;
  hasRequiredSubscriberFilterid = 1;
  Object.defineProperty(subscriberFilterid, "__esModule", {
    value: true
  });
  subscriberFilterid.FilterIdPendingSubscriber = subscriberFilterid.FilterIdEventSubscriber = subscriberFilterid.FilterIdSubscriber = void 0;
  var index_js_1 = /*@__PURE__*/requireUtils$3();
  var subscriber_polling_js_1 = /*@__PURE__*/requireSubscriberPolling();
  function copy(obj) {
    return JSON.parse(JSON.stringify(obj));
  }
  /**
   *  Some backends support subscribing to events using a Filter ID.
   *
   *  When subscribing with this technique, the node issues a unique
   *  //Filter ID//. At this point the node dedicates resources to
   *  the filter, so that periodic calls to follow up on the //Filter ID//
   *  will receive any events since the last call.
   *
   *  @_docloc: api/providers/abstract-provider
   */
  var _provider = /*#__PURE__*/new WeakMap();
  var _filterIdPromise = /*#__PURE__*/new WeakMap();
  var _poller = /*#__PURE__*/new WeakMap();
  var _running = /*#__PURE__*/new WeakMap();
  var _network = /*#__PURE__*/new WeakMap();
  var _hault = /*#__PURE__*/new WeakMap();
  var _FilterIdSubscriber_brand = /*#__PURE__*/new WeakSet();
  var FilterIdSubscriber = /*#__PURE__*/function () {
    /**
     *  Creates a new **FilterIdSubscriber** which will used [[_subscribe]]
     *  and [[_emitResults]] to setup the subscription and provide the event
     *  to the %%provider%%.
     */
    function FilterIdSubscriber(provider) {
      _classCallCheck(this, FilterIdSubscriber);
      _classPrivateMethodInitSpec(this, _FilterIdSubscriber_brand);
      _classPrivateFieldInitSpec(this, _provider, void 0);
      _classPrivateFieldInitSpec(this, _filterIdPromise, void 0);
      _classPrivateFieldInitSpec(this, _poller, void 0);
      _classPrivateFieldInitSpec(this, _running, void 0);
      _classPrivateFieldInitSpec(this, _network, void 0);
      _classPrivateFieldInitSpec(this, _hault, void 0);
      _classPrivateFieldSet2(_provider, this, provider);
      _classPrivateFieldSet2(_filterIdPromise, this, null);
      _classPrivateFieldSet2(_poller, this, _assertClassBrand(_FilterIdSubscriber_brand, this, _poll).bind(this));
      _classPrivateFieldSet2(_running, this, false);
      _classPrivateFieldSet2(_network, this, null);
      _classPrivateFieldSet2(_hault, this, false);
    }
    /**
     *  Sub-classes **must** override this to begin the subscription.
     */
    return _createClass(FilterIdSubscriber, [{
      key: "_subscribe",
      value: function _subscribe(provider) {
        throw new Error("subclasses must override this");
      }
      /**
       *  Sub-classes **must** override this handle the events.
       */
    }, {
      key: "_emitResults",
      value: function _emitResults(provider, result) {
        throw new Error("subclasses must override this");
      }
      /**
       *  Sub-classes **must** override this handle recovery on errors.
       */
    }, {
      key: "_recover",
      value: function _recover(provider) {
        throw new Error("subclasses must override this");
      }
    }, {
      key: "start",
      value: function start() {
        if (_classPrivateFieldGet2(_running, this)) {
          return;
        }
        _classPrivateFieldSet2(_running, this, true);
        _assertClassBrand(_FilterIdSubscriber_brand, this, _poll).call(this, -2);
      }
    }, {
      key: "stop",
      value: function stop() {
        if (!_classPrivateFieldGet2(_running, this)) {
          return;
        }
        _classPrivateFieldSet2(_running, this, false);
        _classPrivateFieldSet2(_hault, this, true);
        _assertClassBrand(_FilterIdSubscriber_brand, this, _teardown).call(this);
        _classPrivateFieldGet2(_provider, this).off("block", _classPrivateFieldGet2(_poller, this));
      }
    }, {
      key: "pause",
      value: function pause(dropWhilePaused) {
        if (dropWhilePaused) {
          _assertClassBrand(_FilterIdSubscriber_brand, this, _teardown).call(this);
        }
        _classPrivateFieldGet2(_provider, this).off("block", _classPrivateFieldGet2(_poller, this));
      }
    }, {
      key: "resume",
      value: function resume() {
        this.start();
      }
    }]);
  }();
  function _poll(_x7) {
    return _poll2.apply(this, arguments);
  }
  function _poll2() {
    _poll2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee5(blockNumber) {
      var filterId, network, result;
      return _regeneratorRuntime().wrap(function _callee5$(_context5) {
        while (1) switch (_context5.prev = _context5.next) {
          case 0:
            _context5.prev = 0;
            // Subscribe if necessary
            if (_classPrivateFieldGet2(_filterIdPromise, this) == null) {
              _classPrivateFieldSet2(_filterIdPromise, this, this._subscribe(_classPrivateFieldGet2(_provider, this)));
            }
            // Get the Filter ID
            filterId = null;
            _context5.prev = 3;
            _context5.next = 6;
            return _classPrivateFieldGet2(_filterIdPromise, this);
          case 6:
            filterId = _context5.sent;
            _context5.next = 13;
            break;
          case 9:
            _context5.prev = 9;
            _context5.t0 = _context5["catch"](3);
            if (!(!(0, index_js_1.isError)(_context5.t0, "UNSUPPORTED_OPERATION") || _context5.t0.operation !== "eth_newFilter")) {
              _context5.next = 13;
              break;
            }
            throw _context5.t0;
          case 13:
            if (!(filterId == null)) {
              _context5.next = 17;
              break;
            }
            _classPrivateFieldSet2(_filterIdPromise, this, null);
            _classPrivateFieldGet2(_provider, this)._recoverSubscriber(this, this._recover(_classPrivateFieldGet2(_provider, this)));
            return _context5.abrupt("return");
          case 17:
            _context5.next = 19;
            return _classPrivateFieldGet2(_provider, this).getNetwork();
          case 19:
            network = _context5.sent;
            if (!_classPrivateFieldGet2(_network, this)) {
              _classPrivateFieldSet2(_network, this, network);
            }
            if (!(_classPrivateFieldGet2(_network, this).chainId !== network.chainId)) {
              _context5.next = 23;
              break;
            }
            throw new Error("chaid changed");
          case 23:
            if (!_classPrivateFieldGet2(_hault, this)) {
              _context5.next = 25;
              break;
            }
            return _context5.abrupt("return");
          case 25:
            _context5.next = 27;
            return _classPrivateFieldGet2(_provider, this).send("eth_getFilterChanges", [filterId]);
          case 27:
            result = _context5.sent;
            _context5.next = 30;
            return this._emitResults(_classPrivateFieldGet2(_provider, this), result);
          case 30:
            _context5.next = 35;
            break;
          case 32:
            _context5.prev = 32;
            _context5.t1 = _context5["catch"](0);
            console.log("@TODO", _context5.t1);
          case 35:
            _classPrivateFieldGet2(_provider, this).once("block", _classPrivateFieldGet2(_poller, this));
          case 36:
          case "end":
            return _context5.stop();
        }
      }, _callee5, this, [[0, 32], [3, 9]]);
    }));
    return _poll2.apply(this, arguments);
  }
  function _teardown() {
    var _this2 = this;
    var filterIdPromise = _classPrivateFieldGet2(_filterIdPromise, this);
    if (filterIdPromise) {
      _classPrivateFieldSet2(_filterIdPromise, this, null);
      filterIdPromise.then(function (filterId) {
        if (_classPrivateFieldGet2(_provider, _this2).destroyed) {
          return;
        }
        _classPrivateFieldGet2(_provider, _this2).send("eth_uninstallFilter", [filterId]);
      });
    }
  }
  subscriberFilterid.FilterIdSubscriber = FilterIdSubscriber;
  /**
   *  A **FilterIdSubscriber** for receiving contract events.
   *
   *  @_docloc: api/providers/abstract-provider
   */
  var _event = /*#__PURE__*/new WeakMap();
  var FilterIdEventSubscriber = /*#__PURE__*/function (_FilterIdSubscriber2) {
    /**
     *  Creates a new **FilterIdEventSubscriber** attached to %%provider%%
     *  listening for %%filter%%.
     */
    function FilterIdEventSubscriber(provider, filter) {
      var _this;
      _classCallCheck(this, FilterIdEventSubscriber);
      _this = _callSuper(this, FilterIdEventSubscriber, [provider]);
      _classPrivateFieldInitSpec(_this, _event, void 0);
      _classPrivateFieldSet2(_event, _this, copy(filter));
      return _this;
    }
    _inherits(FilterIdEventSubscriber, _FilterIdSubscriber2);
    return _createClass(FilterIdEventSubscriber, [{
      key: "_recover",
      value: function _recover(provider) {
        return new subscriber_polling_js_1.PollingEventSubscriber(provider, _classPrivateFieldGet2(_event, this));
      }
    }, {
      key: "_subscribe",
      value: function () {
        var _subscribe2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(provider) {
          var filterId;
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return provider.send("eth_newFilter", [_classPrivateFieldGet2(_event, this)]);
              case 2:
                filterId = _context.sent;
                return _context.abrupt("return", filterId);
              case 4:
              case "end":
                return _context.stop();
            }
          }, _callee, this);
        }));
        function _subscribe(_x) {
          return _subscribe2.apply(this, arguments);
        }
        return _subscribe;
      }()
    }, {
      key: "_emitResults",
      value: function () {
        var _emitResults2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(provider, results) {
          var _iterator, _step, result;
          return _regeneratorRuntime().wrap(function _callee2$(_context2) {
            while (1) switch (_context2.prev = _context2.next) {
              case 0:
                _iterator = _createForOfIteratorHelper(results);
                try {
                  for (_iterator.s(); !(_step = _iterator.n()).done;) {
                    result = _step.value;
                    provider.emit(_classPrivateFieldGet2(_event, this), provider._wrapLog(result, provider._network));
                  }
                } catch (err) {
                  _iterator.e(err);
                } finally {
                  _iterator.f();
                }
              case 2:
              case "end":
                return _context2.stop();
            }
          }, _callee2, this);
        }));
        function _emitResults(_x2, _x3) {
          return _emitResults2.apply(this, arguments);
        }
        return _emitResults;
      }()
    }]);
  }(FilterIdSubscriber);
  subscriberFilterid.FilterIdEventSubscriber = FilterIdEventSubscriber;
  /**
   *  A **FilterIdSubscriber** for receiving pending transactions events.
   *
   *  @_docloc: api/providers/abstract-provider
   */
  var FilterIdPendingSubscriber = /*#__PURE__*/function (_FilterIdSubscriber3) {
    function FilterIdPendingSubscriber() {
      _classCallCheck(this, FilterIdPendingSubscriber);
      return _callSuper(this, FilterIdPendingSubscriber, arguments);
    }
    _inherits(FilterIdPendingSubscriber, _FilterIdSubscriber3);
    return _createClass(FilterIdPendingSubscriber, [{
      key: "_subscribe",
      value: function () {
        var _subscribe3 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(provider) {
          return _regeneratorRuntime().wrap(function _callee3$(_context3) {
            while (1) switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return provider.send("eth_newPendingTransactionFilter", []);
              case 2:
                return _context3.abrupt("return", _context3.sent);
              case 3:
              case "end":
                return _context3.stop();
            }
          }, _callee3);
        }));
        function _subscribe(_x4) {
          return _subscribe3.apply(this, arguments);
        }
        return _subscribe;
      }()
    }, {
      key: "_emitResults",
      value: function () {
        var _emitResults3 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4(provider, results) {
          var _iterator2, _step2, result;
          return _regeneratorRuntime().wrap(function _callee4$(_context4) {
            while (1) switch (_context4.prev = _context4.next) {
              case 0:
                _iterator2 = _createForOfIteratorHelper(results);
                try {
                  for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                    result = _step2.value;
                    provider.emit("pending", result);
                  }
                } catch (err) {
                  _iterator2.e(err);
                } finally {
                  _iterator2.f();
                }
              case 2:
              case "end":
                return _context4.stop();
            }
          }, _callee4);
        }));
        function _emitResults(_x5, _x6) {
          return _emitResults3.apply(this, arguments);
        }
        return _emitResults;
      }()
    }]);
  }(FilterIdSubscriber);
  subscriberFilterid.FilterIdPendingSubscriber = FilterIdPendingSubscriber;
  return subscriberFilterid;
}

var hasRequiredProviderJsonrpc;
function requireProviderJsonrpc() {
  if (hasRequiredProviderJsonrpc) return providerJsonrpc;
  hasRequiredProviderJsonrpc = 1;
  /**
   *  One of the most common ways to interact with the blockchain is
   *  by a node running a JSON-RPC interface which can be connected to,
   *  based on the transport, using:
   *
   *  - HTTP or HTTPS - [[JsonRpcProvider]]
   *  - WebSocket - [[WebSocketProvider]]
   *  - IPC - [[IpcSocketProvider]]
   *
   * @_section: api/providers/jsonrpc:JSON-RPC Provider  [about-jsonrpcProvider]
   */
  Object.defineProperty(providerJsonrpc, "__esModule", {
    value: true
  });
  providerJsonrpc.JsonRpcProvider = providerJsonrpc.JsonRpcApiPollingProvider = providerJsonrpc.JsonRpcApiProvider = providerJsonrpc.JsonRpcSigner = void 0;
  // @TODO:
  // - Add the batching API
  // https://playground.open-rpc.org/?schemaUrl=https://raw.githubusercontent.com/ethereum/eth1.0-apis/assembled-spec/openrpc.json&uiSchema%5BappBar%5D%5Bui:splitView%5D=true&uiSchema%5BappBar%5D%5Bui:input%5D=false&uiSchema%5BappBar%5D%5Bui:examplesDropdown%5D=false
  var index_js_1 = /*@__PURE__*/requireAbi();
  var index_js_2 = /*@__PURE__*/requireAddress$2();
  var index_js_3 = /*@__PURE__*/requireHash();
  var index_js_4 = /*@__PURE__*/requireTransaction();
  var index_js_5 = /*@__PURE__*/requireUtils$3();
  var abstract_provider_js_1 = /*@__PURE__*/requireAbstractProvider();
  var abstract_signer_js_1 = /*@__PURE__*/requireAbstractSigner();
  var network_js_1 = /*@__PURE__*/requireNetwork();
  var subscriber_filterid_js_1 = /*@__PURE__*/requireSubscriberFilterid();
  var subscriber_polling_js_1 = /*@__PURE__*/requireSubscriberPolling();
  var Primitive = "bigint,boolean,function,number,string,symbol".split(/,/g);
  //const Methods = "getAddress,then".split(/,/g);
  function deepCopy(value) {
    if (value == null || Primitive.indexOf(_typeof(value)) >= 0) {
      return value;
    }
    // Keep any Addressable
    if (typeof value.getAddress === "function") {
      return value;
    }
    if (Array.isArray(value)) {
      return value.map(deepCopy);
    }
    if (_typeof(value) === "object") {
      return Object.keys(value).reduce(function (accum, key) {
        accum[key] = value[key];
        return accum;
      }, {});
    }
    throw new Error("should not happen: ".concat(value, " (").concat(_typeof(value), ")"));
  }
  function stall(duration) {
    return new Promise(function (resolve) {
      setTimeout(resolve, duration);
    });
  }
  function getLowerCase(value) {
    if (value) {
      return value.toLowerCase();
    }
    return value;
  }
  function isPollable(value) {
    return value && typeof value.pollingInterval === "number";
  }
  var defaultOptions = {
    polling: false,
    staticNetwork: null,
    batchStallTime: 10,
    batchMaxSize: 1 << 20,
    batchMaxCount: 100,
    cacheTimeout: 250,
    pollingInterval: 4000
  };
  // @TODO: Unchecked Signers
  var JsonRpcSigner = /*#__PURE__*/function (_abstract_signer_js_) {
    function JsonRpcSigner(provider, address) {
      var _this;
      _classCallCheck(this, JsonRpcSigner);
      _this = _callSuper(this, JsonRpcSigner, [provider]);
      _defineProperty(_this, "address", void 0);
      address = (0, index_js_2.getAddress)(address);
      (0, index_js_5.defineProperties)(_this, {
        address: address
      });
      return _this;
    }
    _inherits(JsonRpcSigner, _abstract_signer_js_);
    return _createClass(JsonRpcSigner, [{
      key: "connect",
      value: function connect(provider) {
        (0, index_js_5.assert)(false, "cannot reconnect JsonRpcSigner", "UNSUPPORTED_OPERATION", {
          operation: "signer.connect"
        });
      }
    }, {
      key: "getAddress",
      value: function () {
        var _getAddress = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                return _context.abrupt("return", this.address);
              case 1:
              case "end":
                return _context.stop();
            }
          }, _callee, this);
        }));
        function getAddress() {
          return _getAddress.apply(this, arguments);
        }
        return getAddress;
      }() // JSON-RPC will automatially fill in nonce, etc. so we just check from
    }, {
      key: "populateTransaction",
      value: function () {
        var _populateTransaction = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(tx) {
          return _regeneratorRuntime().wrap(function _callee2$(_context2) {
            while (1) switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.populateCall(tx);
              case 2:
                return _context2.abrupt("return", _context2.sent);
              case 3:
              case "end":
                return _context2.stop();
            }
          }, _callee2, this);
        }));
        function populateTransaction(_x) {
          return _populateTransaction.apply(this, arguments);
        }
        return populateTransaction;
      }() // Returns just the hash of the transaction after sent, which is what
      // the bare JSON-RPC API does;
    }, {
      key: "sendUncheckedTransaction",
      value: function () {
        var _sendUncheckedTransaction = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee6(_tx) {
          var _this2 = this;
          var tx, promises, _from, _to, hexTx;
          return _regeneratorRuntime().wrap(function _callee6$(_context6) {
            while (1) switch (_context6.prev = _context6.next) {
              case 0:
                tx = deepCopy(_tx);
                promises = []; // Make sure the from matches the sender
                if (tx.from) {
                  _from = tx.from;
                  promises.push(_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
                    var from;
                    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
                      while (1) switch (_context3.prev = _context3.next) {
                        case 0:
                          _context3.next = 2;
                          return (0, index_js_2.resolveAddress)(_from, _this2.provider);
                        case 2:
                          from = _context3.sent;
                          (0, index_js_5.assertArgument)(from != null && from.toLowerCase() === _this2.address.toLowerCase(), "from address mismatch", "transaction", _tx);
                          tx.from = from;
                        case 5:
                        case "end":
                          return _context3.stop();
                      }
                    }, _callee3);
                  }))());
                } else {
                  tx.from = this.address;
                }
                // The JSON-RPC for eth_sendTransaction uses 90000 gas; if the user
                // wishes to use this, it is easy to specify explicitly, otherwise
                // we look it up for them.
                if (tx.gasLimit == null) {
                  promises.push(_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
                    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
                      while (1) switch (_context4.prev = _context4.next) {
                        case 0:
                          _context4.next = 2;
                          return _this2.provider.estimateGas(_objectSpread2(_objectSpread2({}, tx), {}, {
                            from: _this2.address
                          }));
                        case 2:
                          tx.gasLimit = _context4.sent;
                        case 3:
                        case "end":
                          return _context4.stop();
                      }
                    }, _callee4);
                  }))());
                }
                // The address may be an ENS name or Addressable
                if (tx.to != null) {
                  _to = tx.to;
                  promises.push(_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
                    return _regeneratorRuntime().wrap(function _callee5$(_context5) {
                      while (1) switch (_context5.prev = _context5.next) {
                        case 0:
                          _context5.next = 2;
                          return (0, index_js_2.resolveAddress)(_to, _this2.provider);
                        case 2:
                          tx.to = _context5.sent;
                        case 3:
                        case "end":
                          return _context5.stop();
                      }
                    }, _callee5);
                  }))());
                }
                // Wait until all of our properties are filled in
                if (!promises.length) {
                  _context6.next = 8;
                  break;
                }
                _context6.next = 8;
                return Promise.all(promises);
              case 8:
                hexTx = this.provider.getRpcTransaction(tx);
                return _context6.abrupt("return", this.provider.send("eth_sendTransaction", [hexTx]));
              case 10:
              case "end":
                return _context6.stop();
            }
          }, _callee6, this);
        }));
        function sendUncheckedTransaction(_x2) {
          return _sendUncheckedTransaction.apply(this, arguments);
        }
        return sendUncheckedTransaction;
      }()
    }, {
      key: "sendTransaction",
      value: function () {
        var _sendTransaction = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee8(tx) {
          var _this3 = this;
          var blockNumber, hash;
          return _regeneratorRuntime().wrap(function _callee8$(_context8) {
            while (1) switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return this.provider.getBlockNumber();
              case 2:
                blockNumber = _context8.sent;
                _context8.next = 5;
                return this.sendUncheckedTransaction(tx);
              case 5:
                hash = _context8.sent;
                _context8.next = 8;
                return new Promise(function (resolve, reject) {
                  var timeouts = [1000, 100];
                  var invalids = 0;
                  var _checkTx = /*#__PURE__*/function () {
                    var _ref4 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {
                      var _tx2;
                      return _regeneratorRuntime().wrap(function _callee7$(_context7) {
                        while (1) switch (_context7.prev = _context7.next) {
                          case 0:
                            _context7.prev = 0;
                            _context7.next = 3;
                            return _this3.provider.getTransaction(hash);
                          case 3:
                            _tx2 = _context7.sent;
                            if (!(_tx2 != null)) {
                              _context7.next = 7;
                              break;
                            }
                            resolve(_tx2.replaceableTransaction(blockNumber));
                            return _context7.abrupt("return");
                          case 7:
                            _context7.next = 24;
                            break;
                          case 9:
                            _context7.prev = 9;
                            _context7.t0 = _context7["catch"](0);
                            if (!((0, index_js_5.isError)(_context7.t0, "CANCELLED") || (0, index_js_5.isError)(_context7.t0, "BAD_DATA") || (0, index_js_5.isError)(_context7.t0, "NETWORK_ERROR") || (0, index_js_5.isError)(_context7.t0, "UNSUPPORTED_OPERATION"))) {
                              _context7.next = 16;
                              break;
                            }
                            if (_context7.t0.info == null) {
                              _context7.t0.info = {};
                            }
                            _context7.t0.info.sendTransactionHash = hash;
                            reject(_context7.t0);
                            return _context7.abrupt("return");
                          case 16:
                            if (!(0, index_js_5.isError)(_context7.t0, "INVALID_ARGUMENT")) {
                              _context7.next = 23;
                              break;
                            }
                            invalids++;
                            if (_context7.t0.info == null) {
                              _context7.t0.info = {};
                            }
                            _context7.t0.info.sendTransactionHash = hash;
                            if (!(invalids > 10)) {
                              _context7.next = 23;
                              break;
                            }
                            reject(_context7.t0);
                            return _context7.abrupt("return");
                          case 23:
                            // Notify anyone that cares; but we will try again, since
                            // it is likely an intermittent service error
                            _this3.provider.emit("error", (0, index_js_5.makeError)("failed to fetch transation after sending (will try again)", "UNKNOWN_ERROR", {
                              error: _context7.t0
                            }));
                          case 24:
                            // Wait another 4 seconds
                            _this3.provider._setTimeout(function () {
                              _checkTx();
                            }, timeouts.pop() || 4000);
                          case 25:
                          case "end":
                            return _context7.stop();
                        }
                      }, _callee7, null, [[0, 9]]);
                    }));
                    return function checkTx() {
                      return _ref4.apply(this, arguments);
                    };
                  }();
                  _checkTx();
                });
              case 8:
                return _context8.abrupt("return", _context8.sent);
              case 9:
              case "end":
                return _context8.stop();
            }
          }, _callee8, this);
        }));
        function sendTransaction(_x3) {
          return _sendTransaction.apply(this, arguments);
        }
        return sendTransaction;
      }()
    }, {
      key: "signTransaction",
      value: function () {
        var _signTransaction = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee9(_tx) {
          var tx, from, hexTx;
          return _regeneratorRuntime().wrap(function _callee9$(_context9) {
            while (1) switch (_context9.prev = _context9.next) {
              case 0:
                tx = deepCopy(_tx); // Make sure the from matches the sender
                if (!tx.from) {
                  _context9.next = 9;
                  break;
                }
                _context9.next = 4;
                return (0, index_js_2.resolveAddress)(tx.from, this.provider);
              case 4:
                from = _context9.sent;
                (0, index_js_5.assertArgument)(from != null && from.toLowerCase() === this.address.toLowerCase(), "from address mismatch", "transaction", _tx);
                tx.from = from;
                _context9.next = 10;
                break;
              case 9:
                tx.from = this.address;
              case 10:
                hexTx = this.provider.getRpcTransaction(tx);
                _context9.next = 13;
                return this.provider.send("eth_signTransaction", [hexTx]);
              case 13:
                return _context9.abrupt("return", _context9.sent);
              case 14:
              case "end":
                return _context9.stop();
            }
          }, _callee9, this);
        }));
        function signTransaction(_x4) {
          return _signTransaction.apply(this, arguments);
        }
        return signTransaction;
      }()
    }, {
      key: "signMessage",
      value: function () {
        var _signMessage = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee10(_message) {
          var message;
          return _regeneratorRuntime().wrap(function _callee10$(_context10) {
            while (1) switch (_context10.prev = _context10.next) {
              case 0:
                message = typeof _message === "string" ? (0, index_js_5.toUtf8Bytes)(_message) : _message;
                _context10.next = 3;
                return this.provider.send("personal_sign", [(0, index_js_5.hexlify)(message), this.address.toLowerCase()]);
              case 3:
                return _context10.abrupt("return", _context10.sent);
              case 4:
              case "end":
                return _context10.stop();
            }
          }, _callee10, this);
        }));
        function signMessage(_x5) {
          return _signMessage.apply(this, arguments);
        }
        return signMessage;
      }()
    }, {
      key: "signTypedData",
      value: function () {
        var _signTypedData = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee12(domain, types, _value) {
          var value, populated;
          return _regeneratorRuntime().wrap(function _callee12$(_context12) {
            while (1) switch (_context12.prev = _context12.next) {
              case 0:
                value = deepCopy(_value); // Populate any ENS names (in-place)
                _context12.next = 3;
                return index_js_3.TypedDataEncoder.resolveNames(domain, types, value, /*#__PURE__*/function () {
                  var _ref5 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee11(value) {
                    var address;
                    return _regeneratorRuntime().wrap(function _callee11$(_context11) {
                      while (1) switch (_context11.prev = _context11.next) {
                        case 0:
                          _context11.next = 2;
                          return (0, index_js_2.resolveAddress)(value);
                        case 2:
                          address = _context11.sent;
                          (0, index_js_5.assertArgument)(address != null, "TypedData does not support null address", "value", value);
                          return _context11.abrupt("return", address);
                        case 5:
                        case "end":
                          return _context11.stop();
                      }
                    }, _callee11);
                  }));
                  return function (_x9) {
                    return _ref5.apply(this, arguments);
                  };
                }());
              case 3:
                populated = _context12.sent;
                _context12.next = 6;
                return this.provider.send("eth_signTypedData_v4", [this.address.toLowerCase(), JSON.stringify(index_js_3.TypedDataEncoder.getPayload(populated.domain, types, populated.value))]);
              case 6:
                return _context12.abrupt("return", _context12.sent);
              case 7:
              case "end":
                return _context12.stop();
            }
          }, _callee12, this);
        }));
        function signTypedData(_x6, _x7, _x8) {
          return _signTypedData.apply(this, arguments);
        }
        return signTypedData;
      }()
    }, {
      key: "unlock",
      value: function () {
        var _unlock = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee13(password) {
          return _regeneratorRuntime().wrap(function _callee13$(_context13) {
            while (1) switch (_context13.prev = _context13.next) {
              case 0:
                return _context13.abrupt("return", this.provider.send("personal_unlockAccount", [this.address.toLowerCase(), password, null]));
              case 1:
              case "end":
                return _context13.stop();
            }
          }, _callee13, this);
        }));
        function unlock(_x10) {
          return _unlock.apply(this, arguments);
        }
        return unlock;
      }() // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign
    }, {
      key: "_legacySignMessage",
      value: function () {
        var _legacySignMessage2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee14(_message) {
          var message;
          return _regeneratorRuntime().wrap(function _callee14$(_context14) {
            while (1) switch (_context14.prev = _context14.next) {
              case 0:
                message = typeof _message === "string" ? (0, index_js_5.toUtf8Bytes)(_message) : _message;
                _context14.next = 3;
                return this.provider.send("eth_sign", [this.address.toLowerCase(), (0, index_js_5.hexlify)(message)]);
              case 3:
                return _context14.abrupt("return", _context14.sent);
              case 4:
              case "end":
                return _context14.stop();
            }
          }, _callee14, this);
        }));
        function _legacySignMessage(_x11) {
          return _legacySignMessage2.apply(this, arguments);
        }
        return _legacySignMessage;
      }()
    }]);
  }(abstract_signer_js_1.AbstractSigner);
  providerJsonrpc.JsonRpcSigner = JsonRpcSigner;
  /**
   *  The JsonRpcApiProvider is an abstract class and **MUST** be
   *  sub-classed.
   *
   *  It provides the base for all JSON-RPC-based Provider interaction.
   *
   *  Sub-classing Notes:
   *  - a sub-class MUST override _send
   *  - a sub-class MUST call the `_start()` method once connected
   */
  var _options = /*#__PURE__*/new WeakMap();
  var _nextId = /*#__PURE__*/new WeakMap();
  var _payloads = /*#__PURE__*/new WeakMap();
  var _drainTimer = /*#__PURE__*/new WeakMap();
  var _notReady = /*#__PURE__*/new WeakMap();
  var _network = /*#__PURE__*/new WeakMap();
  var _pendingDetectNetwork = /*#__PURE__*/new WeakMap();
  var _JsonRpcApiProvider_brand = /*#__PURE__*/new WeakSet();
  var JsonRpcApiProvider = /*#__PURE__*/function (_abstract_provider_js) {
    function JsonRpcApiProvider(network, options) {
      var _this4;
      _classCallCheck(this, JsonRpcApiProvider);
      _this4 = _callSuper(this, JsonRpcApiProvider, [network, options]);
      _classPrivateMethodInitSpec(_this4, _JsonRpcApiProvider_brand);
      _classPrivateFieldInitSpec(_this4, _options, void 0);
      // The next ID to use for the JSON-RPC ID field
      _classPrivateFieldInitSpec(_this4, _nextId, void 0);
      // Payloads are queued and triggered in batches using the drainTimer
      _classPrivateFieldInitSpec(_this4, _payloads, void 0);
      _classPrivateFieldInitSpec(_this4, _drainTimer, void 0);
      _classPrivateFieldInitSpec(_this4, _notReady, void 0);
      _classPrivateFieldInitSpec(_this4, _network, void 0);
      _classPrivateFieldInitSpec(_this4, _pendingDetectNetwork, void 0);
      _classPrivateFieldSet2(_nextId, _this4, 1);
      _classPrivateFieldSet2(_options, _this4, Object.assign({}, defaultOptions, options || {}));
      _classPrivateFieldSet2(_payloads, _this4, []);
      _classPrivateFieldSet2(_drainTimer, _this4, null);
      _classPrivateFieldSet2(_network, _this4, null);
      _classPrivateFieldSet2(_pendingDetectNetwork, _this4, null);
      {
        var resolve = null;
        var promise = new Promise(function (_resolve) {
          resolve = _resolve;
        });
        _classPrivateFieldSet2(_notReady, _this4, {
          promise: promise,
          resolve: resolve
        });
      }
      var staticNetwork = _this4._getOption("staticNetwork");
      if (typeof staticNetwork === "boolean") {
        (0, index_js_5.assertArgument)(!staticNetwork || network !== "any", "staticNetwork cannot be used on special network 'any'", "options", options);
        if (staticNetwork && network != null) {
          _classPrivateFieldSet2(_network, _this4, network_js_1.Network.from(network));
        }
      } else if (staticNetwork) {
        // Make sure any static network is compatbile with the provided netwrok
        (0, index_js_5.assertArgument)(network == null || staticNetwork.matches(network), "staticNetwork MUST match network object", "options", options);
        _classPrivateFieldSet2(_network, _this4, staticNetwork);
      }
      return _this4;
    }
    /**
     *  Returns the value associated with the option %%key%%.
     *
     *  Sub-classes can use this to inquire about configuration options.
     */
    _inherits(JsonRpcApiProvider, _abstract_provider_js);
    return _createClass(JsonRpcApiProvider, [{
      key: "_getOption",
      value: function _getOption(key) {
        return _classPrivateFieldGet2(_options, this)[key];
      }
      /**
       *  Gets the [[Network]] this provider has committed to. On each call, the network
       *  is detected, and if it has changed, the call will reject.
       */
    }, {
      key: "_network",
      get: function get() {
        (0, index_js_5.assert)(_classPrivateFieldGet2(_network, this), "network is not available yet", "NETWORK_ERROR");
        return _classPrivateFieldGet2(_network, this);
      }
      /**
       *  Resolves to the non-normalized value by performing %%req%%.
       *
       *  Sub-classes may override this to modify behavior of actions,
       *  and should generally call ``super._perform`` as a fallback.
       */
    }, {
      key: "_perform",
      value: (function () {
        var _perform2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee15(req) {
          var tx, feeData, request;
          return _regeneratorRuntime().wrap(function _callee15$(_context15) {
            while (1) switch (_context15.prev = _context15.next) {
              case 0:
                if (!(req.method === "call" || req.method === "estimateGas")) {
                  _context15.next = 8;
                  break;
                }
                tx = req.transaction;
                if (!(tx && tx.type != null && (0, index_js_5.getBigInt)(tx.type))) {
                  _context15.next = 8;
                  break;
                }
                if (!(tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null)) {
                  _context15.next = 8;
                  break;
                }
                _context15.next = 6;
                return this.getFeeData();
              case 6:
                feeData = _context15.sent;
                if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {
                  // Network doesn't know about EIP-1559 (and hence type)
                  req = Object.assign({}, req, {
                    transaction: Object.assign({}, tx, {
                      type: undefined
                    })
                  });
                }
              case 8:
                request = this.getRpcRequest(req);
                if (!(request != null)) {
                  _context15.next = 13;
                  break;
                }
                _context15.next = 12;
                return this.send(request.method, request.args);
              case 12:
                return _context15.abrupt("return", _context15.sent);
              case 13:
                return _context15.abrupt("return", _superPropGet(JsonRpcApiProvider, "_perform", this, 3)([req]));
              case 14:
              case "end":
                return _context15.stop();
            }
          }, _callee15, this);
        }));
        function _perform(_x12) {
          return _perform2.apply(this, arguments);
        }
        return _perform;
      }()
      /**
       *  Sub-classes may override this; it detects the *actual* network that
       *  we are **currently** connected to.
       *
       *  Keep in mind that [[send]] may only be used once [[ready]], otherwise the
       *  _send primitive must be used instead.
       */
      )
    }, {
      key: "_detectNetwork",
      value: (function () {
        var _detectNetwork2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee18() {
          var _this5 = this;
          var network;
          return _regeneratorRuntime().wrap(function _callee18$(_context18) {
            while (1) switch (_context18.prev = _context18.next) {
              case 0:
                network = this._getOption("staticNetwork");
                if (!network) {
                  _context18.next = 8;
                  break;
                }
                if (!(network === true)) {
                  _context18.next = 7;
                  break;
                }
                if (!_classPrivateFieldGet2(_network, this)) {
                  _context18.next = 5;
                  break;
                }
                return _context18.abrupt("return", _classPrivateFieldGet2(_network, this));
              case 5:
                _context18.next = 8;
                break;
              case 7:
                return _context18.abrupt("return", network);
              case 8:
                if (!_classPrivateFieldGet2(_pendingDetectNetwork, this)) {
                  _context18.next = 12;
                  break;
                }
                _context18.next = 11;
                return _classPrivateFieldGet2(_pendingDetectNetwork, this);
              case 11:
                return _context18.abrupt("return", _context18.sent);
              case 12:
                if (!this.ready) {
                  _context18.next = 17;
                  break;
                }
                _classPrivateFieldSet2(_pendingDetectNetwork, this, _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee16() {
                  var result;
                  return _regeneratorRuntime().wrap(function _callee16$(_context16) {
                    while (1) switch (_context16.prev = _context16.next) {
                      case 0:
                        _context16.prev = 0;
                        _context16.t0 = network_js_1.Network;
                        _context16.t1 = (index_js_5.getBigInt);
                        _context16.next = 5;
                        return _this5.send("eth_chainId", []);
                      case 5:
                        _context16.t2 = _context16.sent;
                        _context16.t3 = (0, _context16.t1)(_context16.t2);
                        result = _context16.t0.from.call(_context16.t0, _context16.t3);
                        _classPrivateFieldSet2(_pendingDetectNetwork, _this5, null);
                        return _context16.abrupt("return", result);
                      case 12:
                        _context16.prev = 12;
                        _context16.t4 = _context16["catch"](0);
                        _classPrivateFieldSet2(_pendingDetectNetwork, _this5, null);
                        throw _context16.t4;
                      case 16:
                      case "end":
                        return _context16.stop();
                    }
                  }, _callee16, null, [[0, 12]]);
                }))());
                _context18.next = 16;
                return _classPrivateFieldGet2(_pendingDetectNetwork, this);
              case 16:
                return _context18.abrupt("return", _context18.sent);
              case 17:
                // We are not ready yet; use the primitive _send
                _classPrivateFieldSet2(_pendingDetectNetwork, this, function () {
                  var _ref7 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee17(_this$nextId, _this$nextId2) {
                    var payload, result;
                    return _regeneratorRuntime().wrap(function _callee17$(_context17) {
                      while (1) switch (_context17.prev = _context17.next) {
                        case 0:
                          payload = {
                            id: (_classPrivateFieldSet2(_nextId, _this5, (_this$nextId = _classPrivateFieldGet2(_nextId, _this5), _this$nextId2 = _this$nextId++, _this$nextId)), _this$nextId2),
                            method: "eth_chainId",
                            params: [],
                            jsonrpc: "2.0"
                          };
                          _this5.emit("debug", {
                            action: "sendRpcPayload",
                            payload: payload
                          });
                          _context17.prev = 2;
                          _context17.next = 5;
                          return _this5._send(payload);
                        case 5:
                          result = _context17.sent[0];
                          _classPrivateFieldSet2(_pendingDetectNetwork, _this5, null);
                          _context17.next = 14;
                          break;
                        case 9:
                          _context17.prev = 9;
                          _context17.t0 = _context17["catch"](2);
                          _classPrivateFieldSet2(_pendingDetectNetwork, _this5, null);
                          _this5.emit("debug", {
                            action: "receiveRpcError",
                            error: _context17.t0
                          });
                          throw _context17.t0;
                        case 14:
                          _this5.emit("debug", {
                            action: "receiveRpcResult",
                            result: result
                          });
                          if (!("result" in result)) {
                            _context17.next = 17;
                            break;
                          }
                          return _context17.abrupt("return", network_js_1.Network.from((0, index_js_5.getBigInt)(result.result)));
                        case 17:
                          throw _this5.getRpcError(payload, result);
                        case 18:
                        case "end":
                          return _context17.stop();
                      }
                    }, _callee17, null, [[2, 9]]);
                  }));
                  return function (_x13, _x14) {
                    return _ref7.apply(this, arguments);
                  };
                }()());
                _context18.next = 20;
                return _classPrivateFieldGet2(_pendingDetectNetwork, this);
              case 20:
                return _context18.abrupt("return", _context18.sent);
              case 21:
              case "end":
                return _context18.stop();
            }
          }, _callee18, this);
        }));
        function _detectNetwork() {
          return _detectNetwork2.apply(this, arguments);
        }
        return _detectNetwork;
      }()
      /**
       *  Sub-classes **MUST** call this. Until [[_start]] has been called, no calls
       *  will be passed to [[_send]] from [[send]]. If it is overridden, then
       *  ``super._start()`` **MUST** be called.
       *
       *  Calling it multiple times is safe and has no effect.
       */
      )
    }, {
      key: "_start",
      value: function _start() {
        var _this6 = this;
        if (_classPrivateFieldGet2(_notReady, this) == null || _classPrivateFieldGet2(_notReady, this).resolve == null) {
          return;
        }
        _classPrivateFieldGet2(_notReady, this).resolve();
        _classPrivateFieldSet2(_notReady, this, null);
        _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee19() {
          return _regeneratorRuntime().wrap(function _callee19$(_context19) {
            while (1) switch (_context19.prev = _context19.next) {
              case 0:
                if (!(_classPrivateFieldGet2(_network, _this6) == null && !_this6.destroyed)) {
                  _context19.next = 21;
                  break;
                }
                _context19.prev = 1;
                _context19.t0 = _classPrivateFieldSet2;
                _context19.t1 = _network;
                _context19.t2 = _this6;
                _context19.next = 7;
                return _this6._detectNetwork();
              case 7:
                _context19.t3 = _context19.sent;
                (0, _context19.t0)(_context19.t1, _context19.t2, _context19.t3);
                _context19.next = 19;
                break;
              case 11:
                _context19.prev = 11;
                _context19.t4 = _context19["catch"](1);
                if (!_this6.destroyed) {
                  _context19.next = 15;
                  break;
                }
                return _context19.abrupt("break", 21);
              case 15:
                console.log("JsonRpcProvider failed to detect network and cannot start up; retry in 1s (perhaps the URL is wrong or the node is not started)");
                _this6.emit("error", (0, index_js_5.makeError)("failed to bootstrap network detection", "NETWORK_ERROR", {
                  event: "initial-network-discovery",
                  info: {
                    error: _context19.t4
                  }
                }));
                _context19.next = 19;
                return stall(1000);
              case 19:
                _context19.next = 0;
                break;
              case 21:
                // Start dispatching requests
                _assertClassBrand(_JsonRpcApiProvider_brand, _this6, _scheduleDrain).call(_this6);
              case 22:
              case "end":
                return _context19.stop();
            }
          }, _callee19, null, [[1, 11]]);
        }))();
      }
      /**
       *  Resolves once the [[_start]] has been called. This can be used in
       *  sub-classes to defer sending data until the connection has been
       *  established.
       */
    }, {
      key: "_waitUntilReady",
      value: (function () {
        var _waitUntilReady2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee20() {
          return _regeneratorRuntime().wrap(function _callee20$(_context20) {
            while (1) switch (_context20.prev = _context20.next) {
              case 0:
                if (!(_classPrivateFieldGet2(_notReady, this) == null)) {
                  _context20.next = 2;
                  break;
                }
                return _context20.abrupt("return");
              case 2:
                _context20.next = 4;
                return _classPrivateFieldGet2(_notReady, this).promise;
              case 4:
                return _context20.abrupt("return", _context20.sent);
              case 5:
              case "end":
                return _context20.stop();
            }
          }, _callee20, this);
        }));
        function _waitUntilReady() {
          return _waitUntilReady2.apply(this, arguments);
        }
        return _waitUntilReady;
      }()
      /**
       *  Return a Subscriber that will manage the %%sub%%.
       *
       *  Sub-classes may override this to modify the behavior of
       *  subscription management.
       */
      )
    }, {
      key: "_getSubscriber",
      value: function _getSubscriber(sub) {
        // Pending Filters aren't availble via polling
        if (sub.type === "pending") {
          return new subscriber_filterid_js_1.FilterIdPendingSubscriber(this);
        }
        if (sub.type === "event") {
          if (this._getOption("polling")) {
            return new subscriber_polling_js_1.PollingEventSubscriber(this, sub.filter);
          }
          return new subscriber_filterid_js_1.FilterIdEventSubscriber(this, sub.filter);
        }
        // Orphaned Logs are handled automatically, by the filter, since
        // logs with removed are emitted by it
        if (sub.type === "orphan" && sub.filter.orphan === "drop-log") {
          return new abstract_provider_js_1.UnmanagedSubscriber("orphan");
        }
        return _superPropGet(JsonRpcApiProvider, "_getSubscriber", this, 3)([sub]);
      }
      /**
       *  Returns true only if the [[_start]] has been called.
       */
    }, {
      key: "ready",
      get: function get() {
        return _classPrivateFieldGet2(_notReady, this) == null;
      }
      /**
       *  Returns %%tx%% as a normalized JSON-RPC transaction request,
       *  which has all values hexlified and any numeric values converted
       *  to Quantity values.
       */
    }, {
      key: "getRpcTransaction",
      value: function getRpcTransaction(tx) {
        var result = {};
        // JSON-RPC now requires numeric values to be "quantity" values
        ["chainId", "gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach(function (key) {
          if (tx[key] == null) {
            return;
          }
          var dstKey = key;
          if (key === "gasLimit") {
            dstKey = "gas";
          }
          result[dstKey] = (0, index_js_5.toQuantity)((0, index_js_5.getBigInt)(tx[key], "tx.".concat(key)));
        });
        // Make sure addresses and data are lowercase
        ["from", "to", "data"].forEach(function (key) {
          if (tx[key] == null) {
            return;
          }
          result[key] = (0, index_js_5.hexlify)(tx[key]);
        });
        // Normalize the access list object
        if (tx.accessList) {
          result["accessList"] = (0, index_js_4.accessListify)(tx.accessList);
        }
        if (tx.blobVersionedHashes) {
          // @TODO: Remove this <any> case once EIP-4844 added to prepared tx
          result["blobVersionedHashes"] = tx.blobVersionedHashes.map(function (h) {
            return h.toLowerCase();
          });
        }
        // @TODO: blobs should probably also be copied over, optionally
        // accounting for the kzg property to backfill blobVersionedHashes
        // using the commitment. Or should that be left as an exercise to
        // the caller?
        return result;
      }
      /**
       *  Returns the request method and arguments required to perform
       *  %%req%%.
       */
    }, {
      key: "getRpcRequest",
      value: function getRpcRequest(req) {
        switch (req.method) {
          case "chainId":
            return {
              method: "eth_chainId",
              args: []
            };
          case "getBlockNumber":
            return {
              method: "eth_blockNumber",
              args: []
            };
          case "getGasPrice":
            return {
              method: "eth_gasPrice",
              args: []
            };
          case "getPriorityFee":
            return {
              method: "eth_maxPriorityFeePerGas",
              args: []
            };
          case "getBalance":
            return {
              method: "eth_getBalance",
              args: [getLowerCase(req.address), req.blockTag]
            };
          case "getTransactionCount":
            return {
              method: "eth_getTransactionCount",
              args: [getLowerCase(req.address), req.blockTag]
            };
          case "getCode":
            return {
              method: "eth_getCode",
              args: [getLowerCase(req.address), req.blockTag]
            };
          case "getStorage":
            return {
              method: "eth_getStorageAt",
              args: [getLowerCase(req.address), "0x" + req.position.toString(16), req.blockTag]
            };
          case "broadcastTransaction":
            return {
              method: "eth_sendRawTransaction",
              args: [req.signedTransaction]
            };
          case "getBlock":
            if ("blockTag" in req) {
              return {
                method: "eth_getBlockByNumber",
                args: [req.blockTag, !!req.includeTransactions]
              };
            } else if ("blockHash" in req) {
              return {
                method: "eth_getBlockByHash",
                args: [req.blockHash, !!req.includeTransactions]
              };
            }
            break;
          case "getTransaction":
            return {
              method: "eth_getTransactionByHash",
              args: [req.hash]
            };
          case "getTransactionReceipt":
            return {
              method: "eth_getTransactionReceipt",
              args: [req.hash]
            };
          case "call":
            return {
              method: "eth_call",
              args: [this.getRpcTransaction(req.transaction), req.blockTag]
            };
          case "estimateGas":
            {
              return {
                method: "eth_estimateGas",
                args: [this.getRpcTransaction(req.transaction)]
              };
            }
          case "getLogs":
            if (req.filter && req.filter.address != null) {
              if (Array.isArray(req.filter.address)) {
                req.filter.address = req.filter.address.map(getLowerCase);
              } else {
                req.filter.address = getLowerCase(req.filter.address);
              }
            }
            return {
              method: "eth_getLogs",
              args: [req.filter]
            };
        }
        return null;
      }
      /**
       *  Returns an ethers-style Error for the given JSON-RPC error
       *  %%payload%%, coalescing the various strings and error shapes
       *  that different nodes return, coercing them into a machine-readable
       *  standardized error.
       */
    }, {
      key: "getRpcError",
      value: function getRpcError(payload, _error) {
        var method = payload.method;
        var error = _error.error;
        if (method === "eth_estimateGas" && error.message) {
          var msg = error.message;
          if (!msg.match(/revert/i) && msg.match(/insufficient funds/i)) {
            return (0, index_js_5.makeError)("insufficient funds", "INSUFFICIENT_FUNDS", {
              transaction: payload.params[0],
              info: {
                payload: payload,
                error: error
              }
            });
          }
        }
        if (method === "eth_call" || method === "eth_estimateGas") {
          var result = spelunkData(error);
          var e = index_js_1.AbiCoder.getBuiltinCallException(method === "eth_call" ? "call" : "estimateGas", payload.params[0], result ? result.data : null);
          e.info = {
            error: error,
            payload: payload
          };
          return e;
        }
        // Only estimateGas and call can return arbitrary contract-defined text, so now we
        // we can process text safely.
        var message = JSON.stringify(spelunkMessage(error));
        if (typeof error.message === "string" && error.message.match(/user denied|ethers-user-denied/i)) {
          var actionMap = {
            eth_sign: "signMessage",
            personal_sign: "signMessage",
            eth_signTypedData_v4: "signTypedData",
            eth_signTransaction: "signTransaction",
            eth_sendTransaction: "sendTransaction",
            eth_requestAccounts: "requestAccess",
            wallet_requestAccounts: "requestAccess"
          };
          return (0, index_js_5.makeError)("user rejected action", "ACTION_REJECTED", {
            action: actionMap[method] || "unknown",
            reason: "rejected",
            info: {
              payload: payload,
              error: error
            }
          });
        }
        if (method === "eth_sendRawTransaction" || method === "eth_sendTransaction") {
          var transaction = payload.params[0];
          if (message.match(/insufficient funds|base fee exceeds gas limit/i)) {
            return (0, index_js_5.makeError)("insufficient funds for intrinsic transaction cost", "INSUFFICIENT_FUNDS", {
              transaction: transaction,
              info: {
                error: error
              }
            });
          }
          if (message.match(/nonce/i) && message.match(/too low/i)) {
            return (0, index_js_5.makeError)("nonce has already been used", "NONCE_EXPIRED", {
              transaction: transaction,
              info: {
                error: error
              }
            });
          }
          // "replacement transaction underpriced"
          if (message.match(/replacement transaction/i) && message.match(/underpriced/i)) {
            return (0, index_js_5.makeError)("replacement fee too low", "REPLACEMENT_UNDERPRICED", {
              transaction: transaction,
              info: {
                error: error
              }
            });
          }
          if (message.match(/only replay-protected/i)) {
            return (0, index_js_5.makeError)("legacy pre-eip-155 transactions not supported", "UNSUPPORTED_OPERATION", {
              operation: method,
              info: {
                transaction: transaction,
                info: {
                  error: error
                }
              }
            });
          }
        }
        var unsupported = !!message.match(/the method .* does not exist/i);
        if (!unsupported) {
          if (error && error.details && error.details.startsWith("Unauthorized method:")) {
            unsupported = true;
          }
        }
        if (unsupported) {
          return (0, index_js_5.makeError)("unsupported operation", "UNSUPPORTED_OPERATION", {
            operation: payload.method,
            info: {
              error: error,
              payload: payload
            }
          });
        }
        return (0, index_js_5.makeError)("could not coalesce error", "UNKNOWN_ERROR", {
          error: error,
          payload: payload
        });
      }
      /**
       *  Requests the %%method%% with %%params%% via the JSON-RPC protocol
       *  over the underlying channel. This can be used to call methods
       *  on the backend that do not have a high-level API within the Provider
       *  API.
       *
       *  This method queues requests according to the batch constraints
       *  in the options, assigns the request a unique ID.
       *
       *  **Do NOT override** this method in sub-classes; instead
       *  override [[_send]] or force the options values in the
       *  call to the constructor to modify this method's behavior.
       */
    }, {
      key: "send",
      value: function send(method, params) {
        var _this$nextId3,
          _this$nextId4,
          _this7 = this;
        // @TODO: cache chainId?? purge on switch_networks
        // We have been destroyed; no operations are supported anymore
        if (this.destroyed) {
          return Promise.reject((0, index_js_5.makeError)("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", {
            operation: method
          }));
        }
        var id = (_classPrivateFieldSet2(_nextId, this, (_this$nextId3 = _classPrivateFieldGet2(_nextId, this), _this$nextId4 = _this$nextId3++, _this$nextId3)), _this$nextId4);
        var promise = new Promise(function (resolve, reject) {
          _classPrivateFieldGet2(_payloads, _this7).push({
            resolve: resolve,
            reject: reject,
            payload: {
              method: method,
              params: params,
              id: id,
              jsonrpc: "2.0"
            }
          });
        });
        // If there is not a pending drainTimer, set one
        _assertClassBrand(_JsonRpcApiProvider_brand, this, _scheduleDrain).call(this);
        return promise;
      }
      /**
       *  Resolves to the [[Signer]] account for  %%address%% managed by
       *  the client.
       *
       *  If the %%address%% is a number, it is used as an index in the
       *  the accounts from [[listAccounts]].
       *
       *  This can only be used on clients which manage accounts (such as
       *  Geth with imported account or MetaMask).
       *
       *  Throws if the account doesn't exist.
       */
    }, {
      key: "getSigner",
      value: (function () {
        var _getSigner = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee21(address) {
          var accountsPromise, _accounts, _yield, accounts, _iterator, _step, account;
          return _regeneratorRuntime().wrap(function _callee21$(_context21) {
            while (1) switch (_context21.prev = _context21.next) {
              case 0:
                if (address == null) {
                  address = 0;
                }
                accountsPromise = this.send("eth_accounts", []); // Account index
                if (!(typeof address === "number")) {
                  _context21.next = 9;
                  break;
                }
                _context21.next = 5;
                return accountsPromise;
              case 5:
                _accounts = _context21.sent;
                if (!(address >= _accounts.length)) {
                  _context21.next = 8;
                  break;
                }
                throw new Error("no such account");
              case 8:
                return _context21.abrupt("return", new JsonRpcSigner(this, _accounts[address]));
              case 9:
                _context21.next = 11;
                return (0, index_js_5.resolveProperties)({
                  network: this.getNetwork(),
                  accounts: accountsPromise
                });
              case 11:
                _yield = _context21.sent;
                accounts = _yield.accounts;
                // Account address
                address = (0, index_js_2.getAddress)(address);
                _iterator = _createForOfIteratorHelper(accounts);
                _context21.prev = 15;
                _iterator.s();
              case 17:
                if ((_step = _iterator.n()).done) {
                  _context21.next = 23;
                  break;
                }
                account = _step.value;
                if (!((0, index_js_2.getAddress)(account) === address)) {
                  _context21.next = 21;
                  break;
                }
                return _context21.abrupt("return", new JsonRpcSigner(this, address));
              case 21:
                _context21.next = 17;
                break;
              case 23:
                _context21.next = 28;
                break;
              case 25:
                _context21.prev = 25;
                _context21.t0 = _context21["catch"](15);
                _iterator.e(_context21.t0);
              case 28:
                _context21.prev = 28;
                _iterator.f();
                return _context21.finish(28);
              case 31:
                throw new Error("invalid account");
              case 32:
              case "end":
                return _context21.stop();
            }
          }, _callee21, this, [[15, 25, 28, 31]]);
        }));
        function getSigner(_x15) {
          return _getSigner.apply(this, arguments);
        }
        return getSigner;
      }())
    }, {
      key: "listAccounts",
      value: function () {
        var _listAccounts = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee22() {
          var _this8 = this;
          var accounts;
          return _regeneratorRuntime().wrap(function _callee22$(_context22) {
            while (1) switch (_context22.prev = _context22.next) {
              case 0:
                _context22.next = 2;
                return this.send("eth_accounts", []);
              case 2:
                accounts = _context22.sent;
                return _context22.abrupt("return", accounts.map(function (a) {
                  return new JsonRpcSigner(_this8, a);
                }));
              case 4:
              case "end":
                return _context22.stop();
            }
          }, _callee22, this);
        }));
        function listAccounts() {
          return _listAccounts.apply(this, arguments);
        }
        return listAccounts;
      }()
    }, {
      key: "destroy",
      value: function destroy() {
        // Stop processing requests
        if (_classPrivateFieldGet2(_drainTimer, this)) {
          clearTimeout(_classPrivateFieldGet2(_drainTimer, this));
          _classPrivateFieldSet2(_drainTimer, this, null);
        }
        // Cancel all pending requests
        var _iterator2 = _createForOfIteratorHelper(_classPrivateFieldGet2(_payloads, this)),
          _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var _step2$value = _step2.value,
              payload = _step2$value.payload,
              reject = _step2$value.reject;
            reject((0, index_js_5.makeError)("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", {
              operation: payload.method
            }));
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
        _classPrivateFieldSet2(_payloads, this, []);
        // Parent clean-up
        _superPropGet(JsonRpcApiProvider, "destroy", this, 3)([]);
      }
    }]);
  }(abstract_provider_js_1.AbstractProvider);
  function _scheduleDrain() {
    var _this12 = this;
    if (_classPrivateFieldGet2(_drainTimer, this)) {
      return;
    }
    // If we aren't using batching, no harm in sending it immediately
    var stallTime = this._getOption("batchMaxCount") === 1 ? 0 : this._getOption("batchStallTime");
    _classPrivateFieldSet2(_drainTimer, this, setTimeout(function () {
      _classPrivateFieldSet2(_drainTimer, _this12, null);
      var payloads = _classPrivateFieldGet2(_payloads, _this12);
      _classPrivateFieldSet2(_payloads, _this12, []);
      var _loop = function _loop() {
        // Create payload batches that satisfy our batch constraints
        var batch = [payloads.shift()];
        while (payloads.length) {
          if (batch.length === _classPrivateFieldGet2(_options, _this12).batchMaxCount) {
            break;
          }
          batch.push(payloads.shift());
          var bytes = JSON.stringify(batch.map(function (p) {
            return p.payload;
          }));
          if (bytes.length > _classPrivateFieldGet2(_options, _this12).batchMaxSize) {
            payloads.unshift(batch.pop());
            break;
          }
        }
        // Process the result to each payload
        _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee25() {
          var payload, result, _loop2, _ret, _i, _batch, _i2, _batch2, reject;
          return _regeneratorRuntime().wrap(function _callee25$(_context26) {
            while (1) switch (_context26.prev = _context26.next) {
              case 0:
                payload = batch.length === 1 ? batch[0].payload : batch.map(function (p) {
                  return p.payload;
                });
                _this12.emit("debug", {
                  action: "sendRpcPayload",
                  payload: payload
                });
                _context26.prev = 2;
                _context26.next = 5;
                return _this12._send(payload);
              case 5:
                result = _context26.sent;
                _this12.emit("debug", {
                  action: "receiveRpcResult",
                  result: result
                });
                // Process results in batch order
                _loop2 = /*#__PURE__*/_regeneratorRuntime().mark(function _loop2() {
                  var _batch$_i, resolve, reject, payload, resp, error;
                  return _regeneratorRuntime().wrap(function _loop2$(_context25) {
                    while (1) switch (_context25.prev = _context25.next) {
                      case 0:
                        _batch$_i = _batch[_i], resolve = _batch$_i.resolve, reject = _batch$_i.reject, payload = _batch$_i.payload;
                        if (!_this12.destroyed) {
                          _context25.next = 4;
                          break;
                        }
                        reject((0, index_js_5.makeError)("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", {
                          operation: payload.method
                        }));
                        return _context25.abrupt("return", 0);
                      case 4:
                        // Find the matching result
                        resp = result.filter(function (r) {
                          return r.id === payload.id;
                        })[0]; // No result; the node failed us in unexpected ways
                        if (!(resp == null)) {
                          _context25.next = 10;
                          break;
                        }
                        error = (0, index_js_5.makeError)("missing response for request", "BAD_DATA", {
                          value: result,
                          info: {
                            payload: payload
                          }
                        });
                        _this12.emit("error", error);
                        reject(error);
                        return _context25.abrupt("return", 0);
                      case 10:
                        if (!("error" in resp)) {
                          _context25.next = 13;
                          break;
                        }
                        reject(_this12.getRpcError(payload, resp));
                        return _context25.abrupt("return", 0);
                      case 13:
                        // All good; send the result
                        resolve(resp.result);
                      case 14:
                      case "end":
                        return _context25.stop();
                    }
                  }, _loop2);
                });
                _i = 0, _batch = batch;
              case 9:
                if (!(_i < _batch.length)) {
                  _context26.next = 17;
                  break;
                }
                return _context26.delegateYield(_loop2(), "t0", 11);
              case 11:
                _ret = _context26.t0;
                if (!(_ret === 0)) {
                  _context26.next = 14;
                  break;
                }
                return _context26.abrupt("continue", 14);
              case 14:
                _i++;
                _context26.next = 9;
                break;
              case 17:
                _context26.next = 23;
                break;
              case 19:
                _context26.prev = 19;
                _context26.t1 = _context26["catch"](2);
                _this12.emit("debug", {
                  action: "receiveRpcError",
                  error: _context26.t1
                });
                for (_i2 = 0, _batch2 = batch; _i2 < _batch2.length; _i2++) {
                  reject = _batch2[_i2].reject;
                  // @TODO: augment the error with the payload
                  reject(_context26.t1);
                }
              case 23:
              case "end":
                return _context26.stop();
            }
          }, _callee25, null, [[2, 19]]);
        }))();
      };
      while (payloads.length) {
        _loop();
      }
    }, stallTime));
  }
  providerJsonrpc.JsonRpcApiProvider = JsonRpcApiProvider;
  // @TODO: remove this in v7, it is not exported because this functionality
  // is exposed in the JsonRpcApiProvider by setting polling to true. It should
  // be safe to remove regardless, because it isn't reachable, but just in case.
  /**
   *  @_ignore:
   */
  var _pollingInterval = /*#__PURE__*/new WeakMap();
  var JsonRpcApiPollingProvider = /*#__PURE__*/function (_JsonRpcApiProvider2) {
    function JsonRpcApiPollingProvider(network, options) {
      var _this9;
      _classCallCheck(this, JsonRpcApiPollingProvider);
      _this9 = _callSuper(this, JsonRpcApiPollingProvider, [network, options]);
      _classPrivateFieldInitSpec(_this9, _pollingInterval, void 0);
      var pollingInterval = _this9._getOption("pollingInterval");
      if (pollingInterval == null) {
        pollingInterval = defaultOptions.pollingInterval;
      }
      _classPrivateFieldSet2(_pollingInterval, _this9, pollingInterval);
      return _this9;
    }
    _inherits(JsonRpcApiPollingProvider, _JsonRpcApiProvider2);
    return _createClass(JsonRpcApiPollingProvider, [{
      key: "_getSubscriber",
      value: function _getSubscriber(sub) {
        var subscriber = _superPropGet(JsonRpcApiPollingProvider, "_getSubscriber", this, 3)([sub]);
        if (isPollable(subscriber)) {
          subscriber.pollingInterval = _classPrivateFieldGet2(_pollingInterval, this);
        }
        return subscriber;
      }
      /**
       *  The polling interval (default: 4000 ms)
       */
    }, {
      key: "pollingInterval",
      get: function get() {
        return _classPrivateFieldGet2(_pollingInterval, this);
      },
      set: function set(value) {
        var _this10 = this;
        if (!Number.isInteger(value) || value < 0) {
          throw new Error("invalid interval");
        }
        _classPrivateFieldSet2(_pollingInterval, this, value);
        this._forEachSubscriber(function (sub) {
          if (isPollable(sub)) {
            sub.pollingInterval = _classPrivateFieldGet2(_pollingInterval, _this10);
          }
        });
      }
    }]);
  }(JsonRpcApiProvider);
  providerJsonrpc.JsonRpcApiPollingProvider = JsonRpcApiPollingProvider;
  /**
   *  The JsonRpcProvider is one of the most common Providers,
   *  which performs all operations over HTTP (or HTTPS) requests.
   *
   *  Events are processed by polling the backend for the current block
   *  number; when it advances, all block-base events are then checked
   *  for updates.
   */
  var _connect = /*#__PURE__*/new WeakMap();
  var JsonRpcProvider = /*#__PURE__*/function (_JsonRpcApiPollingPro) {
    function JsonRpcProvider(url, network, options) {
      var _this11;
      _classCallCheck(this, JsonRpcProvider);
      if (url == null) {
        url = "http:/\/localhost:8545";
      }
      _this11 = _callSuper(this, JsonRpcProvider, [network, options]);
      _classPrivateFieldInitSpec(_this11, _connect, void 0);
      if (typeof url === "string") {
        _classPrivateFieldSet2(_connect, _this11, new index_js_5.FetchRequest(url));
      } else {
        _classPrivateFieldSet2(_connect, _this11, url.clone());
      }
      return _this11;
    }
    _inherits(JsonRpcProvider, _JsonRpcApiPollingPro);
    return _createClass(JsonRpcProvider, [{
      key: "_getConnection",
      value: function _getConnection() {
        return _classPrivateFieldGet2(_connect, this).clone();
      }
    }, {
      key: "send",
      value: function () {
        var _send2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee23(method, params) {
          return _regeneratorRuntime().wrap(function _callee23$(_context23) {
            while (1) switch (_context23.prev = _context23.next) {
              case 0:
                _context23.next = 2;
                return this._start();
              case 2:
                _context23.next = 4;
                return _superPropGet(JsonRpcProvider, "send", this, 3)([method, params]);
              case 4:
                return _context23.abrupt("return", _context23.sent);
              case 5:
              case "end":
                return _context23.stop();
            }
          }, _callee23, this);
        }));
        function send(_x16, _x17) {
          return _send2.apply(this, arguments);
        }
        return send;
      }()
    }, {
      key: "_send",
      value: function () {
        var _send3 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee24(payload) {
          var request, response, resp;
          return _regeneratorRuntime().wrap(function _callee24$(_context24) {
            while (1) switch (_context24.prev = _context24.next) {
              case 0:
                // Configure a POST connection for the requested method
                request = this._getConnection();
                request.body = JSON.stringify(payload);
                request.setHeader("content-type", "application/json");
                _context24.next = 5;
                return request.send();
              case 5:
                response = _context24.sent;
                response.assertOk();
                resp = response.bodyJson;
                if (!Array.isArray(resp)) {
                  resp = [resp];
                }
                return _context24.abrupt("return", resp);
              case 10:
              case "end":
                return _context24.stop();
            }
          }, _callee24, this);
        }));
        function _send(_x18) {
          return _send3.apply(this, arguments);
        }
        return _send;
      }()
    }]);
  }(JsonRpcApiPollingProvider);
  providerJsonrpc.JsonRpcProvider = JsonRpcProvider;
  function spelunkData(value) {
    if (value == null) {
      return null;
    }
    // These *are* the droids we're looking for.
    if (typeof value.message === "string" && value.message.match(/revert/i) && (0, index_js_5.isHexString)(value.data)) {
      return {
        message: value.message,
        data: value.data
      };
    }
    // Spelunk further...
    if (_typeof(value) === "object") {
      for (var key in value) {
        var result = spelunkData(value[key]);
        if (result) {
          return result;
        }
      }
      return null;
    }
    // Might be a JSON string we can further descend...
    if (typeof value === "string") {
      try {
        return spelunkData(JSON.parse(value));
      } catch (error) {}
    }
    return null;
  }
  function _spelunkMessage(value, result) {
    if (value == null) {
      return;
    }
    // These *are* the droids we're looking for.
    if (typeof value.message === "string") {
      result.push(value.message);
    }
    // Spelunk further...
    if (_typeof(value) === "object") {
      for (var key in value) {
        _spelunkMessage(value[key], result);
      }
    }
    // Might be a JSON string we can further descend...
    if (typeof value === "string") {
      try {
        return _spelunkMessage(JSON.parse(value), result);
      } catch (error) {}
    }
  }
  function spelunkMessage(value) {
    var result = [];
    _spelunkMessage(value, result);
    return result;
  }
  return providerJsonrpc;
}

var hasRequiredProviderAnkr;
function requireProviderAnkr() {
  if (hasRequiredProviderAnkr) return providerAnkr;
  hasRequiredProviderAnkr = 1;
  Object.defineProperty(providerAnkr, "__esModule", {
    value: true
  });
  providerAnkr.AnkrProvider = void 0;
  /**
   *  [[link-ankr]] provides a third-party service for connecting to
   *  various blockchains over JSON-RPC.
   *
   *  **Supported Networks**
   *
   *  - Ethereum Mainnet (``mainnet``)
   *  - Goerli Testnet (``goerli``)
   *  - Sepolia Testnet (``sepolia``)
   *  - Arbitrum (``arbitrum``)
   *  - Base (``base``)
   *  - Base Goerlia Testnet (``base-goerli``)
   *  - Base Sepolia Testnet (``base-sepolia``)
   *  - BNB (``bnb``)
   *  - BNB Testnet (``bnbt``)
   *  - Optimism (``optimism``)
   *  - Optimism Goerli Testnet (``optimism-goerli``)
   *  - Optimism Sepolia Testnet (``optimism-sepolia``)
   *  - Polygon (``matic``)
   *  - Polygon Mumbai Testnet (``matic-mumbai``)
   *
   *  @_subsection: api/providers/thirdparty:Ankr  [providers-ankr]
   */
  var index_js_1 = /*@__PURE__*/requireUtils$3();
  var community_js_1 = /*@__PURE__*/requireCommunity();
  var network_js_1 = /*@__PURE__*/requireNetwork();
  var provider_jsonrpc_js_1 = /*@__PURE__*/requireProviderJsonrpc();
  var defaultApiKey = "9f7d929b018cdffb338517efa06f58359e86ff1ffd350bc889738523659e7972";
  function getHost(name) {
    switch (name) {
      case "mainnet":
        return "rpc.ankr.com/eth";
      case "goerli":
        return "rpc.ankr.com/eth_goerli";
      case "sepolia":
        return "rpc.ankr.com/eth_sepolia";
      case "arbitrum":
        return "rpc.ankr.com/arbitrum";
      case "base":
        return "rpc.ankr.com/base";
      case "base-goerli":
        return "rpc.ankr.com/base_goerli";
      case "base-sepolia":
        return "rpc.ankr.com/base_sepolia";
      case "bnb":
        return "rpc.ankr.com/bsc";
      case "bnbt":
        return "rpc.ankr.com/bsc_testnet_chapel";
      case "matic":
        return "rpc.ankr.com/polygon";
      case "matic-mumbai":
        return "rpc.ankr.com/polygon_mumbai";
      case "optimism":
        return "rpc.ankr.com/optimism";
      case "optimism-goerli":
        return "rpc.ankr.com/optimism_testnet";
      case "optimism-sepolia":
        return "rpc.ankr.com/optimism_sepolia";
    }
    (0, index_js_1.assertArgument)(false, "unsupported network", "network", name);
  }
  /**
   *  The **AnkrProvider** connects to the [[link-ankr]]
   *  JSON-RPC end-points.
   *
   *  By default, a highly-throttled API key is used, which is
   *  appropriate for quick prototypes and simple scripts. To
   *  gain access to an increased rate-limit, it is highly
   *  recommended to [sign up here](link-ankr-signup).
   */
  var AnkrProvider = /*#__PURE__*/function (_provider_jsonrpc_js_) {
    /**
     *  Create a new **AnkrProvider**.
     *
     *  By default connecting to ``mainnet`` with a highly throttled
     *  API key.
     */
    function AnkrProvider(_network, apiKey) {
      var _this;
      _classCallCheck(this, AnkrProvider);
      if (_network == null) {
        _network = "mainnet";
      }
      var network = network_js_1.Network.from(_network);
      if (apiKey == null) {
        apiKey = defaultApiKey;
      }
      // Ankr does not support filterId, so we force polling
      var options = {
        polling: true,
        staticNetwork: network
      };
      var request = AnkrProvider.getRequest(network, apiKey);
      _this = _callSuper(this, AnkrProvider, [request, network, options]);
      /**
       *  The API key for the Ankr connection.
       */
      _defineProperty(_this, "apiKey", void 0);
      (0, index_js_1.defineProperties)(_this, {
        apiKey: apiKey
      });
      return _this;
    }
    _inherits(AnkrProvider, _provider_jsonrpc_js_);
    return _createClass(AnkrProvider, [{
      key: "_getProvider",
      value: function _getProvider(chainId) {
        try {
          return new AnkrProvider(chainId, this.apiKey);
        } catch (error) {}
        return _superPropGet(AnkrProvider, "_getProvider", this, 3)([chainId]);
      }
      /**
       *  Returns a prepared request for connecting to %%network%% with
       *  %%apiKey%%.
       */
    }, {
      key: "getRpcError",
      value: function getRpcError(payload, error) {
        if (payload.method === "eth_sendRawTransaction") {
          if (error && error.error && error.error.message === "INTERNAL_ERROR: could not replace existing tx") {
            error.error.message = "replacement transaction underpriced";
          }
        }
        return _superPropGet(AnkrProvider, "getRpcError", this, 3)([payload, error]);
      }
    }, {
      key: "isCommunityResource",
      value: function isCommunityResource() {
        return this.apiKey === defaultApiKey;
      }
    }], [{
      key: "getRequest",
      value: function getRequest(network, apiKey) {
        if (apiKey == null) {
          apiKey = defaultApiKey;
        }
        var request = new index_js_1.FetchRequest("https://".concat(getHost(network.name), "/").concat(apiKey));
        request.allowGzip = true;
        if (apiKey === defaultApiKey) {
          request.retryFunc = /*#__PURE__*/function () {
            var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(request, response, attempt) {
              return _regeneratorRuntime().wrap(function _callee$(_context) {
                while (1) switch (_context.prev = _context.next) {
                  case 0:
                    (0, community_js_1.showThrottleMessage)("AnkrProvider");
                    return _context.abrupt("return", true);
                  case 2:
                  case "end":
                    return _context.stop();
                }
              }, _callee);
            }));
            return function (_x, _x2, _x3) {
              return _ref.apply(this, arguments);
            };
          }();
        }
        return request;
      }
    }]);
  }(provider_jsonrpc_js_1.JsonRpcProvider);
  providerAnkr.AnkrProvider = AnkrProvider;
  return providerAnkr;
}

var providerAlchemy = {};

var hasRequiredProviderAlchemy;
function requireProviderAlchemy() {
  if (hasRequiredProviderAlchemy) return providerAlchemy;
  hasRequiredProviderAlchemy = 1;
  /**
   *  [[link-alchemy]] provides a third-party service for connecting to
   *  various blockchains over JSON-RPC.
   *
   *  **Supported Networks**
   *
   *  - Ethereum Mainnet (``mainnet``)
   *  - Goerli Testnet (``goerli``)
   *  - Sepolia Testnet (``sepolia``)
   *  - Arbitrum (``arbitrum``)
   *  - Arbitrum Goerli Testnet (``arbitrum-goerli``)
   *  - Arbitrum Sepolia Testnet (``arbitrum-sepolia``)
   *  - Base (``base``)
   *  - Base Goerlia Testnet (``base-goerli``)
   *  - Base Sepolia Testnet (``base-sepolia``)
   *  - Optimism (``optimism``)
   *  - Optimism Goerli Testnet (``optimism-goerli``)
   *  - Optimism Sepolia Testnet (``optimism-sepolia``)
   *  - Polygon (``matic``)
   *  - Polygon Amoy Testnet (``matic-amoy``)
   *  - Polygon Mumbai Testnet (``matic-mumbai``)
   *
   *  @_subsection: api/providers/thirdparty:Alchemy  [providers-alchemy]
   */
  Object.defineProperty(providerAlchemy, "__esModule", {
    value: true
  });
  providerAlchemy.AlchemyProvider = void 0;
  var index_js_1 = /*@__PURE__*/requireUtils$3();
  var community_js_1 = /*@__PURE__*/requireCommunity();
  var network_js_1 = /*@__PURE__*/requireNetwork();
  var provider_jsonrpc_js_1 = /*@__PURE__*/requireProviderJsonrpc();
  var defaultApiKey = "_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC";
  function getHost(name) {
    switch (name) {
      case "mainnet":
        return "eth-mainnet.alchemyapi.io";
      case "goerli":
        return "eth-goerli.g.alchemy.com";
      case "sepolia":
        return "eth-sepolia.g.alchemy.com";
      case "arbitrum":
        return "arb-mainnet.g.alchemy.com";
      case "arbitrum-goerli":
        return "arb-goerli.g.alchemy.com";
      case "arbitrum-sepolia":
        return "arb-sepolia.g.alchemy.com";
      case "base":
        return "base-mainnet.g.alchemy.com";
      case "base-goerli":
        return "base-goerli.g.alchemy.com";
      case "base-sepolia":
        return "base-sepolia.g.alchemy.com";
      case "matic":
        return "polygon-mainnet.g.alchemy.com";
      case "matic-amoy":
        return "polygon-amoy.g.alchemy.com";
      case "matic-mumbai":
        return "polygon-mumbai.g.alchemy.com";
      case "optimism":
        return "opt-mainnet.g.alchemy.com";
      case "optimism-goerli":
        return "opt-goerli.g.alchemy.com";
      case "optimism-sepolia":
        return "opt-sepolia.g.alchemy.com";
    }
    (0, index_js_1.assertArgument)(false, "unsupported network", "network", name);
  }
  /**
   *  The **AlchemyProvider** connects to the [[link-alchemy]]
   *  JSON-RPC end-points.
   *
   *  By default, a highly-throttled API key is used, which is
   *  appropriate for quick prototypes and simple scripts. To
   *  gain access to an increased rate-limit, it is highly
   *  recommended to [sign up here](link-alchemy-signup).
   *
   *  @_docloc: api/providers/thirdparty
   */
  var AlchemyProvider = /*#__PURE__*/function (_provider_jsonrpc_js_) {
    function AlchemyProvider(_network, apiKey) {
      var _this;
      _classCallCheck(this, AlchemyProvider);
      if (_network == null) {
        _network = "mainnet";
      }
      var network = network_js_1.Network.from(_network);
      if (apiKey == null) {
        apiKey = defaultApiKey;
      }
      var request = AlchemyProvider.getRequest(network, apiKey);
      _this = _callSuper(this, AlchemyProvider, [request, network, {
        staticNetwork: network
      }]);
      _defineProperty(_this, "apiKey", void 0);
      (0, index_js_1.defineProperties)(_this, {
        apiKey: apiKey
      });
      return _this;
    }
    _inherits(AlchemyProvider, _provider_jsonrpc_js_);
    return _createClass(AlchemyProvider, [{
      key: "_getProvider",
      value: function _getProvider(chainId) {
        try {
          return new AlchemyProvider(chainId, this.apiKey);
        } catch (error) {}
        return _superPropGet(AlchemyProvider, "_getProvider", this, 3)([chainId]);
      }
    }, {
      key: "_perform",
      value: function () {
        var _perform2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(req) {
          var _yield, trace, tx, data, error;
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                if (!(req.method === "getTransactionResult")) {
                  _context.next = 14;
                  break;
                }
                _context.next = 3;
                return (0, index_js_1.resolveProperties)({
                  trace: this.send("trace_transaction", [req.hash]),
                  tx: this.getTransaction(req.hash)
                });
              case 3:
                _yield = _context.sent;
                trace = _yield.trace;
                tx = _yield.tx;
                if (!(trace == null || tx == null)) {
                  _context.next = 8;
                  break;
                }
                return _context.abrupt("return", null);
              case 8:
                error = false;
                try {
                  data = trace[0].result.output;
                  error = trace[0].error === "Reverted";
                } catch (error) {}
                if (!data) {
                  _context.next = 13;
                  break;
                }
                (0, index_js_1.assert)(!error, "an error occurred during transaction executions", "CALL_EXCEPTION", {
                  action: "getTransactionResult",
                  data: data,
                  reason: null,
                  transaction: tx,
                  invocation: null,
                  revert: null // @TODO
                });
                return _context.abrupt("return", data);
              case 13:
                (0, index_js_1.assert)(false, "could not parse trace result", "BAD_DATA", {
                  value: trace
                });
              case 14:
                _context.next = 16;
                return _superPropGet(AlchemyProvider, "_perform", this, 3)([req]);
              case 16:
                return _context.abrupt("return", _context.sent);
              case 17:
              case "end":
                return _context.stop();
            }
          }, _callee, this);
        }));
        function _perform(_x) {
          return _perform2.apply(this, arguments);
        }
        return _perform;
      }()
    }, {
      key: "isCommunityResource",
      value: function isCommunityResource() {
        return this.apiKey === defaultApiKey;
      }
    }], [{
      key: "getRequest",
      value: function getRequest(network, apiKey) {
        if (apiKey == null) {
          apiKey = defaultApiKey;
        }
        var request = new index_js_1.FetchRequest("https://".concat(getHost(network.name), "/v2/").concat(apiKey));
        request.allowGzip = true;
        if (apiKey === defaultApiKey) {
          request.retryFunc = /*#__PURE__*/function () {
            var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(request, response, attempt) {
              return _regeneratorRuntime().wrap(function _callee2$(_context2) {
                while (1) switch (_context2.prev = _context2.next) {
                  case 0:
                    (0, community_js_1.showThrottleMessage)("alchemy");
                    return _context2.abrupt("return", true);
                  case 2:
                  case "end":
                    return _context2.stop();
                }
              }, _callee2);
            }));
            return function (_x2, _x3, _x4) {
              return _ref.apply(this, arguments);
            };
          }();
        }
        return request;
      }
    }]);
  }(provider_jsonrpc_js_1.JsonRpcProvider);
  providerAlchemy.AlchemyProvider = AlchemyProvider;
  return providerAlchemy;
}

var providerChainstack = {};

var hasRequiredProviderChainstack;
function requireProviderChainstack() {
  if (hasRequiredProviderChainstack) return providerChainstack;
  hasRequiredProviderChainstack = 1;
  Object.defineProperty(providerChainstack, "__esModule", {
    value: true
  });
  providerChainstack.ChainstackProvider = void 0;
  /**
   *  [[link-chainstack]] provides a third-party service for connecting to
   *  various blockchains over JSON-RPC.
   *
   *  **Supported Networks**
   *
   *  - Ethereum Mainnet (``mainnet``)
   *  - Arbitrum (``arbitrum``)
   *  - BNB Smart Chain Mainnet (``bnb``)
   *  - Polygon (``matic``)
   *
   *  @_subsection: api/providers/thirdparty:Chainstack  [providers-chainstack]
   */
  var index_js_1 = /*@__PURE__*/requireUtils$3();
  var community_js_1 = /*@__PURE__*/requireCommunity();
  var network_js_1 = /*@__PURE__*/requireNetwork();
  var provider_jsonrpc_js_1 = /*@__PURE__*/requireProviderJsonrpc();
  function getApiKey(name) {
    switch (name) {
      case "mainnet":
        return "39f1d67cedf8b7831010a665328c9197";
      case "arbitrum":
        return "0550c209db33c3abf4cc927e1e18cea1";
      case "bnb":
        return "98b5a77e531614387366f6fc5da097f8";
      case "matic":
        return "cd9d4d70377471aa7c142ec4a4205249";
    }
    (0, index_js_1.assertArgument)(false, "unsupported network", "network", name);
  }
  function getHost(name) {
    switch (name) {
      case "mainnet":
        return "ethereum-mainnet.core.chainstack.com";
      case "arbitrum":
        return "arbitrum-mainnet.core.chainstack.com";
      case "bnb":
        return "bsc-mainnet.core.chainstack.com";
      case "matic":
        return "polygon-mainnet.core.chainstack.com";
    }
    (0, index_js_1.assertArgument)(false, "unsupported network", "network", name);
  }
  /**
   *  The **ChainstackProvider** connects to the [[link-chainstack]]
   *  JSON-RPC end-points.
   *
   *  By default, a highly-throttled API key is used, which is
   *  appropriate for quick prototypes and simple scripts. To
   *  gain access to an increased rate-limit, it is highly
   *  recommended to [sign up here](link-chainstack).
   */
  var ChainstackProvider = /*#__PURE__*/function (_provider_jsonrpc_js_) {
    /**
     *  Creates a new **ChainstackProvider**.
     */
    function ChainstackProvider(_network, apiKey) {
      var _this;
      _classCallCheck(this, ChainstackProvider);
      if (_network == null) {
        _network = "mainnet";
      }
      var network = network_js_1.Network.from(_network);
      if (apiKey == null) {
        apiKey = getApiKey(network.name);
      }
      var request = ChainstackProvider.getRequest(network, apiKey);
      _this = _callSuper(this, ChainstackProvider, [request, network, {
        staticNetwork: network
      }]);
      /**
       *  The API key for the Chainstack connection.
       */
      _defineProperty(_this, "apiKey", void 0);
      (0, index_js_1.defineProperties)(_this, {
        apiKey: apiKey
      });
      return _this;
    }
    _inherits(ChainstackProvider, _provider_jsonrpc_js_);
    return _createClass(ChainstackProvider, [{
      key: "_getProvider",
      value: function _getProvider(chainId) {
        try {
          return new ChainstackProvider(chainId, this.apiKey);
        } catch (error) {}
        return _superPropGet(ChainstackProvider, "_getProvider", this, 3)([chainId]);
      }
    }, {
      key: "isCommunityResource",
      value: function isCommunityResource() {
        return this.apiKey === getApiKey(this._network.name);
      }
      /**
       *  Returns a prepared request for connecting to %%network%%
       *  with %%apiKey%% and %%projectSecret%%.
       */
    }], [{
      key: "getRequest",
      value: function getRequest(network, apiKey) {
        if (apiKey == null) {
          apiKey = getApiKey(network.name);
        }
        var request = new index_js_1.FetchRequest("https://".concat(getHost(network.name), "/").concat(apiKey));
        request.allowGzip = true;
        if (apiKey === getApiKey(network.name)) {
          request.retryFunc = /*#__PURE__*/function () {
            var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(request, response, attempt) {
              return _regeneratorRuntime().wrap(function _callee$(_context) {
                while (1) switch (_context.prev = _context.next) {
                  case 0:
                    (0, community_js_1.showThrottleMessage)("ChainstackProvider");
                    return _context.abrupt("return", true);
                  case 2:
                  case "end":
                    return _context.stop();
                }
              }, _callee);
            }));
            return function (_x, _x2, _x3) {
              return _ref.apply(this, arguments);
            };
          }();
        }
        return request;
      }
    }]);
  }(provider_jsonrpc_js_1.JsonRpcProvider);
  providerChainstack.ChainstackProvider = ChainstackProvider;
  return providerChainstack;
}

var providerCloudflare = {};

var hasRequiredProviderCloudflare;
function requireProviderCloudflare() {
  if (hasRequiredProviderCloudflare) return providerCloudflare;
  hasRequiredProviderCloudflare = 1;
  /**
   *  About Cloudflare
   *
   *  @_subsection: api/providers/thirdparty:Cloudflare  [providers-cloudflare]
   */
  Object.defineProperty(providerCloudflare, "__esModule", {
    value: true
  });
  providerCloudflare.CloudflareProvider = void 0;
  var index_js_1 = /*@__PURE__*/requireUtils$3();
  var network_js_1 = /*@__PURE__*/requireNetwork();
  var provider_jsonrpc_js_1 = /*@__PURE__*/requireProviderJsonrpc();
  /**
   *  About Cloudflare...
   */
  var CloudflareProvider = /*#__PURE__*/function (_provider_jsonrpc_js_) {
    function CloudflareProvider(_network) {
      _classCallCheck(this, CloudflareProvider);
      if (_network == null) {
        _network = "mainnet";
      }
      var network = network_js_1.Network.from(_network);
      (0, index_js_1.assertArgument)(network.name === "mainnet", "unsupported network", "network", _network);
      return _callSuper(this, CloudflareProvider, ["https:/\/cloudflare-eth.com/", network, {
        staticNetwork: network
      }]);
    }
    _inherits(CloudflareProvider, _provider_jsonrpc_js_);
    return _createClass(CloudflareProvider);
  }(provider_jsonrpc_js_1.JsonRpcProvider);
  providerCloudflare.CloudflareProvider = CloudflareProvider;
  return providerCloudflare;
}

var providerEtherscan = {};

var hasRequiredProviderEtherscan;
function requireProviderEtherscan() {
  if (hasRequiredProviderEtherscan) return providerEtherscan;
  hasRequiredProviderEtherscan = 1;
  /**
   *  [[link-etherscan]] provides a third-party service for connecting to
   *  various blockchains over a combination of JSON-RPC and custom API
   *  endpoints.
   *
   *  **Supported Networks**
   *
   *  - Ethereum Mainnet (``mainnet``)
   *  - Goerli Testnet (``goerli``)
   *  - Sepolia Testnet (``sepolia``)
   *  - Holesky Testnet (``holesky``)
   *  - Arbitrum (``arbitrum``)
   *  - Arbitrum Goerli Testnet (``arbitrum-goerli``)
   *  - Base (``base``)
   *  - Base Sepolia Testnet (``base-sepolia``)
   *  - BNB Smart Chain Mainnet (``bnb``)
   *  - BNB Smart Chain Testnet (``bnbt``)
   *  - Optimism (``optimism``)
   *  - Optimism Goerli Testnet (``optimism-goerli``)
   *  - Polygon (``matic``)
   *  - Polygon Mumbai Testnet (``matic-mumbai``)
   *  - Polygon Amoy Testnet (``matic-amoy``)
   *
   *  @_subsection api/providers/thirdparty:Etherscan  [providers-etherscan]
   */
  Object.defineProperty(providerEtherscan, "__esModule", {
    value: true
  });
  providerEtherscan.EtherscanProvider = providerEtherscan.EtherscanPlugin = void 0;
  var index_js_1 = /*@__PURE__*/requireAbi();
  var index_js_2 = /*@__PURE__*/requireContract();
  var index_js_3 = /*@__PURE__*/requireTransaction();
  var index_js_4 = /*@__PURE__*/requireUtils$3();
  var abstract_provider_js_1 = /*@__PURE__*/requireAbstractProvider();
  var network_js_1 = /*@__PURE__*/requireNetwork();
  var plugins_network_js_1 = /*@__PURE__*/requirePluginsNetwork();
  var community_js_1 = /*@__PURE__*/requireCommunity();
  var THROTTLE = 2000;
  function isPromise(value) {
    return value && typeof value.then === "function";
  }
  var EtherscanPluginId = "org.ethers.plugins.provider.Etherscan";
  /**
   *  A Network can include an **EtherscanPlugin** to provide
   *  a custom base URL.
   *
   *  @_docloc: api/providers/thirdparty:Etherscan
   */
  var EtherscanPlugin = /*#__PURE__*/function (_plugins_network_js_) {
    /**
     *  Creates a new **EtherscanProvider** which will use
     *  %%baseUrl%%.
     */
    function EtherscanPlugin(baseUrl) {
      var _this;
      _classCallCheck(this, EtherscanPlugin);
      _this = _callSuper(this, EtherscanPlugin, [EtherscanPluginId]);
      /**
       *  The Etherscan API base URL.
       */
      _defineProperty(_this, "baseUrl", void 0);
      (0, index_js_4.defineProperties)(_this, {
        baseUrl: baseUrl
      });
      return _this;
    }
    _inherits(EtherscanPlugin, _plugins_network_js_);
    return _createClass(EtherscanPlugin, [{
      key: "clone",
      value: function clone() {
        return new EtherscanPlugin(this.baseUrl);
      }
    }]);
  }(plugins_network_js_1.NetworkPlugin);
  providerEtherscan.EtherscanPlugin = EtherscanPlugin;
  var skipKeys = ["enableCcipRead"];
  var nextId = 1;
  /**
   *  The **EtherscanBaseProvider** is the super-class of
   *  [[EtherscanProvider]], which should generally be used instead.
   *
   *  Since the **EtherscanProvider** includes additional code for
   *  [[Contract]] access, in //rare cases// that contracts are not
   *  used, this class can reduce code size.
   *
   *  @_docloc: api/providers/thirdparty:Etherscan
   */
  var _plugin = /*#__PURE__*/new WeakMap();
  var EtherscanProvider = /*#__PURE__*/function (_abstract_provider_js) {
    /**
     *  Creates a new **EtherscanBaseProvider**.
     */
    function EtherscanProvider(_network, _apiKey) {
      var _this2;
      _classCallCheck(this, EtherscanProvider);
      var apiKey = _apiKey != null ? _apiKey : null;
      _this2 = _callSuper(this, EtherscanProvider);
      /**
       *  The connected network.
       */
      _defineProperty(_this2, "network", void 0);
      /**
       *  The API key or null if using the community provided bandwidth.
       */
      _defineProperty(_this2, "apiKey", void 0);
      _classPrivateFieldInitSpec(_this2, _plugin, void 0);
      var network = network_js_1.Network.from(_network);
      _classPrivateFieldSet2(_plugin, _this2, network.getPlugin(EtherscanPluginId));
      (0, index_js_4.defineProperties)(_this2, {
        apiKey: apiKey,
        network: network
      });
      // Test that the network is supported by Etherscan
      _this2.getBaseUrl();
      return _this2;
    }
    /**
     *  Returns the base URL.
     *
     *  If an [[EtherscanPlugin]] is configured on the
     *  [[EtherscanBaseProvider_network]], returns the plugin's
     *  baseUrl.
     */
    _inherits(EtherscanProvider, _abstract_provider_js);
    return _createClass(EtherscanProvider, [{
      key: "getBaseUrl",
      value: function getBaseUrl() {
        if (_classPrivateFieldGet2(_plugin, this)) {
          return _classPrivateFieldGet2(_plugin, this).baseUrl;
        }
        switch (this.network.name) {
          case "mainnet":
            return "https:/\/api.etherscan.io";
          case "goerli":
            return "https:/\/api-goerli.etherscan.io";
          case "sepolia":
            return "https:/\/api-sepolia.etherscan.io";
          case "holesky":
            return "https:/\/api-holesky.etherscan.io";
          case "arbitrum":
            return "https:/\/api.arbiscan.io";
          case "arbitrum-goerli":
            return "https:/\/api-goerli.arbiscan.io";
          case "base":
            return "https:/\/api.basescan.org";
          case "base-sepolia":
            return "https:/\/api-sepolia.basescan.org";
          case "bnb":
            return "https:/\/api.bscscan.com";
          case "bnbt":
            return "https:/\/api-testnet.bscscan.com";
          case "matic":
            return "https:/\/api.polygonscan.com";
          case "matic-amoy":
            return "https:/\/api-amoy.polygonscan.com";
          case "matic-mumbai":
            return "https:/\/api-testnet.polygonscan.com";
          case "optimism":
            return "https:/\/api-optimistic.etherscan.io";
          case "optimism-goerli":
            return "https:/\/api-goerli-optimistic.etherscan.io";
        }
        (0, index_js_4.assertArgument)(false, "unsupported network", "network", this.network);
      }
      /**
       *  Returns the URL for the %%module%% and %%params%%.
       */
    }, {
      key: "getUrl",
      value: function getUrl(module, params) {
        var query = Object.keys(params).reduce(function (accum, key) {
          var value = params[key];
          if (value != null) {
            accum += "&".concat(key, "=").concat(value);
          }
          return accum;
        }, "");
        var apiKey = this.apiKey ? "&apikey=".concat(this.apiKey) : "";
        return "".concat(this.getBaseUrl(), "/api?module=").concat(module).concat(query).concat(apiKey);
      }
      /**
       *  Returns the URL for using POST requests.
       */
    }, {
      key: "getPostUrl",
      value: function getPostUrl() {
        return "".concat(this.getBaseUrl(), "/api");
      }
      /**
       *  Returns the parameters for using POST requests.
       */
    }, {
      key: "getPostData",
      value: function getPostData(module, params) {
        params.module = module;
        params.apikey = this.apiKey;
        return params;
      }
    }, {
      key: "detectNetwork",
      value: function () {
        var _detectNetwork2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                return _context.abrupt("return", this.network);
              case 1:
              case "end":
                return _context.stop();
            }
          }, _callee, this);
        }));
        function detectNetwork() {
          return _detectNetwork2.apply(this, arguments);
        }
        return detectNetwork;
      }()
      /**
       *  Resolves to the result of calling %%module%% with %%params%%.
       *
       *  If %%post%%, the request is made as a POST request.
       */
    }, {
      key: "fetch",
      value: (function () {
        var _fetch = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(module, params, post) {
          var _this3 = this;
          var id, url, payload, request, response, result;
          return _regeneratorRuntime().wrap(function _callee3$(_context3) {
            while (1) switch (_context3.prev = _context3.next) {
              case 0:
                id = nextId++;
                url = post ? this.getPostUrl() : this.getUrl(module, params);
                payload = post ? this.getPostData(module, params) : null;
                this.emit("debug", {
                  action: "sendRequest",
                  id: id,
                  url: url,
                  payload: payload
                });
                request = new index_js_4.FetchRequest(url);
                request.setThrottleParams({
                  slotInterval: 1000
                });
                request.retryFunc = function (req, resp, attempt) {
                  if (_this3.isCommunityResource()) {
                    (0, community_js_1.showThrottleMessage)("Etherscan");
                  }
                  return Promise.resolve(true);
                };
                request.processFunc = /*#__PURE__*/function () {
                  var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(request, response) {
                    var result, throttle;
                    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
                      while (1) switch (_context2.prev = _context2.next) {
                        case 0:
                          result = response.hasBody() ? JSON.parse((0, index_js_4.toUtf8String)(response.body)) : {};
                          throttle = (typeof result.result === "string" ? result.result : "").toLowerCase().indexOf("rate limit") >= 0;
                          if (module === "proxy") {
                            // This JSON response indicates we are being throttled
                            if (result && result.status == 0 && result.message == "NOTOK" && throttle) {
                              _this3.emit("debug", {
                                action: "receiveError",
                                id: id,
                                reason: "proxy-NOTOK",
                                error: result
                              });
                              response.throwThrottleError(result.result, THROTTLE);
                            }
                          } else {
                            if (throttle) {
                              _this3.emit("debug", {
                                action: "receiveError",
                                id: id,
                                reason: "null result",
                                error: result.result
                              });
                              response.throwThrottleError(result.result, THROTTLE);
                            }
                          }
                          return _context2.abrupt("return", response);
                        case 4:
                        case "end":
                          return _context2.stop();
                      }
                    }, _callee2);
                  }));
                  return function (_x4, _x5) {
                    return _ref.apply(this, arguments);
                  };
                }();
                if (payload) {
                  request.setHeader("content-type", "application/x-www-form-urlencoded; charset=UTF-8");
                  request.body = Object.keys(payload).map(function (k) {
                    return "".concat(k, "=").concat(payload[k]);
                  }).join("&");
                }
                _context3.next = 11;
                return request.send();
              case 11:
                response = _context3.sent;
                try {
                  response.assertOk();
                } catch (error) {
                  this.emit("debug", {
                    action: "receiveError",
                    id: id,
                    error: error,
                    reason: "assertOk"
                  });
                  (0, index_js_4.assert)(false, "response error", "SERVER_ERROR", {
                    request: request,
                    response: response
                  });
                }
                if (!response.hasBody()) {
                  this.emit("debug", {
                    action: "receiveError",
                    id: id,
                    error: "missing body",
                    reason: "null body"
                  });
                  (0, index_js_4.assert)(false, "missing response", "SERVER_ERROR", {
                    request: request,
                    response: response
                  });
                }
                result = JSON.parse((0, index_js_4.toUtf8String)(response.body));
                if (!(module === "proxy")) {
                  _context3.next = 22;
                  break;
                }
                if (result.jsonrpc != "2.0") {
                  this.emit("debug", {
                    action: "receiveError",
                    id: id,
                    result: result,
                    reason: "invalid JSON-RPC"
                  });
                  (0, index_js_4.assert)(false, "invalid JSON-RPC response (missing jsonrpc='2.0')", "SERVER_ERROR", {
                    request: request,
                    response: response,
                    info: {
                      result: result
                    }
                  });
                }
                if (result.error) {
                  this.emit("debug", {
                    action: "receiveError",
                    id: id,
                    result: result,
                    reason: "JSON-RPC error"
                  });
                  (0, index_js_4.assert)(false, "error response", "SERVER_ERROR", {
                    request: request,
                    response: response,
                    info: {
                      result: result
                    }
                  });
                }
                this.emit("debug", {
                  action: "receiveRequest",
                  id: id,
                  result: result
                });
                return _context3.abrupt("return", result.result);
              case 22:
                if (!(result.status == 0 && (result.message === "No records found" || result.message === "No transactions found"))) {
                  _context3.next = 25;
                  break;
                }
                this.emit("debug", {
                  action: "receiveRequest",
                  id: id,
                  result: result
                });
                return _context3.abrupt("return", result.result);
              case 25:
                if (result.status != 1 || typeof result.message === "string" && !result.message.match(/^OK/)) {
                  this.emit("debug", {
                    action: "receiveError",
                    id: id,
                    result: result
                  });
                  (0, index_js_4.assert)(false, "error response", "SERVER_ERROR", {
                    request: request,
                    response: response,
                    info: {
                      result: result
                    }
                  });
                }
                this.emit("debug", {
                  action: "receiveRequest",
                  id: id,
                  result: result
                });
                return _context3.abrupt("return", result.result);
              case 28:
              case "end":
                return _context3.stop();
            }
          }, _callee3, this);
        }));
        function fetch(_x, _x2, _x3) {
          return _fetch.apply(this, arguments);
        }
        return fetch;
      }()
      /**
       *  Returns %%transaction%% normalized for the Etherscan API.
       */
      )
    }, {
      key: "_getTransactionPostData",
      value: function _getTransactionPostData(transaction) {
        var result = {};
        for (var key in transaction) {
          if (skipKeys.indexOf(key) >= 0) {
            continue;
          }
          if (transaction[key] == null) {
            continue;
          }
          var value = transaction[key];
          if (key === "type" && value === 0) {
            continue;
          }
          if (key === "blockTag" && value === "latest") {
            continue;
          }
          // Quantity-types require no leading zero, unless 0
          if ({
            type: true,
            gasLimit: true,
            gasPrice: true,
            maxFeePerGs: true,
            maxPriorityFeePerGas: true,
            nonce: true,
            value: true
          }[key]) {
            value = (0, index_js_4.toQuantity)(value);
          } else if (key === "accessList") {
            value = "[" + (0, index_js_3.accessListify)(value).map(function (set) {
              return "{address:\"".concat(set.address, "\",storageKeys:[\"").concat(set.storageKeys.join('","'), "\"]}");
            }).join(",") + "]";
          } else if (key === "blobVersionedHashes") {
            if (value.length === 0) {
              continue;
            }
            // @TODO: update this once the API supports blobs
            (0, index_js_4.assert)(false, "Etherscan API does not support blobVersionedHashes", "UNSUPPORTED_OPERATION", {
              operation: "_getTransactionPostData",
              info: {
                transaction: transaction
              }
            });
          } else {
            value = (0, index_js_4.hexlify)(value);
          }
          result[key] = value;
        }
        return result;
      }
      /**
       *  Throws the normalized Etherscan error.
       */
    }, {
      key: "_checkError",
      value: function _checkError(req, error, transaction) {
        // Pull any message out if, possible
        var message = "";
        if ((0, index_js_4.isError)(error, "SERVER_ERROR")) {
          // Check for an error emitted by a proxy call
          try {
            message = error.info.result.error.message;
          } catch (e) {}
          if (!message) {
            try {
              message = error.info.message;
            } catch (e) {}
          }
        }
        if (req.method === "estimateGas") {
          if (!message.match(/revert/i) && message.match(/insufficient funds/i)) {
            (0, index_js_4.assert)(false, "insufficient funds", "INSUFFICIENT_FUNDS", {
              transaction: req.transaction
            });
          }
        }
        if (req.method === "call" || req.method === "estimateGas") {
          if (message.match(/execution reverted/i)) {
            var data = "";
            try {
              data = error.info.result.error.data;
            } catch (error) {}
            var e = index_js_1.AbiCoder.getBuiltinCallException(req.method, req.transaction, data);
            e.info = {
              request: req,
              error: error
            };
            throw e;
          }
        }
        if (message) {
          if (req.method === "broadcastTransaction") {
            var _transaction = index_js_3.Transaction.from(req.signedTransaction);
            if (message.match(/replacement/i) && message.match(/underpriced/i)) {
              (0, index_js_4.assert)(false, "replacement fee too low", "REPLACEMENT_UNDERPRICED", {
                transaction: _transaction
              });
            }
            if (message.match(/insufficient funds/)) {
              (0, index_js_4.assert)(false, "insufficient funds for intrinsic transaction cost", "INSUFFICIENT_FUNDS", {
                transaction: _transaction
              });
            }
            if (message.match(/same hash was already imported|transaction nonce is too low|nonce too low/)) {
              (0, index_js_4.assert)(false, "nonce has already been used", "NONCE_EXPIRED", {
                transaction: _transaction
              });
            }
          }
        }
        // Something we could not process
        throw error;
      }
    }, {
      key: "_detectNetwork",
      value: function () {
        var _detectNetwork3 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
          return _regeneratorRuntime().wrap(function _callee4$(_context4) {
            while (1) switch (_context4.prev = _context4.next) {
              case 0:
                return _context4.abrupt("return", this.network);
              case 1:
              case "end":
                return _context4.stop();
            }
          }, _callee4, this);
        }));
        function _detectNetwork() {
          return _detectNetwork3.apply(this, arguments);
        }
        return _detectNetwork;
      }()
    }, {
      key: "_perform",
      value: function () {
        var _perform2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee5(req) {
          var _this4 = this;
          var postData, _postData;
          return _regeneratorRuntime().wrap(function _callee5$(_context5) {
            while (1) switch (_context5.prev = _context5.next) {
              case 0:
                _context5.t0 = req.method;
                _context5.next = _context5.t0 === "chainId" ? 3 : _context5.t0 === "getBlockNumber" ? 4 : _context5.t0 === "getGasPrice" ? 5 : _context5.t0 === "getPriorityFee" ? 6 : _context5.t0 === "getBalance" ? 15 : _context5.t0 === "getTransactionCount" ? 16 : _context5.t0 === "getCode" ? 17 : _context5.t0 === "getStorage" ? 18 : _context5.t0 === "broadcastTransaction" ? 19 : _context5.t0 === "getBlock" ? 20 : _context5.t0 === "getTransaction" ? 23 : _context5.t0 === "getTransactionReceipt" ? 24 : _context5.t0 === "call" ? 25 : _context5.t0 === "estimateGas" ? 39 : 51;
                break;
              case 3:
                return _context5.abrupt("return", this.network.chainId);
              case 4:
                return _context5.abrupt("return", this.fetch("proxy", {
                  action: "eth_blockNumber"
                }));
              case 5:
                return _context5.abrupt("return", this.fetch("proxy", {
                  action: "eth_gasPrice"
                }));
              case 6:
                if (!(this.network.name === "mainnet")) {
                  _context5.next = 10;
                  break;
                }
                return _context5.abrupt("return", "1000000000");
              case 10:
                if (!(this.network.name === "optimism")) {
                  _context5.next = 14;
                  break;
                }
                return _context5.abrupt("return", "1000000");
              case 14:
                throw new Error("fallback onto the AbstractProvider default");
              case 15:
                return _context5.abrupt("return", this.fetch("account", {
                  action: "balance",
                  address: req.address,
                  tag: req.blockTag
                }));
              case 16:
                return _context5.abrupt("return", this.fetch("proxy", {
                  action: "eth_getTransactionCount",
                  address: req.address,
                  tag: req.blockTag
                }));
              case 17:
                return _context5.abrupt("return", this.fetch("proxy", {
                  action: "eth_getCode",
                  address: req.address,
                  tag: req.blockTag
                }));
              case 18:
                return _context5.abrupt("return", this.fetch("proxy", {
                  action: "eth_getStorageAt",
                  address: req.address,
                  position: req.position,
                  tag: req.blockTag
                }));
              case 19:
                return _context5.abrupt("return", this.fetch("proxy", {
                  action: "eth_sendRawTransaction",
                  hex: req.signedTransaction
                }, true)["catch"](function (error) {
                  return _this4._checkError(req, error, req.signedTransaction);
                }));
              case 20:
                if (!("blockTag" in req)) {
                  _context5.next = 22;
                  break;
                }
                return _context5.abrupt("return", this.fetch("proxy", {
                  action: "eth_getBlockByNumber",
                  tag: req.blockTag,
                  "boolean": req.includeTransactions ? "true" : "false"
                }));
              case 22:
                (0, index_js_4.assert)(false, "getBlock by blockHash not supported by Etherscan", "UNSUPPORTED_OPERATION", {
                  operation: "getBlock(blockHash)"
                });
              case 23:
                return _context5.abrupt("return", this.fetch("proxy", {
                  action: "eth_getTransactionByHash",
                  txhash: req.hash
                }));
              case 24:
                return _context5.abrupt("return", this.fetch("proxy", {
                  action: "eth_getTransactionReceipt",
                  txhash: req.hash
                }));
              case 25:
                if (!(req.blockTag !== "latest")) {
                  _context5.next = 27;
                  break;
                }
                throw new Error("EtherscanProvider does not support blockTag for call");
              case 27:
                postData = this._getTransactionPostData(req.transaction);
                postData.module = "proxy";
                postData.action = "eth_call";
                _context5.prev = 30;
                _context5.next = 33;
                return this.fetch("proxy", postData, true);
              case 33:
                return _context5.abrupt("return", _context5.sent);
              case 36:
                _context5.prev = 36;
                _context5.t1 = _context5["catch"](30);
                return _context5.abrupt("return", this._checkError(req, _context5.t1, req.transaction));
              case 39:
                _postData = this._getTransactionPostData(req.transaction);
                _postData.module = "proxy";
                _postData.action = "eth_estimateGas";
                _context5.prev = 42;
                _context5.next = 45;
                return this.fetch("proxy", _postData, true);
              case 45:
                return _context5.abrupt("return", _context5.sent);
              case 48:
                _context5.prev = 48;
                _context5.t2 = _context5["catch"](42);
                return _context5.abrupt("return", this._checkError(req, _context5.t2, req.transaction));
              case 51:
                return _context5.abrupt("break", 52);
              case 52:
                return _context5.abrupt("return", _superPropGet(EtherscanProvider, "_perform", this, 3)([req]));
              case 53:
              case "end":
                return _context5.stop();
            }
          }, _callee5, this, [[30, 36], [42, 48]]);
        }));
        function _perform(_x6) {
          return _perform2.apply(this, arguments);
        }
        return _perform;
      }()
    }, {
      key: "getNetwork",
      value: function () {
        var _getNetwork = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
          return _regeneratorRuntime().wrap(function _callee6$(_context6) {
            while (1) switch (_context6.prev = _context6.next) {
              case 0:
                return _context6.abrupt("return", this.network);
              case 1:
              case "end":
                return _context6.stop();
            }
          }, _callee6, this);
        }));
        function getNetwork() {
          return _getNetwork.apply(this, arguments);
        }
        return getNetwork;
      }()
      /**
       *  Resolves to the current price of ether.
       *
       *  This returns ``0`` on any network other than ``mainnet``.
       */
    }, {
      key: "getEtherPrice",
      value: (function () {
        var _getEtherPrice = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {
          return _regeneratorRuntime().wrap(function _callee7$(_context7) {
            while (1) switch (_context7.prev = _context7.next) {
              case 0:
                if (!(this.network.name !== "mainnet")) {
                  _context7.next = 2;
                  break;
                }
                return _context7.abrupt("return", 0.0);
              case 2:
                _context7.t0 = parseFloat;
                _context7.next = 5;
                return this.fetch("stats", {
                  action: "ethprice"
                });
              case 5:
                _context7.t1 = _context7.sent.ethusd;
                return _context7.abrupt("return", (0, _context7.t0)(_context7.t1));
              case 7:
              case "end":
                return _context7.stop();
            }
          }, _callee7, this);
        }));
        function getEtherPrice() {
          return _getEtherPrice.apply(this, arguments);
        }
        return getEtherPrice;
      }()
      /**
       *  Resolves to a [Contract]] for %%address%%, using the
       *  Etherscan API to retreive the Contract ABI.
       */
      )
    }, {
      key: "getContract",
      value: (function () {
        var _getContract = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee8(_address) {
          var address, resp, abi;
          return _regeneratorRuntime().wrap(function _callee8$(_context8) {
            while (1) switch (_context8.prev = _context8.next) {
              case 0:
                address = this._getAddress(_address);
                if (!isPromise(address)) {
                  _context8.next = 5;
                  break;
                }
                _context8.next = 4;
                return address;
              case 4:
                address = _context8.sent;
              case 5:
                _context8.prev = 5;
                _context8.next = 8;
                return this.fetch("contract", {
                  action: "getabi",
                  address: address
                });
              case 8:
                resp = _context8.sent;
                abi = JSON.parse(resp);
                return _context8.abrupt("return", new index_js_2.Contract(address, abi, this));
              case 13:
                _context8.prev = 13;
                _context8.t0 = _context8["catch"](5);
                return _context8.abrupt("return", null);
              case 16:
              case "end":
                return _context8.stop();
            }
          }, _callee8, this, [[5, 13]]);
        }));
        function getContract(_x7) {
          return _getContract.apply(this, arguments);
        }
        return getContract;
      }())
    }, {
      key: "isCommunityResource",
      value: function isCommunityResource() {
        return this.apiKey == null;
      }
    }]);
  }(abstract_provider_js_1.AbstractProvider);
  providerEtherscan.EtherscanProvider = EtherscanProvider;
  return providerEtherscan;
}

var providerInfura = {};

var providerWebsocket = {};

var ws$1 = {};

var bufferUtil = {exports: {}};

var constants;
var hasRequiredConstants;
function requireConstants() {
  if (hasRequiredConstants) return constants;
  hasRequiredConstants = 1;
  constants = {
    BINARY_TYPES: ['nodebuffer', 'arraybuffer', 'fragments'],
    EMPTY_BUFFER: Buffer.alloc(0),
    GUID: '258EAFA5-E914-47DA-95CA-C5AB0DC85B11',
    kForOnEventAttribute: Symbol('kIsForOnEventAttribute'),
    kListener: Symbol('kListener'),
    kStatusCode: Symbol('status-code'),
    kWebSocket: Symbol('websocket'),
    NOOP: function NOOP() {}
  };
  return constants;
}

var hasRequiredBufferUtil;
function requireBufferUtil() {
  if (hasRequiredBufferUtil) return bufferUtil.exports;
  hasRequiredBufferUtil = 1;
  var _require$$ = requireConstants(),
    EMPTY_BUFFER = _require$$.EMPTY_BUFFER;
  var FastBuffer = Buffer[Symbol.species];

  /**
   * Merges an array of buffers into a new buffer.
   *
   * @param {Buffer[]} list The array of buffers to concat
   * @param {Number} totalLength The total length of buffers in the list
   * @return {Buffer} The resulting buffer
   * @public
   */
  function concat(list, totalLength) {
    if (list.length === 0) return EMPTY_BUFFER;
    if (list.length === 1) return list[0];
    var target = Buffer.allocUnsafe(totalLength);
    var offset = 0;
    for (var i = 0; i < list.length; i++) {
      var buf = list[i];
      target.set(buf, offset);
      offset += buf.length;
    }
    if (offset < totalLength) {
      return new FastBuffer(target.buffer, target.byteOffset, offset);
    }
    return target;
  }

  /**
   * Masks a buffer using the given mask.
   *
   * @param {Buffer} source The buffer to mask
   * @param {Buffer} mask The mask to use
   * @param {Buffer} output The buffer where to store the result
   * @param {Number} offset The offset at which to start writing
   * @param {Number} length The number of bytes to mask.
   * @public
   */
  function _mask(source, mask, output, offset, length) {
    for (var i = 0; i < length; i++) {
      output[offset + i] = source[i] ^ mask[i & 3];
    }
  }

  /**
   * Unmasks a buffer using the given mask.
   *
   * @param {Buffer} buffer The buffer to unmask
   * @param {Buffer} mask The mask to use
   * @public
   */
  function _unmask(buffer, mask) {
    for (var i = 0; i < buffer.length; i++) {
      buffer[i] ^= mask[i & 3];
    }
  }

  /**
   * Converts a buffer to an `ArrayBuffer`.
   *
   * @param {Buffer} buf The buffer to convert
   * @return {ArrayBuffer} Converted buffer
   * @public
   */
  function toArrayBuffer(buf) {
    if (buf.length === buf.buffer.byteLength) {
      return buf.buffer;
    }
    return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);
  }

  /**
   * Converts `data` to a `Buffer`.
   *
   * @param {*} data The data to convert
   * @return {Buffer} The buffer
   * @throws {TypeError}
   * @public
   */
  function toBuffer(data) {
    toBuffer.readOnly = true;
    if (Buffer.isBuffer(data)) return data;
    var buf;
    if (data instanceof ArrayBuffer) {
      buf = new FastBuffer(data);
    } else if (ArrayBuffer.isView(data)) {
      buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);
    } else {
      buf = Buffer.from(data);
      toBuffer.readOnly = false;
    }
    return buf;
  }
  bufferUtil.exports = {
    concat: concat,
    mask: _mask,
    toArrayBuffer: toArrayBuffer,
    toBuffer: toBuffer,
    unmask: _unmask
  };

  /* istanbul ignore else  */
  if (!process.env.WS_NO_BUFFER_UTIL) {
    try {
      var bufferUtil$1 = require('bufferutil');
      bufferUtil.exports.mask = function (source, mask, output, offset, length) {
        if (length < 48) _mask(source, mask, output, offset, length);else bufferUtil$1.mask(source, mask, output, offset, length);
      };
      bufferUtil.exports.unmask = function (buffer, mask) {
        if (buffer.length < 32) _unmask(buffer, mask);else bufferUtil$1.unmask(buffer, mask);
      };
    } catch (e) {
      // Continue regardless of the error.
    }
  }
  return bufferUtil.exports;
}

var limiter;
var hasRequiredLimiter;
function requireLimiter() {
  if (hasRequiredLimiter) return limiter;
  hasRequiredLimiter = 1;
  var kDone = Symbol('kDone');
  var kRun = Symbol('kRun');

  /**
   * A very simple job queue with adjustable concurrency. Adapted from
   * https://github.com/STRML/async-limiter
   */
  var Limiter = /*#__PURE__*/function () {
    /**
     * Creates a new `Limiter`.
     *
     * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
     *     to run concurrently
     */
    function Limiter(concurrency) {
      var _this = this;
      _classCallCheck(this, Limiter);
      this[kDone] = function () {
        _this.pending--;
        _this[kRun]();
      };
      this.concurrency = concurrency || Infinity;
      this.jobs = [];
      this.pending = 0;
    }

    /**
     * Adds a job to the queue.
     *
     * @param {Function} job The job to run
     * @public
     */
    return _createClass(Limiter, [{
      key: "add",
      value: function add(job) {
        this.jobs.push(job);
        this[kRun]();
      }

      /**
       * Removes a job from the queue and runs it if possible.
       *
       * @private
       */
    }, {
      key: kRun,
      value: function value() {
        if (this.pending === this.concurrency) return;
        if (this.jobs.length) {
          var job = this.jobs.shift();
          this.pending++;
          job(this[kDone]);
        }
      }
    }]);
  }();
  limiter = Limiter;
  return limiter;
}

var permessageDeflate;
var hasRequiredPermessageDeflate;
function requirePermessageDeflate() {
  if (hasRequiredPermessageDeflate) return permessageDeflate;
  hasRequiredPermessageDeflate = 1;
  var zlib = require$$3;
  var bufferUtil = requireBufferUtil();
  var Limiter = requireLimiter();
  var _require$$ = requireConstants(),
    kStatusCode = _require$$.kStatusCode;
  var FastBuffer = Buffer[Symbol.species];
  var TRAILER = Buffer.from([0x00, 0x00, 0xff, 0xff]);
  var kPerMessageDeflate = Symbol('permessage-deflate');
  var kTotalLength = Symbol('total-length');
  var kCallback = Symbol('callback');
  var kBuffers = Symbol('buffers');
  var kError = Symbol('error');

  //
  // We limit zlib concurrency, which prevents severe memory fragmentation
  // as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913
  // and https://github.com/websockets/ws/issues/1202
  //
  // Intentionally global; it's the global thread pool that's an issue.
  //
  var zlibLimiter;

  /**
   * permessage-deflate implementation.
   */
  var PerMessageDeflate = /*#__PURE__*/function () {
    /**
     * Creates a PerMessageDeflate instance.
     *
     * @param {Object} [options] Configuration options
     * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
     *     for, or request, a custom client window size
     * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
     *     acknowledge disabling of client context takeover
     * @param {Number} [options.concurrencyLimit=10] The number of concurrent
     *     calls to zlib
     * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
     *     use of a custom server window size
     * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
     *     disabling of server context takeover
     * @param {Number} [options.threshold=1024] Size (in bytes) below which
     *     messages should not be compressed if context takeover is disabled
     * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
     *     deflate
     * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
     *     inflate
     * @param {Boolean} [isServer=false] Create the instance in either server or
     *     client mode
     * @param {Number} [maxPayload=0] The maximum allowed message length
     */
    function PerMessageDeflate(options, isServer, maxPayload) {
      _classCallCheck(this, PerMessageDeflate);
      this._maxPayload = maxPayload | 0;
      this._options = options || {};
      this._threshold = this._options.threshold !== undefined ? this._options.threshold : 1024;
      this._isServer = !!isServer;
      this._deflate = null;
      this._inflate = null;
      this.params = null;
      if (!zlibLimiter) {
        var concurrency = this._options.concurrencyLimit !== undefined ? this._options.concurrencyLimit : 10;
        zlibLimiter = new Limiter(concurrency);
      }
    }

    /**
     * @type {String}
     */
    return _createClass(PerMessageDeflate, [{
      key: "offer",
      value:
      /**
       * Create an extension negotiation offer.
       *
       * @return {Object} Extension parameters
       * @public
       */
      function offer() {
        var params = {};
        if (this._options.serverNoContextTakeover) {
          params.server_no_context_takeover = true;
        }
        if (this._options.clientNoContextTakeover) {
          params.client_no_context_takeover = true;
        }
        if (this._options.serverMaxWindowBits) {
          params.server_max_window_bits = this._options.serverMaxWindowBits;
        }
        if (this._options.clientMaxWindowBits) {
          params.client_max_window_bits = this._options.clientMaxWindowBits;
        } else if (this._options.clientMaxWindowBits == null) {
          params.client_max_window_bits = true;
        }
        return params;
      }

      /**
       * Accept an extension negotiation offer/response.
       *
       * @param {Array} configurations The extension negotiation offers/reponse
       * @return {Object} Accepted configuration
       * @public
       */
    }, {
      key: "accept",
      value: function accept(configurations) {
        configurations = this.normalizeParams(configurations);
        this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
        return this.params;
      }

      /**
       * Releases all resources used by the extension.
       *
       * @public
       */
    }, {
      key: "cleanup",
      value: function cleanup() {
        if (this._inflate) {
          this._inflate.close();
          this._inflate = null;
        }
        if (this._deflate) {
          var callback = this._deflate[kCallback];
          this._deflate.close();
          this._deflate = null;
          if (callback) {
            callback(new Error('The deflate stream was closed while data was being processed'));
          }
        }
      }

      /**
       *  Accept an extension negotiation offer.
       *
       * @param {Array} offers The extension negotiation offers
       * @return {Object} Accepted configuration
       * @private
       */
    }, {
      key: "acceptAsServer",
      value: function acceptAsServer(offers) {
        var opts = this._options;
        var accepted = offers.find(function (params) {
          if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === 'number' && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === 'number' && !params.client_max_window_bits) {
            return false;
          }
          return true;
        });
        if (!accepted) {
          throw new Error('None of the extension offers can be accepted');
        }
        if (opts.serverNoContextTakeover) {
          accepted.server_no_context_takeover = true;
        }
        if (opts.clientNoContextTakeover) {
          accepted.client_no_context_takeover = true;
        }
        if (typeof opts.serverMaxWindowBits === 'number') {
          accepted.server_max_window_bits = opts.serverMaxWindowBits;
        }
        if (typeof opts.clientMaxWindowBits === 'number') {
          accepted.client_max_window_bits = opts.clientMaxWindowBits;
        } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
          delete accepted.client_max_window_bits;
        }
        return accepted;
      }

      /**
       * Accept the extension negotiation response.
       *
       * @param {Array} response The extension negotiation response
       * @return {Object} Accepted configuration
       * @private
       */
    }, {
      key: "acceptAsClient",
      value: function acceptAsClient(response) {
        var params = response[0];
        if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
          throw new Error('Unexpected parameter "client_no_context_takeover"');
        }
        if (!params.client_max_window_bits) {
          if (typeof this._options.clientMaxWindowBits === 'number') {
            params.client_max_window_bits = this._options.clientMaxWindowBits;
          }
        } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === 'number' && params.client_max_window_bits > this._options.clientMaxWindowBits) {
          throw new Error('Unexpected or invalid parameter "client_max_window_bits"');
        }
        return params;
      }

      /**
       * Normalize parameters.
       *
       * @param {Array} configurations The extension negotiation offers/reponse
       * @return {Array} The offers/response with normalized parameters
       * @private
       */
    }, {
      key: "normalizeParams",
      value: function normalizeParams(configurations) {
        var _this = this;
        configurations.forEach(function (params) {
          Object.keys(params).forEach(function (key) {
            var value = params[key];
            if (value.length > 1) {
              throw new Error("Parameter \"".concat(key, "\" must have only a single value"));
            }
            value = value[0];
            if (key === 'client_max_window_bits') {
              if (value !== true) {
                var num = +value;
                if (!Number.isInteger(num) || num < 8 || num > 15) {
                  throw new TypeError("Invalid value for parameter \"".concat(key, "\": ").concat(value));
                }
                value = num;
              } else if (!_this._isServer) {
                throw new TypeError("Invalid value for parameter \"".concat(key, "\": ").concat(value));
              }
            } else if (key === 'server_max_window_bits') {
              var _num = +value;
              if (!Number.isInteger(_num) || _num < 8 || _num > 15) {
                throw new TypeError("Invalid value for parameter \"".concat(key, "\": ").concat(value));
              }
              value = _num;
            } else if (key === 'client_no_context_takeover' || key === 'server_no_context_takeover') {
              if (value !== true) {
                throw new TypeError("Invalid value for parameter \"".concat(key, "\": ").concat(value));
              }
            } else {
              throw new Error("Unknown parameter \"".concat(key, "\""));
            }
            params[key] = value;
          });
        });
        return configurations;
      }

      /**
       * Decompress data. Concurrency limited.
       *
       * @param {Buffer} data Compressed data
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @public
       */
    }, {
      key: "decompress",
      value: function decompress(data, fin, callback) {
        var _this2 = this;
        zlibLimiter.add(function (done) {
          _this2._decompress(data, fin, function (err, result) {
            done();
            callback(err, result);
          });
        });
      }

      /**
       * Compress data. Concurrency limited.
       *
       * @param {(Buffer|String)} data Data to compress
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @public
       */
    }, {
      key: "compress",
      value: function compress(data, fin, callback) {
        var _this3 = this;
        zlibLimiter.add(function (done) {
          _this3._compress(data, fin, function (err, result) {
            done();
            callback(err, result);
          });
        });
      }

      /**
       * Decompress data.
       *
       * @param {Buffer} data Compressed data
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @private
       */
    }, {
      key: "_decompress",
      value: function _decompress(data, fin, callback) {
        var _this4 = this;
        var endpoint = this._isServer ? 'client' : 'server';
        if (!this._inflate) {
          var key = "".concat(endpoint, "_max_window_bits");
          var windowBits = typeof this.params[key] !== 'number' ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._inflate = zlib.createInflateRaw(_objectSpread2(_objectSpread2({}, this._options.zlibInflateOptions), {}, {
            windowBits: windowBits
          }));
          this._inflate[kPerMessageDeflate] = this;
          this._inflate[kTotalLength] = 0;
          this._inflate[kBuffers] = [];
          this._inflate.on('error', inflateOnError);
          this._inflate.on('data', inflateOnData);
        }
        this._inflate[kCallback] = callback;
        this._inflate.write(data);
        if (fin) this._inflate.write(TRAILER);
        this._inflate.flush(function () {
          var err = _this4._inflate[kError];
          if (err) {
            _this4._inflate.close();
            _this4._inflate = null;
            callback(err);
            return;
          }
          var data = bufferUtil.concat(_this4._inflate[kBuffers], _this4._inflate[kTotalLength]);
          if (_this4._inflate._readableState.endEmitted) {
            _this4._inflate.close();
            _this4._inflate = null;
          } else {
            _this4._inflate[kTotalLength] = 0;
            _this4._inflate[kBuffers] = [];
            if (fin && _this4.params["".concat(endpoint, "_no_context_takeover")]) {
              _this4._inflate.reset();
            }
          }
          callback(null, data);
        });
      }

      /**
       * Compress data.
       *
       * @param {(Buffer|String)} data Data to compress
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @private
       */
    }, {
      key: "_compress",
      value: function _compress(data, fin, callback) {
        var _this5 = this;
        var endpoint = this._isServer ? 'server' : 'client';
        if (!this._deflate) {
          var key = "".concat(endpoint, "_max_window_bits");
          var windowBits = typeof this.params[key] !== 'number' ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._deflate = zlib.createDeflateRaw(_objectSpread2(_objectSpread2({}, this._options.zlibDeflateOptions), {}, {
            windowBits: windowBits
          }));
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          this._deflate.on('data', deflateOnData);
        }
        this._deflate[kCallback] = callback;
        this._deflate.write(data);
        this._deflate.flush(zlib.Z_SYNC_FLUSH, function () {
          if (!_this5._deflate) {
            //
            // The deflate stream was closed while data was being processed.
            //
            return;
          }
          var data = bufferUtil.concat(_this5._deflate[kBuffers], _this5._deflate[kTotalLength]);
          if (fin) {
            data = new FastBuffer(data.buffer, data.byteOffset, data.length - 4);
          }

          //
          // Ensure that the callback will not be called again in
          // `PerMessageDeflate#cleanup()`.
          //
          _this5._deflate[kCallback] = null;
          _this5._deflate[kTotalLength] = 0;
          _this5._deflate[kBuffers] = [];
          if (fin && _this5.params["".concat(endpoint, "_no_context_takeover")]) {
            _this5._deflate.reset();
          }
          callback(null, data);
        });
      }
    }], [{
      key: "extensionName",
      get: function get() {
        return 'permessage-deflate';
      }
    }]);
  }();
  permessageDeflate = PerMessageDeflate;

  /**
   * The listener of the `zlib.DeflateRaw` stream `'data'` event.
   *
   * @param {Buffer} chunk A chunk of data
   * @private
   */
  function deflateOnData(chunk) {
    this[kBuffers].push(chunk);
    this[kTotalLength] += chunk.length;
  }

  /**
   * The listener of the `zlib.InflateRaw` stream `'data'` event.
   *
   * @param {Buffer} chunk A chunk of data
   * @private
   */
  function inflateOnData(chunk) {
    this[kTotalLength] += chunk.length;
    if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
      this[kBuffers].push(chunk);
      return;
    }
    this[kError] = new RangeError('Max payload size exceeded');
    this[kError].code = 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH';
    this[kError][kStatusCode] = 1009;
    this.removeListener('data', inflateOnData);
    this.reset();
  }

  /**
   * The listener of the `zlib.InflateRaw` stream `'error'` event.
   *
   * @param {Error} err The emitted error
   * @private
   */
  function inflateOnError(err) {
    //
    // There is no need to call `Zlib#close()` as the handle is automatically
    // closed when an error is emitted.
    //
    this[kPerMessageDeflate]._inflate = null;
    err[kStatusCode] = 1007;
    this[kCallback](err);
  }
  return permessageDeflate;
}

var validation = {exports: {}};

var hasRequiredValidation;
function requireValidation() {
  if (hasRequiredValidation) return validation.exports;
  hasRequiredValidation = 1;
  var isUtf8 = require$$0$1.isUtf8;

  //
  // Allowed token characters:
  //
  // '!', '#', '$', '%', '&', ''', '*', '+', '-',
  // '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'
  //
  // tokenChars[32] === 0 // ' '
  // tokenChars[33] === 1 // '!'
  // tokenChars[34] === 0 // '"'
  // ...
  //
  // prettier-ignore
  var tokenChars = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  // 0 - 15
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  // 16 - 31
  0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0,
  // 32 - 47
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,
  // 48 - 63
  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  // 64 - 79
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1,
  // 80 - 95
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  // 96 - 111
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0 // 112 - 127
  ];

  /**
   * Checks if a status code is allowed in a close frame.
   *
   * @param {Number} code The status code
   * @return {Boolean} `true` if the status code is valid, else `false`
   * @public
   */
  function isValidStatusCode(code) {
    return code >= 1000 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3000 && code <= 4999;
  }

  /**
   * Checks if a given buffer contains only correct UTF-8.
   * Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by
   * Markus Kuhn.
   *
   * @param {Buffer} buf The buffer to check
   * @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`
   * @public
   */
  function _isValidUTF8(buf) {
    var len = buf.length;
    var i = 0;
    while (i < len) {
      if ((buf[i] & 0x80) === 0) {
        // 0xxxxxxx
        i++;
      } else if ((buf[i] & 0xe0) === 0xc0) {
        // 110xxxxx 10xxxxxx
        if (i + 1 === len || (buf[i + 1] & 0xc0) !== 0x80 || (buf[i] & 0xfe) === 0xc0 // Overlong
        ) {
          return false;
        }
        i += 2;
      } else if ((buf[i] & 0xf0) === 0xe0) {
        // 1110xxxx 10xxxxxx 10xxxxxx
        if (i + 2 >= len || (buf[i + 1] & 0xc0) !== 0x80 || (buf[i + 2] & 0xc0) !== 0x80 || buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80 ||
        // Overlong
        buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0 // Surrogate (U+D800 - U+DFFF)
        ) {
          return false;
        }
        i += 3;
      } else if ((buf[i] & 0xf8) === 0xf0) {
        // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
        if (i + 3 >= len || (buf[i + 1] & 0xc0) !== 0x80 || (buf[i + 2] & 0xc0) !== 0x80 || (buf[i + 3] & 0xc0) !== 0x80 || buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80 ||
        // Overlong
        buf[i] === 0xf4 && buf[i + 1] > 0x8f || buf[i] > 0xf4 // > U+10FFFF
        ) {
          return false;
        }
        i += 4;
      } else {
        return false;
      }
    }
    return true;
  }
  validation.exports = {
    isValidStatusCode: isValidStatusCode,
    isValidUTF8: _isValidUTF8,
    tokenChars: tokenChars
  };
  if (isUtf8) {
    validation.exports.isValidUTF8 = function (buf) {
      return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);
    };
  } /* istanbul ignore else  */else if (!process.env.WS_NO_UTF_8_VALIDATE) {
    try {
      var isValidUTF8 = require('utf-8-validate');
      validation.exports.isValidUTF8 = function (buf) {
        return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);
      };
    } catch (e) {
      // Continue regardless of the error.
    }
  }
  return validation.exports;
}

var receiver;
var hasRequiredReceiver;
function requireReceiver() {
  if (hasRequiredReceiver) return receiver;
  hasRequiredReceiver = 1;
  var Writable = require$$0$2.Writable;
  var PerMessageDeflate = requirePermessageDeflate();
  var _require$$ = requireConstants(),
    BINARY_TYPES = _require$$.BINARY_TYPES,
    EMPTY_BUFFER = _require$$.EMPTY_BUFFER,
    kStatusCode = _require$$.kStatusCode,
    kWebSocket = _require$$.kWebSocket;
  var _require$$2 = requireBufferUtil(),
    concat = _require$$2.concat,
    toArrayBuffer = _require$$2.toArrayBuffer,
    unmask = _require$$2.unmask;
  var _require$$3 = requireValidation(),
    isValidStatusCode = _require$$3.isValidStatusCode,
    isValidUTF8 = _require$$3.isValidUTF8;
  var FastBuffer = Buffer[Symbol.species];
  var GET_INFO = 0;
  var GET_PAYLOAD_LENGTH_16 = 1;
  var GET_PAYLOAD_LENGTH_64 = 2;
  var GET_MASK = 3;
  var GET_DATA = 4;
  var INFLATING = 5;
  var DEFER_EVENT = 6;

  /**
   * HyBi Receiver implementation.
   *
   * @extends Writable
   */
  var Receiver = /*#__PURE__*/function (_Writable) {
    /**
     * Creates a Receiver instance.
     *
     * @param {Object} [options] Options object
     * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
     *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
     *     multiple times in the same tick
     * @param {String} [options.binaryType=nodebuffer] The type for binary data
     * @param {Object} [options.extensions] An object containing the negotiated
     *     extensions
     * @param {Boolean} [options.isServer=false] Specifies whether to operate in
     *     client or server mode
     * @param {Number} [options.maxPayload=0] The maximum allowed message length
     * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
     *     not to skip UTF-8 validation for text and close messages
     */
    function Receiver() {
      var _this;
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, Receiver);
      _this = _callSuper(this, Receiver);
      _this._allowSynchronousEvents = options.allowSynchronousEvents !== undefined ? options.allowSynchronousEvents : true;
      _this._binaryType = options.binaryType || BINARY_TYPES[0];
      _this._extensions = options.extensions || {};
      _this._isServer = !!options.isServer;
      _this._maxPayload = options.maxPayload | 0;
      _this._skipUTF8Validation = !!options.skipUTF8Validation;
      _this[kWebSocket] = undefined;
      _this._bufferedBytes = 0;
      _this._buffers = [];
      _this._compressed = false;
      _this._payloadLength = 0;
      _this._mask = undefined;
      _this._fragmented = 0;
      _this._masked = false;
      _this._fin = false;
      _this._opcode = 0;
      _this._totalPayloadLength = 0;
      _this._messageLength = 0;
      _this._fragments = [];
      _this._errored = false;
      _this._loop = false;
      _this._state = GET_INFO;
      return _this;
    }

    /**
     * Implements `Writable.prototype._write()`.
     *
     * @param {Buffer} chunk The chunk of data to write
     * @param {String} encoding The character encoding of `chunk`
     * @param {Function} cb Callback
     * @private
     */
    _inherits(Receiver, _Writable);
    return _createClass(Receiver, [{
      key: "_write",
      value: function _write(chunk, encoding, cb) {
        if (this._opcode === 0x08 && this._state == GET_INFO) return cb();
        this._bufferedBytes += chunk.length;
        this._buffers.push(chunk);
        this.startLoop(cb);
      }

      /**
       * Consumes `n` bytes from the buffered data.
       *
       * @param {Number} n The number of bytes to consume
       * @return {Buffer} The consumed bytes
       * @private
       */
    }, {
      key: "consume",
      value: function consume(n) {
        this._bufferedBytes -= n;
        if (n === this._buffers[0].length) return this._buffers.shift();
        if (n < this._buffers[0].length) {
          var buf = this._buffers[0];
          this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n, buf.length - n);
          return new FastBuffer(buf.buffer, buf.byteOffset, n);
        }
        var dst = Buffer.allocUnsafe(n);
        do {
          var _buf = this._buffers[0];
          var offset = dst.length - n;
          if (n >= _buf.length) {
            dst.set(this._buffers.shift(), offset);
          } else {
            dst.set(new Uint8Array(_buf.buffer, _buf.byteOffset, n), offset);
            this._buffers[0] = new FastBuffer(_buf.buffer, _buf.byteOffset + n, _buf.length - n);
          }
          n -= _buf.length;
        } while (n > 0);
        return dst;
      }

      /**
       * Starts the parsing loop.
       *
       * @param {Function} cb Callback
       * @private
       */
    }, {
      key: "startLoop",
      value: function startLoop(cb) {
        this._loop = true;
        do {
          switch (this._state) {
            case GET_INFO:
              this.getInfo(cb);
              break;
            case GET_PAYLOAD_LENGTH_16:
              this.getPayloadLength16(cb);
              break;
            case GET_PAYLOAD_LENGTH_64:
              this.getPayloadLength64(cb);
              break;
            case GET_MASK:
              this.getMask();
              break;
            case GET_DATA:
              this.getData(cb);
              break;
            case INFLATING:
            case DEFER_EVENT:
              this._loop = false;
              return;
          }
        } while (this._loop);
        if (!this._errored) cb();
      }

      /**
       * Reads the first two bytes of a frame.
       *
       * @param {Function} cb Callback
       * @private
       */
    }, {
      key: "getInfo",
      value: function getInfo(cb) {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        var buf = this.consume(2);
        if ((buf[0] & 0x30) !== 0x00) {
          var error = this.createError(RangeError, 'RSV2 and RSV3 must be clear', true, 1002, 'WS_ERR_UNEXPECTED_RSV_2_3');
          cb(error);
          return;
        }
        var compressed = (buf[0] & 0x40) === 0x40;
        if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
          var _error = this.createError(RangeError, 'RSV1 must be clear', true, 1002, 'WS_ERR_UNEXPECTED_RSV_1');
          cb(_error);
          return;
        }
        this._fin = (buf[0] & 0x80) === 0x80;
        this._opcode = buf[0] & 0x0f;
        this._payloadLength = buf[1] & 0x7f;
        if (this._opcode === 0x00) {
          if (compressed) {
            var _error2 = this.createError(RangeError, 'RSV1 must be clear', true, 1002, 'WS_ERR_UNEXPECTED_RSV_1');
            cb(_error2);
            return;
          }
          if (!this._fragmented) {
            var _error3 = this.createError(RangeError, 'invalid opcode 0', true, 1002, 'WS_ERR_INVALID_OPCODE');
            cb(_error3);
            return;
          }
          this._opcode = this._fragmented;
        } else if (this._opcode === 0x01 || this._opcode === 0x02) {
          if (this._fragmented) {
            var _error4 = this.createError(RangeError, "invalid opcode ".concat(this._opcode), true, 1002, 'WS_ERR_INVALID_OPCODE');
            cb(_error4);
            return;
          }
          this._compressed = compressed;
        } else if (this._opcode > 0x07 && this._opcode < 0x0b) {
          if (!this._fin) {
            var _error5 = this.createError(RangeError, 'FIN must be set', true, 1002, 'WS_ERR_EXPECTED_FIN');
            cb(_error5);
            return;
          }
          if (compressed) {
            var _error6 = this.createError(RangeError, 'RSV1 must be clear', true, 1002, 'WS_ERR_UNEXPECTED_RSV_1');
            cb(_error6);
            return;
          }
          if (this._payloadLength > 0x7d || this._opcode === 0x08 && this._payloadLength === 1) {
            var _error7 = this.createError(RangeError, "invalid payload length ".concat(this._payloadLength), true, 1002, 'WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH');
            cb(_error7);
            return;
          }
        } else {
          var _error8 = this.createError(RangeError, "invalid opcode ".concat(this._opcode), true, 1002, 'WS_ERR_INVALID_OPCODE');
          cb(_error8);
          return;
        }
        if (!this._fin && !this._fragmented) this._fragmented = this._opcode;
        this._masked = (buf[1] & 0x80) === 0x80;
        if (this._isServer) {
          if (!this._masked) {
            var _error9 = this.createError(RangeError, 'MASK must be set', true, 1002, 'WS_ERR_EXPECTED_MASK');
            cb(_error9);
            return;
          }
        } else if (this._masked) {
          var _error10 = this.createError(RangeError, 'MASK must be clear', true, 1002, 'WS_ERR_UNEXPECTED_MASK');
          cb(_error10);
          return;
        }
        if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;else this.haveLength(cb);
      }

      /**
       * Gets extended payload length (7+16).
       *
       * @param {Function} cb Callback
       * @private
       */
    }, {
      key: "getPayloadLength16",
      value: function getPayloadLength16(cb) {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        this._payloadLength = this.consume(2).readUInt16BE(0);
        this.haveLength(cb);
      }

      /**
       * Gets extended payload length (7+64).
       *
       * @param {Function} cb Callback
       * @private
       */
    }, {
      key: "getPayloadLength64",
      value: function getPayloadLength64(cb) {
        if (this._bufferedBytes < 8) {
          this._loop = false;
          return;
        }
        var buf = this.consume(8);
        var num = buf.readUInt32BE(0);

        //
        // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned
        // if payload length is greater than this number.
        //
        if (num > Math.pow(2, 53 - 32) - 1) {
          var error = this.createError(RangeError, 'Unsupported WebSocket frame: payload length > 2^53 - 1', false, 1009, 'WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH');
          cb(error);
          return;
        }
        this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
        this.haveLength(cb);
      }

      /**
       * Payload length has been read.
       *
       * @param {Function} cb Callback
       * @private
       */
    }, {
      key: "haveLength",
      value: function haveLength(cb) {
        if (this._payloadLength && this._opcode < 0x08) {
          this._totalPayloadLength += this._payloadLength;
          if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
            var error = this.createError(RangeError, 'Max payload size exceeded', false, 1009, 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH');
            cb(error);
            return;
          }
        }
        if (this._masked) this._state = GET_MASK;else this._state = GET_DATA;
      }

      /**
       * Reads mask bytes.
       *
       * @private
       */
    }, {
      key: "getMask",
      value: function getMask() {
        if (this._bufferedBytes < 4) {
          this._loop = false;
          return;
        }
        this._mask = this.consume(4);
        this._state = GET_DATA;
      }

      /**
       * Reads data bytes.
       *
       * @param {Function} cb Callback
       * @private
       */
    }, {
      key: "getData",
      value: function getData(cb) {
        var data = EMPTY_BUFFER;
        if (this._payloadLength) {
          if (this._bufferedBytes < this._payloadLength) {
            this._loop = false;
            return;
          }
          data = this.consume(this._payloadLength);
          if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) {
            unmask(data, this._mask);
          }
        }
        if (this._opcode > 0x07) {
          this.controlMessage(data, cb);
          return;
        }
        if (this._compressed) {
          this._state = INFLATING;
          this.decompress(data, cb);
          return;
        }
        if (data.length) {
          //
          // This message is not compressed so its length is the sum of the payload
          // length of all fragments.
          //
          this._messageLength = this._totalPayloadLength;
          this._fragments.push(data);
        }
        this.dataMessage(cb);
      }

      /**
       * Decompresses data.
       *
       * @param {Buffer} data Compressed data
       * @param {Function} cb Callback
       * @private
       */
    }, {
      key: "decompress",
      value: function decompress(data, cb) {
        var _this2 = this;
        var perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        perMessageDeflate.decompress(data, this._fin, function (err, buf) {
          if (err) return cb(err);
          if (buf.length) {
            _this2._messageLength += buf.length;
            if (_this2._messageLength > _this2._maxPayload && _this2._maxPayload > 0) {
              var error = _this2.createError(RangeError, 'Max payload size exceeded', false, 1009, 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH');
              cb(error);
              return;
            }
            _this2._fragments.push(buf);
          }
          _this2.dataMessage(cb);
          if (_this2._state === GET_INFO) _this2.startLoop(cb);
        });
      }

      /**
       * Handles a data message.
       *
       * @param {Function} cb Callback
       * @private
       */
    }, {
      key: "dataMessage",
      value: function dataMessage(cb) {
        var _this3 = this;
        if (!this._fin) {
          this._state = GET_INFO;
          return;
        }
        var messageLength = this._messageLength;
        var fragments = this._fragments;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragmented = 0;
        this._fragments = [];
        if (this._opcode === 2) {
          var data;
          if (this._binaryType === 'nodebuffer') {
            data = concat(fragments, messageLength);
          } else if (this._binaryType === 'arraybuffer') {
            data = toArrayBuffer(concat(fragments, messageLength));
          } else {
            data = fragments;
          }
          if (this._allowSynchronousEvents) {
            this.emit('message', data, true);
            this._state = GET_INFO;
          } else {
            this._state = DEFER_EVENT;
            setImmediate(function () {
              _this3.emit('message', data, true);
              _this3._state = GET_INFO;
              _this3.startLoop(cb);
            });
          }
        } else {
          var buf = concat(fragments, messageLength);
          if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
            var error = this.createError(Error, 'invalid UTF-8 sequence', true, 1007, 'WS_ERR_INVALID_UTF8');
            cb(error);
            return;
          }
          if (this._state === INFLATING || this._allowSynchronousEvents) {
            this.emit('message', buf, false);
            this._state = GET_INFO;
          } else {
            this._state = DEFER_EVENT;
            setImmediate(function () {
              _this3.emit('message', buf, false);
              _this3._state = GET_INFO;
              _this3.startLoop(cb);
            });
          }
        }
      }

      /**
       * Handles a control message.
       *
       * @param {Buffer} data Data to handle
       * @return {(Error|RangeError|undefined)} A possible error
       * @private
       */
    }, {
      key: "controlMessage",
      value: function controlMessage(data, cb) {
        var _this4 = this;
        if (this._opcode === 0x08) {
          if (data.length === 0) {
            this._loop = false;
            this.emit('conclude', 1005, EMPTY_BUFFER);
            this.end();
          } else {
            var code = data.readUInt16BE(0);
            if (!isValidStatusCode(code)) {
              var error = this.createError(RangeError, "invalid status code ".concat(code), true, 1002, 'WS_ERR_INVALID_CLOSE_CODE');
              cb(error);
              return;
            }
            var buf = new FastBuffer(data.buffer, data.byteOffset + 2, data.length - 2);
            if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
              var _error11 = this.createError(Error, 'invalid UTF-8 sequence', true, 1007, 'WS_ERR_INVALID_UTF8');
              cb(_error11);
              return;
            }
            this._loop = false;
            this.emit('conclude', code, buf);
            this.end();
          }
          this._state = GET_INFO;
          return;
        }
        if (this._allowSynchronousEvents) {
          this.emit(this._opcode === 0x09 ? 'ping' : 'pong', data);
          this._state = GET_INFO;
        } else {
          this._state = DEFER_EVENT;
          setImmediate(function () {
            _this4.emit(_this4._opcode === 0x09 ? 'ping' : 'pong', data);
            _this4._state = GET_INFO;
            _this4.startLoop(cb);
          });
        }
      }

      /**
       * Builds an error object.
       *
       * @param {function(new:Error|RangeError)} ErrorCtor The error constructor
       * @param {String} message The error message
       * @param {Boolean} prefix Specifies whether or not to add a default prefix to
       *     `message`
       * @param {Number} statusCode The status code
       * @param {String} errorCode The exposed error code
       * @return {(Error|RangeError)} The error
       * @private
       */
    }, {
      key: "createError",
      value: function createError(ErrorCtor, message, prefix, statusCode, errorCode) {
        this._loop = false;
        this._errored = true;
        var err = new ErrorCtor(prefix ? "Invalid WebSocket frame: ".concat(message) : message);
        Error.captureStackTrace(err, this.createError);
        err.code = errorCode;
        err[kStatusCode] = statusCode;
        return err;
      }
    }]);
  }(Writable);
  receiver = Receiver;
  return receiver;
}

var sender;
var hasRequiredSender;
function requireSender() {
  if (hasRequiredSender) return sender;
  hasRequiredSender = 1;
  require$$0$2.Duplex;
  var randomFillSync = require$$5.randomFillSync;
  var PerMessageDeflate = requirePermessageDeflate();
  var _require$$ = requireConstants(),
    EMPTY_BUFFER = _require$$.EMPTY_BUFFER;
  var _require$$2 = requireValidation(),
    isValidStatusCode = _require$$2.isValidStatusCode;
  var _require$$3 = requireBufferUtil(),
    applyMask = _require$$3.mask,
    toBuffer = _require$$3.toBuffer;
  var kByteLength = Symbol('kByteLength');
  var maskBuffer = Buffer.alloc(4);
  var RANDOM_POOL_SIZE = 8 * 1024;
  var randomPool;
  var randomPoolPointer = RANDOM_POOL_SIZE;

  /**
   * HyBi Sender implementation.
   */
  var Sender = /*#__PURE__*/function () {
    /**
     * Creates a Sender instance.
     *
     * @param {Duplex} socket The connection socket
     * @param {Object} [extensions] An object containing the negotiated extensions
     * @param {Function} [generateMask] The function used to generate the masking
     *     key
     */
    function Sender(socket, extensions, generateMask) {
      _classCallCheck(this, Sender);
      this._extensions = extensions || {};
      if (generateMask) {
        this._generateMask = generateMask;
        this._maskBuffer = Buffer.alloc(4);
      }
      this._socket = socket;
      this._firstFragment = true;
      this._compress = false;
      this._bufferedBytes = 0;
      this._deflating = false;
      this._queue = [];
    }

    /**
     * Frames a piece of data according to the HyBi WebSocket protocol.
     *
     * @param {(Buffer|String)} data The data to frame
     * @param {Object} options Options object
     * @param {Boolean} [options.fin=false] Specifies whether or not to set the
     *     FIN bit
     * @param {Function} [options.generateMask] The function used to generate the
     *     masking key
     * @param {Boolean} [options.mask=false] Specifies whether or not to mask
     *     `data`
     * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
     *     key
     * @param {Number} options.opcode The opcode
     * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
     *     modified
     * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
     *     RSV1 bit
     * @return {(Buffer|String)[]} The framed data
     * @public
     */
    return _createClass(Sender, [{
      key: "close",
      value:
      /**
       * Sends a close message to the other peer.
       *
       * @param {Number} [code] The status code component of the body
       * @param {(String|Buffer)} [data] The message component of the body
       * @param {Boolean} [mask=false] Specifies whether or not to mask the message
       * @param {Function} [cb] Callback
       * @public
       */
      function close(code, data, mask, cb) {
        var buf;
        if (code === undefined) {
          buf = EMPTY_BUFFER;
        } else if (typeof code !== 'number' || !isValidStatusCode(code)) {
          throw new TypeError('First argument must be a valid error code number');
        } else if (data === undefined || !data.length) {
          buf = Buffer.allocUnsafe(2);
          buf.writeUInt16BE(code, 0);
        } else {
          var length = Buffer.byteLength(data);
          if (length > 123) {
            throw new RangeError('The message must not be greater than 123 bytes');
          }
          buf = Buffer.allocUnsafe(2 + length);
          buf.writeUInt16BE(code, 0);
          if (typeof data === 'string') {
            buf.write(data, 2);
          } else {
            buf.set(data, 2);
          }
        }
        var options = _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({}, kByteLength, buf.length), "fin", true), "generateMask", this._generateMask), "mask", mask), "maskBuffer", this._maskBuffer), "opcode", 0x08), "readOnly", false), "rsv1", false);
        if (this._deflating) {
          this.enqueue([this.dispatch, buf, false, options, cb]);
        } else {
          this.sendFrame(Sender.frame(buf, options), cb);
        }
      }

      /**
       * Sends a ping message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback
       * @public
       */
    }, {
      key: "ping",
      value: function ping(data, mask, cb) {
        var byteLength;
        var readOnly;
        if (typeof data === 'string') {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (byteLength > 125) {
          throw new RangeError('The data size must not be greater than 125 bytes');
        }
        var options = _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({}, kByteLength, byteLength), "fin", true), "generateMask", this._generateMask), "mask", mask), "maskBuffer", this._maskBuffer), "opcode", 0x09), "readOnly", readOnly), "rsv1", false);
        if (this._deflating) {
          this.enqueue([this.dispatch, data, false, options, cb]);
        } else {
          this.sendFrame(Sender.frame(data, options), cb);
        }
      }

      /**
       * Sends a pong message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback
       * @public
       */
    }, {
      key: "pong",
      value: function pong(data, mask, cb) {
        var byteLength;
        var readOnly;
        if (typeof data === 'string') {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (byteLength > 125) {
          throw new RangeError('The data size must not be greater than 125 bytes');
        }
        var options = _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({}, kByteLength, byteLength), "fin", true), "generateMask", this._generateMask), "mask", mask), "maskBuffer", this._maskBuffer), "opcode", 0x0a), "readOnly", readOnly), "rsv1", false);
        if (this._deflating) {
          this.enqueue([this.dispatch, data, false, options, cb]);
        } else {
          this.sendFrame(Sender.frame(data, options), cb);
        }
      }

      /**
       * Sends a data message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Object} options Options object
       * @param {Boolean} [options.binary=false] Specifies whether `data` is binary
       *     or text
       * @param {Boolean} [options.compress=false] Specifies whether or not to
       *     compress `data`
       * @param {Boolean} [options.fin=false] Specifies whether the fragment is the
       *     last one
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Function} [cb] Callback
       * @public
       */
    }, {
      key: "send",
      value: function send(data, options, cb) {
        var perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        var opcode = options.binary ? 2 : 1;
        var rsv1 = options.compress;
        var byteLength;
        var readOnly;
        if (typeof data === 'string') {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (this._firstFragment) {
          this._firstFragment = false;
          if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? 'server_no_context_takeover' : 'client_no_context_takeover']) {
            rsv1 = byteLength >= perMessageDeflate._threshold;
          }
          this._compress = rsv1;
        } else {
          rsv1 = false;
          opcode = 0;
        }
        if (options.fin) this._firstFragment = true;
        if (perMessageDeflate) {
          var opts = _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({}, kByteLength, byteLength), "fin", options.fin), "generateMask", this._generateMask), "mask", options.mask), "maskBuffer", this._maskBuffer), "opcode", opcode), "readOnly", readOnly), "rsv1", rsv1);
          if (this._deflating) {
            this.enqueue([this.dispatch, data, this._compress, opts, cb]);
          } else {
            this.dispatch(data, this._compress, opts, cb);
          }
        } else {
          this.sendFrame(Sender.frame(data, _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({}, kByteLength, byteLength), "fin", options.fin), "generateMask", this._generateMask), "mask", options.mask), "maskBuffer", this._maskBuffer), "opcode", opcode), "readOnly", readOnly), "rsv1", false)), cb);
        }
      }

      /**
       * Dispatches a message.
       *
       * @param {(Buffer|String)} data The message to send
       * @param {Boolean} [compress=false] Specifies whether or not to compress
       *     `data`
       * @param {Object} options Options object
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
       *     key
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @param {Function} [cb] Callback
       * @private
       */
    }, {
      key: "dispatch",
      value: function dispatch(data, compress, options, cb) {
        var _this = this;
        if (!compress) {
          this.sendFrame(Sender.frame(data, options), cb);
          return;
        }
        var perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        this._bufferedBytes += options[kByteLength];
        this._deflating = true;
        perMessageDeflate.compress(data, options.fin, function (_, buf) {
          if (_this._socket.destroyed) {
            var err = new Error('The socket was closed while data was being compressed');
            if (typeof cb === 'function') cb(err);
            for (var i = 0; i < _this._queue.length; i++) {
              var params = _this._queue[i];
              var callback = params[params.length - 1];
              if (typeof callback === 'function') callback(err);
            }
            return;
          }
          _this._bufferedBytes -= options[kByteLength];
          _this._deflating = false;
          options.readOnly = false;
          _this.sendFrame(Sender.frame(buf, options), cb);
          _this.dequeue();
        });
      }

      /**
       * Executes queued send operations.
       *
       * @private
       */
    }, {
      key: "dequeue",
      value: function dequeue() {
        while (!this._deflating && this._queue.length) {
          var params = this._queue.shift();
          this._bufferedBytes -= params[3][kByteLength];
          Reflect.apply(params[0], this, params.slice(1));
        }
      }

      /**
       * Enqueues a send operation.
       *
       * @param {Array} params Send operation parameters.
       * @private
       */
    }, {
      key: "enqueue",
      value: function enqueue(params) {
        this._bufferedBytes += params[3][kByteLength];
        this._queue.push(params);
      }

      /**
       * Sends a frame.
       *
       * @param {Buffer[]} list The frame to send
       * @param {Function} [cb] Callback
       * @private
       */
    }, {
      key: "sendFrame",
      value: function sendFrame(list, cb) {
        if (list.length === 2) {
          this._socket.cork();
          this._socket.write(list[0]);
          this._socket.write(list[1], cb);
          this._socket.uncork();
        } else {
          this._socket.write(list[0], cb);
        }
      }
    }], [{
      key: "frame",
      value: function frame(data, options) {
        var mask;
        var merge = false;
        var offset = 2;
        var skipMasking = false;
        if (options.mask) {
          mask = options.maskBuffer || maskBuffer;
          if (options.generateMask) {
            options.generateMask(mask);
          } else {
            if (randomPoolPointer === RANDOM_POOL_SIZE) {
              /* istanbul ignore else  */
              if (randomPool === undefined) {
                //
                // This is lazily initialized because server-sent frames must not
                // be masked so it may never be used.
                //
                randomPool = Buffer.alloc(RANDOM_POOL_SIZE);
              }
              randomFillSync(randomPool, 0, RANDOM_POOL_SIZE);
              randomPoolPointer = 0;
            }
            mask[0] = randomPool[randomPoolPointer++];
            mask[1] = randomPool[randomPoolPointer++];
            mask[2] = randomPool[randomPoolPointer++];
            mask[3] = randomPool[randomPoolPointer++];
          }
          skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
          offset = 6;
        }
        var dataLength;
        if (typeof data === 'string') {
          if ((!options.mask || skipMasking) && options[kByteLength] !== undefined) {
            dataLength = options[kByteLength];
          } else {
            data = Buffer.from(data);
            dataLength = data.length;
          }
        } else {
          dataLength = data.length;
          merge = options.mask && options.readOnly && !skipMasking;
        }
        var payloadLength = dataLength;
        if (dataLength >= 65536) {
          offset += 8;
          payloadLength = 127;
        } else if (dataLength > 125) {
          offset += 2;
          payloadLength = 126;
        }
        var target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);
        target[0] = options.fin ? options.opcode | 0x80 : options.opcode;
        if (options.rsv1) target[0] |= 0x40;
        target[1] = payloadLength;
        if (payloadLength === 126) {
          target.writeUInt16BE(dataLength, 2);
        } else if (payloadLength === 127) {
          target[2] = target[3] = 0;
          target.writeUIntBE(dataLength, 4, 6);
        }
        if (!options.mask) return [target, data];
        target[1] |= 0x80;
        target[offset - 4] = mask[0];
        target[offset - 3] = mask[1];
        target[offset - 2] = mask[2];
        target[offset - 1] = mask[3];
        if (skipMasking) return [target, data];
        if (merge) {
          applyMask(data, mask, target, offset, dataLength);
          return [target];
        }
        applyMask(data, mask, data, 0, dataLength);
        return [target, data];
      }
    }]);
  }();
  sender = Sender;
  return sender;
}

var eventTarget;
var hasRequiredEventTarget;
function requireEventTarget() {
  if (hasRequiredEventTarget) return eventTarget;
  hasRequiredEventTarget = 1;
  var _require$$ = requireConstants(),
    kForOnEventAttribute = _require$$.kForOnEventAttribute,
    kListener = _require$$.kListener;
  var kCode = Symbol('kCode');
  var kData = Symbol('kData');
  var kError = Symbol('kError');
  var kMessage = Symbol('kMessage');
  var kReason = Symbol('kReason');
  var kTarget = Symbol('kTarget');
  var kType = Symbol('kType');
  var kWasClean = Symbol('kWasClean');

  /**
   * Class representing an event.
   */
  var Event = /*#__PURE__*/function () {
    /**
     * Create a new `Event`.
     *
     * @param {String} type The name of the event
     * @throws {TypeError} If the `type` argument is not specified
     */
    function Event(type) {
      _classCallCheck(this, Event);
      this[kTarget] = null;
      this[kType] = type;
    }

    /**
     * @type {*}
     */
    return _createClass(Event, [{
      key: "target",
      get: function get() {
        return this[kTarget];
      }

      /**
       * @type {String}
       */
    }, {
      key: "type",
      get: function get() {
        return this[kType];
      }
    }]);
  }();
  Object.defineProperty(Event.prototype, 'target', {
    enumerable: true
  });
  Object.defineProperty(Event.prototype, 'type', {
    enumerable: true
  });

  /**
   * Class representing a close event.
   *
   * @extends Event
   */
  var CloseEvent = /*#__PURE__*/function (_Event) {
    /**
     * Create a new `CloseEvent`.
     *
     * @param {String} type The name of the event
     * @param {Object} [options] A dictionary object that allows for setting
     *     attributes via object members of the same name
     * @param {Number} [options.code=0] The status code explaining why the
     *     connection was closed
     * @param {String} [options.reason=''] A human-readable string explaining why
     *     the connection was closed
     * @param {Boolean} [options.wasClean=false] Indicates whether or not the
     *     connection was cleanly closed
     */
    function CloseEvent(type) {
      var _this;
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      _classCallCheck(this, CloseEvent);
      _this = _callSuper(this, CloseEvent, [type]);
      _this[kCode] = options.code === undefined ? 0 : options.code;
      _this[kReason] = options.reason === undefined ? '' : options.reason;
      _this[kWasClean] = options.wasClean === undefined ? false : options.wasClean;
      return _this;
    }

    /**
     * @type {Number}
     */
    _inherits(CloseEvent, _Event);
    return _createClass(CloseEvent, [{
      key: "code",
      get: function get() {
        return this[kCode];
      }

      /**
       * @type {String}
       */
    }, {
      key: "reason",
      get: function get() {
        return this[kReason];
      }

      /**
       * @type {Boolean}
       */
    }, {
      key: "wasClean",
      get: function get() {
        return this[kWasClean];
      }
    }]);
  }(Event);
  Object.defineProperty(CloseEvent.prototype, 'code', {
    enumerable: true
  });
  Object.defineProperty(CloseEvent.prototype, 'reason', {
    enumerable: true
  });
  Object.defineProperty(CloseEvent.prototype, 'wasClean', {
    enumerable: true
  });

  /**
   * Class representing an error event.
   *
   * @extends Event
   */
  var ErrorEvent = /*#__PURE__*/function (_Event2) {
    /**
     * Create a new `ErrorEvent`.
     *
     * @param {String} type The name of the event
     * @param {Object} [options] A dictionary object that allows for setting
     *     attributes via object members of the same name
     * @param {*} [options.error=null] The error that generated this event
     * @param {String} [options.message=''] The error message
     */
    function ErrorEvent(type) {
      var _this2;
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      _classCallCheck(this, ErrorEvent);
      _this2 = _callSuper(this, ErrorEvent, [type]);
      _this2[kError] = options.error === undefined ? null : options.error;
      _this2[kMessage] = options.message === undefined ? '' : options.message;
      return _this2;
    }

    /**
     * @type {*}
     */
    _inherits(ErrorEvent, _Event2);
    return _createClass(ErrorEvent, [{
      key: "error",
      get: function get() {
        return this[kError];
      }

      /**
       * @type {String}
       */
    }, {
      key: "message",
      get: function get() {
        return this[kMessage];
      }
    }]);
  }(Event);
  Object.defineProperty(ErrorEvent.prototype, 'error', {
    enumerable: true
  });
  Object.defineProperty(ErrorEvent.prototype, 'message', {
    enumerable: true
  });

  /**
   * Class representing a message event.
   *
   * @extends Event
   */
  var MessageEvent = /*#__PURE__*/function (_Event3) {
    /**
     * Create a new `MessageEvent`.
     *
     * @param {String} type The name of the event
     * @param {Object} [options] A dictionary object that allows for setting
     *     attributes via object members of the same name
     * @param {*} [options.data=null] The message content
     */
    function MessageEvent(type) {
      var _this3;
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      _classCallCheck(this, MessageEvent);
      _this3 = _callSuper(this, MessageEvent, [type]);
      _this3[kData] = options.data === undefined ? null : options.data;
      return _this3;
    }

    /**
     * @type {*}
     */
    _inherits(MessageEvent, _Event3);
    return _createClass(MessageEvent, [{
      key: "data",
      get: function get() {
        return this[kData];
      }
    }]);
  }(Event);
  Object.defineProperty(MessageEvent.prototype, 'data', {
    enumerable: true
  });

  /**
   * This provides methods for emulating the `EventTarget` interface. It's not
   * meant to be used directly.
   *
   * @mixin
   */
  var EventTarget = {
    /**
     * Register an event listener.
     *
     * @param {String} type A string representing the event type to listen for
     * @param {(Function|Object)} handler The listener to add
     * @param {Object} [options] An options object specifies characteristics about
     *     the event listener
     * @param {Boolean} [options.once=false] A `Boolean` indicating that the
     *     listener should be invoked at most once after being added. If `true`,
     *     the listener would be automatically removed when invoked.
     * @public
     */
    addEventListener: function addEventListener(type, handler) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var _iterator = _createForOfIteratorHelper(this.listeners(type)),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var listener = _step.value;
          if (!options[kForOnEventAttribute] && listener[kListener] === handler && !listener[kForOnEventAttribute]) {
            return;
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      var wrapper;
      if (type === 'message') {
        wrapper = function onMessage(data, isBinary) {
          var event = new MessageEvent('message', {
            data: isBinary ? data : data.toString()
          });
          event[kTarget] = this;
          callListener(handler, this, event);
        };
      } else if (type === 'close') {
        wrapper = function onClose(code, message) {
          var event = new CloseEvent('close', {
            code: code,
            reason: message.toString(),
            wasClean: this._closeFrameReceived && this._closeFrameSent
          });
          event[kTarget] = this;
          callListener(handler, this, event);
        };
      } else if (type === 'error') {
        wrapper = function onError(error) {
          var event = new ErrorEvent('error', {
            error: error,
            message: error.message
          });
          event[kTarget] = this;
          callListener(handler, this, event);
        };
      } else if (type === 'open') {
        wrapper = function onOpen() {
          var event = new Event('open');
          event[kTarget] = this;
          callListener(handler, this, event);
        };
      } else {
        return;
      }
      wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];
      wrapper[kListener] = handler;
      if (options.once) {
        this.once(type, wrapper);
      } else {
        this.on(type, wrapper);
      }
    },
    /**
     * Remove an event listener.
     *
     * @param {String} type A string representing the event type to remove
     * @param {(Function|Object)} handler The listener to remove
     * @public
     */
    removeEventListener: function removeEventListener(type, handler) {
      var _iterator2 = _createForOfIteratorHelper(this.listeners(type)),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var listener = _step2.value;
          if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {
            this.removeListener(type, listener);
            break;
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }
  };
  eventTarget = {
    CloseEvent: CloseEvent,
    ErrorEvent: ErrorEvent,
    Event: Event,
    EventTarget: EventTarget,
    MessageEvent: MessageEvent
  };

  /**
   * Call an event listener
   *
   * @param {(Function|Object)} listener The listener to call
   * @param {*} thisArg The value to use as `this`` when calling the listener
   * @param {Event} event The event to pass to the listener
   * @private
   */
  function callListener(listener, thisArg, event) {
    if (_typeof(listener) === 'object' && listener.handleEvent) {
      listener.handleEvent.call(listener, event);
    } else {
      listener.call(thisArg, event);
    }
  }
  return eventTarget;
}

var extension;
var hasRequiredExtension;
function requireExtension() {
  if (hasRequiredExtension) return extension;
  hasRequiredExtension = 1;
  var _require$$ = requireValidation(),
    tokenChars = _require$$.tokenChars;

  /**
   * Adds an offer to the map of extension offers or a parameter to the map of
   * parameters.
   *
   * @param {Object} dest The map of extension offers or parameters
   * @param {String} name The extension or parameter name
   * @param {(Object|Boolean|String)} elem The extension parameters or the
   *     parameter value
   * @private
   */
  function push(dest, name, elem) {
    if (dest[name] === undefined) dest[name] = [elem];else dest[name].push(elem);
  }

  /**
   * Parses the `Sec-WebSocket-Extensions` header into an object.
   *
   * @param {String} header The field value of the header
   * @return {Object} The parsed object
   * @public
   */
  function parse(header) {
    var offers = Object.create(null);
    var params = Object.create(null);
    var mustUnescape = false;
    var isEscaping = false;
    var inQuotes = false;
    var extensionName;
    var paramName;
    var start = -1;
    var code = -1;
    var end = -1;
    var i = 0;
    for (; i < header.length; i++) {
      code = header.charCodeAt(i);
      if (extensionName === undefined) {
        if (end === -1 && tokenChars[code] === 1) {
          if (start === -1) start = i;
        } else if (i !== 0 && (code === 0x20 /* ' ' */ || code === 0x09) /* '\t' */) {
          if (end === -1 && start !== -1) end = i;
        } else if (code === 0x3b /* ';' */ || code === 0x2c /* ',' */) {
          if (start === -1) {
            throw new SyntaxError("Unexpected character at index ".concat(i));
          }
          if (end === -1) end = i;
          var name = header.slice(start, end);
          if (code === 0x2c) {
            push(offers, name, params);
            params = Object.create(null);
          } else {
            extensionName = name;
          }
          start = end = -1;
        } else {
          throw new SyntaxError("Unexpected character at index ".concat(i));
        }
      } else if (paramName === undefined) {
        if (end === -1 && tokenChars[code] === 1) {
          if (start === -1) start = i;
        } else if (code === 0x20 || code === 0x09) {
          if (end === -1 && start !== -1) end = i;
        } else if (code === 0x3b || code === 0x2c) {
          if (start === -1) {
            throw new SyntaxError("Unexpected character at index ".concat(i));
          }
          if (end === -1) end = i;
          push(params, header.slice(start, end), true);
          if (code === 0x2c) {
            push(offers, extensionName, params);
            params = Object.create(null);
            extensionName = undefined;
          }
          start = end = -1;
        } else if (code === 0x3d /* '=' */ && start !== -1 && end === -1) {
          paramName = header.slice(start, i);
          start = end = -1;
        } else {
          throw new SyntaxError("Unexpected character at index ".concat(i));
        }
      } else {
        //
        // The value of a quoted-string after unescaping must conform to the
        // token ABNF, so only token characters are valid.
        // Ref: https://tools.ietf.org/html/rfc6455#section-9.1
        //
        if (isEscaping) {
          if (tokenChars[code] !== 1) {
            throw new SyntaxError("Unexpected character at index ".concat(i));
          }
          if (start === -1) start = i;else if (!mustUnescape) mustUnescape = true;
          isEscaping = false;
        } else if (inQuotes) {
          if (tokenChars[code] === 1) {
            if (start === -1) start = i;
          } else if (code === 0x22 /* '"' */ && start !== -1) {
            inQuotes = false;
            end = i;
          } else if (code === 0x5c /* '\' */) {
            isEscaping = true;
          } else {
            throw new SyntaxError("Unexpected character at index ".concat(i));
          }
        } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {
          inQuotes = true;
        } else if (end === -1 && tokenChars[code] === 1) {
          if (start === -1) start = i;
        } else if (start !== -1 && (code === 0x20 || code === 0x09)) {
          if (end === -1) end = i;
        } else if (code === 0x3b || code === 0x2c) {
          if (start === -1) {
            throw new SyntaxError("Unexpected character at index ".concat(i));
          }
          if (end === -1) end = i;
          var value = header.slice(start, end);
          if (mustUnescape) {
            value = value.replace(/\\/g, '');
            mustUnescape = false;
          }
          push(params, paramName, value);
          if (code === 0x2c) {
            push(offers, extensionName, params);
            params = Object.create(null);
            extensionName = undefined;
          }
          paramName = undefined;
          start = end = -1;
        } else {
          throw new SyntaxError("Unexpected character at index ".concat(i));
        }
      }
    }
    if (start === -1 || inQuotes || code === 0x20 || code === 0x09) {
      throw new SyntaxError('Unexpected end of input');
    }
    if (end === -1) end = i;
    var token = header.slice(start, end);
    if (extensionName === undefined) {
      push(offers, token, params);
    } else {
      if (paramName === undefined) {
        push(params, token, true);
      } else if (mustUnescape) {
        push(params, paramName, token.replace(/\\/g, ''));
      } else {
        push(params, paramName, token);
      }
      push(offers, extensionName, params);
    }
    return offers;
  }

  /**
   * Builds the `Sec-WebSocket-Extensions` header field value.
   *
   * @param {Object} extensions The map of extensions and parameters to format
   * @return {String} A string representing the given object
   * @public
   */
  function format(extensions) {
    return Object.keys(extensions).map(function (extension) {
      var configurations = extensions[extension];
      if (!Array.isArray(configurations)) configurations = [configurations];
      return configurations.map(function (params) {
        return [extension].concat(Object.keys(params).map(function (k) {
          var values = params[k];
          if (!Array.isArray(values)) values = [values];
          return values.map(function (v) {
            return v === true ? k : "".concat(k, "=").concat(v);
          }).join('; ');
        })).join('; ');
      }).join(', ');
    }).join(', ');
  }
  extension = {
    format: format,
    parse: parse
  };
  return extension;
}

var websocket;
var hasRequiredWebsocket;
function requireWebsocket() {
  if (hasRequiredWebsocket) return websocket;
  hasRequiredWebsocket = 1;
  var EventEmitter = require$$0$3;
  var https = require$$2;
  var http = require$$1;
  var net = require$$3$1;
  var tls = require$$4;
  var randomBytes = require$$5.randomBytes,
    createHash = require$$5.createHash;
  require$$0$2.Duplex;
    require$$0$2.Readable;
  var URL = require$$7.URL;
  var PerMessageDeflate = requirePermessageDeflate();
  var Receiver = requireReceiver();
  var Sender = requireSender();
  var _require$$ = requireConstants(),
    BINARY_TYPES = _require$$.BINARY_TYPES,
    EMPTY_BUFFER = _require$$.EMPTY_BUFFER,
    GUID = _require$$.GUID,
    kForOnEventAttribute = _require$$.kForOnEventAttribute,
    kListener = _require$$.kListener,
    kStatusCode = _require$$.kStatusCode,
    kWebSocket = _require$$.kWebSocket,
    NOOP = _require$$.NOOP;
  var _require$$2 = requireEventTarget(),
    _require$$2$EventTarg = _require$$2.EventTarget,
    addEventListener = _require$$2$EventTarg.addEventListener,
    removeEventListener = _require$$2$EventTarg.removeEventListener;
  var _require$$3 = requireExtension(),
    format = _require$$3.format,
    parse = _require$$3.parse;
  var _require$$4 = requireBufferUtil(),
    toBuffer = _require$$4.toBuffer;
  var closeTimeout = 30 * 1000;
  var kAborted = Symbol('kAborted');
  var protocolVersions = [8, 13];
  var readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];
  var subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;

  /**
   * Class representing a WebSocket.
   *
   * @extends EventEmitter
   */
  var WebSocket = /*#__PURE__*/function (_EventEmitter) {
    /**
     * Create a new `WebSocket`.
     *
     * @param {(String|URL)} address The URL to which to connect
     * @param {(String|String[])} [protocols] The subprotocols
     * @param {Object} [options] Connection options
     */
    function WebSocket(address, protocols, options) {
      var _this;
      _classCallCheck(this, WebSocket);
      _this = _callSuper(this, WebSocket);
      _this._binaryType = BINARY_TYPES[0];
      _this._closeCode = 1006;
      _this._closeFrameReceived = false;
      _this._closeFrameSent = false;
      _this._closeMessage = EMPTY_BUFFER;
      _this._closeTimer = null;
      _this._extensions = {};
      _this._paused = false;
      _this._protocol = '';
      _this._readyState = WebSocket.CONNECTING;
      _this._receiver = null;
      _this._sender = null;
      _this._socket = null;
      if (address !== null) {
        _this._bufferedAmount = 0;
        _this._isServer = false;
        _this._redirects = 0;
        if (protocols === undefined) {
          protocols = [];
        } else if (!Array.isArray(protocols)) {
          if (_typeof(protocols) === 'object' && protocols !== null) {
            options = protocols;
            protocols = [];
          } else {
            protocols = [protocols];
          }
        }
        initAsClient(_this, address, protocols, options);
      } else {
        _this._autoPong = options.autoPong;
        _this._isServer = true;
      }
      return _this;
    }

    /**
     * This deviates from the WHATWG interface since ws doesn't support the
     * required default "blob" type (instead we define a custom "nodebuffer"
     * type).
     *
     * @type {String}
     */
    _inherits(WebSocket, _EventEmitter);
    return _createClass(WebSocket, [{
      key: "binaryType",
      get: function get() {
        return this._binaryType;
      },
      set: function set(type) {
        if (!BINARY_TYPES.includes(type)) return;
        this._binaryType = type;

        //
        // Allow to change `binaryType` on the fly.
        //
        if (this._receiver) this._receiver._binaryType = type;
      }

      /**
       * @type {Number}
       */
    }, {
      key: "bufferedAmount",
      get: function get() {
        if (!this._socket) return this._bufferedAmount;
        return this._socket._writableState.length + this._sender._bufferedBytes;
      }

      /**
       * @type {String}
       */
    }, {
      key: "extensions",
      get: function get() {
        return Object.keys(this._extensions).join();
      }

      /**
       * @type {Boolean}
       */
    }, {
      key: "isPaused",
      get: function get() {
        return this._paused;
      }

      /**
       * @type {Function}
       */
      /* istanbul ignore next */
    }, {
      key: "onclose",
      get: function get() {
        return null;
      }

      /**
       * @type {Function}
       */
      /* istanbul ignore next */
    }, {
      key: "onerror",
      get: function get() {
        return null;
      }

      /**
       * @type {Function}
       */
      /* istanbul ignore next */
    }, {
      key: "onopen",
      get: function get() {
        return null;
      }

      /**
       * @type {Function}
       */
      /* istanbul ignore next */
    }, {
      key: "onmessage",
      get: function get() {
        return null;
      }

      /**
       * @type {String}
       */
    }, {
      key: "protocol",
      get: function get() {
        return this._protocol;
      }

      /**
       * @type {Number}
       */
    }, {
      key: "readyState",
      get: function get() {
        return this._readyState;
      }

      /**
       * @type {String}
       */
    }, {
      key: "url",
      get: function get() {
        return this._url;
      }

      /**
       * Set up the socket and the internal resources.
       *
       * @param {Duplex} socket The network socket between the server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Object} options Options object
       * @param {Boolean} [options.allowSynchronousEvents=false] Specifies whether
       *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
       *     multiple times in the same tick
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Number} [options.maxPayload=0] The maximum allowed message size
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       * @private
       */
    }, {
      key: "setSocket",
      value: function setSocket(socket, head, options) {
        var receiver = new Receiver({
          allowSynchronousEvents: options.allowSynchronousEvents,
          binaryType: this.binaryType,
          extensions: this._extensions,
          isServer: this._isServer,
          maxPayload: options.maxPayload,
          skipUTF8Validation: options.skipUTF8Validation
        });
        this._sender = new Sender(socket, this._extensions, options.generateMask);
        this._receiver = receiver;
        this._socket = socket;
        receiver[kWebSocket] = this;
        socket[kWebSocket] = this;
        receiver.on('conclude', receiverOnConclude);
        receiver.on('drain', receiverOnDrain);
        receiver.on('error', receiverOnError);
        receiver.on('message', receiverOnMessage);
        receiver.on('ping', receiverOnPing);
        receiver.on('pong', receiverOnPong);

        //
        // These methods may not be available if `socket` is just a `Duplex`.
        //
        if (socket.setTimeout) socket.setTimeout(0);
        if (socket.setNoDelay) socket.setNoDelay();
        if (head.length > 0) socket.unshift(head);
        socket.on('close', socketOnClose);
        socket.on('data', socketOnData);
        socket.on('end', socketOnEnd);
        socket.on('error', socketOnError);
        this._readyState = WebSocket.OPEN;
        this.emit('open');
      }

      /**
       * Emit the `'close'` event.
       *
       * @private
       */
    }, {
      key: "emitClose",
      value: function emitClose() {
        if (!this._socket) {
          this._readyState = WebSocket.CLOSED;
          this.emit('close', this._closeCode, this._closeMessage);
          return;
        }
        if (this._extensions[PerMessageDeflate.extensionName]) {
          this._extensions[PerMessageDeflate.extensionName].cleanup();
        }
        this._receiver.removeAllListeners();
        this._readyState = WebSocket.CLOSED;
        this.emit('close', this._closeCode, this._closeMessage);
      }

      /**
       * Start a closing handshake.
       *
       *          +----------+   +-----------+   +----------+
       *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
       *    |     +----------+   +-----------+   +----------+     |
       *          +----------+   +-----------+         |
       * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
       *          +----------+   +-----------+   |
       *    |           |                        |   +---+        |
       *                +------------------------+-->|fin| - - - -
       *    |         +---+                      |   +---+
       *     - - - - -|fin|<---------------------+
       *              +---+
       *
       * @param {Number} [code] Status code explaining why the connection is closing
       * @param {(String|Buffer)} [data] The reason why the connection is
       *     closing
       * @public
       */
    }, {
      key: "close",
      value: function close(code, data) {
        var _this2 = this;
        if (this.readyState === WebSocket.CLOSED) return;
        if (this.readyState === WebSocket.CONNECTING) {
          var msg = 'WebSocket was closed before the connection was established';
          abortHandshake(this, this._req, msg);
          return;
        }
        if (this.readyState === WebSocket.CLOSING) {
          if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {
            this._socket.end();
          }
          return;
        }
        this._readyState = WebSocket.CLOSING;
        this._sender.close(code, data, !this._isServer, function (err) {
          //
          // This error is handled by the `'error'` listener on the socket. We only
          // want to know if the close frame has been sent here.
          //
          if (err) return;
          _this2._closeFrameSent = true;
          if (_this2._closeFrameReceived || _this2._receiver._writableState.errorEmitted) {
            _this2._socket.end();
          }
        });

        //
        // Specify a timeout for the closing handshake to complete.
        //
        this._closeTimer = setTimeout(this._socket.destroy.bind(this._socket), closeTimeout);
      }

      /**
       * Pause the socket.
       *
       * @public
       */
    }, {
      key: "pause",
      value: function pause() {
        if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {
          return;
        }
        this._paused = true;
        this._socket.pause();
      }

      /**
       * Send a ping.
       *
       * @param {*} [data] The data to send
       * @param {Boolean} [mask] Indicates whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when the ping is sent
       * @public
       */
    }, {
      key: "ping",
      value: function ping(data, mask, cb) {
        if (this.readyState === WebSocket.CONNECTING) {
          throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
        }
        if (typeof data === 'function') {
          cb = data;
          data = mask = undefined;
        } else if (typeof mask === 'function') {
          cb = mask;
          mask = undefined;
        }
        if (typeof data === 'number') data = data.toString();
        if (this.readyState !== WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === undefined) mask = !this._isServer;
        this._sender.ping(data || EMPTY_BUFFER, mask, cb);
      }

      /**
       * Send a pong.
       *
       * @param {*} [data] The data to send
       * @param {Boolean} [mask] Indicates whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when the pong is sent
       * @public
       */
    }, {
      key: "pong",
      value: function pong(data, mask, cb) {
        if (this.readyState === WebSocket.CONNECTING) {
          throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
        }
        if (typeof data === 'function') {
          cb = data;
          data = mask = undefined;
        } else if (typeof mask === 'function') {
          cb = mask;
          mask = undefined;
        }
        if (typeof data === 'number') data = data.toString();
        if (this.readyState !== WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === undefined) mask = !this._isServer;
        this._sender.pong(data || EMPTY_BUFFER, mask, cb);
      }

      /**
       * Resume the socket.
       *
       * @public
       */
    }, {
      key: "resume",
      value: function resume() {
        if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {
          return;
        }
        this._paused = false;
        if (!this._receiver._writableState.needDrain) this._socket.resume();
      }

      /**
       * Send a data message.
       *
       * @param {*} data The message to send
       * @param {Object} [options] Options object
       * @param {Boolean} [options.binary] Specifies whether `data` is binary or
       *     text
       * @param {Boolean} [options.compress] Specifies whether or not to compress
       *     `data`
       * @param {Boolean} [options.fin=true] Specifies whether the fragment is the
       *     last one
       * @param {Boolean} [options.mask] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when data is written out
       * @public
       */
    }, {
      key: "send",
      value: function send(data, options, cb) {
        if (this.readyState === WebSocket.CONNECTING) {
          throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
        }
        if (typeof options === 'function') {
          cb = options;
          options = {};
        }
        if (typeof data === 'number') data = data.toString();
        if (this.readyState !== WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        var opts = _objectSpread2({
          binary: typeof data !== 'string',
          mask: !this._isServer,
          compress: true,
          fin: true
        }, options);
        if (!this._extensions[PerMessageDeflate.extensionName]) {
          opts.compress = false;
        }
        this._sender.send(data || EMPTY_BUFFER, opts, cb);
      }

      /**
       * Forcibly close the connection.
       *
       * @public
       */
    }, {
      key: "terminate",
      value: function terminate() {
        if (this.readyState === WebSocket.CLOSED) return;
        if (this.readyState === WebSocket.CONNECTING) {
          var msg = 'WebSocket was closed before the connection was established';
          abortHandshake(this, this._req, msg);
          return;
        }
        if (this._socket) {
          this._readyState = WebSocket.CLOSING;
          this._socket.destroy();
        }
      }
    }]);
  }(EventEmitter);
  /**
   * @constant {Number} CONNECTING
   * @memberof WebSocket
   */
  Object.defineProperty(WebSocket, 'CONNECTING', {
    enumerable: true,
    value: readyStates.indexOf('CONNECTING')
  });

  /**
   * @constant {Number} CONNECTING
   * @memberof WebSocket.prototype
   */
  Object.defineProperty(WebSocket.prototype, 'CONNECTING', {
    enumerable: true,
    value: readyStates.indexOf('CONNECTING')
  });

  /**
   * @constant {Number} OPEN
   * @memberof WebSocket
   */
  Object.defineProperty(WebSocket, 'OPEN', {
    enumerable: true,
    value: readyStates.indexOf('OPEN')
  });

  /**
   * @constant {Number} OPEN
   * @memberof WebSocket.prototype
   */
  Object.defineProperty(WebSocket.prototype, 'OPEN', {
    enumerable: true,
    value: readyStates.indexOf('OPEN')
  });

  /**
   * @constant {Number} CLOSING
   * @memberof WebSocket
   */
  Object.defineProperty(WebSocket, 'CLOSING', {
    enumerable: true,
    value: readyStates.indexOf('CLOSING')
  });

  /**
   * @constant {Number} CLOSING
   * @memberof WebSocket.prototype
   */
  Object.defineProperty(WebSocket.prototype, 'CLOSING', {
    enumerable: true,
    value: readyStates.indexOf('CLOSING')
  });

  /**
   * @constant {Number} CLOSED
   * @memberof WebSocket
   */
  Object.defineProperty(WebSocket, 'CLOSED', {
    enumerable: true,
    value: readyStates.indexOf('CLOSED')
  });

  /**
   * @constant {Number} CLOSED
   * @memberof WebSocket.prototype
   */
  Object.defineProperty(WebSocket.prototype, 'CLOSED', {
    enumerable: true,
    value: readyStates.indexOf('CLOSED')
  });
  ['binaryType', 'bufferedAmount', 'extensions', 'isPaused', 'protocol', 'readyState', 'url'].forEach(function (property) {
    Object.defineProperty(WebSocket.prototype, property, {
      enumerable: true
    });
  });

  //
  // Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.
  // See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface
  //
  ['open', 'error', 'close', 'message'].forEach(function (method) {
    Object.defineProperty(WebSocket.prototype, "on".concat(method), {
      enumerable: true,
      get: function get() {
        var _iterator = _createForOfIteratorHelper(this.listeners(method)),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var listener = _step.value;
            if (listener[kForOnEventAttribute]) return listener[kListener];
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        return null;
      },
      set: function set(handler) {
        var _iterator2 = _createForOfIteratorHelper(this.listeners(method)),
          _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var listener = _step2.value;
            if (listener[kForOnEventAttribute]) {
              this.removeListener(method, listener);
              break;
            }
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
        if (typeof handler !== 'function') return;
        this.addEventListener(method, handler, _defineProperty({}, kForOnEventAttribute, true));
      }
    });
  });
  WebSocket.prototype.addEventListener = addEventListener;
  WebSocket.prototype.removeEventListener = removeEventListener;
  websocket = WebSocket;

  /**
   * Initialize a WebSocket client.
   *
   * @param {WebSocket} websocket The client to initialize
   * @param {(String|URL)} address The URL to which to connect
   * @param {Array} protocols The subprotocols
   * @param {Object} [options] Connection options
   * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether any
   *     of the `'message'`, `'ping'`, and `'pong'` events can be emitted multiple
   *     times in the same tick
   * @param {Boolean} [options.autoPong=true] Specifies whether or not to
   *     automatically send a pong in response to a ping
   * @param {Function} [options.finishRequest] A function which can be used to
   *     customize the headers of each http request before it is sent
   * @param {Boolean} [options.followRedirects=false] Whether or not to follow
   *     redirects
   * @param {Function} [options.generateMask] The function used to generate the
   *     masking key
   * @param {Number} [options.handshakeTimeout] Timeout in milliseconds for the
   *     handshake request
   * @param {Number} [options.maxPayload=104857600] The maximum allowed message
   *     size
   * @param {Number} [options.maxRedirects=10] The maximum number of redirects
   *     allowed
   * @param {String} [options.origin] Value of the `Origin` or
   *     `Sec-WebSocket-Origin` header
   * @param {(Boolean|Object)} [options.perMessageDeflate=true] Enable/disable
   *     permessage-deflate
   * @param {Number} [options.protocolVersion=13] Value of the
   *     `Sec-WebSocket-Version` header
   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
   *     not to skip UTF-8 validation for text and close messages
   * @private
   */
  function initAsClient(websocket, address, protocols, options) {
    var opts = _objectSpread2(_objectSpread2({
      allowSynchronousEvents: true,
      autoPong: true,
      protocolVersion: protocolVersions[1],
      maxPayload: 100 * 1024 * 1024,
      skipUTF8Validation: false,
      perMessageDeflate: true,
      followRedirects: false,
      maxRedirects: 10
    }, options), {}, {
      socketPath: undefined,
      hostname: undefined,
      protocol: undefined,
      timeout: undefined,
      method: 'GET',
      host: undefined,
      path: undefined,
      port: undefined
    });
    websocket._autoPong = opts.autoPong;
    if (!protocolVersions.includes(opts.protocolVersion)) {
      throw new RangeError("Unsupported protocol version: ".concat(opts.protocolVersion, " ") + "(supported versions: ".concat(protocolVersions.join(', '), ")"));
    }
    var parsedUrl;
    if (address instanceof URL) {
      parsedUrl = address;
    } else {
      try {
        parsedUrl = new URL(address);
      } catch (e) {
        throw new SyntaxError("Invalid URL: ".concat(address));
      }
    }
    if (parsedUrl.protocol === 'http:') {
      parsedUrl.protocol = 'ws:';
    } else if (parsedUrl.protocol === 'https:') {
      parsedUrl.protocol = 'wss:';
    }
    websocket._url = parsedUrl.href;
    var isSecure = parsedUrl.protocol === 'wss:';
    var isIpcUrl = parsedUrl.protocol === 'ws+unix:';
    var invalidUrlMessage;
    if (parsedUrl.protocol !== 'ws:' && !isSecure && !isIpcUrl) {
      invalidUrlMessage = 'The URL\'s protocol must be one of "ws:", "wss:", ' + '"http:", "https", or "ws+unix:"';
    } else if (isIpcUrl && !parsedUrl.pathname) {
      invalidUrlMessage = "The URL's pathname is empty";
    } else if (parsedUrl.hash) {
      invalidUrlMessage = 'The URL contains a fragment identifier';
    }
    if (invalidUrlMessage) {
      var err = new SyntaxError(invalidUrlMessage);
      if (websocket._redirects === 0) {
        throw err;
      } else {
        emitErrorAndClose(websocket, err);
        return;
      }
    }
    var defaultPort = isSecure ? 443 : 80;
    var key = randomBytes(16).toString('base64');
    var request = isSecure ? https.request : http.request;
    var protocolSet = new Set();
    var perMessageDeflate;
    opts.createConnection = opts.createConnection || (isSecure ? tlsConnect : netConnect);
    opts.defaultPort = opts.defaultPort || defaultPort;
    opts.port = parsedUrl.port || defaultPort;
    opts.host = parsedUrl.hostname.startsWith('[') ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
    opts.headers = _objectSpread2(_objectSpread2({}, opts.headers), {}, {
      'Sec-WebSocket-Version': opts.protocolVersion,
      'Sec-WebSocket-Key': key,
      Connection: 'Upgrade',
      Upgrade: 'websocket'
    });
    opts.path = parsedUrl.pathname + parsedUrl.search;
    opts.timeout = opts.handshakeTimeout;
    if (opts.perMessageDeflate) {
      perMessageDeflate = new PerMessageDeflate(opts.perMessageDeflate !== true ? opts.perMessageDeflate : {}, false, opts.maxPayload);
      opts.headers['Sec-WebSocket-Extensions'] = format(_defineProperty({}, PerMessageDeflate.extensionName, perMessageDeflate.offer()));
    }
    if (protocols.length) {
      var _iterator3 = _createForOfIteratorHelper(protocols),
        _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var protocol = _step3.value;
          if (typeof protocol !== 'string' || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {
            throw new SyntaxError('An invalid or duplicated subprotocol was specified');
          }
          protocolSet.add(protocol);
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
      opts.headers['Sec-WebSocket-Protocol'] = protocols.join(',');
    }
    if (opts.origin) {
      if (opts.protocolVersion < 13) {
        opts.headers['Sec-WebSocket-Origin'] = opts.origin;
      } else {
        opts.headers.Origin = opts.origin;
      }
    }
    if (parsedUrl.username || parsedUrl.password) {
      opts.auth = "".concat(parsedUrl.username, ":").concat(parsedUrl.password);
    }
    if (isIpcUrl) {
      var parts = opts.path.split(':');
      opts.socketPath = parts[0];
      opts.path = parts[1];
    }
    var req;
    if (opts.followRedirects) {
      if (websocket._redirects === 0) {
        websocket._originalIpc = isIpcUrl;
        websocket._originalSecure = isSecure;
        websocket._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;
        var headers = options && options.headers;

        //
        // Shallow copy the user provided options so that headers can be changed
        // without mutating the original object.
        //
        options = _objectSpread2(_objectSpread2({}, options), {}, {
          headers: {}
        });
        if (headers) {
          for (var _i = 0, _Object$entries = Object.entries(headers); _i < _Object$entries.length; _i++) {
            var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
              _key = _Object$entries$_i[0],
              value = _Object$entries$_i[1];
            options.headers[_key.toLowerCase()] = value;
          }
        }
      } else if (websocket.listenerCount('redirect') === 0) {
        var isSameHost = isIpcUrl ? websocket._originalIpc ? opts.socketPath === websocket._originalHostOrSocketPath : false : websocket._originalIpc ? false : parsedUrl.host === websocket._originalHostOrSocketPath;
        if (!isSameHost || websocket._originalSecure && !isSecure) {
          //
          // Match curl 7.77.0 behavior and drop the following headers. These
          // headers are also dropped when following a redirect to a subdomain.
          //
          delete opts.headers.authorization;
          delete opts.headers.cookie;
          if (!isSameHost) delete opts.headers.host;
          opts.auth = undefined;
        }
      }

      //
      // Match curl 7.77.0 behavior and make the first `Authorization` header win.
      // If the `Authorization` header is set, then there is nothing to do as it
      // will take precedence.
      //
      if (opts.auth && !options.headers.authorization) {
        options.headers.authorization = 'Basic ' + Buffer.from(opts.auth).toString('base64');
      }
      req = websocket._req = request(opts);
      if (websocket._redirects) {
        //
        // Unlike what is done for the `'upgrade'` event, no early exit is
        // triggered here if the user calls `websocket.close()` or
        // `websocket.terminate()` from a listener of the `'redirect'` event. This
        // is because the user can also call `request.destroy()` with an error
        // before calling `websocket.close()` or `websocket.terminate()` and this
        // would result in an error being emitted on the `request` object with no
        // `'error'` event listeners attached.
        //
        websocket.emit('redirect', websocket.url, req);
      }
    } else {
      req = websocket._req = request(opts);
    }
    if (opts.timeout) {
      req.on('timeout', function () {
        abortHandshake(websocket, req, 'Opening handshake has timed out');
      });
    }
    req.on('error', function (err) {
      if (req === null || req[kAborted]) return;
      req = websocket._req = null;
      emitErrorAndClose(websocket, err);
    });
    req.on('response', function (res) {
      var location = res.headers.location;
      var statusCode = res.statusCode;
      if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
        if (++websocket._redirects > opts.maxRedirects) {
          abortHandshake(websocket, req, 'Maximum redirects exceeded');
          return;
        }
        req.abort();
        var addr;
        try {
          addr = new URL(location, address);
        } catch (e) {
          var _err = new SyntaxError("Invalid URL: ".concat(location));
          emitErrorAndClose(websocket, _err);
          return;
        }
        initAsClient(websocket, addr, protocols, options);
      } else if (!websocket.emit('unexpected-response', req, res)) {
        abortHandshake(websocket, req, "Unexpected server response: ".concat(res.statusCode));
      }
    });
    req.on('upgrade', function (res, socket, head) {
      websocket.emit('upgrade', res);

      //
      // The user may have closed the connection from a listener of the
      // `'upgrade'` event.
      //
      if (websocket.readyState !== WebSocket.CONNECTING) return;
      req = websocket._req = null;
      var upgrade = res.headers.upgrade;
      if (upgrade === undefined || upgrade.toLowerCase() !== 'websocket') {
        abortHandshake(websocket, socket, 'Invalid Upgrade header');
        return;
      }
      var digest = createHash('sha1').update(key + GUID).digest('base64');
      if (res.headers['sec-websocket-accept'] !== digest) {
        abortHandshake(websocket, socket, 'Invalid Sec-WebSocket-Accept header');
        return;
      }
      var serverProt = res.headers['sec-websocket-protocol'];
      var protError;
      if (serverProt !== undefined) {
        if (!protocolSet.size) {
          protError = 'Server sent a subprotocol but none was requested';
        } else if (!protocolSet.has(serverProt)) {
          protError = 'Server sent an invalid subprotocol';
        }
      } else if (protocolSet.size) {
        protError = 'Server sent no subprotocol';
      }
      if (protError) {
        abortHandshake(websocket, socket, protError);
        return;
      }
      if (serverProt) websocket._protocol = serverProt;
      var secWebSocketExtensions = res.headers['sec-websocket-extensions'];
      if (secWebSocketExtensions !== undefined) {
        if (!perMessageDeflate) {
          var message = 'Server sent a Sec-WebSocket-Extensions header but no extension ' + 'was requested';
          abortHandshake(websocket, socket, message);
          return;
        }
        var extensions;
        try {
          extensions = parse(secWebSocketExtensions);
        } catch (err) {
          var _message = 'Invalid Sec-WebSocket-Extensions header';
          abortHandshake(websocket, socket, _message);
          return;
        }
        var extensionNames = Object.keys(extensions);
        if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {
          var _message2 = 'Server indicated an extension that was not requested';
          abortHandshake(websocket, socket, _message2);
          return;
        }
        try {
          perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
        } catch (err) {
          var _message3 = 'Invalid Sec-WebSocket-Extensions header';
          abortHandshake(websocket, socket, _message3);
          return;
        }
        websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
      }
      websocket.setSocket(socket, head, {
        allowSynchronousEvents: opts.allowSynchronousEvents,
        generateMask: opts.generateMask,
        maxPayload: opts.maxPayload,
        skipUTF8Validation: opts.skipUTF8Validation
      });
    });
    if (opts.finishRequest) {
      opts.finishRequest(req, websocket);
    } else {
      req.end();
    }
  }

  /**
   * Emit the `'error'` and `'close'` events.
   *
   * @param {WebSocket} websocket The WebSocket instance
   * @param {Error} The error to emit
   * @private
   */
  function emitErrorAndClose(websocket, err) {
    websocket._readyState = WebSocket.CLOSING;
    websocket.emit('error', err);
    websocket.emitClose();
  }

  /**
   * Create a `net.Socket` and initiate a connection.
   *
   * @param {Object} options Connection options
   * @return {net.Socket} The newly created socket used to start the connection
   * @private
   */
  function netConnect(options) {
    options.path = options.socketPath;
    return net.connect(options);
  }

  /**
   * Create a `tls.TLSSocket` and initiate a connection.
   *
   * @param {Object} options Connection options
   * @return {tls.TLSSocket} The newly created socket used to start the connection
   * @private
   */
  function tlsConnect(options) {
    options.path = undefined;
    if (!options.servername && options.servername !== '') {
      options.servername = net.isIP(options.host) ? '' : options.host;
    }
    return tls.connect(options);
  }

  /**
   * Abort the handshake and emit an error.
   *
   * @param {WebSocket} websocket The WebSocket instance
   * @param {(http.ClientRequest|net.Socket|tls.Socket)} stream The request to
   *     abort or the socket to destroy
   * @param {String} message The error message
   * @private
   */
  function abortHandshake(websocket, stream, message) {
    websocket._readyState = WebSocket.CLOSING;
    var err = new Error(message);
    Error.captureStackTrace(err, abortHandshake);
    if (stream.setHeader) {
      stream[kAborted] = true;
      stream.abort();
      if (stream.socket && !stream.socket.destroyed) {
        //
        // On Node.js >= 14.3.0 `request.abort()` does not destroy the socket if
        // called after the request completed. See
        // https://github.com/websockets/ws/issues/1869.
        //
        stream.socket.destroy();
      }
      process.nextTick(emitErrorAndClose, websocket, err);
    } else {
      stream.destroy(err);
      stream.once('error', websocket.emit.bind(websocket, 'error'));
      stream.once('close', websocket.emitClose.bind(websocket));
    }
  }

  /**
   * Handle cases where the `ping()`, `pong()`, or `send()` methods are called
   * when the `readyState` attribute is `CLOSING` or `CLOSED`.
   *
   * @param {WebSocket} websocket The WebSocket instance
   * @param {*} [data] The data to send
   * @param {Function} [cb] Callback
   * @private
   */
  function sendAfterClose(websocket, data, cb) {
    if (data) {
      var length = toBuffer(data).length;

      //
      // The `_bufferedAmount` property is used only when the peer is a client and
      // the opening handshake fails. Under these circumstances, in fact, the
      // `setSocket()` method is not called, so the `_socket` and `_sender`
      // properties are set to `null`.
      //
      if (websocket._socket) websocket._sender._bufferedBytes += length;else websocket._bufferedAmount += length;
    }
    if (cb) {
      var err = new Error("WebSocket is not open: readyState ".concat(websocket.readyState, " ") + "(".concat(readyStates[websocket.readyState], ")"));
      process.nextTick(cb, err);
    }
  }

  /**
   * The listener of the `Receiver` `'conclude'` event.
   *
   * @param {Number} code The status code
   * @param {Buffer} reason The reason for closing
   * @private
   */
  function receiverOnConclude(code, reason) {
    var websocket = this[kWebSocket];
    websocket._closeFrameReceived = true;
    websocket._closeMessage = reason;
    websocket._closeCode = code;
    if (websocket._socket[kWebSocket] === undefined) return;
    websocket._socket.removeListener('data', socketOnData);
    process.nextTick(resume, websocket._socket);
    if (code === 1005) websocket.close();else websocket.close(code, reason);
  }

  /**
   * The listener of the `Receiver` `'drain'` event.
   *
   * @private
   */
  function receiverOnDrain() {
    var websocket = this[kWebSocket];
    if (!websocket.isPaused) websocket._socket.resume();
  }

  /**
   * The listener of the `Receiver` `'error'` event.
   *
   * @param {(RangeError|Error)} err The emitted error
   * @private
   */
  function receiverOnError(err) {
    var websocket = this[kWebSocket];
    if (websocket._socket[kWebSocket] !== undefined) {
      websocket._socket.removeListener('data', socketOnData);

      //
      // On Node.js < 14.0.0 the `'error'` event is emitted synchronously. See
      // https://github.com/websockets/ws/issues/1940.
      //
      process.nextTick(resume, websocket._socket);
      websocket.close(err[kStatusCode]);
    }
    websocket.emit('error', err);
  }

  /**
   * The listener of the `Receiver` `'finish'` event.
   *
   * @private
   */
  function receiverOnFinish() {
    this[kWebSocket].emitClose();
  }

  /**
   * The listener of the `Receiver` `'message'` event.
   *
   * @param {Buffer|ArrayBuffer|Buffer[])} data The message
   * @param {Boolean} isBinary Specifies whether the message is binary or not
   * @private
   */
  function receiverOnMessage(data, isBinary) {
    this[kWebSocket].emit('message', data, isBinary);
  }

  /**
   * The listener of the `Receiver` `'ping'` event.
   *
   * @param {Buffer} data The data included in the ping frame
   * @private
   */
  function receiverOnPing(data) {
    var websocket = this[kWebSocket];
    if (websocket._autoPong) websocket.pong(data, !this._isServer, NOOP);
    websocket.emit('ping', data);
  }

  /**
   * The listener of the `Receiver` `'pong'` event.
   *
   * @param {Buffer} data The data included in the pong frame
   * @private
   */
  function receiverOnPong(data) {
    this[kWebSocket].emit('pong', data);
  }

  /**
   * Resume a readable stream
   *
   * @param {Readable} stream The readable stream
   * @private
   */
  function resume(stream) {
    stream.resume();
  }

  /**
   * The listener of the socket `'close'` event.
   *
   * @private
   */
  function socketOnClose() {
    var websocket = this[kWebSocket];
    this.removeListener('close', socketOnClose);
    this.removeListener('data', socketOnData);
    this.removeListener('end', socketOnEnd);
    websocket._readyState = WebSocket.CLOSING;
    var chunk;

    //
    // The close frame might not have been received or the `'end'` event emitted,
    // for example, if the socket was destroyed due to an error. Ensure that the
    // `receiver` stream is closed after writing any remaining buffered data to
    // it. If the readable side of the socket is in flowing mode then there is no
    // buffered data as everything has been already written and `readable.read()`
    // will return `null`. If instead, the socket is paused, any possible buffered
    // data will be read as a single chunk.
    //
    if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) {
      websocket._receiver.write(chunk);
    }
    websocket._receiver.end();
    this[kWebSocket] = undefined;
    clearTimeout(websocket._closeTimer);
    if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {
      websocket.emitClose();
    } else {
      websocket._receiver.on('error', receiverOnFinish);
      websocket._receiver.on('finish', receiverOnFinish);
    }
  }

  /**
   * The listener of the socket `'data'` event.
   *
   * @param {Buffer} chunk A chunk of data
   * @private
   */
  function socketOnData(chunk) {
    if (!this[kWebSocket]._receiver.write(chunk)) {
      this.pause();
    }
  }

  /**
   * The listener of the socket `'end'` event.
   *
   * @private
   */
  function socketOnEnd() {
    var websocket = this[kWebSocket];
    websocket._readyState = WebSocket.CLOSING;
    websocket._receiver.end();
    this.end();
  }

  /**
   * The listener of the socket `'error'` event.
   *
   * @private
   */
  function socketOnError() {
    var websocket = this[kWebSocket];
    this.removeListener('error', socketOnError);
    this.on('error', NOOP);
    if (websocket) {
      websocket._readyState = WebSocket.CLOSING;
      this.destroy();
    }
  }
  return websocket;
}

var stream;
var hasRequiredStream;
function requireStream() {
  if (hasRequiredStream) return stream;
  hasRequiredStream = 1;
  var Duplex = require$$0$2.Duplex;

  /**
   * Emits the `'close'` event on a stream.
   *
   * @param {Duplex} stream The stream.
   * @private
   */
  function emitClose(stream) {
    stream.emit('close');
  }

  /**
   * The listener of the `'end'` event.
   *
   * @private
   */
  function duplexOnEnd() {
    if (!this.destroyed && this._writableState.finished) {
      this.destroy();
    }
  }

  /**
   * The listener of the `'error'` event.
   *
   * @param {Error} err The error
   * @private
   */
  function duplexOnError(err) {
    this.removeListener('error', duplexOnError);
    this.destroy();
    if (this.listenerCount('error') === 0) {
      // Do not suppress the throwing behavior.
      this.emit('error', err);
    }
  }

  /**
   * Wraps a `WebSocket` in a duplex stream.
   *
   * @param {WebSocket} ws The `WebSocket` to wrap
   * @param {Object} [options] The options for the `Duplex` constructor
   * @return {Duplex} The duplex stream
   * @public
   */
  function createWebSocketStream(ws, options) {
    var terminateOnDestroy = true;
    var duplex = new Duplex(_objectSpread2(_objectSpread2({}, options), {}, {
      autoDestroy: false,
      emitClose: false,
      objectMode: false,
      writableObjectMode: false
    }));
    ws.on('message', function message(msg, isBinary) {
      var data = !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;
      if (!duplex.push(data)) ws.pause();
    });
    ws.once('error', function error(err) {
      if (duplex.destroyed) return;

      // Prevent `ws.terminate()` from being called by `duplex._destroy()`.
      //
      // - If the `'error'` event is emitted before the `'open'` event, then
      //   `ws.terminate()` is a noop as no socket is assigned.
      // - Otherwise, the error is re-emitted by the listener of the `'error'`
      //   event of the `Receiver` object. The listener already closes the
      //   connection by calling `ws.close()`. This allows a close frame to be
      //   sent to the other peer. If `ws.terminate()` is called right after this,
      //   then the close frame might not be sent.
      terminateOnDestroy = false;
      duplex.destroy(err);
    });
    ws.once('close', function close() {
      if (duplex.destroyed) return;
      duplex.push(null);
    });
    duplex._destroy = function (err, callback) {
      if (ws.readyState === ws.CLOSED) {
        callback(err);
        process.nextTick(emitClose, duplex);
        return;
      }
      var called = false;
      ws.once('error', function error(err) {
        called = true;
        callback(err);
      });
      ws.once('close', function close() {
        if (!called) callback(err);
        process.nextTick(emitClose, duplex);
      });
      if (terminateOnDestroy) ws.terminate();
    };
    duplex._final = function (callback) {
      if (ws.readyState === ws.CONNECTING) {
        ws.once('open', function open() {
          duplex._final(callback);
        });
        return;
      }

      // If the value of the `_socket` property is `null` it means that `ws` is a
      // client websocket and the handshake failed. In fact, when this happens, a
      // socket is never assigned to the websocket. Wait for the `'error'` event
      // that will be emitted by the websocket.
      if (ws._socket === null) return;
      if (ws._socket._writableState.finished) {
        callback();
        if (duplex._readableState.endEmitted) duplex.destroy();
      } else {
        ws._socket.once('finish', function finish() {
          // `duplex` is not destroyed here because the `'end'` event will be
          // emitted on `duplex` after this `'finish'` event. The EOF signaling
          // `null` chunk is, in fact, pushed when the websocket emits `'close'`.
          callback();
        });
        ws.close();
      }
    };
    duplex._read = function () {
      if (ws.isPaused) ws.resume();
    };
    duplex._write = function (chunk, encoding, callback) {
      if (ws.readyState === ws.CONNECTING) {
        ws.once('open', function open() {
          duplex._write(chunk, encoding, callback);
        });
        return;
      }
      ws.send(chunk, callback);
    };
    duplex.on('end', duplexOnEnd);
    duplex.on('error', duplexOnError);
    return duplex;
  }
  stream = createWebSocketStream;
  return stream;
}

var subprotocol;
var hasRequiredSubprotocol;
function requireSubprotocol() {
  if (hasRequiredSubprotocol) return subprotocol;
  hasRequiredSubprotocol = 1;
  var _require$$ = requireValidation(),
    tokenChars = _require$$.tokenChars;

  /**
   * Parses the `Sec-WebSocket-Protocol` header into a set of subprotocol names.
   *
   * @param {String} header The field value of the header
   * @return {Set} The subprotocol names
   * @public
   */
  function parse(header) {
    var protocols = new Set();
    var start = -1;
    var end = -1;
    var i = 0;
    for (i; i < header.length; i++) {
      var code = header.charCodeAt(i);
      if (end === -1 && tokenChars[code] === 1) {
        if (start === -1) start = i;
      } else if (i !== 0 && (code === 0x20 /* ' ' */ || code === 0x09) /* '\t' */) {
        if (end === -1 && start !== -1) end = i;
      } else if (code === 0x2c /* ',' */) {
        if (start === -1) {
          throw new SyntaxError("Unexpected character at index ".concat(i));
        }
        if (end === -1) end = i;
        var _protocol = header.slice(start, end);
        if (protocols.has(_protocol)) {
          throw new SyntaxError("The \"".concat(_protocol, "\" subprotocol is duplicated"));
        }
        protocols.add(_protocol);
        start = end = -1;
      } else {
        throw new SyntaxError("Unexpected character at index ".concat(i));
      }
    }
    if (start === -1 || end !== -1) {
      throw new SyntaxError('Unexpected end of input');
    }
    var protocol = header.slice(start, i);
    if (protocols.has(protocol)) {
      throw new SyntaxError("The \"".concat(protocol, "\" subprotocol is duplicated"));
    }
    protocols.add(protocol);
    return protocols;
  }
  subprotocol = {
    parse: parse
  };
  return subprotocol;
}

var websocketServer;
var hasRequiredWebsocketServer;
function requireWebsocketServer() {
  if (hasRequiredWebsocketServer) return websocketServer;
  hasRequiredWebsocketServer = 1;
  var EventEmitter = require$$0$3;
  var http = require$$1;
  require$$0$2.Duplex;
  var createHash = require$$5.createHash;
  var extension = requireExtension();
  var PerMessageDeflate = requirePermessageDeflate();
  var subprotocol = requireSubprotocol();
  var WebSocket = requireWebsocket();
  var _require$$ = requireConstants(),
    GUID = _require$$.GUID,
    kWebSocket = _require$$.kWebSocket;
  var keyRegex = /^[+/0-9A-Za-z]{22}==$/;
  var RUNNING = 0;
  var CLOSING = 1;
  var CLOSED = 2;

  /**
   * Class representing a WebSocket server.
   *
   * @extends EventEmitter
   */
  var WebSocketServer = /*#__PURE__*/function (_EventEmitter) {
    /**
     * Create a `WebSocketServer` instance.
     *
     * @param {Object} options Configuration options
     * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
     *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
     *     multiple times in the same tick
     * @param {Boolean} [options.autoPong=true] Specifies whether or not to
     *     automatically send a pong in response to a ping
     * @param {Number} [options.backlog=511] The maximum length of the queue of
     *     pending connections
     * @param {Boolean} [options.clientTracking=true] Specifies whether or not to
     *     track clients
     * @param {Function} [options.handleProtocols] A hook to handle protocols
     * @param {String} [options.host] The hostname where to bind the server
     * @param {Number} [options.maxPayload=104857600] The maximum allowed message
     *     size
     * @param {Boolean} [options.noServer=false] Enable no server mode
     * @param {String} [options.path] Accept only connections matching this path
     * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable
     *     permessage-deflate
     * @param {Number} [options.port] The port where to bind the server
     * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S
     *     server to use
     * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
     *     not to skip UTF-8 validation for text and close messages
     * @param {Function} [options.verifyClient] A hook to reject connections
     * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`
     *     class to use. It must be the `WebSocket` class or class that extends it
     * @param {Function} [callback] A listener for the `listening` event
     */
    function WebSocketServer(options, callback) {
      var _this;
      _classCallCheck(this, WebSocketServer);
      _this = _callSuper(this, WebSocketServer);
      options = _objectSpread2({
        allowSynchronousEvents: true,
        autoPong: true,
        maxPayload: 100 * 1024 * 1024,
        skipUTF8Validation: false,
        perMessageDeflate: false,
        handleProtocols: null,
        clientTracking: true,
        verifyClient: null,
        noServer: false,
        backlog: null,
        // use default (511 as implemented in net.js)
        server: null,
        host: null,
        path: null,
        port: null,
        WebSocket: WebSocket
      }, options);
      if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {
        throw new TypeError('One and only one of the "port", "server", or "noServer" options ' + 'must be specified');
      }
      if (options.port != null) {
        _this._server = http.createServer(function (req, res) {
          var body = http.STATUS_CODES[426];
          res.writeHead(426, {
            'Content-Length': body.length,
            'Content-Type': 'text/plain'
          });
          res.end(body);
        });
        _this._server.listen(options.port, options.host, options.backlog, callback);
      } else if (options.server) {
        _this._server = options.server;
      }
      if (_this._server) {
        var emitConnection = _this.emit.bind(_this, 'connection');
        _this._removeListeners = addListeners(_this._server, {
          listening: _this.emit.bind(_this, 'listening'),
          error: _this.emit.bind(_this, 'error'),
          upgrade: function upgrade(req, socket, head) {
            _this.handleUpgrade(req, socket, head, emitConnection);
          }
        });
      }
      if (options.perMessageDeflate === true) options.perMessageDeflate = {};
      if (options.clientTracking) {
        _this.clients = new Set();
        _this._shouldEmitClose = false;
      }
      _this.options = options;
      _this._state = RUNNING;
      return _this;
    }

    /**
     * Returns the bound address, the address family name, and port of the server
     * as reported by the operating system if listening on an IP socket.
     * If the server is listening on a pipe or UNIX domain socket, the name is
     * returned as a string.
     *
     * @return {(Object|String|null)} The address of the server
     * @public
     */
    _inherits(WebSocketServer, _EventEmitter);
    return _createClass(WebSocketServer, [{
      key: "address",
      value: function address() {
        if (this.options.noServer) {
          throw new Error('The server is operating in "noServer" mode');
        }
        if (!this._server) return null;
        return this._server.address();
      }

      /**
       * Stop the server from accepting new connections and emit the `'close'` event
       * when all existing connections are closed.
       *
       * @param {Function} [cb] A one-time listener for the `'close'` event
       * @public
       */
    }, {
      key: "close",
      value: function close(cb) {
        var _this2 = this;
        if (this._state === CLOSED) {
          if (cb) {
            this.once('close', function () {
              cb(new Error('The server is not running'));
            });
          }
          process.nextTick(emitClose, this);
          return;
        }
        if (cb) this.once('close', cb);
        if (this._state === CLOSING) return;
        this._state = CLOSING;
        if (this.options.noServer || this.options.server) {
          if (this._server) {
            this._removeListeners();
            this._removeListeners = this._server = null;
          }
          if (this.clients) {
            if (!this.clients.size) {
              process.nextTick(emitClose, this);
            } else {
              this._shouldEmitClose = true;
            }
          } else {
            process.nextTick(emitClose, this);
          }
        } else {
          var server = this._server;
          this._removeListeners();
          this._removeListeners = this._server = null;

          //
          // The HTTP/S server was created internally. Close it, and rely on its
          // `'close'` event.
          //
          server.close(function () {
            emitClose(_this2);
          });
        }
      }

      /**
       * See if a given request should be handled by this server instance.
       *
       * @param {http.IncomingMessage} req Request object to inspect
       * @return {Boolean} `true` if the request is valid, else `false`
       * @public
       */
    }, {
      key: "shouldHandle",
      value: function shouldHandle(req) {
        if (this.options.path) {
          var index = req.url.indexOf('?');
          var pathname = index !== -1 ? req.url.slice(0, index) : req.url;
          if (pathname !== this.options.path) return false;
        }
        return true;
      }

      /**
       * Handle a HTTP Upgrade request.
       *
       * @param {http.IncomingMessage} req The request object
       * @param {Duplex} socket The network socket between the server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Function} cb Callback
       * @public
       */
    }, {
      key: "handleUpgrade",
      value: function handleUpgrade(req, socket, head, cb) {
        var _this3 = this;
        socket.on('error', socketOnError);
        var key = req.headers['sec-websocket-key'];
        var upgrade = req.headers.upgrade;
        var version = +req.headers['sec-websocket-version'];
        if (req.method !== 'GET') {
          var message = 'Invalid HTTP method';
          abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);
          return;
        }
        if (upgrade === undefined || upgrade.toLowerCase() !== 'websocket') {
          var _message = 'Invalid Upgrade header';
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, _message);
          return;
        }
        if (key === undefined || !keyRegex.test(key)) {
          var _message2 = 'Missing or invalid Sec-WebSocket-Key header';
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, _message2);
          return;
        }
        if (version !== 8 && version !== 13) {
          var _message3 = 'Missing or invalid Sec-WebSocket-Version header';
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, _message3);
          return;
        }
        if (!this.shouldHandle(req)) {
          abortHandshake(socket, 400);
          return;
        }
        var secWebSocketProtocol = req.headers['sec-websocket-protocol'];
        var protocols = new Set();
        if (secWebSocketProtocol !== undefined) {
          try {
            protocols = subprotocol.parse(secWebSocketProtocol);
          } catch (err) {
            var _message4 = 'Invalid Sec-WebSocket-Protocol header';
            abortHandshakeOrEmitwsClientError(this, req, socket, 400, _message4);
            return;
          }
        }
        var secWebSocketExtensions = req.headers['sec-websocket-extensions'];
        var extensions = {};
        if (this.options.perMessageDeflate && secWebSocketExtensions !== undefined) {
          var perMessageDeflate = new PerMessageDeflate(this.options.perMessageDeflate, true, this.options.maxPayload);
          try {
            var offers = extension.parse(secWebSocketExtensions);
            if (offers[PerMessageDeflate.extensionName]) {
              perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
              extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
            }
          } catch (err) {
            var _message5 = 'Invalid or unacceptable Sec-WebSocket-Extensions header';
            abortHandshakeOrEmitwsClientError(this, req, socket, 400, _message5);
            return;
          }
        }

        //
        // Optionally call external client verification handler.
        //
        if (this.options.verifyClient) {
          var info = {
            origin: req.headers["".concat(version === 8 ? 'sec-websocket-origin' : 'origin')],
            secure: !!(req.socket.authorized || req.socket.encrypted),
            req: req
          };
          if (this.options.verifyClient.length === 2) {
            this.options.verifyClient(info, function (verified, code, message, headers) {
              if (!verified) {
                return abortHandshake(socket, code || 401, message, headers);
              }
              _this3.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
            });
            return;
          }
          if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);
        }
        this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
      }

      /**
       * Upgrade the connection to WebSocket.
       *
       * @param {Object} extensions The accepted extensions
       * @param {String} key The value of the `Sec-WebSocket-Key` header
       * @param {Set} protocols The subprotocols
       * @param {http.IncomingMessage} req The request object
       * @param {Duplex} socket The network socket between the server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Function} cb Callback
       * @throws {Error} If called more than once with the same socket
       * @private
       */
    }, {
      key: "completeUpgrade",
      value: function completeUpgrade(extensions, key, protocols, req, socket, head, cb) {
        var _this4 = this;
        //
        // Destroy the socket if the client has already sent a FIN packet.
        //
        if (!socket.readable || !socket.writable) return socket.destroy();
        if (socket[kWebSocket]) {
          throw new Error('server.handleUpgrade() was called more than once with the same ' + 'socket, possibly due to a misconfiguration');
        }
        if (this._state > RUNNING) return abortHandshake(socket, 503);
        var digest = createHash('sha1').update(key + GUID).digest('base64');
        var headers = ['HTTP/1.1 101 Switching Protocols', 'Upgrade: websocket', 'Connection: Upgrade', "Sec-WebSocket-Accept: ".concat(digest)];
        var ws = new this.options.WebSocket(null, undefined, this.options);
        if (protocols.size) {
          //
          // Optionally call external protocol selection handler.
          //
          var protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;
          if (protocol) {
            headers.push("Sec-WebSocket-Protocol: ".concat(protocol));
            ws._protocol = protocol;
          }
        }
        if (extensions[PerMessageDeflate.extensionName]) {
          var params = extensions[PerMessageDeflate.extensionName].params;
          var value = extension.format(_defineProperty({}, PerMessageDeflate.extensionName, [params]));
          headers.push("Sec-WebSocket-Extensions: ".concat(value));
          ws._extensions = extensions;
        }

        //
        // Allow external modification/inspection of handshake headers.
        //
        this.emit('headers', headers, req);
        socket.write(headers.concat('\r\n').join('\r\n'));
        socket.removeListener('error', socketOnError);
        ws.setSocket(socket, head, {
          allowSynchronousEvents: this.options.allowSynchronousEvents,
          maxPayload: this.options.maxPayload,
          skipUTF8Validation: this.options.skipUTF8Validation
        });
        if (this.clients) {
          this.clients.add(ws);
          ws.on('close', function () {
            _this4.clients["delete"](ws);
            if (_this4._shouldEmitClose && !_this4.clients.size) {
              process.nextTick(emitClose, _this4);
            }
          });
        }
        cb(ws, req);
      }
    }]);
  }(EventEmitter);
  websocketServer = WebSocketServer;

  /**
   * Add event listeners on an `EventEmitter` using a map of <event, listener>
   * pairs.
   *
   * @param {EventEmitter} server The event emitter
   * @param {Object.<String, Function>} map The listeners to add
   * @return {Function} A function that will remove the added listeners when
   *     called
   * @private
   */
  function addListeners(server, map) {
    for (var _i = 0, _Object$keys = Object.keys(map); _i < _Object$keys.length; _i++) {
      var event = _Object$keys[_i];
      server.on(event, map[event]);
    }
    return function removeListeners() {
      for (var _i2 = 0, _Object$keys2 = Object.keys(map); _i2 < _Object$keys2.length; _i2++) {
        var _event = _Object$keys2[_i2];
        server.removeListener(_event, map[_event]);
      }
    };
  }

  /**
   * Emit a `'close'` event on an `EventEmitter`.
   *
   * @param {EventEmitter} server The event emitter
   * @private
   */
  function emitClose(server) {
    server._state = CLOSED;
    server.emit('close');
  }

  /**
   * Handle socket errors.
   *
   * @private
   */
  function socketOnError() {
    this.destroy();
  }

  /**
   * Close the connection when preconditions are not fulfilled.
   *
   * @param {Duplex} socket The socket of the upgrade request
   * @param {Number} code The HTTP response status code
   * @param {String} [message] The HTTP response body
   * @param {Object} [headers] Additional HTTP response headers
   * @private
   */
  function abortHandshake(socket, code, message, headers) {
    //
    // The socket is writable unless the user destroyed or ended it before calling
    // `server.handleUpgrade()` or in the `verifyClient` function, which is a user
    // error. Handling this does not make much sense as the worst that can happen
    // is that some of the data written by the user might be discarded due to the
    // call to `socket.end()` below, which triggers an `'error'` event that in
    // turn causes the socket to be destroyed.
    //
    message = message || http.STATUS_CODES[code];
    headers = _objectSpread2({
      Connection: 'close',
      'Content-Type': 'text/html',
      'Content-Length': Buffer.byteLength(message)
    }, headers);
    socket.once('finish', socket.destroy);
    socket.end("HTTP/1.1 ".concat(code, " ").concat(http.STATUS_CODES[code], "\r\n") + Object.keys(headers).map(function (h) {
      return "".concat(h, ": ").concat(headers[h]);
    }).join('\r\n') + '\r\n\r\n' + message);
  }

  /**
   * Emit a `'wsClientError'` event on a `WebSocketServer` if there is at least
   * one listener for it, otherwise call `abortHandshake()`.
   *
   * @param {WebSocketServer} server The WebSocket server
   * @param {http.IncomingMessage} req The request object
   * @param {Duplex} socket The socket of the upgrade request
   * @param {Number} code The HTTP response status code
   * @param {String} message The HTTP response body
   * @private
   */
  function abortHandshakeOrEmitwsClientError(server, req, socket, code, message) {
    if (server.listenerCount('wsClientError')) {
      var err = new Error(message);
      Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);
      server.emit('wsClientError', err, socket, req);
    } else {
      abortHandshake(socket, code, message);
    }
  }
  return websocketServer;
}

var ws;
var hasRequiredWs$1;
function requireWs$1() {
  if (hasRequiredWs$1) return ws;
  hasRequiredWs$1 = 1;
  var WebSocket = requireWebsocket();
  WebSocket.createWebSocketStream = requireStream();
  WebSocket.Server = requireWebsocketServer();
  WebSocket.Receiver = requireReceiver();
  WebSocket.Sender = requireSender();
  WebSocket.WebSocket = WebSocket;
  WebSocket.WebSocketServer = WebSocket.Server;
  ws = WebSocket;
  return ws;
}

var hasRequiredWs;
function requireWs() {
  if (hasRequiredWs) return ws$1;
  hasRequiredWs = 1;
  (function (exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.WebSocket = void 0;
    var ws_1 = requireWs$1();
    Object.defineProperty(exports, "WebSocket", {
      enumerable: true,
      get: function get() {
        return ws_1.WebSocket;
      }
    });
  })(ws$1);
  return ws$1;
}

var providerSocket = {};

var hasRequiredProviderSocket;
function requireProviderSocket() {
  if (hasRequiredProviderSocket) return providerSocket;
  hasRequiredProviderSocket = 1;
  /**
   *  Generic long-lived socket provider.
   *
   *  Sub-classing notes
   *  - a sub-class MUST call the `_start()` method once connected
   *  - a sub-class MUST override the `_write(string)` method
   *  - a sub-class MUST call `_processMessage(string)` for each message
   *
   *  @_subsection: api/providers/abstract-provider:Socket Providers  [about-socketProvider]
   */
  Object.defineProperty(providerSocket, "__esModule", {
    value: true
  });
  providerSocket.SocketProvider = providerSocket.SocketEventSubscriber = providerSocket.SocketPendingSubscriber = providerSocket.SocketBlockSubscriber = providerSocket.SocketSubscriber = void 0;
  var abstract_provider_js_1 = /*@__PURE__*/requireAbstractProvider();
  var index_js_1 = /*@__PURE__*/requireUtils$3();
  var provider_jsonrpc_js_1 = /*@__PURE__*/requireProviderJsonrpc();
  /**
   *  A **SocketSubscriber** uses a socket transport to handle events and
   *  should use [[_emit]] to manage the events.
   */
  var _provider = /*#__PURE__*/new WeakMap();
  var _filter = /*#__PURE__*/new WeakMap();
  var _filterId = /*#__PURE__*/new WeakMap();
  var _paused = /*#__PURE__*/new WeakMap();
  var _emitPromise = /*#__PURE__*/new WeakMap();
  var SocketSubscriber = /*#__PURE__*/function () {
    /**
     *  Creates a new **SocketSubscriber** attached to %%provider%% listening
     *  to %%filter%%.
     */
    function SocketSubscriber(provider, filter) {
      _classCallCheck(this, SocketSubscriber);
      _classPrivateFieldInitSpec(this, _provider, void 0);
      _classPrivateFieldInitSpec(this, _filter, void 0);
      _classPrivateFieldInitSpec(this, _filterId, void 0);
      _classPrivateFieldInitSpec(this, _paused, void 0);
      _classPrivateFieldInitSpec(this, _emitPromise, void 0);
      _classPrivateFieldSet2(_provider, this, provider);
      _classPrivateFieldSet2(_filter, this, JSON.stringify(filter));
      _classPrivateFieldSet2(_filterId, this, null);
      _classPrivateFieldSet2(_paused, this, null);
      _classPrivateFieldSet2(_emitPromise, this, null);
    }
    return _createClass(SocketSubscriber, [{
      key: "filter",
      get:
      /**
       *  The filter.
       */
      function get() {
        return JSON.parse(_classPrivateFieldGet2(_filter, this));
      }
    }, {
      key: "start",
      value: function start() {
        var _this = this;
        _classPrivateFieldSet2(_filterId, this, _classPrivateFieldGet2(_provider, this).send("eth_subscribe", this.filter).then(function (filterId) {
          _classPrivateFieldGet2(_provider, _this)._register(filterId, _this);
          return filterId;
        }));
      }
    }, {
      key: "stop",
      value: function stop() {
        var _this2 = this;
        _classPrivateFieldGet2(_filterId, this).then(function (filterId) {
          if (_classPrivateFieldGet2(_provider, _this2).destroyed) {
            return;
          }
          _classPrivateFieldGet2(_provider, _this2).send("eth_unsubscribe", [filterId]);
        });
        _classPrivateFieldSet2(_filterId, this, null);
      }
      // @TODO: pause should trap the current blockNumber, unsub, and on resume use getLogs
      //        and resume
    }, {
      key: "pause",
      value: function pause(dropWhilePaused) {
        (0, index_js_1.assert)(dropWhilePaused, "preserve logs while paused not supported by SocketSubscriber yet", "UNSUPPORTED_OPERATION", {
          operation: "pause(false)"
        });
        _classPrivateFieldSet2(_paused, this, !!dropWhilePaused);
      }
    }, {
      key: "resume",
      value: function resume() {
        _classPrivateFieldSet2(_paused, this, null);
      }
      /**
       *  @_ignore:
       */
    }, {
      key: "_handleMessage",
      value: function _handleMessage(message) {
        var _this3 = this;
        if (_classPrivateFieldGet2(_filterId, this) == null) {
          return;
        }
        if (_classPrivateFieldGet2(_paused, this) === null) {
          var emitPromise = _classPrivateFieldGet2(_emitPromise, this);
          if (emitPromise == null) {
            emitPromise = this._emit(_classPrivateFieldGet2(_provider, this), message);
          } else {
            emitPromise = emitPromise.then(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
              return _regeneratorRuntime().wrap(function _callee$(_context) {
                while (1) switch (_context.prev = _context.next) {
                  case 0:
                    _context.next = 2;
                    return _this3._emit(_classPrivateFieldGet2(_provider, _this3), message);
                  case 2:
                  case "end":
                    return _context.stop();
                }
              }, _callee);
            })));
          }
          _classPrivateFieldSet2(_emitPromise, this, emitPromise.then(function () {
            if (_classPrivateFieldGet2(_emitPromise, _this3) === emitPromise) {
              _classPrivateFieldSet2(_emitPromise, _this3, null);
            }
          }));
        }
      }
      /**
       *  Sub-classes **must** override this to emit the events on the
       *  provider.
       */
    }, {
      key: "_emit",
      value: (function () {
        var _emit2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(provider, message) {
          return _regeneratorRuntime().wrap(function _callee2$(_context2) {
            while (1) switch (_context2.prev = _context2.next) {
              case 0:
                throw new Error("sub-classes must implemente this; _emit");
              case 1:
              case "end":
                return _context2.stop();
            }
          }, _callee2);
        }));
        function _emit(_x, _x2) {
          return _emit2.apply(this, arguments);
        }
        return _emit;
      }())
    }]);
  }();
  providerSocket.SocketSubscriber = SocketSubscriber;
  /**
   *  A **SocketBlockSubscriber** listens for ``newHeads`` events and emits
   *  ``"block"`` events.
   */
  var SocketBlockSubscriber = /*#__PURE__*/function (_SocketSubscriber2) {
    /**
     *  @_ignore:
     */
    function SocketBlockSubscriber(provider) {
      _classCallCheck(this, SocketBlockSubscriber);
      return _callSuper(this, SocketBlockSubscriber, [provider, ["newHeads"]]);
    }
    _inherits(SocketBlockSubscriber, _SocketSubscriber2);
    return _createClass(SocketBlockSubscriber, [{
      key: "_emit",
      value: function () {
        var _emit3 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(provider, message) {
          return _regeneratorRuntime().wrap(function _callee3$(_context3) {
            while (1) switch (_context3.prev = _context3.next) {
              case 0:
                provider.emit("block", parseInt(message.number));
              case 1:
              case "end":
                return _context3.stop();
            }
          }, _callee3);
        }));
        function _emit(_x3, _x4) {
          return _emit3.apply(this, arguments);
        }
        return _emit;
      }()
    }]);
  }(SocketSubscriber);
  providerSocket.SocketBlockSubscriber = SocketBlockSubscriber;
  /**
   *  A **SocketPendingSubscriber** listens for pending transacitons and emits
   *  ``"pending"`` events.
   */
  var SocketPendingSubscriber = /*#__PURE__*/function (_SocketSubscriber3) {
    /**
     *  @_ignore:
     */
    function SocketPendingSubscriber(provider) {
      _classCallCheck(this, SocketPendingSubscriber);
      return _callSuper(this, SocketPendingSubscriber, [provider, ["newPendingTransactions"]]);
    }
    _inherits(SocketPendingSubscriber, _SocketSubscriber3);
    return _createClass(SocketPendingSubscriber, [{
      key: "_emit",
      value: function () {
        var _emit4 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4(provider, message) {
          return _regeneratorRuntime().wrap(function _callee4$(_context4) {
            while (1) switch (_context4.prev = _context4.next) {
              case 0:
                provider.emit("pending", message);
              case 1:
              case "end":
                return _context4.stop();
            }
          }, _callee4);
        }));
        function _emit(_x5, _x6) {
          return _emit4.apply(this, arguments);
        }
        return _emit;
      }()
    }]);
  }(SocketSubscriber);
  providerSocket.SocketPendingSubscriber = SocketPendingSubscriber;
  /**
   *  A **SocketEventSubscriber** listens for event logs.
   */
  var _logFilter = /*#__PURE__*/new WeakMap();
  var SocketEventSubscriber = /*#__PURE__*/function (_SocketSubscriber4) {
    /**
     *  @_ignore:
     */
    function SocketEventSubscriber(provider, filter) {
      var _this4;
      _classCallCheck(this, SocketEventSubscriber);
      _this4 = _callSuper(this, SocketEventSubscriber, [provider, ["logs", filter]]);
      _classPrivateFieldInitSpec(_this4, _logFilter, void 0);
      _classPrivateFieldSet2(_logFilter, _this4, JSON.stringify(filter));
      return _this4;
    }
    _inherits(SocketEventSubscriber, _SocketSubscriber4);
    return _createClass(SocketEventSubscriber, [{
      key: "logFilter",
      get:
      /**
       *  The filter.
       */
      function get() {
        return JSON.parse(_classPrivateFieldGet2(_logFilter, this));
      }
    }, {
      key: "_emit",
      value: function () {
        var _emit5 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee5(provider, message) {
          return _regeneratorRuntime().wrap(function _callee5$(_context5) {
            while (1) switch (_context5.prev = _context5.next) {
              case 0:
                provider.emit(this.logFilter, provider._wrapLog(message, provider._network));
              case 1:
              case "end":
                return _context5.stop();
            }
          }, _callee5, this);
        }));
        function _emit(_x7, _x8) {
          return _emit5.apply(this, arguments);
        }
        return _emit;
      }()
    }]);
  }(SocketSubscriber);
  providerSocket.SocketEventSubscriber = SocketEventSubscriber;
  /**
   *  A **SocketProvider** is backed by a long-lived connection over a
   *  socket, which can subscribe and receive real-time messages over
   *  its communication channel.
   */
  var _callbacks = /*#__PURE__*/new WeakMap();
  var _subs = /*#__PURE__*/new WeakMap();
  var _pending = /*#__PURE__*/new WeakMap();
  var SocketProvider = /*#__PURE__*/function (_provider_jsonrpc_js_) {
    /**
     *  Creates a new **SocketProvider** connected to %%network%%.
     *
     *  If unspecified, the network will be discovered.
     */
    function SocketProvider(network, _options) {
      var _this5;
      _classCallCheck(this, SocketProvider);
      // Copy the options
      var options = Object.assign({}, _options != null ? _options : {});
      // Support for batches is generally not supported for
      // connection-base providers; if this changes in the future
      // the _send should be updated to reflect this
      (0, index_js_1.assertArgument)(options.batchMaxCount == null || options.batchMaxCount === 1, "sockets-based providers do not support batches", "options.batchMaxCount", _options);
      options.batchMaxCount = 1;
      // Socket-based Providers (generally) cannot change their network,
      // since they have a long-lived connection; but let people override
      // this if they have just cause.
      if (options.staticNetwork == null) {
        options.staticNetwork = true;
      }
      _this5 = _callSuper(this, SocketProvider, [network, options]);
      _classPrivateFieldInitSpec(_this5, _callbacks, void 0);
      // Maps each filterId to its subscriber
      _classPrivateFieldInitSpec(_this5, _subs, void 0);
      // If any events come in before a subscriber has finished
      // registering, queue them
      _classPrivateFieldInitSpec(_this5, _pending, void 0);
      _classPrivateFieldSet2(_callbacks, _this5, new Map());
      _classPrivateFieldSet2(_subs, _this5, new Map());
      _classPrivateFieldSet2(_pending, _this5, new Map());
      return _this5;
    }
    // This value is only valid after _start has been called
    /*
    get _network(): Network {
        if (this.#network == null) {
            throw new Error("this shouldn't happen");
        }
        return this.#network.clone();
    }
    */
    _inherits(SocketProvider, _provider_jsonrpc_js_);
    return _createClass(SocketProvider, [{
      key: "_getSubscriber",
      value: function _getSubscriber(sub) {
        switch (sub.type) {
          case "close":
            return new abstract_provider_js_1.UnmanagedSubscriber("close");
          case "block":
            return new SocketBlockSubscriber(this);
          case "pending":
            return new SocketPendingSubscriber(this);
          case "event":
            return new SocketEventSubscriber(this, sub.filter);
          case "orphan":
            // Handled auto-matically within AbstractProvider
            // when the log.removed = true
            if (sub.filter.orphan === "drop-log") {
              return new abstract_provider_js_1.UnmanagedSubscriber("drop-log");
            }
        }
        return _superPropGet(SocketProvider, "_getSubscriber", this, 3)([sub]);
      }
      /**
       *  Register a new subscriber. This is used internalled by Subscribers
       *  and generally is unecessary unless extending capabilities.
       */
    }, {
      key: "_register",
      value: function _register(filterId, subscriber) {
        _classPrivateFieldGet2(_subs, this).set(filterId, subscriber);
        var pending = _classPrivateFieldGet2(_pending, this).get(filterId);
        if (pending) {
          var _iterator = _createForOfIteratorHelper(pending),
            _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var message = _step.value;
              subscriber._handleMessage(message);
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
          _classPrivateFieldGet2(_pending, this)["delete"](filterId);
        }
      }
    }, {
      key: "_send",
      value: function () {
        var _send2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee6(payload) {
          var _this6 = this;
          var promise;
          return _regeneratorRuntime().wrap(function _callee6$(_context6) {
            while (1) switch (_context6.prev = _context6.next) {
              case 0:
                // WebSocket provider doesn't accept batches
                (0, index_js_1.assertArgument)(!Array.isArray(payload), "WebSocket does not support batch send", "payload", payload);
                // @TODO: stringify payloads here and store to prevent mutations
                // Prepare a promise to respond to
                promise = new Promise(function (resolve, reject) {
                  _classPrivateFieldGet2(_callbacks, _this6).set(payload.id, {
                    payload: payload,
                    resolve: resolve,
                    reject: reject
                  });
                }); // Wait until the socket is connected before writing to it
                _context6.next = 4;
                return this._waitUntilReady();
              case 4:
                _context6.next = 6;
                return this._write(JSON.stringify(payload));
              case 6:
                _context6.next = 8;
                return promise;
              case 8:
                _context6.t0 = _context6.sent;
                return _context6.abrupt("return", [_context6.t0]);
              case 10:
              case "end":
                return _context6.stop();
            }
          }, _callee6, this);
        }));
        function _send(_x9) {
          return _send2.apply(this, arguments);
        }
        return _send;
      }() // Sub-classes must call this once they are connected
      /*
      async _start(): Promise<void> {
          if (this.#ready) { return; }
           for (const { payload } of this.#callbacks.values()) {
              await this._write(JSON.stringify(payload));
          }
           this.#ready = (async function() {
              await super._start();
          })();
      }
      */
      /**
       *  Sub-classes **must** call this with messages received over their
       *  transport to be processed and dispatched.
       */
    }, {
      key: "_processMessage",
      value: function () {
        var _processMessage2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee7(message) {
          var result, callback, filterId, subscriber, pending;
          return _regeneratorRuntime().wrap(function _callee7$(_context7) {
            while (1) switch (_context7.prev = _context7.next) {
              case 0:
                result = JSON.parse(message);
                if (!(result && _typeof(result) === "object" && "id" in result)) {
                  _context7.next = 10;
                  break;
                }
                callback = _classPrivateFieldGet2(_callbacks, this).get(result.id);
                if (!(callback == null)) {
                  _context7.next = 6;
                  break;
                }
                this.emit("error", (0, index_js_1.makeError)("received result for unknown id", "UNKNOWN_ERROR", {
                  reasonCode: "UNKNOWN_ID",
                  result: result
                }));
                return _context7.abrupt("return");
              case 6:
                _classPrivateFieldGet2(_callbacks, this)["delete"](result.id);
                callback.resolve(result);
                _context7.next = 18;
                break;
              case 10:
                if (!(result && result.method === "eth_subscription")) {
                  _context7.next = 16;
                  break;
                }
                filterId = result.params.subscription;
                subscriber = _classPrivateFieldGet2(_subs, this).get(filterId);
                if (subscriber) {
                  subscriber._handleMessage(result.params.result);
                } else {
                  pending = _classPrivateFieldGet2(_pending, this).get(filterId);
                  if (pending == null) {
                    pending = [];
                    _classPrivateFieldGet2(_pending, this).set(filterId, pending);
                  }
                  pending.push(result.params.result);
                }
                _context7.next = 18;
                break;
              case 16:
                this.emit("error", (0, index_js_1.makeError)("received unexpected message", "UNKNOWN_ERROR", {
                  reasonCode: "UNEXPECTED_MESSAGE",
                  result: result
                }));
                return _context7.abrupt("return");
              case 18:
              case "end":
                return _context7.stop();
            }
          }, _callee7, this);
        }));
        function _processMessage(_x10) {
          return _processMessage2.apply(this, arguments);
        }
        return _processMessage;
      }()
      /**
       *  Sub-classes **must** override this to send %%message%% over their
       *  transport.
       */
    }, {
      key: "_write",
      value: (function () {
        var _write2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee8(message) {
          return _regeneratorRuntime().wrap(function _callee8$(_context8) {
            while (1) switch (_context8.prev = _context8.next) {
              case 0:
                throw new Error("sub-classes must override this");
              case 1:
              case "end":
                return _context8.stop();
            }
          }, _callee8);
        }));
        function _write(_x11) {
          return _write2.apply(this, arguments);
        }
        return _write;
      }())
    }]);
  }(provider_jsonrpc_js_1.JsonRpcApiProvider);
  providerSocket.SocketProvider = SocketProvider;
  return providerSocket;
}

var hasRequiredProviderWebsocket;
function requireProviderWebsocket() {
  if (hasRequiredProviderWebsocket) return providerWebsocket;
  hasRequiredProviderWebsocket = 1;
  Object.defineProperty(providerWebsocket, "__esModule", {
    value: true
  });
  providerWebsocket.WebSocketProvider = void 0;
  var ws_js_1 = /*@__PURE__*/requireWs(); /*-browser*/
  var provider_socket_js_1 = /*@__PURE__*/requireProviderSocket();
  /**
   *  A JSON-RPC provider which is backed by a WebSocket.
   *
   *  WebSockets are often preferred because they retain a live connection
   *  to a server, which permits more instant access to events.
   *
   *  However, this incurs higher server infrasturture costs, so additional
   *  resources may be required to host your own WebSocket nodes and many
   *  third-party services charge additional fees for WebSocket endpoints.
   */
  var _connect = /*#__PURE__*/new WeakMap();
  var _websocket = /*#__PURE__*/new WeakMap();
  var WebSocketProvider = /*#__PURE__*/function (_provider_socket_js_) {
    function WebSocketProvider(url, network, options) {
      var _this;
      _classCallCheck(this, WebSocketProvider);
      _this = _callSuper(this, WebSocketProvider, [network, options]);
      _classPrivateFieldInitSpec(_this, _connect, void 0);
      _classPrivateFieldInitSpec(_this, _websocket, void 0);
      if (typeof url === "string") {
        _classPrivateFieldSet2(_connect, _this, function () {
          return new ws_js_1.WebSocket(url);
        });
        _classPrivateFieldSet2(_websocket, _this, _classPrivateFieldGet2(_connect, _this).call(_this));
      } else if (typeof url === "function") {
        _classPrivateFieldSet2(_connect, _this, url);
        _classPrivateFieldSet2(_websocket, _this, url());
      } else {
        _classPrivateFieldSet2(_connect, _this, null);
        _classPrivateFieldSet2(_websocket, _this, url);
      }
      _this.websocket.onopen = /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              _context.next = 3;
              return _this._start();
            case 3:
              _this.resume();
              _context.next = 9;
              break;
            case 6:
              _context.prev = 6;
              _context.t0 = _context["catch"](0);
              console.log("failed to start WebsocketProvider", _context.t0);
              // @TODO: now what? Attempt reconnect?
            case 9:
            case "end":
              return _context.stop();
          }
        }, _callee, null, [[0, 6]]);
      }));
      _this.websocket.onmessage = function (message) {
        _this._processMessage(message.data);
      };
      /*
              this.websocket.onclose = (event) => {
                  // @TODO: What event.code should we reconnect on?
                  const reconnect = false;
                  if (reconnect) {
                      this.pause(true);
                      if (this.#connect) {
                          this.#websocket = this.#connect();
                          this.#websocket.onopen = ...
                          // @TODO: this requires the super class to rebroadcast; move it there
                      }
                      this._reconnect();
                  }
              };
      */
      return _this;
    }
    _inherits(WebSocketProvider, _provider_socket_js_);
    return _createClass(WebSocketProvider, [{
      key: "websocket",
      get: function get() {
        if (_classPrivateFieldGet2(_websocket, this) == null) {
          throw new Error("websocket closed");
        }
        return _classPrivateFieldGet2(_websocket, this);
      }
    }, {
      key: "_write",
      value: function () {
        var _write2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(message) {
          return _regeneratorRuntime().wrap(function _callee2$(_context2) {
            while (1) switch (_context2.prev = _context2.next) {
              case 0:
                this.websocket.send(message);
              case 1:
              case "end":
                return _context2.stop();
            }
          }, _callee2, this);
        }));
        function _write(_x) {
          return _write2.apply(this, arguments);
        }
        return _write;
      }()
    }, {
      key: "destroy",
      value: function () {
        var _destroy = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
          return _regeneratorRuntime().wrap(function _callee3$(_context3) {
            while (1) switch (_context3.prev = _context3.next) {
              case 0:
                if (_classPrivateFieldGet2(_websocket, this) != null) {
                  _classPrivateFieldGet2(_websocket, this).close();
                  _classPrivateFieldSet2(_websocket, this, null);
                }
                _superPropGet(WebSocketProvider, "destroy", this, 3)([]);
              case 2:
              case "end":
                return _context3.stop();
            }
          }, _callee3, this);
        }));
        function destroy() {
          return _destroy.apply(this, arguments);
        }
        return destroy;
      }()
    }]);
  }(provider_socket_js_1.SocketProvider);
  providerWebsocket.WebSocketProvider = WebSocketProvider;
  return providerWebsocket;
}

var hasRequiredProviderInfura;
function requireProviderInfura() {
  if (hasRequiredProviderInfura) return providerInfura;
  hasRequiredProviderInfura = 1;
  Object.defineProperty(providerInfura, "__esModule", {
    value: true
  });
  providerInfura.InfuraProvider = providerInfura.InfuraWebSocketProvider = void 0;
  /**
   *  [[link-infura]] provides a third-party service for connecting to
   *  various blockchains over JSON-RPC.
   *
   *  **Supported Networks**
   *
   *  - Ethereum Mainnet (``mainnet``)
   *  - Goerli Testnet (``goerli``)
   *  - Sepolia Testnet (``sepolia``)
   *  - Arbitrum (``arbitrum``)
   *  - Arbitrum Goerli Testnet (``arbitrum-goerli``)
   *  - Arbitrum Sepolia Testnet (``arbitrum-sepolia``)
   *  - Base (``base``)
   *  - Base Goerlia Testnet (``base-goerli``)
   *  - Base Sepolia Testnet (``base-sepolia``)
   *  - BNB Smart Chain Mainnet (``bnb``)
   *  - BNB Smart Chain Testnet (``bnbt``)
   *  - Linea (``linea``)
   *  - Linea Goerli Testnet (``linea-goerli``)
   *  - Linea Sepolia Testnet (``linea-sepolia``)
   *  - Optimism (``optimism``)
   *  - Optimism Goerli Testnet (``optimism-goerli``)
   *  - Optimism Sepolia Testnet (``optimism-sepolia``)
   *  - Polygon (``matic``)
   *  - Polygon Amoy Testnet (``matic-amoy``)
   *  - Polygon Mumbai Testnet (``matic-mumbai``)
   *
   *  @_subsection: api/providers/thirdparty:INFURA  [providers-infura]
   */
  var index_js_1 = /*@__PURE__*/requireUtils$3();
  var community_js_1 = /*@__PURE__*/requireCommunity();
  var network_js_1 = /*@__PURE__*/requireNetwork();
  var provider_jsonrpc_js_1 = /*@__PURE__*/requireProviderJsonrpc();
  var provider_websocket_js_1 = /*@__PURE__*/requireProviderWebsocket();
  var defaultProjectId = "84842078b09946638c03157f83405213";
  function getHost(name) {
    switch (name) {
      case "mainnet":
        return "mainnet.infura.io";
      case "goerli":
        return "goerli.infura.io";
      case "sepolia":
        return "sepolia.infura.io";
      case "arbitrum":
        return "arbitrum-mainnet.infura.io";
      case "arbitrum-goerli":
        return "arbitrum-goerli.infura.io";
      case "arbitrum-sepolia":
        return "arbitrum-sepolia.infura.io";
      case "base":
        return "base-mainnet.infura.io";
      case "base-goerlia":
        return "base-goerli.infura.io";
      case "base-sepolia":
        return "base-sepolia.infura.io";
      case "bnb":
        return "bnbsmartchain-mainnet.infura.io";
      case "bnbt":
        return "bnbsmartchain-testnet.infura.io";
      case "linea":
        return "linea-mainnet.infura.io";
      case "linea-goerli":
        return "linea-goerli.infura.io";
      case "linea-sepolia":
        return "linea-sepolia.infura.io";
      case "matic":
        return "polygon-mainnet.infura.io";
      case "matic-amoy":
        return "polygon-amoy.infura.io";
      case "matic-mumbai":
        return "polygon-mumbai.infura.io";
      case "optimism":
        return "optimism-mainnet.infura.io";
      case "optimism-goerli":
        return "optimism-goerli.infura.io";
      case "optimism-sepolia":
        return "optimism-sepolia.infura.io";
    }
    (0, index_js_1.assertArgument)(false, "unsupported network", "network", name);
  }
  /**
   *  The **InfuraWebSocketProvider** connects to the [[link-infura]]
   *  WebSocket end-points.
   *
   *  By default, a highly-throttled API key is used, which is
   *  appropriate for quick prototypes and simple scripts. To
   *  gain access to an increased rate-limit, it is highly
   *  recommended to [sign up here](link-infura-signup).
   */
  var InfuraWebSocketProvider = /*#__PURE__*/function (_provider_websocket_j) {
    /**
     *  Creates a new **InfuraWebSocketProvider**.
     */
    function InfuraWebSocketProvider(network, projectId) {
      var _this;
      _classCallCheck(this, InfuraWebSocketProvider);
      var provider = new InfuraProvider(network, projectId);
      var req = provider._getConnection();
      (0, index_js_1.assert)(!req.credentials, "INFURA WebSocket project secrets unsupported", "UNSUPPORTED_OPERATION", {
        operation: "InfuraProvider.getWebSocketProvider()"
      });
      var url = req.url.replace(/^http/i, "ws").replace("/v3/", "/ws/v3/");
      _this = _callSuper(this, InfuraWebSocketProvider, [url, provider._network]);
      /**
       *  The Project ID for the INFURA connection.
       */
      _defineProperty(_this, "projectId", void 0);
      /**
       *  The Project Secret.
       *
       *  If null, no authenticated requests are made. This should not
       *  be used outside of private contexts.
       */
      _defineProperty(_this, "projectSecret", void 0);
      (0, index_js_1.defineProperties)(_this, {
        projectId: provider.projectId,
        projectSecret: provider.projectSecret
      });
      return _this;
    }
    _inherits(InfuraWebSocketProvider, _provider_websocket_j);
    return _createClass(InfuraWebSocketProvider, [{
      key: "isCommunityResource",
      value: function isCommunityResource() {
        return this.projectId === defaultProjectId;
      }
    }]);
  }(provider_websocket_js_1.WebSocketProvider);
  providerInfura.InfuraWebSocketProvider = InfuraWebSocketProvider;
  /**
   *  The **InfuraProvider** connects to the [[link-infura]]
   *  JSON-RPC end-points.
   *
   *  By default, a highly-throttled API key is used, which is
   *  appropriate for quick prototypes and simple scripts. To
   *  gain access to an increased rate-limit, it is highly
   *  recommended to [sign up here](link-infura-signup).
   */
  var InfuraProvider = /*#__PURE__*/function (_provider_jsonrpc_js_) {
    /**
     *  Creates a new **InfuraProvider**.
     */
    function InfuraProvider(_network, projectId, projectSecret) {
      var _this2;
      _classCallCheck(this, InfuraProvider);
      if (_network == null) {
        _network = "mainnet";
      }
      var network = network_js_1.Network.from(_network);
      if (projectId == null) {
        projectId = defaultProjectId;
      }
      if (projectSecret == null) {
        projectSecret = null;
      }
      var request = InfuraProvider.getRequest(network, projectId, projectSecret);
      _this2 = _callSuper(this, InfuraProvider, [request, network, {
        staticNetwork: network
      }]);
      /**
       *  The Project ID for the INFURA connection.
       */
      _defineProperty(_this2, "projectId", void 0);
      /**
       *  The Project Secret.
       *
       *  If null, no authenticated requests are made. This should not
       *  be used outside of private contexts.
       */
      _defineProperty(_this2, "projectSecret", void 0);
      (0, index_js_1.defineProperties)(_this2, {
        projectId: projectId,
        projectSecret: projectSecret
      });
      return _this2;
    }
    _inherits(InfuraProvider, _provider_jsonrpc_js_);
    return _createClass(InfuraProvider, [{
      key: "_getProvider",
      value: function _getProvider(chainId) {
        try {
          return new InfuraProvider(chainId, this.projectId, this.projectSecret);
        } catch (error) {}
        return _superPropGet(InfuraProvider, "_getProvider", this, 3)([chainId]);
      }
    }, {
      key: "isCommunityResource",
      value: function isCommunityResource() {
        return this.projectId === defaultProjectId;
      }
      /**
       *  Creates a new **InfuraWebSocketProvider**.
       */
    }], [{
      key: "getWebSocketProvider",
      value: function getWebSocketProvider(network, projectId) {
        return new InfuraWebSocketProvider(network, projectId);
      }
      /**
       *  Returns a prepared request for connecting to %%network%%
       *  with %%projectId%% and %%projectSecret%%.
       */
    }, {
      key: "getRequest",
      value: function getRequest(network, projectId, projectSecret) {
        if (projectId == null) {
          projectId = defaultProjectId;
        }
        if (projectSecret == null) {
          projectSecret = null;
        }
        var request = new index_js_1.FetchRequest("https://".concat(getHost(network.name), "/v3/").concat(projectId));
        request.allowGzip = true;
        if (projectSecret) {
          request.setCredentials("", projectSecret);
        }
        if (projectId === defaultProjectId) {
          request.retryFunc = /*#__PURE__*/function () {
            var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(request, response, attempt) {
              return _regeneratorRuntime().wrap(function _callee$(_context) {
                while (1) switch (_context.prev = _context.next) {
                  case 0:
                    (0, community_js_1.showThrottleMessage)("InfuraProvider");
                    return _context.abrupt("return", true);
                  case 2:
                  case "end":
                    return _context.stop();
                }
              }, _callee);
            }));
            return function (_x, _x2, _x3) {
              return _ref.apply(this, arguments);
            };
          }();
        }
        return request;
      }
    }]);
  }(provider_jsonrpc_js_1.JsonRpcProvider);
  providerInfura.InfuraProvider = InfuraProvider;
  return providerInfura;
}

var providerQuicknode = {};

var hasRequiredProviderQuicknode;
function requireProviderQuicknode() {
  if (hasRequiredProviderQuicknode) return providerQuicknode;
  hasRequiredProviderQuicknode = 1;
  /**
   *  [[link-quicknode]] provides a third-party service for connecting to
   *  various blockchains over JSON-RPC.
   *
   *  **Supported Networks**
   *
   *  - Ethereum Mainnet (``mainnet``)
   *  - Goerli Testnet (``goerli``)
   *  - Sepolia Testnet (``sepolia``)
   *  - Holesky Testnet (``holesky``)
   *  - Arbitrum (``arbitrum``)
   *  - Arbitrum Goerli Testnet (``arbitrum-goerli``)
   *  - Arbitrum Sepolia Testnet (``arbitrum-sepolia``)
   *  - Base Mainnet (``base``);
   *  - Base Goerli Testnet (``base-goerli``);
   *  - Base Sepolia Testnet (``base-sepolia``);
   *  - BNB Smart Chain Mainnet (``bnb``)
   *  - BNB Smart Chain Testnet (``bnbt``)
   *  - Optimism (``optimism``)
   *  - Optimism Goerli Testnet (``optimism-goerli``)
   *  - Optimism Sepolia Testnet (``optimism-sepolia``)
   *  - Polygon (``matic``)
   *  - Polygon Mumbai Testnet (``matic-mumbai``)
   *
   *  @_subsection: api/providers/thirdparty:QuickNode  [providers-quicknode]
   */
  Object.defineProperty(providerQuicknode, "__esModule", {
    value: true
  });
  providerQuicknode.QuickNodeProvider = void 0;
  var index_js_1 = /*@__PURE__*/requireUtils$3();
  var community_js_1 = /*@__PURE__*/requireCommunity();
  var network_js_1 = /*@__PURE__*/requireNetwork();
  var provider_jsonrpc_js_1 = /*@__PURE__*/requireProviderJsonrpc();
  var defaultToken = "919b412a057b5e9c9b6dce193c5a60242d6efadb";
  function getHost(name) {
    switch (name) {
      case "mainnet":
        return "ethers.quiknode.pro";
      case "goerli":
        return "ethers.ethereum-goerli.quiknode.pro";
      case "sepolia":
        return "ethers.ethereum-sepolia.quiknode.pro";
      case "holesky":
        return "ethers.ethereum-holesky.quiknode.pro";
      case "arbitrum":
        return "ethers.arbitrum-mainnet.quiknode.pro";
      case "arbitrum-goerli":
        return "ethers.arbitrum-goerli.quiknode.pro";
      case "arbitrum-sepolia":
        return "ethers.arbitrum-sepolia.quiknode.pro";
      case "base":
        return "ethers.base-mainnet.quiknode.pro";
      case "base-goerli":
        return "ethers.base-goerli.quiknode.pro";
      case "base-spolia":
        return "ethers.base-sepolia.quiknode.pro";
      case "bnb":
        return "ethers.bsc.quiknode.pro";
      case "bnbt":
        return "ethers.bsc-testnet.quiknode.pro";
      case "matic":
        return "ethers.matic.quiknode.pro";
      case "matic-mumbai":
        return "ethers.matic-testnet.quiknode.pro";
      case "optimism":
        return "ethers.optimism.quiknode.pro";
      case "optimism-goerli":
        return "ethers.optimism-goerli.quiknode.pro";
      case "optimism-sepolia":
        return "ethers.optimism-sepolia.quiknode.pro";
      case "xdai":
        return "ethers.xdai.quiknode.pro";
    }
    (0, index_js_1.assertArgument)(false, "unsupported network", "network", name);
  }
  /*
  @TODO:
    These networks are not currently present in the Network
    default included networks. Research them and ensure they
    are EVM compatible and work with ethers
  	  http://ethers.matic-amoy.quiknode.pro
  	  http://ethers.avalanche-mainnet.quiknode.pro
    http://ethers.avalanche-testnet.quiknode.pro
    http://ethers.blast-sepolia.quiknode.pro
    http://ethers.celo-mainnet.quiknode.pro
    http://ethers.fantom.quiknode.pro
    http://ethers.imx-demo.quiknode.pro
    http://ethers.imx-mainnet.quiknode.pro
    http://ethers.imx-testnet.quiknode.pro
    http://ethers.near-mainnet.quiknode.pro
    http://ethers.near-testnet.quiknode.pro
    http://ethers.nova-mainnet.quiknode.pro
    http://ethers.scroll-mainnet.quiknode.pro
    http://ethers.scroll-testnet.quiknode.pro
    http://ethers.tron-mainnet.quiknode.pro
    http://ethers.zkevm-mainnet.quiknode.pro
    http://ethers.zkevm-testnet.quiknode.pro
    http://ethers.zksync-mainnet.quiknode.pro
    http://ethers.zksync-testnet.quiknode.pro
  */
  /**
   *  The **QuickNodeProvider** connects to the [[link-quicknode]]
   *  JSON-RPC end-points.
   *
   *  By default, a highly-throttled API token is used, which is
   *  appropriate for quick prototypes and simple scripts. To
   *  gain access to an increased rate-limit, it is highly
   *  recommended to [sign up here](link-quicknode).
   */
  var QuickNodeProvider = /*#__PURE__*/function (_provider_jsonrpc_js_) {
    /**
     *  Creates a new **QuickNodeProvider**.
     */
    function QuickNodeProvider(_network, token) {
      var _this;
      _classCallCheck(this, QuickNodeProvider);
      if (_network == null) {
        _network = "mainnet";
      }
      var network = network_js_1.Network.from(_network);
      if (token == null) {
        token = defaultToken;
      }
      var request = QuickNodeProvider.getRequest(network, token);
      _this = _callSuper(this, QuickNodeProvider, [request, network, {
        staticNetwork: network
      }]);
      /**
       *  The API token.
       */
      _defineProperty(_this, "token", void 0);
      (0, index_js_1.defineProperties)(_this, {
        token: token
      });
      return _this;
    }
    _inherits(QuickNodeProvider, _provider_jsonrpc_js_);
    return _createClass(QuickNodeProvider, [{
      key: "_getProvider",
      value: function _getProvider(chainId) {
        try {
          return new QuickNodeProvider(chainId, this.token);
        } catch (error) {}
        return _superPropGet(QuickNodeProvider, "_getProvider", this, 3)([chainId]);
      }
    }, {
      key: "isCommunityResource",
      value: function isCommunityResource() {
        return this.token === defaultToken;
      }
      /**
       *  Returns a new request prepared for %%network%% and the
       *  %%token%%.
       */
    }], [{
      key: "getRequest",
      value: function getRequest(network, token) {
        if (token == null) {
          token = defaultToken;
        }
        var request = new index_js_1.FetchRequest("https://".concat(getHost(network.name), "/").concat(token));
        request.allowGzip = true;
        //if (projectSecret) { request.setCredentials("", projectSecret); }
        if (token === defaultToken) {
          request.retryFunc = /*#__PURE__*/function () {
            var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(request, response, attempt) {
              return _regeneratorRuntime().wrap(function _callee$(_context) {
                while (1) switch (_context.prev = _context.next) {
                  case 0:
                    (0, community_js_1.showThrottleMessage)("QuickNodeProvider");
                    return _context.abrupt("return", true);
                  case 2:
                  case "end":
                    return _context.stop();
                }
              }, _callee);
            }));
            return function (_x, _x2, _x3) {
              return _ref.apply(this, arguments);
            };
          }();
        }
        return request;
      }
    }]);
  }(provider_jsonrpc_js_1.JsonRpcProvider);
  providerQuicknode.QuickNodeProvider = QuickNodeProvider;
  return providerQuicknode;
}

var providerFallback = {};

var hasRequiredProviderFallback;
function requireProviderFallback() {
  if (hasRequiredProviderFallback) return providerFallback;
  hasRequiredProviderFallback = 1;
  Object.defineProperty(providerFallback, "__esModule", {
    value: true
  });
  providerFallback.FallbackProvider = void 0;
  /**
   *  A **FallbackProvider** provides resilience, security and performance
   *  in a way that is customizable and configurable.
   *
   *  @_section: api/providers/fallback-provider:Fallback Provider [about-fallback-provider]
   */
  var index_js_1 = /*@__PURE__*/requireUtils$3();
  var abstract_provider_js_1 = /*@__PURE__*/requireAbstractProvider();
  var network_js_1 = /*@__PURE__*/requireNetwork();
  var BN_1 = BigInt("1");
  var BN_2 = BigInt("2");
  function shuffle(array) {
    for (var i = array.length - 1; i > 0; i--) {
      var j = Math.floor(Math.random() * (i + 1));
      var tmp = array[i];
      array[i] = array[j];
      array[j] = tmp;
    }
  }
  function stall(duration) {
    return new Promise(function (resolve) {
      setTimeout(resolve, duration);
    });
  }
  function getTime() {
    return new Date().getTime();
  }
  function stringify(value) {
    return JSON.stringify(value, function (key, value) {
      if (typeof value === "bigint") {
        return {
          type: "bigint",
          value: value.toString()
        };
      }
      return value;
    });
  }
  var defaultConfig = {
    stallTimeout: 400,
    priority: 1,
    weight: 1
  };
  var defaultState = {
    blockNumber: -2,
    requests: 0,
    lateResponses: 0,
    errorResponses: 0,
    outOfSync: -1,
    unsupportedEvents: 0,
    rollingDuration: 0,
    score: 0,
    _network: null,
    _updateNumber: null,
    _totalTime: 0,
    _lastFatalError: null,
    _lastFatalErrorTimestamp: 0
  };
  function waitForSync(_x, _x2) {
    return _waitForSync.apply(this, arguments);
  }
  function _waitForSync() {
    _waitForSync = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee7(config, blockNumber) {
      return _regeneratorRuntime().wrap(function _callee7$(_context7) {
        while (1) switch (_context7.prev = _context7.next) {
          case 0:
            if (!(config.blockNumber < 0 || config.blockNumber < blockNumber)) {
              _context7.next = 9;
              break;
            }
            if (!config._updateNumber) {
              config._updateNumber = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
                var _blockNumber;
                return _regeneratorRuntime().wrap(function _callee6$(_context6) {
                  while (1) switch (_context6.prev = _context6.next) {
                    case 0:
                      _context6.prev = 0;
                      _context6.next = 3;
                      return config.provider.getBlockNumber();
                    case 3:
                      _blockNumber = _context6.sent;
                      if (_blockNumber > config.blockNumber) {
                        config.blockNumber = _blockNumber;
                      }
                      _context6.next = 12;
                      break;
                    case 7:
                      _context6.prev = 7;
                      _context6.t0 = _context6["catch"](0);
                      config.blockNumber = -2;
                      config._lastFatalError = _context6.t0;
                      config._lastFatalErrorTimestamp = getTime();
                    case 12:
                      config._updateNumber = null;
                    case 13:
                    case "end":
                      return _context6.stop();
                  }
                }, _callee6, null, [[0, 7]]);
              }))();
            }
            _context7.next = 4;
            return config._updateNumber;
          case 4:
            config.outOfSync++;
            if (!config._lastFatalError) {
              _context7.next = 7;
              break;
            }
            return _context7.abrupt("break", 9);
          case 7:
            _context7.next = 0;
            break;
          case 9:
          case "end":
            return _context7.stop();
        }
      }, _callee7);
    }));
    return _waitForSync.apply(this, arguments);
  }
  function _normalize(value) {
    if (value == null) {
      return "null";
    }
    if (Array.isArray(value)) {
      return "[" + value.map(_normalize).join(",") + "]";
    }
    if (_typeof(value) === "object" && typeof value.toJSON === "function") {
      return _normalize(value.toJSON());
    }
    switch (_typeof(value)) {
      case "boolean":
      case "symbol":
        return value.toString();
      case "bigint":
      case "number":
        return BigInt(value).toString();
      case "string":
        return JSON.stringify(value);
      case "object":
        {
          var keys = Object.keys(value);
          keys.sort();
          return "{" + keys.map(function (k) {
            return "".concat(JSON.stringify(k), ":").concat(_normalize(value[k]));
          }).join(",") + "}";
        }
    }
    console.log("Could not serialize", value);
    throw new Error("Hmm...");
  }
  function normalizeResult(value) {
    if ("error" in value) {
      var error = value.error;
      return {
        tag: _normalize(error),
        value: error
      };
    }
    var result = value.result;
    return {
      tag: _normalize(result),
      value: result
    };
  }
  // This strategy picks the highest weight result, as long as the weight is
  // equal to or greater than quorum
  function checkQuorum(quorum, results) {
    var tally = new Map();
    var _iterator = _createForOfIteratorHelper(results),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _step$value = _step.value,
          value = _step$value.value,
          tag = _step$value.tag,
          weight = _step$value.weight;
        var t = tally.get(tag) || {
          value: value,
          weight: 0
        };
        t.weight += weight;
        tally.set(tag, t);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    var best = null;
    var _iterator2 = _createForOfIteratorHelper(tally.values()),
      _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var r = _step2.value;
        if (r.weight >= quorum && (!best || r.weight > best.weight)) {
          best = r;
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
    if (best) {
      return best.value;
    }
    return undefined;
  }
  function getMedian(quorum, results) {
    var resultWeight = 0;
    var errorMap = new Map();
    var bestError = null;
    var values = [];
    var _iterator3 = _createForOfIteratorHelper(results),
      _step3;
    try {
      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
        var _step3$value = _step3.value,
          value = _step3$value.value,
          tag = _step3$value.tag,
          weight = _step3$value.weight;
        if (value instanceof Error) {
          var e = errorMap.get(tag) || {
            value: value,
            weight: 0
          };
          e.weight += weight;
          errorMap.set(tag, e);
          if (bestError == null || e.weight > bestError.weight) {
            bestError = e;
          }
        } else {
          values.push(BigInt(value));
          resultWeight += weight;
        }
      }
    } catch (err) {
      _iterator3.e(err);
    } finally {
      _iterator3.f();
    }
    if (resultWeight < quorum) {
      // We have quorum for an error
      if (bestError && bestError.weight >= quorum) {
        return bestError.value;
      }
      // We do not have quorum for a result
      return undefined;
    }
    // Get the sorted values
    values.sort(function (a, b) {
      return a < b ? -1 : b > a ? 1 : 0;
    });
    var mid = Math.floor(values.length / 2);
    // Odd-length; take the middle value
    if (values.length % 2) {
      return values[mid];
    }
    // Even length; take the ceiling of the mean of the center two values
    return (values[mid - 1] + values[mid] + BN_1) / BN_2;
  }
  function getAnyResult(quorum, results) {
    // If any value or error meets quorum, that is our preferred result
    var result = checkQuorum(quorum, results);
    if (result !== undefined) {
      return result;
    }
    // Otherwise, do we have any result?
    var _iterator4 = _createForOfIteratorHelper(results),
      _step4;
    try {
      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
        var r = _step4.value;
        if (r.value) {
          return r.value;
        }
      }
      // Nope!
    } catch (err) {
      _iterator4.e(err);
    } finally {
      _iterator4.f();
    }
    return undefined;
  }
  function getFuzzyMode(quorum, results) {
    if (quorum === 1) {
      return (0, index_js_1.getNumber)(getMedian(quorum, results), "%internal");
    }
    var tally = new Map();
    var add = function add(result, weight) {
      var t = tally.get(result) || {
        result: result,
        weight: 0
      };
      t.weight += weight;
      tally.set(result, t);
    };
    var _iterator5 = _createForOfIteratorHelper(results),
      _step5;
    try {
      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
        var _step5$value = _step5.value,
          weight = _step5$value.weight,
          value = _step5$value.value;
        var r = (0, index_js_1.getNumber)(value);
        add(r - 1, weight);
        add(r, weight);
        add(r + 1, weight);
      }
    } catch (err) {
      _iterator5.e(err);
    } finally {
      _iterator5.f();
    }
    var bestWeight = 0;
    var bestResult = undefined;
    var _iterator6 = _createForOfIteratorHelper(tally.values()),
      _step6;
    try {
      for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
        var _step6$value = _step6.value,
          _weight = _step6$value.weight,
          result = _step6$value.result;
        // Use this result, if this result meets quorum and has either:
        // - a better weight
        // - or equal weight, but the result is larger
        if (_weight >= quorum && (_weight > bestWeight || bestResult != null && _weight === bestWeight && result > bestResult)) {
          bestWeight = _weight;
          bestResult = result;
        }
      }
    } catch (err) {
      _iterator6.e(err);
    } finally {
      _iterator6.f();
    }
    return bestResult;
  }
  /**
   *  A **FallbackProvider** manages several [[Providers]] providing
   *  resilience by switching between slow or misbehaving nodes, security
   *  by requiring multiple backends to aggree and performance by allowing
   *  faster backends to respond earlier.
   *
   */
  var _configs = /*#__PURE__*/new WeakMap();
  var _height = /*#__PURE__*/new WeakMap();
  var _initialSyncPromise = /*#__PURE__*/new WeakMap();
  var _FallbackProvider_brand = /*#__PURE__*/new WeakSet();
  var FallbackProvider = /*#__PURE__*/function (_abstract_provider_js) {
    /**
     *  Creates a new **FallbackProvider** with %%providers%% connected to
     *  %%network%%.
     *
     *  If a [[Provider]] is included in %%providers%%, defaults are used
     *  for the configuration.
     */
    function FallbackProvider(providers, _network, options) {
      var _this;
      _classCallCheck(this, FallbackProvider);
      _this = _callSuper(this, FallbackProvider, [_network, options]);
      // Grab the next (random) config that is not already part of
      // the running set
      _classPrivateMethodInitSpec(_this, _FallbackProvider_brand);
      /**
       *  The number of backends that must agree on a value before it is
       *  accpeted.
       */
      _defineProperty(_this, "quorum", void 0);
      /**
       *  @_ignore:
       */
      _defineProperty(_this, "eventQuorum", void 0);
      /**
       *  @_ignore:
       */
      _defineProperty(_this, "eventWorkers", void 0);
      _classPrivateFieldInitSpec(_this, _configs, void 0);
      _classPrivateFieldInitSpec(_this, _height, void 0);
      _classPrivateFieldInitSpec(_this, _initialSyncPromise, void 0);
      _classPrivateFieldSet2(_configs, _this, providers.map(function (p) {
        if (p instanceof abstract_provider_js_1.AbstractProvider) {
          return Object.assign({
            provider: p
          }, defaultConfig, defaultState);
        } else {
          return Object.assign({}, defaultConfig, p, defaultState);
        }
      }));
      _classPrivateFieldSet2(_height, _this, -2);
      _classPrivateFieldSet2(_initialSyncPromise, _this, null);
      if (options && options.quorum != null) {
        _this.quorum = options.quorum;
      } else {
        _this.quorum = Math.ceil(_classPrivateFieldGet2(_configs, _this).reduce(function (accum, config) {
          accum += config.weight;
          return accum;
        }, 0) / 2);
      }
      _this.eventQuorum = 1;
      _this.eventWorkers = 1;
      (0, index_js_1.assertArgument)(_this.quorum <= _classPrivateFieldGet2(_configs, _this).reduce(function (a, c) {
        return a + c.weight;
      }, 0), "quorum exceed provider weight", "quorum", _this.quorum);
      return _this;
    }
    _inherits(FallbackProvider, _abstract_provider_js);
    return _createClass(FallbackProvider, [{
      key: "providerConfigs",
      get: function get() {
        return _classPrivateFieldGet2(_configs, this).map(function (c) {
          var result = Object.assign({}, c);
          for (var key in result) {
            if (key[0] === "_") {
              delete result[key];
            }
          }
          return result;
        });
      }
    }, {
      key: "_detectNetwork",
      value: function () {
        var _detectNetwork2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                _context.t0 = network_js_1.Network;
                _context.t1 = (index_js_1.getBigInt);
                _context.next = 4;
                return this._perform({
                  method: "chainId"
                });
              case 4:
                _context.t2 = _context.sent;
                _context.t3 = (0, _context.t1)(_context.t2);
                return _context.abrupt("return", _context.t0.from.call(_context.t0, _context.t3));
              case 7:
              case "end":
                return _context.stop();
            }
          }, _callee, this);
        }));
        function _detectNetwork() {
          return _detectNetwork2.apply(this, arguments);
        }
        return _detectNetwork;
      }() // @TODO: Add support to select providers to be the event subscriber
      //_getSubscriber(sub: Subscription): Subscriber {
      //    throw new Error("@TODO");
      //}
      /**
       *  Transforms a %%req%% into the correct method call on %%provider%%.
       */
    }, {
      key: "_translatePerform",
      value: function () {
        var _translatePerform2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(provider, req) {
          var block;
          return _regeneratorRuntime().wrap(function _callee2$(_context2) {
            while (1) switch (_context2.prev = _context2.next) {
              case 0:
                _context2.t0 = req.method;
                _context2.next = _context2.t0 === "broadcastTransaction" ? 3 : _context2.t0 === "call" ? 6 : _context2.t0 === "chainId" ? 9 : _context2.t0 === "estimateGas" ? 12 : _context2.t0 === "getBalance" ? 15 : _context2.t0 === "getBlock" ? 18 : _context2.t0 === "getBlockNumber" ? 22 : _context2.t0 === "getCode" ? 25 : _context2.t0 === "getGasPrice" ? 28 : _context2.t0 === "getPriorityFee" ? 31 : _context2.t0 === "getLogs" ? 34 : _context2.t0 === "getStorage" ? 37 : _context2.t0 === "getTransaction" ? 40 : _context2.t0 === "getTransactionCount" ? 43 : _context2.t0 === "getTransactionReceipt" ? 46 : _context2.t0 === "getTransactionResult" ? 49 : 52;
                break;
              case 3:
                _context2.next = 5;
                return provider.broadcastTransaction(req.signedTransaction);
              case 5:
                return _context2.abrupt("return", _context2.sent);
              case 6:
                _context2.next = 8;
                return provider.call(Object.assign({}, req.transaction, {
                  blockTag: req.blockTag
                }));
              case 8:
                return _context2.abrupt("return", _context2.sent);
              case 9:
                _context2.next = 11;
                return provider.getNetwork();
              case 11:
                return _context2.abrupt("return", _context2.sent.chainId);
              case 12:
                _context2.next = 14;
                return provider.estimateGas(req.transaction);
              case 14:
                return _context2.abrupt("return", _context2.sent);
              case 15:
                _context2.next = 17;
                return provider.getBalance(req.address, req.blockTag);
              case 17:
                return _context2.abrupt("return", _context2.sent);
              case 18:
                block = "blockHash" in req ? req.blockHash : req.blockTag;
                _context2.next = 21;
                return provider.getBlock(block, req.includeTransactions);
              case 21:
                return _context2.abrupt("return", _context2.sent);
              case 22:
                _context2.next = 24;
                return provider.getBlockNumber();
              case 24:
                return _context2.abrupt("return", _context2.sent);
              case 25:
                _context2.next = 27;
                return provider.getCode(req.address, req.blockTag);
              case 27:
                return _context2.abrupt("return", _context2.sent);
              case 28:
                _context2.next = 30;
                return provider.getFeeData();
              case 30:
                return _context2.abrupt("return", _context2.sent.gasPrice);
              case 31:
                _context2.next = 33;
                return provider.getFeeData();
              case 33:
                return _context2.abrupt("return", _context2.sent.maxPriorityFeePerGas);
              case 34:
                _context2.next = 36;
                return provider.getLogs(req.filter);
              case 36:
                return _context2.abrupt("return", _context2.sent);
              case 37:
                _context2.next = 39;
                return provider.getStorage(req.address, req.position, req.blockTag);
              case 39:
                return _context2.abrupt("return", _context2.sent);
              case 40:
                _context2.next = 42;
                return provider.getTransaction(req.hash);
              case 42:
                return _context2.abrupt("return", _context2.sent);
              case 43:
                _context2.next = 45;
                return provider.getTransactionCount(req.address, req.blockTag);
              case 45:
                return _context2.abrupt("return", _context2.sent);
              case 46:
                _context2.next = 48;
                return provider.getTransactionReceipt(req.hash);
              case 48:
                return _context2.abrupt("return", _context2.sent);
              case 49:
                _context2.next = 51;
                return provider.getTransactionResult(req.hash);
              case 51:
                return _context2.abrupt("return", _context2.sent);
              case 52:
              case "end":
                return _context2.stop();
            }
          }, _callee2);
        }));
        function _translatePerform(_x3, _x4) {
          return _translatePerform2.apply(this, arguments);
        }
        return _translatePerform;
      }()
    }, {
      key: "_perform",
      value: function () {
        var _perform2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4(req) {
          var results, broadcasts, done, _iterator7, _step7, value, _result2, waiting, _result3, running, inflightQuorum, runner, result, _iterator8, _step8, _runner;
          return _regeneratorRuntime().wrap(function _callee4$(_context4) {
            while (1) switch (_context4.prev = _context4.next) {
              case 0:
                if (!(req.method === "broadcastTransaction")) {
                  _context4.next = 37;
                  break;
                }
                // Once any broadcast provides a positive result, use it. No
                // need to wait for anyone else
                results = _classPrivateFieldGet2(_configs, this).map(function (c) {
                  return null;
                });
                broadcasts = _classPrivateFieldGet2(_configs, this).map(/*#__PURE__*/function () {
                  var _ref2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(_ref, index) {
                    var provider, weight, _result;
                    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
                      while (1) switch (_context3.prev = _context3.next) {
                        case 0:
                          provider = _ref.provider, weight = _ref.weight;
                          _context3.prev = 1;
                          _context3.next = 4;
                          return provider._perform(req);
                        case 4:
                          _result = _context3.sent;
                          results[index] = Object.assign(normalizeResult({
                            result: _result
                          }), {
                            weight: weight
                          });
                          _context3.next = 11;
                          break;
                        case 8:
                          _context3.prev = 8;
                          _context3.t0 = _context3["catch"](1);
                          results[index] = Object.assign(normalizeResult({
                            error: _context3.t0
                          }), {
                            weight: weight
                          });
                        case 11:
                        case "end":
                          return _context3.stop();
                      }
                    }, _callee3, null, [[1, 8]]);
                  }));
                  return function (_x6, _x7) {
                    return _ref2.apply(this, arguments);
                  };
                }()); // As each promise finishes...
              case 3:
                // Check for a valid broadcast result
                done = results.filter(function (r) {
                  return r != null;
                });
                _iterator7 = _createForOfIteratorHelper(done);
                _context4.prev = 6;
                _iterator7.s();
              case 8:
                if ((_step7 = _iterator7.n()).done) {
                  _context4.next = 14;
                  break;
                }
                value = _step7.value.value;
                if (value instanceof Error) {
                  _context4.next = 12;
                  break;
                }
                return _context4.abrupt("return", value);
              case 12:
                _context4.next = 8;
                break;
              case 14:
                _context4.next = 19;
                break;
              case 16:
                _context4.prev = 16;
                _context4.t0 = _context4["catch"](6);
                _iterator7.e(_context4.t0);
              case 19:
                _context4.prev = 19;
                _iterator7.f();
                return _context4.finish(19);
              case 22:
                // Check for a legit broadcast error (one which we cannot
                // recover from; some nodes may return the following red
                // herring events:
                // - alredy seend (UNKNOWN_ERROR)
                // - NONCE_EXPIRED
                // - REPLACEMENT_UNDERPRICED
                _result2 = checkQuorum(this.quorum, results.filter(function (r) {
                  return r != null;
                }));
                if (!(0, index_js_1.isError)(_result2, "INSUFFICIENT_FUNDS")) {
                  _context4.next = 25;
                  break;
                }
                throw _result2;
              case 25:
                // Kick off the next provider (if any)
                waiting = broadcasts.filter(function (b, i) {
                  return results[i] == null;
                });
                if (!(waiting.length === 0)) {
                  _context4.next = 28;
                  break;
                }
                return _context4.abrupt("break", 32);
              case 28:
                _context4.next = 30;
                return Promise.race(waiting);
              case 30:
                _context4.next = 3;
                break;
              case 32:
                // Use standard quorum results; any result was returned above,
                // so this will find any error that met quorum if any
                _result3 = getAnyResult(this.quorum, results);
                (0, index_js_1.assert)(_result3 !== undefined, "problem multi-broadcasting", "SERVER_ERROR", {
                  request: "%sub-requests",
                  info: {
                    request: req,
                    results: results.map(stringify)
                  }
                });
                if (!(_result3 instanceof Error)) {
                  _context4.next = 36;
                  break;
                }
                throw _result3;
              case 36:
                return _context4.abrupt("return", _result3);
              case 37:
                _context4.next = 39;
                return _assertClassBrand(_FallbackProvider_brand, this, _initialSync).call(this);
              case 39:
                // Bootstrap enough runners to meet quorum
                running = new Set();
                inflightQuorum = 0;
              case 41:
                runner = _assertClassBrand(_FallbackProvider_brand, this, _addRunner).call(this, running, req);
                if (!(runner == null)) {
                  _context4.next = 45;
                  break;
                }
                return _context4.abrupt("break", 50);
              case 45:
                inflightQuorum += runner.config.weight;
                if (!(inflightQuorum >= this.quorum)) {
                  _context4.next = 48;
                  break;
                }
                return _context4.abrupt("break", 50);
              case 48:
                _context4.next = 41;
                break;
              case 50:
                _context4.next = 52;
                return _assertClassBrand(_FallbackProvider_brand, this, _waitForQuorum).call(this, running, req);
              case 52:
                result = _context4.sent;
                // Track requests sent to a provider that are still
                // outstanding after quorum has been otherwise found
                _iterator8 = _createForOfIteratorHelper(running);
                try {
                  for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
                    _runner = _step8.value;
                    if (_runner.perform && _runner.result == null) {
                      _runner.config.lateResponses++;
                    }
                  }
                } catch (err) {
                  _iterator8.e(err);
                } finally {
                  _iterator8.f();
                }
                return _context4.abrupt("return", result);
              case 56:
              case "end":
                return _context4.stop();
            }
          }, _callee4, this, [[6, 16, 19, 22]]);
        }));
        function _perform(_x5) {
          return _perform2.apply(this, arguments);
        }
        return _perform;
      }()
    }, {
      key: "destroy",
      value: function () {
        var _destroy = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
          var _iterator9, _step9, provider;
          return _regeneratorRuntime().wrap(function _callee5$(_context5) {
            while (1) switch (_context5.prev = _context5.next) {
              case 0:
                _iterator9 = _createForOfIteratorHelper(_classPrivateFieldGet2(_configs, this));
                try {
                  for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
                    provider = _step9.value.provider;
                    provider.destroy();
                  }
                } catch (err) {
                  _iterator9.e(err);
                } finally {
                  _iterator9.f();
                }
                _superPropGet(FallbackProvider, "destroy", this, 3)([]);
              case 3:
              case "end":
                return _context5.stop();
            }
          }, _callee5, this);
        }));
        function destroy() {
          return _destroy.apply(this, arguments);
        }
        return destroy;
      }()
    }]);
  }(abstract_provider_js_1.AbstractProvider);
  function _getNextConfig(running) {
    // @TODO: Maybe do a check here to favour (heavily) providers that
    //        do not require waitForSync and disfavour providers that
    //        seem down-ish or are behaving slowly
    var configs = Array.from(running).map(function (r) {
      return r.config;
    });
    // Shuffle the states, sorted by priority
    var allConfigs = _classPrivateFieldGet2(_configs, this).slice();
    shuffle(allConfigs);
    allConfigs.sort(function (a, b) {
      return a.priority - b.priority;
    });
    var _iterator10 = _createForOfIteratorHelper(allConfigs),
      _step10;
    try {
      for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
        var config = _step10.value;
        if (config._lastFatalError) {
          continue;
        }
        if (configs.indexOf(config) === -1) {
          return config;
        }
      }
    } catch (err) {
      _iterator10.e(err);
    } finally {
      _iterator10.f();
    }
    return null;
  }
  // Adds a new runner (if available) to running.
  function _addRunner(running, req) {
    var _this2 = this;
    var config = _assertClassBrand(_FallbackProvider_brand, this, _getNextConfig).call(this, running);
    // No runners available
    if (config == null) {
      return null;
    }
    // Create a new runner
    var runner = {
      config: config,
      result: null,
      didBump: false,
      perform: null,
      staller: null
    };
    var now = getTime();
    // Start performing this operation
    runner.perform = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {
      var result, dt;
      return _regeneratorRuntime().wrap(function _callee8$(_context8) {
        while (1) switch (_context8.prev = _context8.next) {
          case 0:
            _context8.prev = 0;
            config.requests++;
            _context8.next = 4;
            return _this2._translatePerform(config.provider, req);
          case 4:
            result = _context8.sent;
            runner.result = {
              result: result
            };
            _context8.next = 12;
            break;
          case 8:
            _context8.prev = 8;
            _context8.t0 = _context8["catch"](0);
            config.errorResponses++;
            runner.result = {
              error: _context8.t0
            };
          case 12:
            dt = getTime() - now;
            config._totalTime += dt;
            config.rollingDuration = 0.95 * config.rollingDuration + 0.05 * dt;
            runner.perform = null;
          case 16:
          case "end":
            return _context8.stop();
        }
      }, _callee8, null, [[0, 8]]);
    }))();
    // Start a staller; when this times out, it's time to force
    // kicking off another runner because we are taking too long
    runner.staller = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {
      return _regeneratorRuntime().wrap(function _callee9$(_context9) {
        while (1) switch (_context9.prev = _context9.next) {
          case 0:
            _context9.next = 2;
            return stall(config.stallTimeout);
          case 2:
            runner.staller = null;
          case 3:
          case "end":
            return _context9.stop();
        }
      }, _callee9);
    }))();
    running.add(runner);
    return runner;
  }
  // Initializes the blockNumber and network for each runner and
  // blocks until initialized
  function _initialSync() {
    return _initialSync2.apply(this, arguments);
  }
  function _initialSync2() {
    _initialSync2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {
      var _this3 = this;
      var initialSync, promises;
      return _regeneratorRuntime().wrap(function _callee12$(_context12) {
        while (1) switch (_context12.prev = _context12.next) {
          case 0:
            initialSync = _classPrivateFieldGet2(_initialSyncPromise, this);
            if (!initialSync) {
              promises = [];
              _classPrivateFieldGet2(_configs, this).forEach(function (config) {
                promises.push(_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {
                  return _regeneratorRuntime().wrap(function _callee10$(_context10) {
                    while (1) switch (_context10.prev = _context10.next) {
                      case 0:
                        _context10.next = 2;
                        return waitForSync(config, 0);
                      case 2:
                        if (config._lastFatalError) {
                          _context10.next = 6;
                          break;
                        }
                        _context10.next = 5;
                        return config.provider.getNetwork();
                      case 5:
                        config._network = _context10.sent;
                      case 6:
                      case "end":
                        return _context10.stop();
                    }
                  }, _callee10);
                }))());
              });
              _classPrivateFieldSet2(_initialSyncPromise, this, initialSync = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {
                var chainId, _iterator11, _step11, config, network;
                return _regeneratorRuntime().wrap(function _callee11$(_context11) {
                  while (1) switch (_context11.prev = _context11.next) {
                    case 0:
                      _context11.next = 2;
                      return Promise.all(promises);
                    case 2:
                      // Check all the networks match
                      chainId = null;
                      _iterator11 = _createForOfIteratorHelper(_classPrivateFieldGet2(_configs, _this3));
                      _context11.prev = 4;
                      _iterator11.s();
                    case 6:
                      if ((_step11 = _iterator11.n()).done) {
                        _context11.next = 14;
                        break;
                      }
                      config = _step11.value;
                      if (!config._lastFatalError) {
                        _context11.next = 10;
                        break;
                      }
                      return _context11.abrupt("continue", 12);
                    case 10:
                      network = config._network;
                      if (chainId == null) {
                        chainId = network.chainId;
                      } else if (network.chainId !== chainId) {
                        (0, index_js_1.assert)(false, "cannot mix providers on different networks", "UNSUPPORTED_OPERATION", {
                          operation: "new FallbackProvider"
                        });
                      }
                    case 12:
                      _context11.next = 6;
                      break;
                    case 14:
                      _context11.next = 19;
                      break;
                    case 16:
                      _context11.prev = 16;
                      _context11.t0 = _context11["catch"](4);
                      _iterator11.e(_context11.t0);
                    case 19:
                      _context11.prev = 19;
                      _iterator11.f();
                      return _context11.finish(19);
                    case 22:
                    case "end":
                      return _context11.stop();
                  }
                }, _callee11, null, [[4, 16, 19, 22]]);
              }))());
            }
            _context12.next = 4;
            return initialSync;
          case 4:
          case "end":
            return _context12.stop();
        }
      }, _callee12, this);
    }));
    return _initialSync2.apply(this, arguments);
  }
  function _checkQuorum(_x8, _x9) {
    return _checkQuorum2.apply(this, arguments);
  }
  function _checkQuorum2() {
    _checkQuorum2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee13(running, req) {
      var results, _iterator12, _step12, runner, _normalizeResult, tag, value, mode;
      return _regeneratorRuntime().wrap(function _callee13$(_context13) {
        while (1) switch (_context13.prev = _context13.next) {
          case 0:
            // Get all the result objects
            results = [];
            _iterator12 = _createForOfIteratorHelper(running);
            try {
              for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
                runner = _step12.value;
                if (runner.result != null) {
                  _normalizeResult = normalizeResult(runner.result), tag = _normalizeResult.tag, value = _normalizeResult.value;
                  results.push({
                    tag: tag,
                    value: value,
                    weight: runner.config.weight
                  });
                }
              }
              // Are there enough results to event meet quorum?
            } catch (err) {
              _iterator12.e(err);
            } finally {
              _iterator12.f();
            }
            if (!(results.reduce(function (a, r) {
              return a + r.weight;
            }, 0) < this.quorum)) {
              _context13.next = 5;
              break;
            }
            return _context13.abrupt("return", undefined);
          case 5:
            _context13.t0 = req.method;
            _context13.next = _context13.t0 === "getBlockNumber" ? 8 : _context13.t0 === "getGasPrice" ? 14 : _context13.t0 === "getPriorityFee" ? 14 : _context13.t0 === "estimateGas" ? 14 : _context13.t0 === "getBlock" ? 15 : _context13.t0 === "call" ? 18 : _context13.t0 === "chainId" ? 18 : _context13.t0 === "getBalance" ? 18 : _context13.t0 === "getTransactionCount" ? 18 : _context13.t0 === "getCode" ? 18 : _context13.t0 === "getStorage" ? 18 : _context13.t0 === "getTransaction" ? 18 : _context13.t0 === "getTransactionReceipt" ? 18 : _context13.t0 === "getLogs" ? 18 : _context13.t0 === "broadcastTransaction" ? 19 : 20;
            break;
          case 8:
            // We need to get the bootstrap block height
            if (_classPrivateFieldGet2(_height, this) === -2) {
              _classPrivateFieldSet2(_height, this, Math.ceil((0, index_js_1.getNumber)(getMedian(this.quorum, _classPrivateFieldGet2(_configs, this).filter(function (c) {
                return !c._lastFatalError;
              }).map(function (c) {
                return {
                  value: c.blockNumber,
                  tag: (0, index_js_1.getNumber)(c.blockNumber).toString(),
                  weight: c.weight
                };
              })))));
            }
            // Find the mode across all the providers, allowing for
            // a little drift between block heights
            mode = getFuzzyMode(this.quorum, results);
            if (!(mode === undefined)) {
              _context13.next = 12;
              break;
            }
            return _context13.abrupt("return", undefined);
          case 12:
            if (mode > _classPrivateFieldGet2(_height, this)) {
              _classPrivateFieldSet2(_height, this, mode);
            }
            return _context13.abrupt("return", _classPrivateFieldGet2(_height, this));
          case 14:
            return _context13.abrupt("return", getMedian(this.quorum, results));
          case 15:
            if (!("blockTag" in req && req.blockTag === "pending")) {
              _context13.next = 17;
              break;
            }
            return _context13.abrupt("return", getAnyResult(this.quorum, results));
          case 17:
            return _context13.abrupt("return", checkQuorum(this.quorum, results));
          case 18:
            return _context13.abrupt("return", checkQuorum(this.quorum, results));
          case 19:
            return _context13.abrupt("return", getAnyResult(this.quorum, results));
          case 20:
            (0, index_js_1.assert)(false, "unsupported method", "UNSUPPORTED_OPERATION", {
              operation: "_perform(".concat(stringify(req.method), ")")
            });
          case 21:
          case "end":
            return _context13.stop();
        }
      }, _callee13, this);
    }));
    return _checkQuorum2.apply(this, arguments);
  }
  function _waitForQuorum(_x10, _x11) {
    return _waitForQuorum2.apply(this, arguments);
  }
  function _waitForQuorum2() {
    _waitForQuorum2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee14(running, req) {
      var interesting, newRunners, _iterator13, _step13, runner, value, i;
      return _regeneratorRuntime().wrap(function _callee14$(_context14) {
        while (1) switch (_context14.prev = _context14.next) {
          case 0:
            if (!(running.size === 0)) {
              _context14.next = 2;
              break;
            }
            throw new Error("no runners?!");
          case 2:
            // Any promises that are interesting to watch for; an expired stall
            // or a successful perform
            interesting = [];
            newRunners = 0;
            _iterator13 = _createForOfIteratorHelper(running);
            _context14.prev = 5;
            _iterator13.s();
          case 7:
            if ((_step13 = _iterator13.n()).done) {
              _context14.next = 19;
              break;
            }
            runner = _step13.value;
            // No responses, yet; keep an eye on it
            if (runner.perform) {
              interesting.push(runner.perform);
            }
            // Still stalling...
            if (!runner.staller) {
              _context14.next = 13;
              break;
            }
            interesting.push(runner.staller);
            return _context14.abrupt("continue", 17);
          case 13:
            if (!runner.didBump) {
              _context14.next = 15;
              break;
            }
            return _context14.abrupt("continue", 17);
          case 15:
            // Got a response (result or error) or stalled; kick off another runner
            runner.didBump = true;
            newRunners++;
          case 17:
            _context14.next = 7;
            break;
          case 19:
            _context14.next = 24;
            break;
          case 21:
            _context14.prev = 21;
            _context14.t0 = _context14["catch"](5);
            _iterator13.e(_context14.t0);
          case 24:
            _context14.prev = 24;
            _iterator13.f();
            return _context14.finish(24);
          case 27:
            _context14.next = 29;
            return _assertClassBrand(_FallbackProvider_brand, this, _checkQuorum).call(this, running, req);
          case 29:
            value = _context14.sent;
            if (!(value !== undefined)) {
              _context14.next = 34;
              break;
            }
            if (!(value instanceof Error)) {
              _context14.next = 33;
              break;
            }
            throw value;
          case 33:
            return _context14.abrupt("return", value);
          case 34:
            // Add any new runners, because a staller timed out or a result
            // or error response came in.
            for (i = 0; i < newRunners; i++) {
              _assertClassBrand(_FallbackProvider_brand, this, _addRunner).call(this, running, req);
            }
            // All providers have returned, and we have no result
            (0, index_js_1.assert)(interesting.length > 0, "quorum not met", "SERVER_ERROR", {
              request: "%sub-requests",
              info: {
                request: req,
                results: Array.from(running).map(function (r) {
                  return stringify(r.result);
                })
              }
            });
            // Wait for someone to either complete its perform or stall out
            _context14.next = 38;
            return Promise.race(interesting);
          case 38:
            _context14.next = 40;
            return _assertClassBrand(_FallbackProvider_brand, this, _waitForQuorum).call(this, running, req);
          case 40:
            return _context14.abrupt("return", _context14.sent);
          case 41:
          case "end":
            return _context14.stop();
        }
      }, _callee14, this, [[5, 21, 24, 27]]);
    }));
    return _waitForQuorum2.apply(this, arguments);
  }
  providerFallback.FallbackProvider = FallbackProvider;
  return providerFallback;
}

var hasRequiredDefaultProvider;
function requireDefaultProvider() {
  if (hasRequiredDefaultProvider) return defaultProvider;
  hasRequiredDefaultProvider = 1;
  Object.defineProperty(defaultProvider, "__esModule", {
    value: true
  });
  defaultProvider.getDefaultProvider = void 0;
  var index_js_1 = /*@__PURE__*/requireUtils$3();
  var provider_ankr_js_1 = /*@__PURE__*/requireProviderAnkr();
  var provider_alchemy_js_1 = /*@__PURE__*/requireProviderAlchemy();
  var provider_chainstack_js_1 = /*@__PURE__*/requireProviderChainstack();
  var provider_cloudflare_js_1 = /*@__PURE__*/requireProviderCloudflare();
  var provider_etherscan_js_1 = /*@__PURE__*/requireProviderEtherscan();
  var provider_infura_js_1 = /*@__PURE__*/requireProviderInfura();
  //import { PocketProvider } from "./provider-pocket.js";
  var provider_quicknode_js_1 = /*@__PURE__*/requireProviderQuicknode();
  var provider_fallback_js_1 = /*@__PURE__*/requireProviderFallback();
  var provider_jsonrpc_js_1 = /*@__PURE__*/requireProviderJsonrpc();
  var network_js_1 = /*@__PURE__*/requireNetwork();
  var provider_websocket_js_1 = /*@__PURE__*/requireProviderWebsocket();
  function isWebSocketLike(value) {
    return value && typeof value.send === "function" && typeof value.close === "function";
  }
  var Testnets = "goerli kovan sepolia classicKotti optimism-goerli arbitrum-goerli matic-mumbai bnbt".split(" ");
  /**
   *  Returns a default provider for %%network%%.
   *
   *  If %%network%% is a [[WebSocketLike]] or string that begins with
   *  ``"ws:"`` or ``"wss:"``, a [[WebSocketProvider]] is returned backed
   *  by that WebSocket or URL.
   *
   *  If %%network%% is a string that begins with ``"HTTP:"`` or ``"HTTPS:"``,
   *  a [[JsonRpcProvider]] is returned connected to that URL.
   *
   *  Otherwise, a default provider is created backed by well-known public
   *  Web3 backends (such as [[link-infura]]) using community-provided API
   *  keys.
   *
   *  The %%options%% allows specifying custom API keys per backend (setting
   *  an API key to ``"-"`` will omit that provider) and ``options.exclusive``
   *  can be set to either a backend name or and array of backend names, which
   *  will whitelist **only** those backends.
   *
   *  Current backend strings supported are:
   *  - ``"alchemy"``
   *  - ``"ankr"``
   *  - ``"cloudflare"``
   *  - ``"chainstack"``
   *  - ``"etherscan"``
   *  - ``"infura"``
   *  - ``"publicPolygon"``
   *  - ``"quicknode"``
   *
   *  @example:
   *    // Connect to a local Geth node
   *    provider = getDefaultProvider("http://localhost:8545/");
   *
   *    // Connect to Ethereum mainnet with any current and future
   *    // third-party services available
   *    provider = getDefaultProvider("mainnet");
   *
   *    // Connect to Polygon, but only allow Etherscan and
   *    // INFURA and use "MY_API_KEY" in calls to Etherscan.
   *    provider = getDefaultProvider("matic", {
   *      etherscan: "MY_API_KEY",
   *      exclusive: [ "etherscan", "infura" ]
   *    });
   */
  function getDefaultProvider(network, options) {
    if (options == null) {
      options = {};
    }
    var allowService = function allowService(name) {
      if (options[name] === "-") {
        return false;
      }
      if (typeof options.exclusive === "string") {
        return name === options.exclusive;
      }
      if (Array.isArray(options.exclusive)) {
        return options.exclusive.indexOf(name) !== -1;
      }
      return true;
    };
    if (typeof network === "string" && network.match(/^https?:/)) {
      return new provider_jsonrpc_js_1.JsonRpcProvider(network);
    }
    if (typeof network === "string" && network.match(/^wss?:/) || isWebSocketLike(network)) {
      return new provider_websocket_js_1.WebSocketProvider(network);
    }
    // Get the network and name, if possible
    var staticNetwork = null;
    try {
      staticNetwork = network_js_1.Network.from(network);
    } catch (error) {}
    var providers = [];
    if (allowService("publicPolygon") && staticNetwork) {
      if (staticNetwork.name === "matic") {
        providers.push(new provider_jsonrpc_js_1.JsonRpcProvider("https:/\/polygon-rpc.com/", staticNetwork, {
          staticNetwork: staticNetwork
        }));
      } else if (staticNetwork.name === "matic-amoy") {
        providers.push(new provider_jsonrpc_js_1.JsonRpcProvider("https:/\/rpc-amoy.polygon.technology/", staticNetwork, {
          staticNetwork: staticNetwork
        }));
      }
    }
    if (allowService("alchemy")) {
      try {
        providers.push(new provider_alchemy_js_1.AlchemyProvider(network, options.alchemy));
      } catch (error) {}
    }
    if (allowService("ankr") && options.ankr != null) {
      try {
        providers.push(new provider_ankr_js_1.AnkrProvider(network, options.ankr));
      } catch (error) {}
    }
    if (allowService("chainstack")) {
      try {
        providers.push(new provider_chainstack_js_1.ChainstackProvider(network, options.chainstack));
      } catch (error) {}
    }
    if (allowService("cloudflare")) {
      try {
        providers.push(new provider_cloudflare_js_1.CloudflareProvider(network));
      } catch (error) {}
    }
    if (allowService("etherscan")) {
      try {
        providers.push(new provider_etherscan_js_1.EtherscanProvider(network, options.etherscan));
      } catch (error) {}
    }
    if (allowService("infura")) {
      try {
        var projectId = options.infura;
        var projectSecret = undefined;
        if (_typeof(projectId) === "object") {
          projectSecret = projectId.projectSecret;
          projectId = projectId.projectId;
        }
        providers.push(new provider_infura_js_1.InfuraProvider(network, projectId, projectSecret));
      } catch (error) {}
    }
    /*
        if (options.pocket !== "-") {
            try {
                let appId = options.pocket;
                let secretKey: undefined | string = undefined;
                let loadBalancer: undefined | boolean = undefined;
                if (typeof(appId) === "object") {
                    loadBalancer = !!appId.loadBalancer;
                    secretKey = appId.secretKey;
                    appId = appId.appId;
                }
                providers.push(new PocketProvider(network, appId, secretKey, loadBalancer));
            } catch (error) { console.log(error); }
        }
    */
    if (allowService("quicknode")) {
      try {
        var token = options.quicknode;
        providers.push(new provider_quicknode_js_1.QuickNodeProvider(network, token));
      } catch (error) {}
    }
    (0, index_js_1.assert)(providers.length, "unsupported default network", "UNSUPPORTED_OPERATION", {
      operation: "getDefaultProvider"
    });
    // No need for a FallbackProvider
    if (providers.length === 1) {
      return providers[0];
    }
    // We use the floor because public third-party providers can be unreliable,
    // so a low number of providers with a large quorum will fail too often
    var quorum = Math.floor(providers.length / 2);
    if (quorum > 2) {
      quorum = 2;
    }
    // Testnets don't need as strong a security gaurantee and speed is
    // more useful during testing
    if (staticNetwork && Testnets.indexOf(staticNetwork.name) !== -1) {
      quorum = 1;
    }
    // Provided override qorum takes priority
    if (options && options.quorum) {
      quorum = options.quorum;
    }
    return new provider_fallback_js_1.FallbackProvider(providers, undefined, {
      quorum: quorum
    });
  }
  defaultProvider.getDefaultProvider = getDefaultProvider;
  return defaultProvider;
}

var signerNoncemanager = {};

var hasRequiredSignerNoncemanager;
function requireSignerNoncemanager() {
  if (hasRequiredSignerNoncemanager) return signerNoncemanager;
  hasRequiredSignerNoncemanager = 1;
  Object.defineProperty(signerNoncemanager, "__esModule", {
    value: true
  });
  signerNoncemanager.NonceManager = void 0;
  var index_js_1 = /*@__PURE__*/requireUtils$3();
  var abstract_signer_js_1 = /*@__PURE__*/requireAbstractSigner();
  /**
   *  A **NonceManager** wraps another [[Signer]] and automatically manages
   *  the nonce, ensuring serialized and sequential nonces are used during
   *  transaction.
   */
  var _noncePromise = /*#__PURE__*/new WeakMap();
  var _delta = /*#__PURE__*/new WeakMap();
  var NonceManager = /*#__PURE__*/function (_abstract_signer_js_) {
    /**
     *  Creates a new **NonceManager** to manage %%signer%%.
     */
    function NonceManager(signer) {
      var _this;
      _classCallCheck(this, NonceManager);
      _this = _callSuper(this, NonceManager, [signer.provider]);
      /**
       *  The Signer being managed.
       */
      _defineProperty(_this, "signer", void 0);
      _classPrivateFieldInitSpec(_this, _noncePromise, void 0);
      _classPrivateFieldInitSpec(_this, _delta, void 0);
      (0, index_js_1.defineProperties)(_this, {
        signer: signer
      });
      _classPrivateFieldSet2(_noncePromise, _this, null);
      _classPrivateFieldSet2(_delta, _this, 0);
      return _this;
    }
    _inherits(NonceManager, _abstract_signer_js_);
    return _createClass(NonceManager, [{
      key: "getAddress",
      value: function () {
        var _getAddress = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                return _context.abrupt("return", this.signer.getAddress());
              case 1:
              case "end":
                return _context.stop();
            }
          }, _callee, this);
        }));
        function getAddress() {
          return _getAddress.apply(this, arguments);
        }
        return getAddress;
      }()
    }, {
      key: "connect",
      value: function connect(provider) {
        return new NonceManager(this.signer.connect(provider));
      }
    }, {
      key: "getNonce",
      value: function () {
        var _getNonce = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(blockTag) {
          var delta;
          return _regeneratorRuntime().wrap(function _callee2$(_context2) {
            while (1) switch (_context2.prev = _context2.next) {
              case 0:
                if (!(blockTag === "pending")) {
                  _context2.next = 8;
                  break;
                }
                if (_classPrivateFieldGet2(_noncePromise, this) == null) {
                  _classPrivateFieldSet2(_noncePromise, this, _superPropGet(NonceManager, "getNonce", this, 3)(["pending"]));
                }
                delta = _classPrivateFieldGet2(_delta, this);
                _context2.next = 5;
                return _classPrivateFieldGet2(_noncePromise, this);
              case 5:
                _context2.t0 = _context2.sent;
                _context2.t1 = delta;
                return _context2.abrupt("return", _context2.t0 + _context2.t1);
              case 8:
                return _context2.abrupt("return", _superPropGet(NonceManager, "getNonce", this, 3)([blockTag]));
              case 9:
              case "end":
                return _context2.stop();
            }
          }, _callee2, this);
        }));
        function getNonce(_x) {
          return _getNonce.apply(this, arguments);
        }
        return getNonce;
      }()
      /**
       *  Manually increment the nonce. This may be useful when managng
       *  offline transactions.
       */
    }, {
      key: "increment",
      value: function increment() {
        var _this$delta;
        _classPrivateFieldSet2(_delta, this, (_this$delta = _classPrivateFieldGet2(_delta, this), _this$delta++, _this$delta));
      }
      /**
       *  Resets the nonce, causing the **NonceManager** to reload the current
       *  nonce from the blockchain on the next transaction.
       */
    }, {
      key: "reset",
      value: function reset() {
        _classPrivateFieldSet2(_delta, this, 0);
        _classPrivateFieldSet2(_noncePromise, this, null);
      }
    }, {
      key: "sendTransaction",
      value: function () {
        var _sendTransaction = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(tx) {
          var noncePromise;
          return _regeneratorRuntime().wrap(function _callee3$(_context3) {
            while (1) switch (_context3.prev = _context3.next) {
              case 0:
                noncePromise = this.getNonce("pending");
                this.increment();
                _context3.next = 4;
                return this.signer.populateTransaction(tx);
              case 4:
                tx = _context3.sent;
                _context3.next = 7;
                return noncePromise;
              case 7:
                tx.nonce = _context3.sent;
                _context3.next = 10;
                return this.signer.sendTransaction(tx);
              case 10:
                return _context3.abrupt("return", _context3.sent);
              case 11:
              case "end":
                return _context3.stop();
            }
          }, _callee3, this);
        }));
        function sendTransaction(_x2) {
          return _sendTransaction.apply(this, arguments);
        }
        return sendTransaction;
      }()
    }, {
      key: "signTransaction",
      value: function signTransaction(tx) {
        return this.signer.signTransaction(tx);
      }
    }, {
      key: "signMessage",
      value: function signMessage(message) {
        return this.signer.signMessage(message);
      }
    }, {
      key: "signTypedData",
      value: function signTypedData(domain, types, value) {
        return this.signer.signTypedData(domain, types, value);
      }
    }]);
  }(abstract_signer_js_1.AbstractSigner);
  signerNoncemanager.NonceManager = NonceManager;
  return signerNoncemanager;
}

var providerBrowser = {};

var hasRequiredProviderBrowser;
function requireProviderBrowser() {
  if (hasRequiredProviderBrowser) return providerBrowser;
  hasRequiredProviderBrowser = 1;
  Object.defineProperty(providerBrowser, "__esModule", {
    value: true
  });
  providerBrowser.BrowserProvider = void 0;
  var index_js_1 = /*@__PURE__*/requireUtils$3();
  var provider_jsonrpc_js_1 = /*@__PURE__*/requireProviderJsonrpc();
  /**
   *  A **BrowserProvider** is intended to wrap an injected provider which
   *  adheres to the [[link-eip-1193]] standard, which most (if not all)
   *  currently do.
   */
  var _request = /*#__PURE__*/new WeakMap();
  var BrowserProvider = /*#__PURE__*/function (_provider_jsonrpc_js_) {
    /**
     *  Connnect to the %%ethereum%% provider, optionally forcing the
     *  %%network%%.
     */
    function BrowserProvider(ethereum, network, _options) {
      var _this;
      _classCallCheck(this, BrowserProvider);
      // Copy the options
      var options = Object.assign({}, _options != null ? _options : {}, {
        batchMaxCount: 1
      });
      (0, index_js_1.assertArgument)(ethereum && ethereum.request, "invalid EIP-1193 provider", "ethereum", ethereum);
      _this = _callSuper(this, BrowserProvider, [network, options]);
      _classPrivateFieldInitSpec(_this, _request, void 0);
      _classPrivateFieldSet2(_request, _this, /*#__PURE__*/function () {
        var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(method, params) {
          var payload, result, error;
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                payload = {
                  method: method,
                  params: params
                };
                _this.emit("debug", {
                  action: "sendEip1193Request",
                  payload: payload
                });
                _context.prev = 2;
                _context.next = 5;
                return ethereum.request(payload);
              case 5:
                result = _context.sent;
                _this.emit("debug", {
                  action: "receiveEip1193Result",
                  result: result
                });
                return _context.abrupt("return", result);
              case 10:
                _context.prev = 10;
                _context.t0 = _context["catch"](2);
                error = new Error(_context.t0.message);
                error.code = _context.t0.code;
                error.data = _context.t0.data;
                error.payload = payload;
                _this.emit("debug", {
                  action: "receiveEip1193Error",
                  error: error
                });
                throw error;
              case 18:
              case "end":
                return _context.stop();
            }
          }, _callee, null, [[2, 10]]);
        }));
        return function (_x, _x2) {
          return _ref.apply(this, arguments);
        };
      }());
      return _this;
    }
    _inherits(BrowserProvider, _provider_jsonrpc_js_);
    return _createClass(BrowserProvider, [{
      key: "send",
      value: function () {
        var _send2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(method, params) {
          return _regeneratorRuntime().wrap(function _callee2$(_context2) {
            while (1) switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this._start();
              case 2:
                _context2.next = 4;
                return _superPropGet(BrowserProvider, "send", this, 3)([method, params]);
              case 4:
                return _context2.abrupt("return", _context2.sent);
              case 5:
              case "end":
                return _context2.stop();
            }
          }, _callee2, this);
        }));
        function send(_x3, _x4) {
          return _send2.apply(this, arguments);
        }
        return send;
      }()
    }, {
      key: "_send",
      value: function () {
        var _send3 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(payload) {
          var result;
          return _regeneratorRuntime().wrap(function _callee3$(_context3) {
            while (1) switch (_context3.prev = _context3.next) {
              case 0:
                (0, index_js_1.assertArgument)(!Array.isArray(payload), "EIP-1193 does not support batch request", "payload", payload);
                _context3.prev = 1;
                _context3.next = 4;
                return _classPrivateFieldGet2(_request, this).call(this, payload.method, payload.params || []);
              case 4:
                result = _context3.sent;
                return _context3.abrupt("return", [{
                  id: payload.id,
                  result: result
                }]);
              case 8:
                _context3.prev = 8;
                _context3.t0 = _context3["catch"](1);
                return _context3.abrupt("return", [{
                  id: payload.id,
                  error: {
                    code: _context3.t0.code,
                    data: _context3.t0.data,
                    message: _context3.t0.message
                  }
                }]);
              case 11:
              case "end":
                return _context3.stop();
            }
          }, _callee3, this, [[1, 8]]);
        }));
        function _send(_x5) {
          return _send3.apply(this, arguments);
        }
        return _send;
      }()
    }, {
      key: "getRpcError",
      value: function getRpcError(payload, error) {
        error = JSON.parse(JSON.stringify(error));
        // EIP-1193 gives us some machine-readable error codes, so rewrite
        // them into 
        switch (error.error.code || -1) {
          case 4001:
            error.error.message = "ethers-user-denied: ".concat(error.error.message);
            break;
          case 4200:
            error.error.message = "ethers-unsupported: ".concat(error.error.message);
            break;
        }
        return _superPropGet(BrowserProvider, "getRpcError", this, 3)([payload, error]);
      }
      /**
       *  Resolves to ``true`` if the provider manages the %%address%%.
       */
    }, {
      key: "hasSigner",
      value: (function () {
        var _hasSigner = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4(address) {
          var accounts;
          return _regeneratorRuntime().wrap(function _callee4$(_context4) {
            while (1) switch (_context4.prev = _context4.next) {
              case 0:
                if (address == null) {
                  address = 0;
                }
                _context4.next = 3;
                return this.send("eth_accounts", []);
              case 3:
                accounts = _context4.sent;
                if (!(typeof address === "number")) {
                  _context4.next = 6;
                  break;
                }
                return _context4.abrupt("return", accounts.length > address);
              case 6:
                address = address.toLowerCase();
                return _context4.abrupt("return", accounts.filter(function (a) {
                  return a.toLowerCase() === address;
                }).length !== 0);
              case 8:
              case "end":
                return _context4.stop();
            }
          }, _callee4, this);
        }));
        function hasSigner(_x6) {
          return _hasSigner.apply(this, arguments);
        }
        return hasSigner;
      }())
    }, {
      key: "getSigner",
      value: function () {
        var _getSigner = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee5(address) {
          var payload;
          return _regeneratorRuntime().wrap(function _callee5$(_context5) {
            while (1) switch (_context5.prev = _context5.next) {
              case 0:
                if (address == null) {
                  address = 0;
                }
                _context5.next = 3;
                return this.hasSigner(address);
              case 3:
                if (_context5.sent) {
                  _context5.next = 13;
                  break;
                }
                _context5.prev = 4;
                _context5.next = 7;
                return _classPrivateFieldGet2(_request, this).call(this, "eth_requestAccounts", []);
              case 7:
                _context5.next = 13;
                break;
              case 9:
                _context5.prev = 9;
                _context5.t0 = _context5["catch"](4);
                payload = _context5.t0.payload;
                throw this.getRpcError(payload, {
                  id: payload.id,
                  error: _context5.t0
                });
              case 13:
                _context5.next = 15;
                return _superPropGet(BrowserProvider, "getSigner", this, 3)([address]);
              case 15:
                return _context5.abrupt("return", _context5.sent);
              case 16:
              case "end":
                return _context5.stop();
            }
          }, _callee5, this, [[4, 9]]);
        }));
        function getSigner(_x7) {
          return _getSigner.apply(this, arguments);
        }
        return getSigner;
      }()
    }]);
  }(provider_jsonrpc_js_1.JsonRpcApiPollingProvider);
  providerBrowser.BrowserProvider = BrowserProvider;
  return providerBrowser;
}

var providerPocket = {};

var hasRequiredProviderPocket;
function requireProviderPocket() {
  if (hasRequiredProviderPocket) return providerPocket;
  hasRequiredProviderPocket = 1;
  Object.defineProperty(providerPocket, "__esModule", {
    value: true
  });
  providerPocket.PocketProvider = void 0;
  /**
   *  [[link-pocket]] provides a third-party service for connecting to
   *  various blockchains over JSON-RPC.
   *
   *  **Supported Networks**
   *
   *  - Ethereum Mainnet (``mainnet``)
   *  - Goerli Testnet (``goerli``)
   *  - Polygon (``matic``)
   *  - Arbitrum (``arbitrum``)
   *
   *  @_subsection: api/providers/thirdparty:Pocket  [providers-pocket]
   */
  var index_js_1 = /*@__PURE__*/requireUtils$3();
  var community_js_1 = /*@__PURE__*/requireCommunity();
  var network_js_1 = /*@__PURE__*/requireNetwork();
  var provider_jsonrpc_js_1 = /*@__PURE__*/requireProviderJsonrpc();
  var defaultApplicationId = "62e1ad51b37b8e00394bda3b";
  function getHost(name) {
    switch (name) {
      case "mainnet":
        return "eth-mainnet.gateway.pokt.network";
      case "goerli":
        return "eth-goerli.gateway.pokt.network";
      case "matic":
        return "poly-mainnet.gateway.pokt.network";
      case "matic-mumbai":
        return "polygon-mumbai-rpc.gateway.pokt.network";
    }
    (0, index_js_1.assertArgument)(false, "unsupported network", "network", name);
  }
  /**
   *  The **PocketProvider** connects to the [[link-pocket]]
   *  JSON-RPC end-points.
   *
   *  By default, a highly-throttled API key is used, which is
   *  appropriate for quick prototypes and simple scripts. To
   *  gain access to an increased rate-limit, it is highly
   *  recommended to [sign up here](link-pocket-signup).
   */
  var PocketProvider = /*#__PURE__*/function (_provider_jsonrpc_js_) {
    /**
     *  Create a new **PocketProvider**.
     *
     *  By default connecting to ``mainnet`` with a highly throttled
     *  API key.
     */
    function PocketProvider(_network, applicationId, applicationSecret) {
      var _this;
      _classCallCheck(this, PocketProvider);
      if (_network == null) {
        _network = "mainnet";
      }
      var network = network_js_1.Network.from(_network);
      if (applicationId == null) {
        applicationId = defaultApplicationId;
      }
      if (applicationSecret == null) {
        applicationSecret = null;
      }
      var options = {
        staticNetwork: network
      };
      var request = PocketProvider.getRequest(network, applicationId, applicationSecret);
      _this = _callSuper(this, PocketProvider, [request, network, options]);
      /**
       *  The Application ID for the Pocket connection.
       */
      _defineProperty(_this, "applicationId", void 0);
      /**
       *  The Application Secret for making authenticated requests
       *  to the Pocket connection.
       */
      _defineProperty(_this, "applicationSecret", void 0);
      (0, index_js_1.defineProperties)(_this, {
        applicationId: applicationId,
        applicationSecret: applicationSecret
      });
      return _this;
    }
    _inherits(PocketProvider, _provider_jsonrpc_js_);
    return _createClass(PocketProvider, [{
      key: "_getProvider",
      value: function _getProvider(chainId) {
        try {
          return new PocketProvider(chainId, this.applicationId, this.applicationSecret);
        } catch (error) {}
        return _superPropGet(PocketProvider, "_getProvider", this, 3)([chainId]);
      }
      /**
       *  Returns a prepared request for connecting to %%network%% with
       *  %%applicationId%%.
       */
    }, {
      key: "isCommunityResource",
      value: function isCommunityResource() {
        return this.applicationId === defaultApplicationId;
      }
    }], [{
      key: "getRequest",
      value: function getRequest(network, applicationId, applicationSecret) {
        if (applicationId == null) {
          applicationId = defaultApplicationId;
        }
        var request = new index_js_1.FetchRequest("https://".concat(getHost(network.name), "/v1/lb/").concat(applicationId));
        request.allowGzip = true;
        if (applicationSecret) {
          request.setCredentials("", applicationSecret);
        }
        if (applicationId === defaultApplicationId) {
          request.retryFunc = /*#__PURE__*/function () {
            var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(request, response, attempt) {
              return _regeneratorRuntime().wrap(function _callee$(_context) {
                while (1) switch (_context.prev = _context.next) {
                  case 0:
                    (0, community_js_1.showThrottleMessage)("PocketProvider");
                    return _context.abrupt("return", true);
                  case 2:
                  case "end":
                    return _context.stop();
                }
              }, _callee);
            }));
            return function (_x, _x2, _x3) {
              return _ref.apply(this, arguments);
            };
          }();
        }
        return request;
      }
    }]);
  }(provider_jsonrpc_js_1.JsonRpcProvider);
  providerPocket.PocketProvider = PocketProvider;
  return providerPocket;
}

var providerIpcsocket = {};

var hasRequiredProviderIpcsocket;
function requireProviderIpcsocket() {
  if (hasRequiredProviderIpcsocket) return providerIpcsocket;
  hasRequiredProviderIpcsocket = 1;
  Object.defineProperty(providerIpcsocket, "__esModule", {
    value: true
  });
  providerIpcsocket.IpcSocketProvider = void 0;
  var net_1 = require$$3$1;
  var provider_socket_js_1 = /*@__PURE__*/requireProviderSocket();
  // @TODO: Is this sufficient? Is this robust? Will newlines occur between
  // all payloads and only between payloads?
  function splitBuffer(data) {
    var messages = [];
    var lastStart = 0;
    while (true) {
      var nl = data.indexOf(10, lastStart);
      if (nl === -1) {
        break;
      }
      messages.push(data.subarray(lastStart, nl).toString().trim());
      lastStart = nl + 1;
    }
    return {
      messages: messages,
      remaining: data.subarray(lastStart)
    };
  }
  /**
   *  An **IpcSocketProvider** connects over an IPC socket on the host
   *  which provides fast access to the node, but requires the node and
   *  the script run on the same machine.
   */
  var _socket = /*#__PURE__*/new WeakMap();
  var IpcSocketProvider = /*#__PURE__*/function (_provider_socket_js_) {
    function IpcSocketProvider(path, network, options) {
      var _this;
      _classCallCheck(this, IpcSocketProvider);
      _this = _callSuper(this, IpcSocketProvider, [network, options]);
      _classPrivateFieldInitSpec(_this, _socket, void 0);
      _classPrivateFieldSet2(_socket, _this, (0, net_1.connect)(path));
      _this.socket.on("ready", /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              _context.next = 3;
              return _this._start();
            case 3:
              _context.next = 8;
              break;
            case 5:
              _context.prev = 5;
              _context.t0 = _context["catch"](0);
              console.log("failed to start IpcSocketProvider", _context.t0);
              // @TODO: Now what? Restart?
            case 8:
            case "end":
              return _context.stop();
          }
        }, _callee, null, [[0, 5]]);
      })));
      var response = Buffer.alloc(0);
      _this.socket.on("data", function (data) {
        response = Buffer.concat([response, data]);
        var _splitBuffer = splitBuffer(response),
          messages = _splitBuffer.messages,
          remaining = _splitBuffer.remaining;
        messages.forEach(function (message) {
          _this._processMessage(message);
        });
        response = remaining;
      });
      _this.socket.on("end", function () {
        _this.emit("close");
        _this.socket.destroy();
        _this.socket.end();
      });
      return _this;
    }
    _inherits(IpcSocketProvider, _provider_socket_js_);
    return _createClass(IpcSocketProvider, [{
      key: "socket",
      get:
      /**
       *  The connected socket.
       */
      function get() {
        return _classPrivateFieldGet2(_socket, this);
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this.socket.destroy();
        this.socket.end();
        _superPropGet(IpcSocketProvider, "destroy", this, 3)([]);
      }
    }, {
      key: "_write",
      value: function () {
        var _write2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(message) {
          return _regeneratorRuntime().wrap(function _callee2$(_context2) {
            while (1) switch (_context2.prev = _context2.next) {
              case 0:
                this.socket.write(message);
              case 1:
              case "end":
                return _context2.stop();
            }
          }, _callee2, this);
        }));
        function _write(_x) {
          return _write2.apply(this, arguments);
        }
        return _write;
      }()
    }]);
  }(provider_socket_js_1.SocketProvider);
  providerIpcsocket.IpcSocketProvider = IpcSocketProvider;
  return providerIpcsocket;
}

var hasRequiredProviders;
function requireProviders() {
  if (hasRequiredProviders) return providers;
  hasRequiredProviders = 1;
  (function (exports) {

    /**
     *  A **Provider** provides a connection to the blockchain, whch can be
     *  used to query its current state, simulate execution and send transactions
     *  to update the state.
     *
     *  It is one of the most fundamental components of interacting with a
     *  blockchain application, and there are many ways to connect, such as over
     *  HTTP, WebSockets or injected providers such as [MetaMask](link-metamask).
     *
     *  @_section: api/providers:Providers  [about-providers]
     */
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.SocketEventSubscriber = exports.SocketPendingSubscriber = exports.SocketBlockSubscriber = exports.SocketSubscriber = exports.WebSocketProvider = exports.SocketProvider = exports.IpcSocketProvider = exports.QuickNodeProvider = exports.PocketProvider = exports.InfuraWebSocketProvider = exports.InfuraProvider = exports.EtherscanPlugin = exports.EtherscanProvider = exports.ChainstackProvider = exports.CloudflareProvider = exports.AnkrProvider = exports.AlchemyProvider = exports.BrowserProvider = exports.JsonRpcSigner = exports.JsonRpcProvider = exports.JsonRpcApiProvider = exports.FallbackProvider = exports.copyRequest = exports.TransactionResponse = exports.TransactionReceipt = exports.Log = exports.FeeData = exports.Block = exports.FetchUrlFeeDataNetworkPlugin = exports.FeeDataNetworkPlugin = exports.EnsPlugin = exports.GasCostPlugin = exports.NetworkPlugin = exports.NonceManager = exports.Network = exports.MulticoinProviderPlugin = exports.EnsResolver = exports.getDefaultProvider = exports.showThrottleMessage = exports.VoidSigner = exports.AbstractSigner = exports.UnmanagedSubscriber = exports.AbstractProvider = void 0;
    var abstract_provider_js_1 = /*@__PURE__*/requireAbstractProvider();
    Object.defineProperty(exports, "AbstractProvider", {
      enumerable: true,
      get: function get() {
        return abstract_provider_js_1.AbstractProvider;
      }
    });
    Object.defineProperty(exports, "UnmanagedSubscriber", {
      enumerable: true,
      get: function get() {
        return abstract_provider_js_1.UnmanagedSubscriber;
      }
    });
    var abstract_signer_js_1 = /*@__PURE__*/requireAbstractSigner();
    Object.defineProperty(exports, "AbstractSigner", {
      enumerable: true,
      get: function get() {
        return abstract_signer_js_1.AbstractSigner;
      }
    });
    Object.defineProperty(exports, "VoidSigner", {
      enumerable: true,
      get: function get() {
        return abstract_signer_js_1.VoidSigner;
      }
    });
    var community_js_1 = /*@__PURE__*/requireCommunity();
    Object.defineProperty(exports, "showThrottleMessage", {
      enumerable: true,
      get: function get() {
        return community_js_1.showThrottleMessage;
      }
    });
    var default_provider_js_1 = /*@__PURE__*/requireDefaultProvider();
    Object.defineProperty(exports, "getDefaultProvider", {
      enumerable: true,
      get: function get() {
        return default_provider_js_1.getDefaultProvider;
      }
    });
    var ens_resolver_js_1 = /*@__PURE__*/requireEnsResolver();
    Object.defineProperty(exports, "EnsResolver", {
      enumerable: true,
      get: function get() {
        return ens_resolver_js_1.EnsResolver;
      }
    });
    Object.defineProperty(exports, "MulticoinProviderPlugin", {
      enumerable: true,
      get: function get() {
        return ens_resolver_js_1.MulticoinProviderPlugin;
      }
    });
    var network_js_1 = /*@__PURE__*/requireNetwork();
    Object.defineProperty(exports, "Network", {
      enumerable: true,
      get: function get() {
        return network_js_1.Network;
      }
    });
    var signer_noncemanager_js_1 = /*@__PURE__*/requireSignerNoncemanager();
    Object.defineProperty(exports, "NonceManager", {
      enumerable: true,
      get: function get() {
        return signer_noncemanager_js_1.NonceManager;
      }
    });
    var plugins_network_js_1 = /*@__PURE__*/requirePluginsNetwork();
    Object.defineProperty(exports, "NetworkPlugin", {
      enumerable: true,
      get: function get() {
        return plugins_network_js_1.NetworkPlugin;
      }
    });
    Object.defineProperty(exports, "GasCostPlugin", {
      enumerable: true,
      get: function get() {
        return plugins_network_js_1.GasCostPlugin;
      }
    });
    Object.defineProperty(exports, "EnsPlugin", {
      enumerable: true,
      get: function get() {
        return plugins_network_js_1.EnsPlugin;
      }
    });
    Object.defineProperty(exports, "FeeDataNetworkPlugin", {
      enumerable: true,
      get: function get() {
        return plugins_network_js_1.FeeDataNetworkPlugin;
      }
    });
    Object.defineProperty(exports, "FetchUrlFeeDataNetworkPlugin", {
      enumerable: true,
      get: function get() {
        return plugins_network_js_1.FetchUrlFeeDataNetworkPlugin;
      }
    });
    var provider_js_1 = /*@__PURE__*/requireProvider();
    Object.defineProperty(exports, "Block", {
      enumerable: true,
      get: function get() {
        return provider_js_1.Block;
      }
    });
    Object.defineProperty(exports, "FeeData", {
      enumerable: true,
      get: function get() {
        return provider_js_1.FeeData;
      }
    });
    Object.defineProperty(exports, "Log", {
      enumerable: true,
      get: function get() {
        return provider_js_1.Log;
      }
    });
    Object.defineProperty(exports, "TransactionReceipt", {
      enumerable: true,
      get: function get() {
        return provider_js_1.TransactionReceipt;
      }
    });
    Object.defineProperty(exports, "TransactionResponse", {
      enumerable: true,
      get: function get() {
        return provider_js_1.TransactionResponse;
      }
    });
    Object.defineProperty(exports, "copyRequest", {
      enumerable: true,
      get: function get() {
        return provider_js_1.copyRequest;
      }
    });
    var provider_fallback_js_1 = /*@__PURE__*/requireProviderFallback();
    Object.defineProperty(exports, "FallbackProvider", {
      enumerable: true,
      get: function get() {
        return provider_fallback_js_1.FallbackProvider;
      }
    });
    var provider_jsonrpc_js_1 = /*@__PURE__*/requireProviderJsonrpc();
    Object.defineProperty(exports, "JsonRpcApiProvider", {
      enumerable: true,
      get: function get() {
        return provider_jsonrpc_js_1.JsonRpcApiProvider;
      }
    });
    Object.defineProperty(exports, "JsonRpcProvider", {
      enumerable: true,
      get: function get() {
        return provider_jsonrpc_js_1.JsonRpcProvider;
      }
    });
    Object.defineProperty(exports, "JsonRpcSigner", {
      enumerable: true,
      get: function get() {
        return provider_jsonrpc_js_1.JsonRpcSigner;
      }
    });
    var provider_browser_js_1 = /*@__PURE__*/requireProviderBrowser();
    Object.defineProperty(exports, "BrowserProvider", {
      enumerable: true,
      get: function get() {
        return provider_browser_js_1.BrowserProvider;
      }
    });
    var provider_alchemy_js_1 = /*@__PURE__*/requireProviderAlchemy();
    Object.defineProperty(exports, "AlchemyProvider", {
      enumerable: true,
      get: function get() {
        return provider_alchemy_js_1.AlchemyProvider;
      }
    });
    var provider_ankr_js_1 = /*@__PURE__*/requireProviderAnkr();
    Object.defineProperty(exports, "AnkrProvider", {
      enumerable: true,
      get: function get() {
        return provider_ankr_js_1.AnkrProvider;
      }
    });
    var provider_cloudflare_js_1 = /*@__PURE__*/requireProviderCloudflare();
    Object.defineProperty(exports, "CloudflareProvider", {
      enumerable: true,
      get: function get() {
        return provider_cloudflare_js_1.CloudflareProvider;
      }
    });
    var provider_chainstack_js_1 = /*@__PURE__*/requireProviderChainstack();
    Object.defineProperty(exports, "ChainstackProvider", {
      enumerable: true,
      get: function get() {
        return provider_chainstack_js_1.ChainstackProvider;
      }
    });
    var provider_etherscan_js_1 = /*@__PURE__*/requireProviderEtherscan();
    Object.defineProperty(exports, "EtherscanProvider", {
      enumerable: true,
      get: function get() {
        return provider_etherscan_js_1.EtherscanProvider;
      }
    });
    Object.defineProperty(exports, "EtherscanPlugin", {
      enumerable: true,
      get: function get() {
        return provider_etherscan_js_1.EtherscanPlugin;
      }
    });
    var provider_infura_js_1 = /*@__PURE__*/requireProviderInfura();
    Object.defineProperty(exports, "InfuraProvider", {
      enumerable: true,
      get: function get() {
        return provider_infura_js_1.InfuraProvider;
      }
    });
    Object.defineProperty(exports, "InfuraWebSocketProvider", {
      enumerable: true,
      get: function get() {
        return provider_infura_js_1.InfuraWebSocketProvider;
      }
    });
    var provider_pocket_js_1 = /*@__PURE__*/requireProviderPocket();
    Object.defineProperty(exports, "PocketProvider", {
      enumerable: true,
      get: function get() {
        return provider_pocket_js_1.PocketProvider;
      }
    });
    var provider_quicknode_js_1 = /*@__PURE__*/requireProviderQuicknode();
    Object.defineProperty(exports, "QuickNodeProvider", {
      enumerable: true,
      get: function get() {
        return provider_quicknode_js_1.QuickNodeProvider;
      }
    });
    var provider_ipcsocket_js_1 = /*@__PURE__*/requireProviderIpcsocket(); /*-browser*/
    Object.defineProperty(exports, "IpcSocketProvider", {
      enumerable: true,
      get: function get() {
        return provider_ipcsocket_js_1.IpcSocketProvider;
      }
    });
    var provider_socket_js_1 = /*@__PURE__*/requireProviderSocket();
    Object.defineProperty(exports, "SocketProvider", {
      enumerable: true,
      get: function get() {
        return provider_socket_js_1.SocketProvider;
      }
    });
    var provider_websocket_js_1 = /*@__PURE__*/requireProviderWebsocket();
    Object.defineProperty(exports, "WebSocketProvider", {
      enumerable: true,
      get: function get() {
        return provider_websocket_js_1.WebSocketProvider;
      }
    });
    var provider_socket_js_2 = /*@__PURE__*/requireProviderSocket();
    Object.defineProperty(exports, "SocketSubscriber", {
      enumerable: true,
      get: function get() {
        return provider_socket_js_2.SocketSubscriber;
      }
    });
    Object.defineProperty(exports, "SocketBlockSubscriber", {
      enumerable: true,
      get: function get() {
        return provider_socket_js_2.SocketBlockSubscriber;
      }
    });
    Object.defineProperty(exports, "SocketPendingSubscriber", {
      enumerable: true,
      get: function get() {
        return provider_socket_js_2.SocketPendingSubscriber;
      }
    });
    Object.defineProperty(exports, "SocketEventSubscriber", {
      enumerable: true,
      get: function get() {
        return provider_socket_js_2.SocketEventSubscriber;
      }
    });
  })(providers);
  return providers;
}

var wallet$1 = {};

var baseWallet = {};

var hasRequiredBaseWallet;
function requireBaseWallet() {
  if (hasRequiredBaseWallet) return baseWallet;
  hasRequiredBaseWallet = 1;
  Object.defineProperty(baseWallet, "__esModule", {
    value: true
  });
  baseWallet.BaseWallet = void 0;
  var index_js_1 = /*@__PURE__*/requireAddress$2();
  var index_js_2 = /*@__PURE__*/requireHash();
  var index_js_3 = /*@__PURE__*/requireProviders();
  var index_js_4 = /*@__PURE__*/requireTransaction();
  var index_js_5 = /*@__PURE__*/requireUtils$3();
  /**
   *  The **BaseWallet** is a stream-lined implementation of a
   *  [[Signer]] that operates with a private key.
   *
   *  It is preferred to use the [[Wallet]] class, as it offers
   *  additional functionality and simplifies loading a variety
   *  of JSON formats, Mnemonic Phrases, etc.
   *
   *  This class may be of use for those attempting to implement
   *  a minimal Signer.
   */
  var _signingKey = /*#__PURE__*/new WeakMap();
  var BaseWallet = /*#__PURE__*/function (_index_js_3$AbstractS) {
    /**
     *  Creates a new BaseWallet for %%privateKey%%, optionally
     *  connected to %%provider%%.
     *
     *  If %%provider%% is not specified, only offline methods can
     *  be used.
     */
    function BaseWallet(privateKey, provider) {
      var _this;
      _classCallCheck(this, BaseWallet);
      _this = _callSuper(this, BaseWallet, [provider]);
      /**
       *  The wallet address.
       */
      _defineProperty(_this, "address", void 0);
      _classPrivateFieldInitSpec(_this, _signingKey, void 0);
      (0, index_js_5.assertArgument)(privateKey && typeof privateKey.sign === "function", "invalid private key", "privateKey", "[ REDACTED ]");
      _classPrivateFieldSet2(_signingKey, _this, privateKey);
      var address = (0, index_js_4.computeAddress)(_this.signingKey.publicKey);
      (0, index_js_5.defineProperties)(_this, {
        address: address
      });
      return _this;
    }
    // Store private values behind getters to reduce visibility
    // in console.log
    /**
     *  The [[SigningKey]] used for signing payloads.
     */
    _inherits(BaseWallet, _index_js_3$AbstractS);
    return _createClass(BaseWallet, [{
      key: "signingKey",
      get: function get() {
        return _classPrivateFieldGet2(_signingKey, this);
      }
      /**
       *  The private key for this wallet.
       */
    }, {
      key: "privateKey",
      get: function get() {
        return this.signingKey.privateKey;
      }
    }, {
      key: "getAddress",
      value: function () {
        var _getAddress = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                return _context.abrupt("return", this.address);
              case 1:
              case "end":
                return _context.stop();
            }
          }, _callee, this);
        }));
        function getAddress() {
          return _getAddress.apply(this, arguments);
        }
        return getAddress;
      }()
    }, {
      key: "connect",
      value: function connect(provider) {
        return new BaseWallet(_classPrivateFieldGet2(_signingKey, this), provider);
      }
    }, {
      key: "signTransaction",
      value: function () {
        var _signTransaction = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(tx) {
          var _yield, to, from, btx;
          return _regeneratorRuntime().wrap(function _callee2$(_context2) {
            while (1) switch (_context2.prev = _context2.next) {
              case 0:
                tx = (0, index_js_3.copyRequest)(tx);
                // Replace any Addressable or ENS name with an address
                _context2.next = 3;
                return (0, index_js_5.resolveProperties)({
                  to: tx.to ? (0, index_js_1.resolveAddress)(tx.to, this.provider) : undefined,
                  from: tx.from ? (0, index_js_1.resolveAddress)(tx.from, this.provider) : undefined
                });
              case 3:
                _yield = _context2.sent;
                to = _yield.to;
                from = _yield.from;
                if (to != null) {
                  tx.to = to;
                }
                if (from != null) {
                  tx.from = from;
                }
                if (tx.from != null) {
                  (0, index_js_5.assertArgument)((0, index_js_1.getAddress)(tx.from) === this.address, "transaction from address mismatch", "tx.from", tx.from);
                  delete tx.from;
                }
                // Build the transaction
                btx = index_js_4.Transaction.from(tx);
                btx.signature = this.signingKey.sign(btx.unsignedHash);
                return _context2.abrupt("return", btx.serialized);
              case 12:
              case "end":
                return _context2.stop();
            }
          }, _callee2, this);
        }));
        function signTransaction(_x) {
          return _signTransaction.apply(this, arguments);
        }
        return signTransaction;
      }()
    }, {
      key: "signMessage",
      value: function () {
        var _signMessage = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(message) {
          return _regeneratorRuntime().wrap(function _callee3$(_context3) {
            while (1) switch (_context3.prev = _context3.next) {
              case 0:
                return _context3.abrupt("return", this.signMessageSync(message));
              case 1:
              case "end":
                return _context3.stop();
            }
          }, _callee3, this);
        }));
        function signMessage(_x2) {
          return _signMessage.apply(this, arguments);
        }
        return signMessage;
      }() // @TODO: Add a secialized signTx and signTyped sync that enforces
      // all parameters are known?
      /**
       *  Returns the signature for %%message%% signed with this wallet.
       */
    }, {
      key: "signMessageSync",
      value: function signMessageSync(message) {
        return this.signingKey.sign((0, index_js_2.hashMessage)(message)).serialized;
      }
    }, {
      key: "signTypedData",
      value: function () {
        var _signTypedData = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee5(domain, types, value) {
          var _this2 = this;
          var populated;
          return _regeneratorRuntime().wrap(function _callee5$(_context5) {
            while (1) switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return index_js_2.TypedDataEncoder.resolveNames(domain, types, value, /*#__PURE__*/function () {
                  var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4(name) {
                    var address;
                    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
                      while (1) switch (_context4.prev = _context4.next) {
                        case 0:
                          // @TODO: this should use resolveName; addresses don't
                          //        need a provider
                          (0, index_js_5.assert)(_this2.provider != null, "cannot resolve ENS names without a provider", "UNSUPPORTED_OPERATION", {
                            operation: "resolveName",
                            info: {
                              name: name
                            }
                          });
                          _context4.next = 3;
                          return _this2.provider.resolveName(name);
                        case 3:
                          address = _context4.sent;
                          (0, index_js_5.assert)(address != null, "unconfigured ENS name", "UNCONFIGURED_NAME", {
                            value: name
                          });
                          return _context4.abrupt("return", address);
                        case 6:
                        case "end":
                          return _context4.stop();
                      }
                    }, _callee4);
                  }));
                  return function (_x6) {
                    return _ref.apply(this, arguments);
                  };
                }());
              case 2:
                populated = _context5.sent;
                return _context5.abrupt("return", this.signingKey.sign(index_js_2.TypedDataEncoder.hash(populated.domain, types, populated.value)).serialized);
              case 4:
              case "end":
                return _context5.stop();
            }
          }, _callee5, this);
        }));
        function signTypedData(_x3, _x4, _x5) {
          return _signTypedData.apply(this, arguments);
        }
        return signTypedData;
      }()
    }]);
  }(index_js_3.AbstractSigner);
  baseWallet.BaseWallet = BaseWallet;
  return baseWallet;
}

var hdwallet = {};

var langEn = {};

var wordlistOwl = {};

var decodeOwl = {};

var hasRequiredDecodeOwl;
function requireDecodeOwl() {
  if (hasRequiredDecodeOwl) return decodeOwl;
  hasRequiredDecodeOwl = 1;
  Object.defineProperty(decodeOwl, "__esModule", {
    value: true
  });
  decodeOwl.decodeOwl = decodeOwl.decode = void 0;
  var index_js_1 = /*@__PURE__*/requireUtils$3();
  var subsChrs = " !#$%&'()*+,-./<=>?@[]^_`{|}~";
  var Word = /^[a-z]*$/i;
  function unfold(words, sep) {
    var initial = 97;
    return words.reduce(function (accum, word) {
      if (word === sep) {
        initial++;
      } else if (word.match(Word)) {
        accum.push(String.fromCharCode(initial) + word);
      } else {
        initial = 97;
        accum.push(word);
      }
      return accum;
    }, []);
  }
  /**
   *  @_ignore
   */
  function decode(data, subs) {
    // Replace all the substitutions with their expanded form
    for (var i = subsChrs.length - 1; i >= 0; i--) {
      data = data.split(subsChrs[i]).join(subs.substring(2 * i, 2 * i + 2));
    }
    // Get all tle clumps; each suffix, first-increment and second-increment
    var clumps = [];
    var leftover = data.replace(/(:|([0-9])|([A-Z][a-z]*))/g, function (all, item, semi, word) {
      if (semi) {
        for (var _i = parseInt(semi); _i >= 0; _i--) {
          clumps.push(";");
        }
      } else {
        clumps.push(item.toLowerCase());
      }
      return "";
    });
    /* c8 ignore start */
    if (leftover) {
      throw new Error("leftovers: ".concat(JSON.stringify(leftover)));
    }
    /* c8 ignore stop */
    return unfold(unfold(clumps, ";"), ":");
  }
  decodeOwl.decode = decode;
  /**
   *  @_ignore
   */
  function decodeOwl$1(data) {
    (0, index_js_1.assertArgument)(data[0] === "0", "unsupported auwl data", "data", data);
    return decode(data.substring(1 + 2 * subsChrs.length), data.substring(1, 1 + 2 * subsChrs.length));
  }
  decodeOwl.decodeOwl = decodeOwl$1;
  return decodeOwl;
}

var wordlist = {};

var hasRequiredWordlist;
function requireWordlist() {
  if (hasRequiredWordlist) return wordlist;
  hasRequiredWordlist = 1;
  Object.defineProperty(wordlist, "__esModule", {
    value: true
  });
  wordlist.Wordlist = void 0;
  var index_js_1 = /*@__PURE__*/requireUtils$3();
  /**
   *  A Wordlist represents a collection of language-specific
   *  words used to encode and devoce [[link-bip-39]] encoded data
   *  by mapping words to 11-bit values and vice versa.
   */
  var Wordlist = /*#__PURE__*/function () {
    /**
     *  Creates a new Wordlist instance.
     *
     *  Sub-classes MUST call this if they provide their own constructor,
     *  passing in the locale string of the language.
     *
     *  Generally there is no need to create instances of a Wordlist,
     *  since each language-specific Wordlist creates an instance and
     *  there is no state kept internally, so they are safe to share.
     */
    function Wordlist(locale) {
      _classCallCheck(this, Wordlist);
      _defineProperty(this, "locale", void 0);
      (0, index_js_1.defineProperties)(this, {
        locale: locale
      });
    }
    /**
     *  Sub-classes may override this to provide a language-specific
     *  method for spliting %%phrase%% into individual words.
     *
     *  By default, %%phrase%% is split using any sequences of
     *  white-space as defined by regular expressions (i.e. ``/\s+/``).
     */
    return _createClass(Wordlist, [{
      key: "split",
      value: function split(phrase) {
        return phrase.toLowerCase().split(/\s+/g);
      }
      /**
       *  Sub-classes may override this to provider a language-specific
       *  method for joining %%words%% into a phrase.
       *
       *  By default, %%words%% are joined by a single space.
       */
    }, {
      key: "join",
      value: function join(words) {
        return words.join(" ");
      }
    }]);
  }();
  wordlist.Wordlist = Wordlist;
  return wordlist;
}

var hasRequiredWordlistOwl;
function requireWordlistOwl() {
  if (hasRequiredWordlistOwl) return wordlistOwl;
  hasRequiredWordlistOwl = 1;
  // Use the encode-latin.js script to create the necessary
  // data files to be consumed by this class
  Object.defineProperty(wordlistOwl, "__esModule", {
    value: true
  });
  wordlistOwl.WordlistOwl = void 0;
  var index_js_1 = /*@__PURE__*/requireHash();
  var index_js_2 = /*@__PURE__*/requireUtils$3();
  var decode_owl_js_1 = /*@__PURE__*/requireDecodeOwl();
  var wordlist_js_1 = /*@__PURE__*/requireWordlist();
  /**
   *  An OWL format Wordlist is an encoding method that exploits
   *  the general locality of alphabetically sorted words to
   *  achieve a simple but effective means of compression.
   *
   *  This class is generally not useful to most developers as
   *  it is used mainly internally to keep Wordlists for languages
   *  based on ASCII-7 small.
   *
   *  If necessary, there are tools within the ``generation/`` folder
   *  to create the necessary data.
   */
  var _data = /*#__PURE__*/new WeakMap();
  var _checksum = /*#__PURE__*/new WeakMap();
  var _words = /*#__PURE__*/new WeakMap();
  var _WordlistOwl_brand = /*#__PURE__*/new WeakSet();
  var WordlistOwl = /*#__PURE__*/function (_wordlist_js_1$Wordli) {
    /**
     *  Creates a new Wordlist for %%locale%% using the OWL %%data%%
     *  and validated against the %%checksum%%.
     */
    function WordlistOwl(locale, data, _checksum2) {
      var _this;
      _classCallCheck(this, WordlistOwl);
      _this = _callSuper(this, WordlistOwl, [locale]);
      _classPrivateMethodInitSpec(_this, _WordlistOwl_brand);
      _classPrivateFieldInitSpec(_this, _data, void 0);
      _classPrivateFieldInitSpec(_this, _checksum, void 0);
      _classPrivateFieldInitSpec(_this, _words, void 0);
      _classPrivateFieldSet2(_data, _this, data);
      _classPrivateFieldSet2(_checksum, _this, _checksum2);
      _classPrivateFieldSet2(_words, _this, null);
      return _this;
    }
    /**
     *  The OWL-encoded data.
     */
    _inherits(WordlistOwl, _wordlist_js_1$Wordli);
    return _createClass(WordlistOwl, [{
      key: "_data",
      get: function get() {
        return _classPrivateFieldGet2(_data, this);
      }
      /**
       *  Decode all the words for the wordlist.
       */
    }, {
      key: "_decodeWords",
      value: function _decodeWords() {
        return (0, decode_owl_js_1.decodeOwl)(_classPrivateFieldGet2(_data, this));
      }
    }, {
      key: "getWord",
      value: function getWord(index) {
        var words = _assertClassBrand(_WordlistOwl_brand, this, _loadWords).call(this);
        (0, index_js_2.assertArgument)(index >= 0 && index < words.length, "invalid word index: ".concat(index), "index", index);
        return words[index];
      }
    }, {
      key: "getWordIndex",
      value: function getWordIndex(word) {
        return _assertClassBrand(_WordlistOwl_brand, this, _loadWords).call(this).indexOf(word);
      }
    }]);
  }(wordlist_js_1.Wordlist);
  function _loadWords() {
    if (_classPrivateFieldGet2(_words, this) == null) {
      var words = this._decodeWords();
      // Verify the computed list matches the official list
      var checksum = (0, index_js_1.id)(words.join("\n") + "\n");
      /* c8 ignore start */
      if (checksum !== _classPrivateFieldGet2(_checksum, this)) {
        throw new Error("BIP39 Wordlist for ".concat(this.locale, " FAILED"));
      }
      /* c8 ignore stop */
      _classPrivateFieldSet2(_words, this, words);
    }
    return _classPrivateFieldGet2(_words, this);
  }
  wordlistOwl.WordlistOwl = WordlistOwl;
  return wordlistOwl;
}

var hasRequiredLangEn;
function requireLangEn() {
  if (hasRequiredLangEn) return langEn;
  hasRequiredLangEn = 1;
  Object.defineProperty(langEn, "__esModule", {
    value: true
  });
  langEn.LangEn = void 0;
  var wordlist_owl_js_1 = /*@__PURE__*/requireWordlistOwl();
  var words = "0erleonalorenseinceregesticitStanvetearctssi#ch2Athck&tneLl0And#Il.yLeOutO=S|S%b/ra@SurdU'0Ce[Cid|CountCu'Hie=IdOu,-Qui*Ro[TT]T%T*[Tu$0AptDD-tD*[Ju,M.UltV<)Vi)0Rob-0FairF%dRaid0A(EEntRee0Ead0MRRp%tS!_rmBumCoholErtI&LLeyLowMo,O}PhaReadySoT Ways0A>urAz(gOngOuntU'd0Aly,Ch%Ci|G G!GryIm$K!Noun)Nu$O` Sw T&naTiqueXietyY1ArtOlogyPe?P!Pro=Ril1ChCt-EaEnaGueMMedM%MyOundR<+Re,Ri=RowTTefa@Ti,Tw%k0KPe@SaultSetSi,SumeThma0H!>OmTa{T&dT.udeTra@0Ct]D.Gu,NtTh%ToTumn0Era+OcadoOid0AkeA*AyEsomeFulKw?d0Is:ByChel%C#D+GL<)Lc#y~MbooN<aNn RRelyRga(R*lSeS-SketTt!3A^AnAutyCau'ComeEfF%eG(Ha=H(dLie=LowLtN^Nef./TrayTt Twe&Y#d3Cyc!DKeNdOlogyRdR`Tt _{AdeAmeAnketA,EakE[IndOodO[omOu'UeUrUsh_rdAtDyIlMbNeNusOkO,Rd R(gRrowSsTtomUn)XY_{etA(AndA[A=EadEezeI{Id+IefIghtIngIskOccoliOk&OnzeOomO` OwnUsh2Bb!DdyD+tFf$oIldLbLkL!tNd!Nk Rd&Rg R,SS(e[SyTt Y Zz:Bba+B(B!CtusGeKe~LmM aMpNN$N)lNdyNn#NoeNvasNy#Pab!P.$Pta(RRb#RdRgoRpetRryRtSeShS(o/!Su$TT$ogT^Teg%yTt!UghtU'Ut]Ve3Il(gL yM|NsusNturyRe$Rta(_irAlkAmp]An+AosApt Ar+A'AtEapE{Ee'EfErryE,I{&IefIldIm}yOi)Oo'R#-U{!UnkUrn0G?Nnam#Rc!Tiz&TyVil_imApArifyAwAyE<ErkEv I{I|IffImbIn-IpO{OgO'O`OudOwnUbUmpU, Ut^_^A,C#utDeFfeeIlInL!@L%LumnMb(eMeMf%tM-Mm#Mp<yNc tNdu@NfirmNg*[N}@Nsid NtrolNv()OkOlPp PyR$ReRnR*@/Tt#U^UntryUp!Ur'Us(V Yo>_{Ad!AftAmA}AshAt AwlAzyEamEd.EekEwI{etImeIspIt-OpO[Ou^OwdUci$UelUi'Umb!Un^UshYY,$2BeLtu*PPbo?dRiousRr|Rta(R=Sh]/omTe3C!:DMa+MpN)Ng R(gShUght WnY3AlBa>BrisCadeCemb CideCl(eC%a>C*a'ErF&'F(eFyG*eLayLiv M<dMi'Ni$Nti,NyP?tP&dPos.P`PutyRi=ScribeS tSignSkSpair/royTailTe@VelopVi)Vo>3AgramAlAm#dAryCeE'lEtFf G.$Gn.yLemmaNn NosaurRe@RtSag*eScov Sea'ShSmi[S%d Splay/<)V tVideV%)Zzy5Ct%Cum|G~Lph(Ma(Na>NkeyN%OrSeUb!Ve_ftAg#AmaA,-AwEamE[IftIllInkIpI=OpUmY2CkMbNeR(g/T^Ty1Arf1Nam-:G G!RlyRnR`Sily/Sy1HoOlogyOnomy0GeItUca>1F%t0G1GhtTh 2BowD E@r-Eg<tEm|Eph<tEvat%I>Se0B?kBodyBra)Er+Ot]PloyPow Pty0Ab!A@DD![D%'EmyErgyF%)Ga+G(eH<)JoyLi,OughR-hRollSu*T Ti*TryVelope1Isode0U$Uip0AA'OdeOs]R%Upt0CapeSayS&)Ta>0Ern$H-s1Id&)IlOkeOl=1A@Amp!Ce[Ch<+C.eCludeCu'Ecu>Erci'Hau,Hib.I!I,ItOt-P<dPe@Pi*Pla(Po'P*[T&dTra0EEbrow:Br-CeCultyDeIntI`~L'MeMilyMousNNcyNtasyRmSh]TT$Th TigueUltV%.e3Atu*Bru?yD $EEdElMa!N)/iv$T^V W3B Ct]EldGu*LeLmLt N$NdNeNg NishReRmR,Sc$ShTT}[X_gAmeAshAtAv%EeIghtIpOatO{O%Ow UidUshY_mCusGIlLd~owOdOtR)Re,R+tRkRtu}RumRw?dSsil/ UndX_gi!AmeEqu|EshI&dIn+OgOntO,OwnOz&U.2ElNNnyRna)RyTu*:D+tInLaxy~ yMePRa+Rba+Rd&Rl-Rm|SSpTeTh U+Ze3N $NiusN*Nt!Nu(e/u*2O,0AntFtGg!Ng RaffeRlVe_dAn)A*A[IdeImp'ObeOomOryO=OwUe_tDde[LdOdO'RillaSpelSsipV nWn_bA)A(AntApeA[Av.yEatE&IdIefItOc yOupOwUnt_rdE[IdeIltIt?N3M:B.IrLfMm M, NdPpyRb%RdRshR=,TVeWkZ?d3AdAl`ArtAvyD+hogIght~oLmetLpNRo3Dd&Gh~NtPRe/%y5BbyCkeyLdLeLiday~owMeNeyOdPeRnRr%R'Sp.$/TelUrV 5BGeM<Mb!M%Nd*dNgryNtRd!RryRtSb<d3Brid:1EOn0EaEntifyLe2N%e4LLeg$L}[0A+Ita>M&'Mu}Pa@Po'Pro=Pul'0ChCludeComeC*a'DexD-a>Do%Du,ryF<tFl-tF%mHa!H .Iti$Je@JuryMa>N Noc|PutQuiryS<eSe@SideSpi*/$lTa@T e,ToVe,V.eVol=3On0L<dOla>Sue0Em1Ory:CketGu?RZz3AlousAns~yWel9BInKeUr}yY5D+I)MpNg!Ni%Nk/:Ng?oo3EnEpT^upY3CkDD}yNdNgdomSsTT^&TeTt&Wi4EeIfeO{Ow:BBelB%Dd DyKeMpNgua+PtopR+T T(UghUndryVaWWnWsu.Y Zy3Ad AfArnA=Ctu*FtGG$G&dIsu*M#NdNg`NsOp?dSs#Tt Vel3ArB tyBr?yC&'FeFtGhtKeMbM.NkOnQuid/Tt!VeZ?d5AdAnB, C$CkG-NelyNgOpTt yUdUn+VeY$5CkyGga+Mb N?N^Xury3R-s:Ch(eDG-G}tIdIlInJ%KeMm$NNa+Nda>NgoNs]Nu$P!Rb!R^Rg(R(eRketRria+SkSs/ T^T i$ThTrixTt XimumZe3AdowAnAsu*AtCh<-D$DiaLodyLtMb M%yNt]NuRcyR+R.RryShSsa+T$Thod3Dd!DnightLk~]M-NdNimumN%Nu>Rac!Rr%S ySs/akeXXedXtu*5Bi!DelDifyMM|N.%NkeyN, N`OnR$ReRn(gSqu.oTh T]T%Unta(U'VeVie5ChFf(LeLtiplySc!SeumShroomS-/Tu$3Self/ yTh:I=MePk(Rrow/yT]Tu*3ArCkEdGati=G!@I` PhewR=/TTw%kUtr$V WsXt3CeGht5B!I'M(eeOd!Rm$R`SeTab!TeTh(gTi)VelW5C!?Mb R'T:K0EyJe@Li+Scu*S =Ta(Vious0CurE<Tob 0Or1FF Fi)T&2L1Ay0DI=Ymp-0It0CeEI#L(eLy1EnEraIn]Po'T]1An+B.Ch?dD D(?yG<I|Ig($Ph<0Tr-h0H 0Tdo%T TputTside0AlEnEr0NN 0Yg&0/ 0O}:CtDd!GeIrLa)LmNdaNelN-N` P RadeR|RkRrotRtySsT^ThTi|TrolTt nU'VeYm|3A)AnutArAs<tL-<NN$tyNcilOp!Pp Rfe@Rm.Rs#T2O}OtoRa'Ys-$0AnoCn-Ctu*E)GGe#~LotNkO} Pe/olT^Zza_)A}tA,-A>AyEa'Ed+U{UgUn+2EmEtIntL?LeLi)NdNyOlPul?Rt]S.]Ssib!/TatoTt yV tyWd W _@i)Ai'Ed-tEf Epa*Es|EttyEv|I)IdeIm?yIntI%.yIs#Iva>IzeOb!mO)[Odu)Of.OgramOje@Omo>OofOp tyOsp O>@OudOvide2Bl-Dd(g~LpL'Mpk(N^PilPpyR^a'R.yRpo'R'ShTZz!3Ramid:99Al.yAntumArt E,]I{ItIzO>:Bb.Cco#CeCkD?DioIlInI'~yMpN^NdomN+PidReTeTh V&WZ%3AdyAlAs#BelBuildC$lCei=CipeC%dCyc!Du)F!@F%mFu'G]G*tGul?Je@LaxLea'LiefLyMa(Memb M(dMo=Nd NewNtOp&PairPeatPla)P%tQui*ScueSemb!Si,Sour)Sp#'SultTi*T*atTurnUn]Ve$ViewW?d2Y`m0BBb#CeChDeD+F!GhtGidNgOtPp!SkTu$V$V 5AdA,BotBu,CketM<)OfOkieOmSeTa>UghUndU>Y$5Bb DeGLeNNwayR$:DDd!D}[FeIlLadLm#L#LtLu>MeMp!NdTisfyToshiU)Usa+VeY1A!AnA*Att E}HemeHoolI&)I[%sOrp]OutRapRe&RiptRub1AAr^As#AtC#dC*tCt]Cur.yEdEkGm|Le@~M(?Ni%N'Nt&)RiesRvi)Ss]Tt!TupV&_dowAftAllowA*EdEllEriffIeldIftI}IpIv O{OeOotOpOrtOuld O=RimpRugUff!Y0Bl(gCkDeE+GhtGnL|Lk~yLv Mil?Mp!N)NgR&/ Tua>XZe1A>Et^IIllInIrtUll0AbAmEepEnd I)IdeIghtImOg<OtOwUsh0AllArtI!OkeOo`0A{AkeApIffOw0ApCc Ci$CkDaFtL?Ldi LidLut]L=Me#eNgOnRryRtUlUndUpUr)U`0A)A*Ati$AwnEakEci$EedEllEndH eI)Id IkeInIr.L.OilOns%O#OrtOtRayReadR(gY0Ua*UeezeUir*l_b!AdiumAffA+AirsAmpAndArtA>AyEakEelEmEpE*oI{IllIngO{Oma^O}OolOryO=Ra>gyReetRikeR#gRugg!Ud|UffUmb!Y!0Bje@Bm.BwayC)[ChDd&Ff G?G+,ItMm NNnyN'tP PplyP*meReRfa)R+Rpri'RroundR=ySpe@/a(1AllowAmpApArmE?EetIftImIngIt^Ord1MbolMptomRup/em:B!Ck!GIlL|LkNkPeR+tSk/eTtooXi3A^Am~NN<tNnisNtRm/Xt_nkAtEmeEnE%yE*EyIngIsOughtReeRi=RowUmbUnd 0CketDeG LtMb MeNyPRedSsueT!5A,BaccoDayDdl EGe` I!tK&MatoM%rowNeNgueNightOlO`PP-Pp!R^RnadoRtoi'SsT$Uri,W?dW WnY_{AdeAff-Ag-A(Ansf ApAshA=lAyEatEeEndI$IbeI{Igg ImIpOphyOub!U{UeUlyUmpetU,U`Y2BeIt]Mb!NaN}lRkeyRnRt!1El=EntyI)InI,O1PeP-$:5Ly5B*lla0Ab!Awa*C!Cov D DoFairFoldHappyIf%mIqueItIv 'KnownLo{TilUsu$Veil1Da>GradeHoldOnP Set1B<Ge0A+EEdEfulE![U$0Il.y:C<tCuumGueLidL!yL=NNishP%Rious/Ult3H-!L=tNd%Ntu*NueRbRifyRs]RyS'lT <3Ab!Br<tCiousCt%yDeoEw~a+Nta+Ol(Rtu$RusSaS.Su$T$Vid5C$I)IdLc<oLumeTeYa+:GeG#ItLk~LnutNtRfa*RmRri%ShSp/eT VeY3Al`Ap#ArA'lA` BDd(gEk&dIrdLcome/T_!AtEatEelEnE*IpIsp 0DeD`FeLd~NNdowNeNgNkNn Nt ReSdomSeShT}[5LfM<Nd OdOlRdRkRldRryR`_pE{E,!I,I>Ong::Rd3Ar~ow9UUngU`:3BraRo9NeO";
  var checksum = "0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60";
  var _wordlist = null;
  /**
   *  The [[link-bip39-en]] for [mnemonic phrases](link-bip-39).
   *
   *  @_docloc: api/wordlists
   */
  var LangEn = /*#__PURE__*/function (_wordlist_owl_js_1$Wo) {
    /**
     *  Creates a new instance of the English language Wordlist.
     *
     *  This should be unnecessary most of the time as the exported
     *  [[langEn]] should suffice.
     *
     *  @_ignore:
     */
    function LangEn() {
      _classCallCheck(this, LangEn);
      return _callSuper(this, LangEn, ["en", words, checksum]);
    }
    /**
     *  Returns a singleton instance of a ``LangEn``, creating it
     *  if this is the first time being called.
     */
    _inherits(LangEn, _wordlist_owl_js_1$Wo);
    return _createClass(LangEn, null, [{
      key: "wordlist",
      value: function wordlist() {
        if (_wordlist == null) {
          _wordlist = new LangEn();
        }
        return _wordlist;
      }
    }]);
  }(wordlist_owl_js_1.WordlistOwl);
  langEn.LangEn = LangEn;
  return langEn;
}

var mnemonic = {};

var hasRequiredMnemonic;
function requireMnemonic() {
  if (hasRequiredMnemonic) return mnemonic;
  hasRequiredMnemonic = 1;
  Object.defineProperty(mnemonic, "__esModule", {
    value: true
  });
  mnemonic.Mnemonic = void 0;
  var index_js_1 = /*@__PURE__*/requireCrypto();
  var index_js_2 = /*@__PURE__*/requireUtils$3();
  var lang_en_js_1 = /*@__PURE__*/requireLangEn();
  // Returns a byte with the MSB bits set
  function getUpperMask(bits) {
    return (1 << bits) - 1 << 8 - bits & 0xff;
  }
  // Returns a byte with the LSB bits set
  function getLowerMask(bits) {
    return (1 << bits) - 1 & 0xff;
  }
  function mnemonicToEntropy(mnemonic, wordlist) {
    (0, index_js_2.assertNormalize)("NFKD");
    if (wordlist == null) {
      wordlist = lang_en_js_1.LangEn.wordlist();
    }
    var words = wordlist.split(mnemonic);
    (0, index_js_2.assertArgument)(words.length % 3 === 0 && words.length >= 12 && words.length <= 24, "invalid mnemonic length", "mnemonic", "[ REDACTED ]");
    var entropy = new Uint8Array(Math.ceil(11 * words.length / 8));
    var offset = 0;
    for (var i = 0; i < words.length; i++) {
      var index = wordlist.getWordIndex(words[i].normalize("NFKD"));
      (0, index_js_2.assertArgument)(index >= 0, "invalid mnemonic word at index ".concat(i), "mnemonic", "[ REDACTED ]");
      for (var bit = 0; bit < 11; bit++) {
        if (index & 1 << 10 - bit) {
          entropy[offset >> 3] |= 1 << 7 - offset % 8;
        }
        offset++;
      }
    }
    var entropyBits = 32 * words.length / 3;
    var checksumBits = words.length / 3;
    var checksumMask = getUpperMask(checksumBits);
    var checksum = (0, index_js_2.getBytes)((0, index_js_1.sha256)(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;
    (0, index_js_2.assertArgument)(checksum === (entropy[entropy.length - 1] & checksumMask), "invalid mnemonic checksum", "mnemonic", "[ REDACTED ]");
    return (0, index_js_2.hexlify)(entropy.slice(0, entropyBits / 8));
  }
  function entropyToMnemonic(entropy, wordlist) {
    (0, index_js_2.assertArgument)(entropy.length % 4 === 0 && entropy.length >= 16 && entropy.length <= 32, "invalid entropy size", "entropy", "[ REDACTED ]");
    if (wordlist == null) {
      wordlist = lang_en_js_1.LangEn.wordlist();
    }
    var indices = [0];
    var remainingBits = 11;
    for (var i = 0; i < entropy.length; i++) {
      // Consume the whole byte (with still more to go)
      if (remainingBits > 8) {
        indices[indices.length - 1] <<= 8;
        indices[indices.length - 1] |= entropy[i];
        remainingBits -= 8;
        // This byte will complete an 11-bit index
      } else {
        indices[indices.length - 1] <<= remainingBits;
        indices[indices.length - 1] |= entropy[i] >> 8 - remainingBits;
        // Start the next word
        indices.push(entropy[i] & getLowerMask(8 - remainingBits));
        remainingBits += 3;
      }
    }
    // Compute the checksum bits
    var checksumBits = entropy.length / 4;
    var checksum = parseInt((0, index_js_1.sha256)(entropy).substring(2, 4), 16) & getUpperMask(checksumBits);
    // Shift the checksum into the word indices
    indices[indices.length - 1] <<= checksumBits;
    indices[indices.length - 1] |= checksum >> 8 - checksumBits;
    return wordlist.join(indices.map(function (index) {
      return wordlist.getWord(index);
    }));
  }
  var _guard = {};
  /**
   *  A **Mnemonic** wraps all properties required to compute [[link-bip-39]]
   *  seeds and convert between phrases and entropy.
   */
  var Mnemonic = /*#__PURE__*/function () {
    /**
     *  @private
     */
    function Mnemonic(guard, entropy, phrase, password, wordlist) {
      _classCallCheck(this, Mnemonic);
      /**
       *  The mnemonic phrase of 12, 15, 18, 21 or 24 words.
       *
       *  Use the [[wordlist]] ``split`` method to get the individual words.
       */
      _defineProperty(this, "phrase", void 0);
      /**
       *  The password used for this mnemonic. If no password is used this
       *  is the empty string (i.e. ``""``) as per the specification.
       */
      _defineProperty(this, "password", void 0);
      /**
       *  The wordlist for this mnemonic.
       */
      _defineProperty(this, "wordlist", void 0);
      /**
       *  The underlying entropy which the mnemonic encodes.
       */
      _defineProperty(this, "entropy", void 0);
      if (password == null) {
        password = "";
      }
      if (wordlist == null) {
        wordlist = lang_en_js_1.LangEn.wordlist();
      }
      (0, index_js_2.assertPrivate)(guard, _guard, "Mnemonic");
      (0, index_js_2.defineProperties)(this, {
        phrase: phrase,
        password: password,
        wordlist: wordlist,
        entropy: entropy
      });
    }
    /**
     *  Returns the seed for the mnemonic.
     */
    return _createClass(Mnemonic, [{
      key: "computeSeed",
      value: function computeSeed() {
        var salt = (0, index_js_2.toUtf8Bytes)("mnemonic" + this.password, "NFKD");
        return (0, index_js_1.pbkdf2)((0, index_js_2.toUtf8Bytes)(this.phrase, "NFKD"), salt, 2048, 64, "sha512");
      }
      /**
       *  Creates a new Mnemonic for the %%phrase%%.
       *
       *  The default %%password%% is the empty string and the default
       *  wordlist is the [English wordlists](LangEn).
       */
    }], [{
      key: "fromPhrase",
      value: function fromPhrase(phrase, password, wordlist) {
        // Normalize the case and space; throws if invalid
        var entropy = mnemonicToEntropy(phrase, wordlist);
        phrase = entropyToMnemonic((0, index_js_2.getBytes)(entropy), wordlist);
        return new Mnemonic(_guard, entropy, phrase, password, wordlist);
      }
      /**
       *  Create a new **Mnemonic** from the %%entropy%%.
       *
       *  The default %%password%% is the empty string and the default
       *  wordlist is the [English wordlists](LangEn).
       */
    }, {
      key: "fromEntropy",
      value: function fromEntropy(_entropy, password, wordlist) {
        var entropy = (0, index_js_2.getBytes)(_entropy, "entropy");
        var phrase = entropyToMnemonic(entropy, wordlist);
        return new Mnemonic(_guard, (0, index_js_2.hexlify)(entropy), phrase, password, wordlist);
      }
      /**
       *  Returns the phrase for %%mnemonic%%.
       */
    }, {
      key: "entropyToPhrase",
      value: function entropyToPhrase(_entropy, wordlist) {
        var entropy = (0, index_js_2.getBytes)(_entropy, "entropy");
        return entropyToMnemonic(entropy, wordlist);
      }
      /**
       *  Returns the entropy for %%phrase%%.
       */
    }, {
      key: "phraseToEntropy",
      value: function phraseToEntropy(phrase, wordlist) {
        return mnemonicToEntropy(phrase, wordlist);
      }
      /**
       *  Returns true if %%phrase%% is a valid [[link-bip-39]] phrase.
       *
       *  This checks all the provided words belong to the %%wordlist%%,
       *  that the length is valid and the checksum is correct.
       */
    }, {
      key: "isValidMnemonic",
      value: function isValidMnemonic(phrase, wordlist) {
        try {
          mnemonicToEntropy(phrase, wordlist);
          return true;
        } catch (error) {}
        return false;
      }
    }]);
  }();
  mnemonic.Mnemonic = Mnemonic;
  return mnemonic;
}

var jsonKeystore = {};

var lib_commonjs = {};

var aes = {};

var hasRequiredAes;
function requireAes() {
  if (hasRequiredAes) return aes;
  hasRequiredAes = 1;
  /*! MIT License. Copyright 2015-2022 Richard Moore <me@ricmoo.com>. See LICENSE.txt. */
  var __classPrivateFieldGet = aes && aes.__classPrivateFieldGet || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var __classPrivateFieldSet = aes && aes.__classPrivateFieldSet || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var _AES_key, _AES_Kd, _AES_Ke;
  Object.defineProperty(aes, "__esModule", {
    value: true
  });
  aes.AES = void 0;
  // Number of rounds by keysize
  var numberOfRounds = {
    16: 10,
    24: 12,
    32: 14
  };
  // Round constant words
  var rcon = [0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91];
  // S-box and Inverse S-box (S is for Substitution)
  var S = [0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16];
  var Si = [0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb, 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e, 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73, 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4, 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d];
  // Transformations for encryption
  var T1 = [0xc66363a5, 0xf87c7c84, 0xee777799, 0xf67b7b8d, 0xfff2f20d, 0xd66b6bbd, 0xde6f6fb1, 0x91c5c554, 0x60303050, 0x02010103, 0xce6767a9, 0x562b2b7d, 0xe7fefe19, 0xb5d7d762, 0x4dababe6, 0xec76769a, 0x8fcaca45, 0x1f82829d, 0x89c9c940, 0xfa7d7d87, 0xeffafa15, 0xb25959eb, 0x8e4747c9, 0xfbf0f00b, 0x41adadec, 0xb3d4d467, 0x5fa2a2fd, 0x45afafea, 0x239c9cbf, 0x53a4a4f7, 0xe4727296, 0x9bc0c05b, 0x75b7b7c2, 0xe1fdfd1c, 0x3d9393ae, 0x4c26266a, 0x6c36365a, 0x7e3f3f41, 0xf5f7f702, 0x83cccc4f, 0x6834345c, 0x51a5a5f4, 0xd1e5e534, 0xf9f1f108, 0xe2717193, 0xabd8d873, 0x62313153, 0x2a15153f, 0x0804040c, 0x95c7c752, 0x46232365, 0x9dc3c35e, 0x30181828, 0x379696a1, 0x0a05050f, 0x2f9a9ab5, 0x0e070709, 0x24121236, 0x1b80809b, 0xdfe2e23d, 0xcdebeb26, 0x4e272769, 0x7fb2b2cd, 0xea75759f, 0x1209091b, 0x1d83839e, 0x582c2c74, 0x341a1a2e, 0x361b1b2d, 0xdc6e6eb2, 0xb45a5aee, 0x5ba0a0fb, 0xa45252f6, 0x763b3b4d, 0xb7d6d661, 0x7db3b3ce, 0x5229297b, 0xdde3e33e, 0x5e2f2f71, 0x13848497, 0xa65353f5, 0xb9d1d168, 0x00000000, 0xc1eded2c, 0x40202060, 0xe3fcfc1f, 0x79b1b1c8, 0xb65b5bed, 0xd46a6abe, 0x8dcbcb46, 0x67bebed9, 0x7239394b, 0x944a4ade, 0x984c4cd4, 0xb05858e8, 0x85cfcf4a, 0xbbd0d06b, 0xc5efef2a, 0x4faaaae5, 0xedfbfb16, 0x864343c5, 0x9a4d4dd7, 0x66333355, 0x11858594, 0x8a4545cf, 0xe9f9f910, 0x04020206, 0xfe7f7f81, 0xa05050f0, 0x783c3c44, 0x259f9fba, 0x4ba8a8e3, 0xa25151f3, 0x5da3a3fe, 0x804040c0, 0x058f8f8a, 0x3f9292ad, 0x219d9dbc, 0x70383848, 0xf1f5f504, 0x63bcbcdf, 0x77b6b6c1, 0xafdada75, 0x42212163, 0x20101030, 0xe5ffff1a, 0xfdf3f30e, 0xbfd2d26d, 0x81cdcd4c, 0x180c0c14, 0x26131335, 0xc3ecec2f, 0xbe5f5fe1, 0x359797a2, 0x884444cc, 0x2e171739, 0x93c4c457, 0x55a7a7f2, 0xfc7e7e82, 0x7a3d3d47, 0xc86464ac, 0xba5d5de7, 0x3219192b, 0xe6737395, 0xc06060a0, 0x19818198, 0x9e4f4fd1, 0xa3dcdc7f, 0x44222266, 0x542a2a7e, 0x3b9090ab, 0x0b888883, 0x8c4646ca, 0xc7eeee29, 0x6bb8b8d3, 0x2814143c, 0xa7dede79, 0xbc5e5ee2, 0x160b0b1d, 0xaddbdb76, 0xdbe0e03b, 0x64323256, 0x743a3a4e, 0x140a0a1e, 0x924949db, 0x0c06060a, 0x4824246c, 0xb85c5ce4, 0x9fc2c25d, 0xbdd3d36e, 0x43acacef, 0xc46262a6, 0x399191a8, 0x319595a4, 0xd3e4e437, 0xf279798b, 0xd5e7e732, 0x8bc8c843, 0x6e373759, 0xda6d6db7, 0x018d8d8c, 0xb1d5d564, 0x9c4e4ed2, 0x49a9a9e0, 0xd86c6cb4, 0xac5656fa, 0xf3f4f407, 0xcfeaea25, 0xca6565af, 0xf47a7a8e, 0x47aeaee9, 0x10080818, 0x6fbabad5, 0xf0787888, 0x4a25256f, 0x5c2e2e72, 0x381c1c24, 0x57a6a6f1, 0x73b4b4c7, 0x97c6c651, 0xcbe8e823, 0xa1dddd7c, 0xe874749c, 0x3e1f1f21, 0x964b4bdd, 0x61bdbddc, 0x0d8b8b86, 0x0f8a8a85, 0xe0707090, 0x7c3e3e42, 0x71b5b5c4, 0xcc6666aa, 0x904848d8, 0x06030305, 0xf7f6f601, 0x1c0e0e12, 0xc26161a3, 0x6a35355f, 0xae5757f9, 0x69b9b9d0, 0x17868691, 0x99c1c158, 0x3a1d1d27, 0x279e9eb9, 0xd9e1e138, 0xebf8f813, 0x2b9898b3, 0x22111133, 0xd26969bb, 0xa9d9d970, 0x078e8e89, 0x339494a7, 0x2d9b9bb6, 0x3c1e1e22, 0x15878792, 0xc9e9e920, 0x87cece49, 0xaa5555ff, 0x50282878, 0xa5dfdf7a, 0x038c8c8f, 0x59a1a1f8, 0x09898980, 0x1a0d0d17, 0x65bfbfda, 0xd7e6e631, 0x844242c6, 0xd06868b8, 0x824141c3, 0x299999b0, 0x5a2d2d77, 0x1e0f0f11, 0x7bb0b0cb, 0xa85454fc, 0x6dbbbbd6, 0x2c16163a];
  var T2 = [0xa5c66363, 0x84f87c7c, 0x99ee7777, 0x8df67b7b, 0x0dfff2f2, 0xbdd66b6b, 0xb1de6f6f, 0x5491c5c5, 0x50603030, 0x03020101, 0xa9ce6767, 0x7d562b2b, 0x19e7fefe, 0x62b5d7d7, 0xe64dabab, 0x9aec7676, 0x458fcaca, 0x9d1f8282, 0x4089c9c9, 0x87fa7d7d, 0x15effafa, 0xebb25959, 0xc98e4747, 0x0bfbf0f0, 0xec41adad, 0x67b3d4d4, 0xfd5fa2a2, 0xea45afaf, 0xbf239c9c, 0xf753a4a4, 0x96e47272, 0x5b9bc0c0, 0xc275b7b7, 0x1ce1fdfd, 0xae3d9393, 0x6a4c2626, 0x5a6c3636, 0x417e3f3f, 0x02f5f7f7, 0x4f83cccc, 0x5c683434, 0xf451a5a5, 0x34d1e5e5, 0x08f9f1f1, 0x93e27171, 0x73abd8d8, 0x53623131, 0x3f2a1515, 0x0c080404, 0x5295c7c7, 0x65462323, 0x5e9dc3c3, 0x28301818, 0xa1379696, 0x0f0a0505, 0xb52f9a9a, 0x090e0707, 0x36241212, 0x9b1b8080, 0x3ddfe2e2, 0x26cdebeb, 0x694e2727, 0xcd7fb2b2, 0x9fea7575, 0x1b120909, 0x9e1d8383, 0x74582c2c, 0x2e341a1a, 0x2d361b1b, 0xb2dc6e6e, 0xeeb45a5a, 0xfb5ba0a0, 0xf6a45252, 0x4d763b3b, 0x61b7d6d6, 0xce7db3b3, 0x7b522929, 0x3edde3e3, 0x715e2f2f, 0x97138484, 0xf5a65353, 0x68b9d1d1, 0x00000000, 0x2cc1eded, 0x60402020, 0x1fe3fcfc, 0xc879b1b1, 0xedb65b5b, 0xbed46a6a, 0x468dcbcb, 0xd967bebe, 0x4b723939, 0xde944a4a, 0xd4984c4c, 0xe8b05858, 0x4a85cfcf, 0x6bbbd0d0, 0x2ac5efef, 0xe54faaaa, 0x16edfbfb, 0xc5864343, 0xd79a4d4d, 0x55663333, 0x94118585, 0xcf8a4545, 0x10e9f9f9, 0x06040202, 0x81fe7f7f, 0xf0a05050, 0x44783c3c, 0xba259f9f, 0xe34ba8a8, 0xf3a25151, 0xfe5da3a3, 0xc0804040, 0x8a058f8f, 0xad3f9292, 0xbc219d9d, 0x48703838, 0x04f1f5f5, 0xdf63bcbc, 0xc177b6b6, 0x75afdada, 0x63422121, 0x30201010, 0x1ae5ffff, 0x0efdf3f3, 0x6dbfd2d2, 0x4c81cdcd, 0x14180c0c, 0x35261313, 0x2fc3ecec, 0xe1be5f5f, 0xa2359797, 0xcc884444, 0x392e1717, 0x5793c4c4, 0xf255a7a7, 0x82fc7e7e, 0x477a3d3d, 0xacc86464, 0xe7ba5d5d, 0x2b321919, 0x95e67373, 0xa0c06060, 0x98198181, 0xd19e4f4f, 0x7fa3dcdc, 0x66442222, 0x7e542a2a, 0xab3b9090, 0x830b8888, 0xca8c4646, 0x29c7eeee, 0xd36bb8b8, 0x3c281414, 0x79a7dede, 0xe2bc5e5e, 0x1d160b0b, 0x76addbdb, 0x3bdbe0e0, 0x56643232, 0x4e743a3a, 0x1e140a0a, 0xdb924949, 0x0a0c0606, 0x6c482424, 0xe4b85c5c, 0x5d9fc2c2, 0x6ebdd3d3, 0xef43acac, 0xa6c46262, 0xa8399191, 0xa4319595, 0x37d3e4e4, 0x8bf27979, 0x32d5e7e7, 0x438bc8c8, 0x596e3737, 0xb7da6d6d, 0x8c018d8d, 0x64b1d5d5, 0xd29c4e4e, 0xe049a9a9, 0xb4d86c6c, 0xfaac5656, 0x07f3f4f4, 0x25cfeaea, 0xafca6565, 0x8ef47a7a, 0xe947aeae, 0x18100808, 0xd56fbaba, 0x88f07878, 0x6f4a2525, 0x725c2e2e, 0x24381c1c, 0xf157a6a6, 0xc773b4b4, 0x5197c6c6, 0x23cbe8e8, 0x7ca1dddd, 0x9ce87474, 0x213e1f1f, 0xdd964b4b, 0xdc61bdbd, 0x860d8b8b, 0x850f8a8a, 0x90e07070, 0x427c3e3e, 0xc471b5b5, 0xaacc6666, 0xd8904848, 0x05060303, 0x01f7f6f6, 0x121c0e0e, 0xa3c26161, 0x5f6a3535, 0xf9ae5757, 0xd069b9b9, 0x91178686, 0x5899c1c1, 0x273a1d1d, 0xb9279e9e, 0x38d9e1e1, 0x13ebf8f8, 0xb32b9898, 0x33221111, 0xbbd26969, 0x70a9d9d9, 0x89078e8e, 0xa7339494, 0xb62d9b9b, 0x223c1e1e, 0x92158787, 0x20c9e9e9, 0x4987cece, 0xffaa5555, 0x78502828, 0x7aa5dfdf, 0x8f038c8c, 0xf859a1a1, 0x80098989, 0x171a0d0d, 0xda65bfbf, 0x31d7e6e6, 0xc6844242, 0xb8d06868, 0xc3824141, 0xb0299999, 0x775a2d2d, 0x111e0f0f, 0xcb7bb0b0, 0xfca85454, 0xd66dbbbb, 0x3a2c1616];
  var T3 = [0x63a5c663, 0x7c84f87c, 0x7799ee77, 0x7b8df67b, 0xf20dfff2, 0x6bbdd66b, 0x6fb1de6f, 0xc55491c5, 0x30506030, 0x01030201, 0x67a9ce67, 0x2b7d562b, 0xfe19e7fe, 0xd762b5d7, 0xabe64dab, 0x769aec76, 0xca458fca, 0x829d1f82, 0xc94089c9, 0x7d87fa7d, 0xfa15effa, 0x59ebb259, 0x47c98e47, 0xf00bfbf0, 0xadec41ad, 0xd467b3d4, 0xa2fd5fa2, 0xafea45af, 0x9cbf239c, 0xa4f753a4, 0x7296e472, 0xc05b9bc0, 0xb7c275b7, 0xfd1ce1fd, 0x93ae3d93, 0x266a4c26, 0x365a6c36, 0x3f417e3f, 0xf702f5f7, 0xcc4f83cc, 0x345c6834, 0xa5f451a5, 0xe534d1e5, 0xf108f9f1, 0x7193e271, 0xd873abd8, 0x31536231, 0x153f2a15, 0x040c0804, 0xc75295c7, 0x23654623, 0xc35e9dc3, 0x18283018, 0x96a13796, 0x050f0a05, 0x9ab52f9a, 0x07090e07, 0x12362412, 0x809b1b80, 0xe23ddfe2, 0xeb26cdeb, 0x27694e27, 0xb2cd7fb2, 0x759fea75, 0x091b1209, 0x839e1d83, 0x2c74582c, 0x1a2e341a, 0x1b2d361b, 0x6eb2dc6e, 0x5aeeb45a, 0xa0fb5ba0, 0x52f6a452, 0x3b4d763b, 0xd661b7d6, 0xb3ce7db3, 0x297b5229, 0xe33edde3, 0x2f715e2f, 0x84971384, 0x53f5a653, 0xd168b9d1, 0x00000000, 0xed2cc1ed, 0x20604020, 0xfc1fe3fc, 0xb1c879b1, 0x5bedb65b, 0x6abed46a, 0xcb468dcb, 0xbed967be, 0x394b7239, 0x4ade944a, 0x4cd4984c, 0x58e8b058, 0xcf4a85cf, 0xd06bbbd0, 0xef2ac5ef, 0xaae54faa, 0xfb16edfb, 0x43c58643, 0x4dd79a4d, 0x33556633, 0x85941185, 0x45cf8a45, 0xf910e9f9, 0x02060402, 0x7f81fe7f, 0x50f0a050, 0x3c44783c, 0x9fba259f, 0xa8e34ba8, 0x51f3a251, 0xa3fe5da3, 0x40c08040, 0x8f8a058f, 0x92ad3f92, 0x9dbc219d, 0x38487038, 0xf504f1f5, 0xbcdf63bc, 0xb6c177b6, 0xda75afda, 0x21634221, 0x10302010, 0xff1ae5ff, 0xf30efdf3, 0xd26dbfd2, 0xcd4c81cd, 0x0c14180c, 0x13352613, 0xec2fc3ec, 0x5fe1be5f, 0x97a23597, 0x44cc8844, 0x17392e17, 0xc45793c4, 0xa7f255a7, 0x7e82fc7e, 0x3d477a3d, 0x64acc864, 0x5de7ba5d, 0x192b3219, 0x7395e673, 0x60a0c060, 0x81981981, 0x4fd19e4f, 0xdc7fa3dc, 0x22664422, 0x2a7e542a, 0x90ab3b90, 0x88830b88, 0x46ca8c46, 0xee29c7ee, 0xb8d36bb8, 0x143c2814, 0xde79a7de, 0x5ee2bc5e, 0x0b1d160b, 0xdb76addb, 0xe03bdbe0, 0x32566432, 0x3a4e743a, 0x0a1e140a, 0x49db9249, 0x060a0c06, 0x246c4824, 0x5ce4b85c, 0xc25d9fc2, 0xd36ebdd3, 0xacef43ac, 0x62a6c462, 0x91a83991, 0x95a43195, 0xe437d3e4, 0x798bf279, 0xe732d5e7, 0xc8438bc8, 0x37596e37, 0x6db7da6d, 0x8d8c018d, 0xd564b1d5, 0x4ed29c4e, 0xa9e049a9, 0x6cb4d86c, 0x56faac56, 0xf407f3f4, 0xea25cfea, 0x65afca65, 0x7a8ef47a, 0xaee947ae, 0x08181008, 0xbad56fba, 0x7888f078, 0x256f4a25, 0x2e725c2e, 0x1c24381c, 0xa6f157a6, 0xb4c773b4, 0xc65197c6, 0xe823cbe8, 0xdd7ca1dd, 0x749ce874, 0x1f213e1f, 0x4bdd964b, 0xbddc61bd, 0x8b860d8b, 0x8a850f8a, 0x7090e070, 0x3e427c3e, 0xb5c471b5, 0x66aacc66, 0x48d89048, 0x03050603, 0xf601f7f6, 0x0e121c0e, 0x61a3c261, 0x355f6a35, 0x57f9ae57, 0xb9d069b9, 0x86911786, 0xc15899c1, 0x1d273a1d, 0x9eb9279e, 0xe138d9e1, 0xf813ebf8, 0x98b32b98, 0x11332211, 0x69bbd269, 0xd970a9d9, 0x8e89078e, 0x94a73394, 0x9bb62d9b, 0x1e223c1e, 0x87921587, 0xe920c9e9, 0xce4987ce, 0x55ffaa55, 0x28785028, 0xdf7aa5df, 0x8c8f038c, 0xa1f859a1, 0x89800989, 0x0d171a0d, 0xbfda65bf, 0xe631d7e6, 0x42c68442, 0x68b8d068, 0x41c38241, 0x99b02999, 0x2d775a2d, 0x0f111e0f, 0xb0cb7bb0, 0x54fca854, 0xbbd66dbb, 0x163a2c16];
  var T4 = [0x6363a5c6, 0x7c7c84f8, 0x777799ee, 0x7b7b8df6, 0xf2f20dff, 0x6b6bbdd6, 0x6f6fb1de, 0xc5c55491, 0x30305060, 0x01010302, 0x6767a9ce, 0x2b2b7d56, 0xfefe19e7, 0xd7d762b5, 0xababe64d, 0x76769aec, 0xcaca458f, 0x82829d1f, 0xc9c94089, 0x7d7d87fa, 0xfafa15ef, 0x5959ebb2, 0x4747c98e, 0xf0f00bfb, 0xadadec41, 0xd4d467b3, 0xa2a2fd5f, 0xafafea45, 0x9c9cbf23, 0xa4a4f753, 0x727296e4, 0xc0c05b9b, 0xb7b7c275, 0xfdfd1ce1, 0x9393ae3d, 0x26266a4c, 0x36365a6c, 0x3f3f417e, 0xf7f702f5, 0xcccc4f83, 0x34345c68, 0xa5a5f451, 0xe5e534d1, 0xf1f108f9, 0x717193e2, 0xd8d873ab, 0x31315362, 0x15153f2a, 0x04040c08, 0xc7c75295, 0x23236546, 0xc3c35e9d, 0x18182830, 0x9696a137, 0x05050f0a, 0x9a9ab52f, 0x0707090e, 0x12123624, 0x80809b1b, 0xe2e23ddf, 0xebeb26cd, 0x2727694e, 0xb2b2cd7f, 0x75759fea, 0x09091b12, 0x83839e1d, 0x2c2c7458, 0x1a1a2e34, 0x1b1b2d36, 0x6e6eb2dc, 0x5a5aeeb4, 0xa0a0fb5b, 0x5252f6a4, 0x3b3b4d76, 0xd6d661b7, 0xb3b3ce7d, 0x29297b52, 0xe3e33edd, 0x2f2f715e, 0x84849713, 0x5353f5a6, 0xd1d168b9, 0x00000000, 0xeded2cc1, 0x20206040, 0xfcfc1fe3, 0xb1b1c879, 0x5b5bedb6, 0x6a6abed4, 0xcbcb468d, 0xbebed967, 0x39394b72, 0x4a4ade94, 0x4c4cd498, 0x5858e8b0, 0xcfcf4a85, 0xd0d06bbb, 0xefef2ac5, 0xaaaae54f, 0xfbfb16ed, 0x4343c586, 0x4d4dd79a, 0x33335566, 0x85859411, 0x4545cf8a, 0xf9f910e9, 0x02020604, 0x7f7f81fe, 0x5050f0a0, 0x3c3c4478, 0x9f9fba25, 0xa8a8e34b, 0x5151f3a2, 0xa3a3fe5d, 0x4040c080, 0x8f8f8a05, 0x9292ad3f, 0x9d9dbc21, 0x38384870, 0xf5f504f1, 0xbcbcdf63, 0xb6b6c177, 0xdada75af, 0x21216342, 0x10103020, 0xffff1ae5, 0xf3f30efd, 0xd2d26dbf, 0xcdcd4c81, 0x0c0c1418, 0x13133526, 0xecec2fc3, 0x5f5fe1be, 0x9797a235, 0x4444cc88, 0x1717392e, 0xc4c45793, 0xa7a7f255, 0x7e7e82fc, 0x3d3d477a, 0x6464acc8, 0x5d5de7ba, 0x19192b32, 0x737395e6, 0x6060a0c0, 0x81819819, 0x4f4fd19e, 0xdcdc7fa3, 0x22226644, 0x2a2a7e54, 0x9090ab3b, 0x8888830b, 0x4646ca8c, 0xeeee29c7, 0xb8b8d36b, 0x14143c28, 0xdede79a7, 0x5e5ee2bc, 0x0b0b1d16, 0xdbdb76ad, 0xe0e03bdb, 0x32325664, 0x3a3a4e74, 0x0a0a1e14, 0x4949db92, 0x06060a0c, 0x24246c48, 0x5c5ce4b8, 0xc2c25d9f, 0xd3d36ebd, 0xacacef43, 0x6262a6c4, 0x9191a839, 0x9595a431, 0xe4e437d3, 0x79798bf2, 0xe7e732d5, 0xc8c8438b, 0x3737596e, 0x6d6db7da, 0x8d8d8c01, 0xd5d564b1, 0x4e4ed29c, 0xa9a9e049, 0x6c6cb4d8, 0x5656faac, 0xf4f407f3, 0xeaea25cf, 0x6565afca, 0x7a7a8ef4, 0xaeaee947, 0x08081810, 0xbabad56f, 0x787888f0, 0x25256f4a, 0x2e2e725c, 0x1c1c2438, 0xa6a6f157, 0xb4b4c773, 0xc6c65197, 0xe8e823cb, 0xdddd7ca1, 0x74749ce8, 0x1f1f213e, 0x4b4bdd96, 0xbdbddc61, 0x8b8b860d, 0x8a8a850f, 0x707090e0, 0x3e3e427c, 0xb5b5c471, 0x6666aacc, 0x4848d890, 0x03030506, 0xf6f601f7, 0x0e0e121c, 0x6161a3c2, 0x35355f6a, 0x5757f9ae, 0xb9b9d069, 0x86869117, 0xc1c15899, 0x1d1d273a, 0x9e9eb927, 0xe1e138d9, 0xf8f813eb, 0x9898b32b, 0x11113322, 0x6969bbd2, 0xd9d970a9, 0x8e8e8907, 0x9494a733, 0x9b9bb62d, 0x1e1e223c, 0x87879215, 0xe9e920c9, 0xcece4987, 0x5555ffaa, 0x28287850, 0xdfdf7aa5, 0x8c8c8f03, 0xa1a1f859, 0x89898009, 0x0d0d171a, 0xbfbfda65, 0xe6e631d7, 0x4242c684, 0x6868b8d0, 0x4141c382, 0x9999b029, 0x2d2d775a, 0x0f0f111e, 0xb0b0cb7b, 0x5454fca8, 0xbbbbd66d, 0x16163a2c];
  // Transformations for decryption
  var T5 = [0x51f4a750, 0x7e416553, 0x1a17a4c3, 0x3a275e96, 0x3bab6bcb, 0x1f9d45f1, 0xacfa58ab, 0x4be30393, 0x2030fa55, 0xad766df6, 0x88cc7691, 0xf5024c25, 0x4fe5d7fc, 0xc52acbd7, 0x26354480, 0xb562a38f, 0xdeb15a49, 0x25ba1b67, 0x45ea0e98, 0x5dfec0e1, 0xc32f7502, 0x814cf012, 0x8d4697a3, 0x6bd3f9c6, 0x038f5fe7, 0x15929c95, 0xbf6d7aeb, 0x955259da, 0xd4be832d, 0x587421d3, 0x49e06929, 0x8ec9c844, 0x75c2896a, 0xf48e7978, 0x99583e6b, 0x27b971dd, 0xbee14fb6, 0xf088ad17, 0xc920ac66, 0x7dce3ab4, 0x63df4a18, 0xe51a3182, 0x97513360, 0x62537f45, 0xb16477e0, 0xbb6bae84, 0xfe81a01c, 0xf9082b94, 0x70486858, 0x8f45fd19, 0x94de6c87, 0x527bf8b7, 0xab73d323, 0x724b02e2, 0xe31f8f57, 0x6655ab2a, 0xb2eb2807, 0x2fb5c203, 0x86c57b9a, 0xd33708a5, 0x302887f2, 0x23bfa5b2, 0x02036aba, 0xed16825c, 0x8acf1c2b, 0xa779b492, 0xf307f2f0, 0x4e69e2a1, 0x65daf4cd, 0x0605bed5, 0xd134621f, 0xc4a6fe8a, 0x342e539d, 0xa2f355a0, 0x058ae132, 0xa4f6eb75, 0x0b83ec39, 0x4060efaa, 0x5e719f06, 0xbd6e1051, 0x3e218af9, 0x96dd063d, 0xdd3e05ae, 0x4de6bd46, 0x91548db5, 0x71c45d05, 0x0406d46f, 0x605015ff, 0x1998fb24, 0xd6bde997, 0x894043cc, 0x67d99e77, 0xb0e842bd, 0x07898b88, 0xe7195b38, 0x79c8eedb, 0xa17c0a47, 0x7c420fe9, 0xf8841ec9, 0x00000000, 0x09808683, 0x322bed48, 0x1e1170ac, 0x6c5a724e, 0xfd0efffb, 0x0f853856, 0x3daed51e, 0x362d3927, 0x0a0fd964, 0x685ca621, 0x9b5b54d1, 0x24362e3a, 0x0c0a67b1, 0x9357e70f, 0xb4ee96d2, 0x1b9b919e, 0x80c0c54f, 0x61dc20a2, 0x5a774b69, 0x1c121a16, 0xe293ba0a, 0xc0a02ae5, 0x3c22e043, 0x121b171d, 0x0e090d0b, 0xf28bc7ad, 0x2db6a8b9, 0x141ea9c8, 0x57f11985, 0xaf75074c, 0xee99ddbb, 0xa37f60fd, 0xf701269f, 0x5c72f5bc, 0x44663bc5, 0x5bfb7e34, 0x8b432976, 0xcb23c6dc, 0xb6edfc68, 0xb8e4f163, 0xd731dcca, 0x42638510, 0x13972240, 0x84c61120, 0x854a247d, 0xd2bb3df8, 0xaef93211, 0xc729a16d, 0x1d9e2f4b, 0xdcb230f3, 0x0d8652ec, 0x77c1e3d0, 0x2bb3166c, 0xa970b999, 0x119448fa, 0x47e96422, 0xa8fc8cc4, 0xa0f03f1a, 0x567d2cd8, 0x223390ef, 0x87494ec7, 0xd938d1c1, 0x8ccaa2fe, 0x98d40b36, 0xa6f581cf, 0xa57ade28, 0xdab78e26, 0x3fadbfa4, 0x2c3a9de4, 0x5078920d, 0x6a5fcc9b, 0x547e4662, 0xf68d13c2, 0x90d8b8e8, 0x2e39f75e, 0x82c3aff5, 0x9f5d80be, 0x69d0937c, 0x6fd52da9, 0xcf2512b3, 0xc8ac993b, 0x10187da7, 0xe89c636e, 0xdb3bbb7b, 0xcd267809, 0x6e5918f4, 0xec9ab701, 0x834f9aa8, 0xe6956e65, 0xaaffe67e, 0x21bccf08, 0xef15e8e6, 0xbae79bd9, 0x4a6f36ce, 0xea9f09d4, 0x29b07cd6, 0x31a4b2af, 0x2a3f2331, 0xc6a59430, 0x35a266c0, 0x744ebc37, 0xfc82caa6, 0xe090d0b0, 0x33a7d815, 0xf104984a, 0x41ecdaf7, 0x7fcd500e, 0x1791f62f, 0x764dd68d, 0x43efb04d, 0xccaa4d54, 0xe49604df, 0x9ed1b5e3, 0x4c6a881b, 0xc12c1fb8, 0x4665517f, 0x9d5eea04, 0x018c355d, 0xfa877473, 0xfb0b412e, 0xb3671d5a, 0x92dbd252, 0xe9105633, 0x6dd64713, 0x9ad7618c, 0x37a10c7a, 0x59f8148e, 0xeb133c89, 0xcea927ee, 0xb761c935, 0xe11ce5ed, 0x7a47b13c, 0x9cd2df59, 0x55f2733f, 0x1814ce79, 0x73c737bf, 0x53f7cdea, 0x5ffdaa5b, 0xdf3d6f14, 0x7844db86, 0xcaaff381, 0xb968c43e, 0x3824342c, 0xc2a3405f, 0x161dc372, 0xbce2250c, 0x283c498b, 0xff0d9541, 0x39a80171, 0x080cb3de, 0xd8b4e49c, 0x6456c190, 0x7bcb8461, 0xd532b670, 0x486c5c74, 0xd0b85742];
  var T6 = [0x5051f4a7, 0x537e4165, 0xc31a17a4, 0x963a275e, 0xcb3bab6b, 0xf11f9d45, 0xabacfa58, 0x934be303, 0x552030fa, 0xf6ad766d, 0x9188cc76, 0x25f5024c, 0xfc4fe5d7, 0xd7c52acb, 0x80263544, 0x8fb562a3, 0x49deb15a, 0x6725ba1b, 0x9845ea0e, 0xe15dfec0, 0x02c32f75, 0x12814cf0, 0xa38d4697, 0xc66bd3f9, 0xe7038f5f, 0x9515929c, 0xebbf6d7a, 0xda955259, 0x2dd4be83, 0xd3587421, 0x2949e069, 0x448ec9c8, 0x6a75c289, 0x78f48e79, 0x6b99583e, 0xdd27b971, 0xb6bee14f, 0x17f088ad, 0x66c920ac, 0xb47dce3a, 0x1863df4a, 0x82e51a31, 0x60975133, 0x4562537f, 0xe0b16477, 0x84bb6bae, 0x1cfe81a0, 0x94f9082b, 0x58704868, 0x198f45fd, 0x8794de6c, 0xb7527bf8, 0x23ab73d3, 0xe2724b02, 0x57e31f8f, 0x2a6655ab, 0x07b2eb28, 0x032fb5c2, 0x9a86c57b, 0xa5d33708, 0xf2302887, 0xb223bfa5, 0xba02036a, 0x5ced1682, 0x2b8acf1c, 0x92a779b4, 0xf0f307f2, 0xa14e69e2, 0xcd65daf4, 0xd50605be, 0x1fd13462, 0x8ac4a6fe, 0x9d342e53, 0xa0a2f355, 0x32058ae1, 0x75a4f6eb, 0x390b83ec, 0xaa4060ef, 0x065e719f, 0x51bd6e10, 0xf93e218a, 0x3d96dd06, 0xaedd3e05, 0x464de6bd, 0xb591548d, 0x0571c45d, 0x6f0406d4, 0xff605015, 0x241998fb, 0x97d6bde9, 0xcc894043, 0x7767d99e, 0xbdb0e842, 0x8807898b, 0x38e7195b, 0xdb79c8ee, 0x47a17c0a, 0xe97c420f, 0xc9f8841e, 0x00000000, 0x83098086, 0x48322bed, 0xac1e1170, 0x4e6c5a72, 0xfbfd0eff, 0x560f8538, 0x1e3daed5, 0x27362d39, 0x640a0fd9, 0x21685ca6, 0xd19b5b54, 0x3a24362e, 0xb10c0a67, 0x0f9357e7, 0xd2b4ee96, 0x9e1b9b91, 0x4f80c0c5, 0xa261dc20, 0x695a774b, 0x161c121a, 0x0ae293ba, 0xe5c0a02a, 0x433c22e0, 0x1d121b17, 0x0b0e090d, 0xadf28bc7, 0xb92db6a8, 0xc8141ea9, 0x8557f119, 0x4caf7507, 0xbbee99dd, 0xfda37f60, 0x9ff70126, 0xbc5c72f5, 0xc544663b, 0x345bfb7e, 0x768b4329, 0xdccb23c6, 0x68b6edfc, 0x63b8e4f1, 0xcad731dc, 0x10426385, 0x40139722, 0x2084c611, 0x7d854a24, 0xf8d2bb3d, 0x11aef932, 0x6dc729a1, 0x4b1d9e2f, 0xf3dcb230, 0xec0d8652, 0xd077c1e3, 0x6c2bb316, 0x99a970b9, 0xfa119448, 0x2247e964, 0xc4a8fc8c, 0x1aa0f03f, 0xd8567d2c, 0xef223390, 0xc787494e, 0xc1d938d1, 0xfe8ccaa2, 0x3698d40b, 0xcfa6f581, 0x28a57ade, 0x26dab78e, 0xa43fadbf, 0xe42c3a9d, 0x0d507892, 0x9b6a5fcc, 0x62547e46, 0xc2f68d13, 0xe890d8b8, 0x5e2e39f7, 0xf582c3af, 0xbe9f5d80, 0x7c69d093, 0xa96fd52d, 0xb3cf2512, 0x3bc8ac99, 0xa710187d, 0x6ee89c63, 0x7bdb3bbb, 0x09cd2678, 0xf46e5918, 0x01ec9ab7, 0xa8834f9a, 0x65e6956e, 0x7eaaffe6, 0x0821bccf, 0xe6ef15e8, 0xd9bae79b, 0xce4a6f36, 0xd4ea9f09, 0xd629b07c, 0xaf31a4b2, 0x312a3f23, 0x30c6a594, 0xc035a266, 0x37744ebc, 0xa6fc82ca, 0xb0e090d0, 0x1533a7d8, 0x4af10498, 0xf741ecda, 0x0e7fcd50, 0x2f1791f6, 0x8d764dd6, 0x4d43efb0, 0x54ccaa4d, 0xdfe49604, 0xe39ed1b5, 0x1b4c6a88, 0xb8c12c1f, 0x7f466551, 0x049d5eea, 0x5d018c35, 0x73fa8774, 0x2efb0b41, 0x5ab3671d, 0x5292dbd2, 0x33e91056, 0x136dd647, 0x8c9ad761, 0x7a37a10c, 0x8e59f814, 0x89eb133c, 0xeecea927, 0x35b761c9, 0xede11ce5, 0x3c7a47b1, 0x599cd2df, 0x3f55f273, 0x791814ce, 0xbf73c737, 0xea53f7cd, 0x5b5ffdaa, 0x14df3d6f, 0x867844db, 0x81caaff3, 0x3eb968c4, 0x2c382434, 0x5fc2a340, 0x72161dc3, 0x0cbce225, 0x8b283c49, 0x41ff0d95, 0x7139a801, 0xde080cb3, 0x9cd8b4e4, 0x906456c1, 0x617bcb84, 0x70d532b6, 0x74486c5c, 0x42d0b857];
  var T7 = [0xa75051f4, 0x65537e41, 0xa4c31a17, 0x5e963a27, 0x6bcb3bab, 0x45f11f9d, 0x58abacfa, 0x03934be3, 0xfa552030, 0x6df6ad76, 0x769188cc, 0x4c25f502, 0xd7fc4fe5, 0xcbd7c52a, 0x44802635, 0xa38fb562, 0x5a49deb1, 0x1b6725ba, 0x0e9845ea, 0xc0e15dfe, 0x7502c32f, 0xf012814c, 0x97a38d46, 0xf9c66bd3, 0x5fe7038f, 0x9c951592, 0x7aebbf6d, 0x59da9552, 0x832dd4be, 0x21d35874, 0x692949e0, 0xc8448ec9, 0x896a75c2, 0x7978f48e, 0x3e6b9958, 0x71dd27b9, 0x4fb6bee1, 0xad17f088, 0xac66c920, 0x3ab47dce, 0x4a1863df, 0x3182e51a, 0x33609751, 0x7f456253, 0x77e0b164, 0xae84bb6b, 0xa01cfe81, 0x2b94f908, 0x68587048, 0xfd198f45, 0x6c8794de, 0xf8b7527b, 0xd323ab73, 0x02e2724b, 0x8f57e31f, 0xab2a6655, 0x2807b2eb, 0xc2032fb5, 0x7b9a86c5, 0x08a5d337, 0x87f23028, 0xa5b223bf, 0x6aba0203, 0x825ced16, 0x1c2b8acf, 0xb492a779, 0xf2f0f307, 0xe2a14e69, 0xf4cd65da, 0xbed50605, 0x621fd134, 0xfe8ac4a6, 0x539d342e, 0x55a0a2f3, 0xe132058a, 0xeb75a4f6, 0xec390b83, 0xefaa4060, 0x9f065e71, 0x1051bd6e, 0x8af93e21, 0x063d96dd, 0x05aedd3e, 0xbd464de6, 0x8db59154, 0x5d0571c4, 0xd46f0406, 0x15ff6050, 0xfb241998, 0xe997d6bd, 0x43cc8940, 0x9e7767d9, 0x42bdb0e8, 0x8b880789, 0x5b38e719, 0xeedb79c8, 0x0a47a17c, 0x0fe97c42, 0x1ec9f884, 0x00000000, 0x86830980, 0xed48322b, 0x70ac1e11, 0x724e6c5a, 0xfffbfd0e, 0x38560f85, 0xd51e3dae, 0x3927362d, 0xd9640a0f, 0xa621685c, 0x54d19b5b, 0x2e3a2436, 0x67b10c0a, 0xe70f9357, 0x96d2b4ee, 0x919e1b9b, 0xc54f80c0, 0x20a261dc, 0x4b695a77, 0x1a161c12, 0xba0ae293, 0x2ae5c0a0, 0xe0433c22, 0x171d121b, 0x0d0b0e09, 0xc7adf28b, 0xa8b92db6, 0xa9c8141e, 0x198557f1, 0x074caf75, 0xddbbee99, 0x60fda37f, 0x269ff701, 0xf5bc5c72, 0x3bc54466, 0x7e345bfb, 0x29768b43, 0xc6dccb23, 0xfc68b6ed, 0xf163b8e4, 0xdccad731, 0x85104263, 0x22401397, 0x112084c6, 0x247d854a, 0x3df8d2bb, 0x3211aef9, 0xa16dc729, 0x2f4b1d9e, 0x30f3dcb2, 0x52ec0d86, 0xe3d077c1, 0x166c2bb3, 0xb999a970, 0x48fa1194, 0x642247e9, 0x8cc4a8fc, 0x3f1aa0f0, 0x2cd8567d, 0x90ef2233, 0x4ec78749, 0xd1c1d938, 0xa2fe8cca, 0x0b3698d4, 0x81cfa6f5, 0xde28a57a, 0x8e26dab7, 0xbfa43fad, 0x9de42c3a, 0x920d5078, 0xcc9b6a5f, 0x4662547e, 0x13c2f68d, 0xb8e890d8, 0xf75e2e39, 0xaff582c3, 0x80be9f5d, 0x937c69d0, 0x2da96fd5, 0x12b3cf25, 0x993bc8ac, 0x7da71018, 0x636ee89c, 0xbb7bdb3b, 0x7809cd26, 0x18f46e59, 0xb701ec9a, 0x9aa8834f, 0x6e65e695, 0xe67eaaff, 0xcf0821bc, 0xe8e6ef15, 0x9bd9bae7, 0x36ce4a6f, 0x09d4ea9f, 0x7cd629b0, 0xb2af31a4, 0x23312a3f, 0x9430c6a5, 0x66c035a2, 0xbc37744e, 0xcaa6fc82, 0xd0b0e090, 0xd81533a7, 0x984af104, 0xdaf741ec, 0x500e7fcd, 0xf62f1791, 0xd68d764d, 0xb04d43ef, 0x4d54ccaa, 0x04dfe496, 0xb5e39ed1, 0x881b4c6a, 0x1fb8c12c, 0x517f4665, 0xea049d5e, 0x355d018c, 0x7473fa87, 0x412efb0b, 0x1d5ab367, 0xd25292db, 0x5633e910, 0x47136dd6, 0x618c9ad7, 0x0c7a37a1, 0x148e59f8, 0x3c89eb13, 0x27eecea9, 0xc935b761, 0xe5ede11c, 0xb13c7a47, 0xdf599cd2, 0x733f55f2, 0xce791814, 0x37bf73c7, 0xcdea53f7, 0xaa5b5ffd, 0x6f14df3d, 0xdb867844, 0xf381caaf, 0xc43eb968, 0x342c3824, 0x405fc2a3, 0xc372161d, 0x250cbce2, 0x498b283c, 0x9541ff0d, 0x017139a8, 0xb3de080c, 0xe49cd8b4, 0xc1906456, 0x84617bcb, 0xb670d532, 0x5c74486c, 0x5742d0b8];
  var T8 = [0xf4a75051, 0x4165537e, 0x17a4c31a, 0x275e963a, 0xab6bcb3b, 0x9d45f11f, 0xfa58abac, 0xe303934b, 0x30fa5520, 0x766df6ad, 0xcc769188, 0x024c25f5, 0xe5d7fc4f, 0x2acbd7c5, 0x35448026, 0x62a38fb5, 0xb15a49de, 0xba1b6725, 0xea0e9845, 0xfec0e15d, 0x2f7502c3, 0x4cf01281, 0x4697a38d, 0xd3f9c66b, 0x8f5fe703, 0x929c9515, 0x6d7aebbf, 0x5259da95, 0xbe832dd4, 0x7421d358, 0xe0692949, 0xc9c8448e, 0xc2896a75, 0x8e7978f4, 0x583e6b99, 0xb971dd27, 0xe14fb6be, 0x88ad17f0, 0x20ac66c9, 0xce3ab47d, 0xdf4a1863, 0x1a3182e5, 0x51336097, 0x537f4562, 0x6477e0b1, 0x6bae84bb, 0x81a01cfe, 0x082b94f9, 0x48685870, 0x45fd198f, 0xde6c8794, 0x7bf8b752, 0x73d323ab, 0x4b02e272, 0x1f8f57e3, 0x55ab2a66, 0xeb2807b2, 0xb5c2032f, 0xc57b9a86, 0x3708a5d3, 0x2887f230, 0xbfa5b223, 0x036aba02, 0x16825ced, 0xcf1c2b8a, 0x79b492a7, 0x07f2f0f3, 0x69e2a14e, 0xdaf4cd65, 0x05bed506, 0x34621fd1, 0xa6fe8ac4, 0x2e539d34, 0xf355a0a2, 0x8ae13205, 0xf6eb75a4, 0x83ec390b, 0x60efaa40, 0x719f065e, 0x6e1051bd, 0x218af93e, 0xdd063d96, 0x3e05aedd, 0xe6bd464d, 0x548db591, 0xc45d0571, 0x06d46f04, 0x5015ff60, 0x98fb2419, 0xbde997d6, 0x4043cc89, 0xd99e7767, 0xe842bdb0, 0x898b8807, 0x195b38e7, 0xc8eedb79, 0x7c0a47a1, 0x420fe97c, 0x841ec9f8, 0x00000000, 0x80868309, 0x2bed4832, 0x1170ac1e, 0x5a724e6c, 0x0efffbfd, 0x8538560f, 0xaed51e3d, 0x2d392736, 0x0fd9640a, 0x5ca62168, 0x5b54d19b, 0x362e3a24, 0x0a67b10c, 0x57e70f93, 0xee96d2b4, 0x9b919e1b, 0xc0c54f80, 0xdc20a261, 0x774b695a, 0x121a161c, 0x93ba0ae2, 0xa02ae5c0, 0x22e0433c, 0x1b171d12, 0x090d0b0e, 0x8bc7adf2, 0xb6a8b92d, 0x1ea9c814, 0xf1198557, 0x75074caf, 0x99ddbbee, 0x7f60fda3, 0x01269ff7, 0x72f5bc5c, 0x663bc544, 0xfb7e345b, 0x4329768b, 0x23c6dccb, 0xedfc68b6, 0xe4f163b8, 0x31dccad7, 0x63851042, 0x97224013, 0xc6112084, 0x4a247d85, 0xbb3df8d2, 0xf93211ae, 0x29a16dc7, 0x9e2f4b1d, 0xb230f3dc, 0x8652ec0d, 0xc1e3d077, 0xb3166c2b, 0x70b999a9, 0x9448fa11, 0xe9642247, 0xfc8cc4a8, 0xf03f1aa0, 0x7d2cd856, 0x3390ef22, 0x494ec787, 0x38d1c1d9, 0xcaa2fe8c, 0xd40b3698, 0xf581cfa6, 0x7ade28a5, 0xb78e26da, 0xadbfa43f, 0x3a9de42c, 0x78920d50, 0x5fcc9b6a, 0x7e466254, 0x8d13c2f6, 0xd8b8e890, 0x39f75e2e, 0xc3aff582, 0x5d80be9f, 0xd0937c69, 0xd52da96f, 0x2512b3cf, 0xac993bc8, 0x187da710, 0x9c636ee8, 0x3bbb7bdb, 0x267809cd, 0x5918f46e, 0x9ab701ec, 0x4f9aa883, 0x956e65e6, 0xffe67eaa, 0xbccf0821, 0x15e8e6ef, 0xe79bd9ba, 0x6f36ce4a, 0x9f09d4ea, 0xb07cd629, 0xa4b2af31, 0x3f23312a, 0xa59430c6, 0xa266c035, 0x4ebc3774, 0x82caa6fc, 0x90d0b0e0, 0xa7d81533, 0x04984af1, 0xecdaf741, 0xcd500e7f, 0x91f62f17, 0x4dd68d76, 0xefb04d43, 0xaa4d54cc, 0x9604dfe4, 0xd1b5e39e, 0x6a881b4c, 0x2c1fb8c1, 0x65517f46, 0x5eea049d, 0x8c355d01, 0x877473fa, 0x0b412efb, 0x671d5ab3, 0xdbd25292, 0x105633e9, 0xd647136d, 0xd7618c9a, 0xa10c7a37, 0xf8148e59, 0x133c89eb, 0xa927eece, 0x61c935b7, 0x1ce5ede1, 0x47b13c7a, 0xd2df599c, 0xf2733f55, 0x14ce7918, 0xc737bf73, 0xf7cdea53, 0xfdaa5b5f, 0x3d6f14df, 0x44db8678, 0xaff381ca, 0x68c43eb9, 0x24342c38, 0xa3405fc2, 0x1dc37216, 0xe2250cbc, 0x3c498b28, 0x0d9541ff, 0xa8017139, 0x0cb3de08, 0xb4e49cd8, 0x56c19064, 0xcb84617b, 0x32b670d5, 0x6c5c7448, 0xb85742d0];
  // Transformations for decryption key expansion
  var U1 = [0x00000000, 0x0e090d0b, 0x1c121a16, 0x121b171d, 0x3824342c, 0x362d3927, 0x24362e3a, 0x2a3f2331, 0x70486858, 0x7e416553, 0x6c5a724e, 0x62537f45, 0x486c5c74, 0x4665517f, 0x547e4662, 0x5a774b69, 0xe090d0b0, 0xee99ddbb, 0xfc82caa6, 0xf28bc7ad, 0xd8b4e49c, 0xd6bde997, 0xc4a6fe8a, 0xcaaff381, 0x90d8b8e8, 0x9ed1b5e3, 0x8ccaa2fe, 0x82c3aff5, 0xa8fc8cc4, 0xa6f581cf, 0xb4ee96d2, 0xbae79bd9, 0xdb3bbb7b, 0xd532b670, 0xc729a16d, 0xc920ac66, 0xe31f8f57, 0xed16825c, 0xff0d9541, 0xf104984a, 0xab73d323, 0xa57ade28, 0xb761c935, 0xb968c43e, 0x9357e70f, 0x9d5eea04, 0x8f45fd19, 0x814cf012, 0x3bab6bcb, 0x35a266c0, 0x27b971dd, 0x29b07cd6, 0x038f5fe7, 0x0d8652ec, 0x1f9d45f1, 0x119448fa, 0x4be30393, 0x45ea0e98, 0x57f11985, 0x59f8148e, 0x73c737bf, 0x7dce3ab4, 0x6fd52da9, 0x61dc20a2, 0xad766df6, 0xa37f60fd, 0xb16477e0, 0xbf6d7aeb, 0x955259da, 0x9b5b54d1, 0x894043cc, 0x87494ec7, 0xdd3e05ae, 0xd33708a5, 0xc12c1fb8, 0xcf2512b3, 0xe51a3182, 0xeb133c89, 0xf9082b94, 0xf701269f, 0x4de6bd46, 0x43efb04d, 0x51f4a750, 0x5ffdaa5b, 0x75c2896a, 0x7bcb8461, 0x69d0937c, 0x67d99e77, 0x3daed51e, 0x33a7d815, 0x21bccf08, 0x2fb5c203, 0x058ae132, 0x0b83ec39, 0x1998fb24, 0x1791f62f, 0x764dd68d, 0x7844db86, 0x6a5fcc9b, 0x6456c190, 0x4e69e2a1, 0x4060efaa, 0x527bf8b7, 0x5c72f5bc, 0x0605bed5, 0x080cb3de, 0x1a17a4c3, 0x141ea9c8, 0x3e218af9, 0x302887f2, 0x223390ef, 0x2c3a9de4, 0x96dd063d, 0x98d40b36, 0x8acf1c2b, 0x84c61120, 0xaef93211, 0xa0f03f1a, 0xb2eb2807, 0xbce2250c, 0xe6956e65, 0xe89c636e, 0xfa877473, 0xf48e7978, 0xdeb15a49, 0xd0b85742, 0xc2a3405f, 0xccaa4d54, 0x41ecdaf7, 0x4fe5d7fc, 0x5dfec0e1, 0x53f7cdea, 0x79c8eedb, 0x77c1e3d0, 0x65daf4cd, 0x6bd3f9c6, 0x31a4b2af, 0x3fadbfa4, 0x2db6a8b9, 0x23bfa5b2, 0x09808683, 0x07898b88, 0x15929c95, 0x1b9b919e, 0xa17c0a47, 0xaf75074c, 0xbd6e1051, 0xb3671d5a, 0x99583e6b, 0x97513360, 0x854a247d, 0x8b432976, 0xd134621f, 0xdf3d6f14, 0xcd267809, 0xc32f7502, 0xe9105633, 0xe7195b38, 0xf5024c25, 0xfb0b412e, 0x9ad7618c, 0x94de6c87, 0x86c57b9a, 0x88cc7691, 0xa2f355a0, 0xacfa58ab, 0xbee14fb6, 0xb0e842bd, 0xea9f09d4, 0xe49604df, 0xf68d13c2, 0xf8841ec9, 0xd2bb3df8, 0xdcb230f3, 0xcea927ee, 0xc0a02ae5, 0x7a47b13c, 0x744ebc37, 0x6655ab2a, 0x685ca621, 0x42638510, 0x4c6a881b, 0x5e719f06, 0x5078920d, 0x0a0fd964, 0x0406d46f, 0x161dc372, 0x1814ce79, 0x322bed48, 0x3c22e043, 0x2e39f75e, 0x2030fa55, 0xec9ab701, 0xe293ba0a, 0xf088ad17, 0xfe81a01c, 0xd4be832d, 0xdab78e26, 0xc8ac993b, 0xc6a59430, 0x9cd2df59, 0x92dbd252, 0x80c0c54f, 0x8ec9c844, 0xa4f6eb75, 0xaaffe67e, 0xb8e4f163, 0xb6edfc68, 0x0c0a67b1, 0x02036aba, 0x10187da7, 0x1e1170ac, 0x342e539d, 0x3a275e96, 0x283c498b, 0x26354480, 0x7c420fe9, 0x724b02e2, 0x605015ff, 0x6e5918f4, 0x44663bc5, 0x4a6f36ce, 0x587421d3, 0x567d2cd8, 0x37a10c7a, 0x39a80171, 0x2bb3166c, 0x25ba1b67, 0x0f853856, 0x018c355d, 0x13972240, 0x1d9e2f4b, 0x47e96422, 0x49e06929, 0x5bfb7e34, 0x55f2733f, 0x7fcd500e, 0x71c45d05, 0x63df4a18, 0x6dd64713, 0xd731dcca, 0xd938d1c1, 0xcb23c6dc, 0xc52acbd7, 0xef15e8e6, 0xe11ce5ed, 0xf307f2f0, 0xfd0efffb, 0xa779b492, 0xa970b999, 0xbb6bae84, 0xb562a38f, 0x9f5d80be, 0x91548db5, 0x834f9aa8, 0x8d4697a3];
  var U2 = [0x00000000, 0x0b0e090d, 0x161c121a, 0x1d121b17, 0x2c382434, 0x27362d39, 0x3a24362e, 0x312a3f23, 0x58704868, 0x537e4165, 0x4e6c5a72, 0x4562537f, 0x74486c5c, 0x7f466551, 0x62547e46, 0x695a774b, 0xb0e090d0, 0xbbee99dd, 0xa6fc82ca, 0xadf28bc7, 0x9cd8b4e4, 0x97d6bde9, 0x8ac4a6fe, 0x81caaff3, 0xe890d8b8, 0xe39ed1b5, 0xfe8ccaa2, 0xf582c3af, 0xc4a8fc8c, 0xcfa6f581, 0xd2b4ee96, 0xd9bae79b, 0x7bdb3bbb, 0x70d532b6, 0x6dc729a1, 0x66c920ac, 0x57e31f8f, 0x5ced1682, 0x41ff0d95, 0x4af10498, 0x23ab73d3, 0x28a57ade, 0x35b761c9, 0x3eb968c4, 0x0f9357e7, 0x049d5eea, 0x198f45fd, 0x12814cf0, 0xcb3bab6b, 0xc035a266, 0xdd27b971, 0xd629b07c, 0xe7038f5f, 0xec0d8652, 0xf11f9d45, 0xfa119448, 0x934be303, 0x9845ea0e, 0x8557f119, 0x8e59f814, 0xbf73c737, 0xb47dce3a, 0xa96fd52d, 0xa261dc20, 0xf6ad766d, 0xfda37f60, 0xe0b16477, 0xebbf6d7a, 0xda955259, 0xd19b5b54, 0xcc894043, 0xc787494e, 0xaedd3e05, 0xa5d33708, 0xb8c12c1f, 0xb3cf2512, 0x82e51a31, 0x89eb133c, 0x94f9082b, 0x9ff70126, 0x464de6bd, 0x4d43efb0, 0x5051f4a7, 0x5b5ffdaa, 0x6a75c289, 0x617bcb84, 0x7c69d093, 0x7767d99e, 0x1e3daed5, 0x1533a7d8, 0x0821bccf, 0x032fb5c2, 0x32058ae1, 0x390b83ec, 0x241998fb, 0x2f1791f6, 0x8d764dd6, 0x867844db, 0x9b6a5fcc, 0x906456c1, 0xa14e69e2, 0xaa4060ef, 0xb7527bf8, 0xbc5c72f5, 0xd50605be, 0xde080cb3, 0xc31a17a4, 0xc8141ea9, 0xf93e218a, 0xf2302887, 0xef223390, 0xe42c3a9d, 0x3d96dd06, 0x3698d40b, 0x2b8acf1c, 0x2084c611, 0x11aef932, 0x1aa0f03f, 0x07b2eb28, 0x0cbce225, 0x65e6956e, 0x6ee89c63, 0x73fa8774, 0x78f48e79, 0x49deb15a, 0x42d0b857, 0x5fc2a340, 0x54ccaa4d, 0xf741ecda, 0xfc4fe5d7, 0xe15dfec0, 0xea53f7cd, 0xdb79c8ee, 0xd077c1e3, 0xcd65daf4, 0xc66bd3f9, 0xaf31a4b2, 0xa43fadbf, 0xb92db6a8, 0xb223bfa5, 0x83098086, 0x8807898b, 0x9515929c, 0x9e1b9b91, 0x47a17c0a, 0x4caf7507, 0x51bd6e10, 0x5ab3671d, 0x6b99583e, 0x60975133, 0x7d854a24, 0x768b4329, 0x1fd13462, 0x14df3d6f, 0x09cd2678, 0x02c32f75, 0x33e91056, 0x38e7195b, 0x25f5024c, 0x2efb0b41, 0x8c9ad761, 0x8794de6c, 0x9a86c57b, 0x9188cc76, 0xa0a2f355, 0xabacfa58, 0xb6bee14f, 0xbdb0e842, 0xd4ea9f09, 0xdfe49604, 0xc2f68d13, 0xc9f8841e, 0xf8d2bb3d, 0xf3dcb230, 0xeecea927, 0xe5c0a02a, 0x3c7a47b1, 0x37744ebc, 0x2a6655ab, 0x21685ca6, 0x10426385, 0x1b4c6a88, 0x065e719f, 0x0d507892, 0x640a0fd9, 0x6f0406d4, 0x72161dc3, 0x791814ce, 0x48322bed, 0x433c22e0, 0x5e2e39f7, 0x552030fa, 0x01ec9ab7, 0x0ae293ba, 0x17f088ad, 0x1cfe81a0, 0x2dd4be83, 0x26dab78e, 0x3bc8ac99, 0x30c6a594, 0x599cd2df, 0x5292dbd2, 0x4f80c0c5, 0x448ec9c8, 0x75a4f6eb, 0x7eaaffe6, 0x63b8e4f1, 0x68b6edfc, 0xb10c0a67, 0xba02036a, 0xa710187d, 0xac1e1170, 0x9d342e53, 0x963a275e, 0x8b283c49, 0x80263544, 0xe97c420f, 0xe2724b02, 0xff605015, 0xf46e5918, 0xc544663b, 0xce4a6f36, 0xd3587421, 0xd8567d2c, 0x7a37a10c, 0x7139a801, 0x6c2bb316, 0x6725ba1b, 0x560f8538, 0x5d018c35, 0x40139722, 0x4b1d9e2f, 0x2247e964, 0x2949e069, 0x345bfb7e, 0x3f55f273, 0x0e7fcd50, 0x0571c45d, 0x1863df4a, 0x136dd647, 0xcad731dc, 0xc1d938d1, 0xdccb23c6, 0xd7c52acb, 0xe6ef15e8, 0xede11ce5, 0xf0f307f2, 0xfbfd0eff, 0x92a779b4, 0x99a970b9, 0x84bb6bae, 0x8fb562a3, 0xbe9f5d80, 0xb591548d, 0xa8834f9a, 0xa38d4697];
  var U3 = [0x00000000, 0x0d0b0e09, 0x1a161c12, 0x171d121b, 0x342c3824, 0x3927362d, 0x2e3a2436, 0x23312a3f, 0x68587048, 0x65537e41, 0x724e6c5a, 0x7f456253, 0x5c74486c, 0x517f4665, 0x4662547e, 0x4b695a77, 0xd0b0e090, 0xddbbee99, 0xcaa6fc82, 0xc7adf28b, 0xe49cd8b4, 0xe997d6bd, 0xfe8ac4a6, 0xf381caaf, 0xb8e890d8, 0xb5e39ed1, 0xa2fe8cca, 0xaff582c3, 0x8cc4a8fc, 0x81cfa6f5, 0x96d2b4ee, 0x9bd9bae7, 0xbb7bdb3b, 0xb670d532, 0xa16dc729, 0xac66c920, 0x8f57e31f, 0x825ced16, 0x9541ff0d, 0x984af104, 0xd323ab73, 0xde28a57a, 0xc935b761, 0xc43eb968, 0xe70f9357, 0xea049d5e, 0xfd198f45, 0xf012814c, 0x6bcb3bab, 0x66c035a2, 0x71dd27b9, 0x7cd629b0, 0x5fe7038f, 0x52ec0d86, 0x45f11f9d, 0x48fa1194, 0x03934be3, 0x0e9845ea, 0x198557f1, 0x148e59f8, 0x37bf73c7, 0x3ab47dce, 0x2da96fd5, 0x20a261dc, 0x6df6ad76, 0x60fda37f, 0x77e0b164, 0x7aebbf6d, 0x59da9552, 0x54d19b5b, 0x43cc8940, 0x4ec78749, 0x05aedd3e, 0x08a5d337, 0x1fb8c12c, 0x12b3cf25, 0x3182e51a, 0x3c89eb13, 0x2b94f908, 0x269ff701, 0xbd464de6, 0xb04d43ef, 0xa75051f4, 0xaa5b5ffd, 0x896a75c2, 0x84617bcb, 0x937c69d0, 0x9e7767d9, 0xd51e3dae, 0xd81533a7, 0xcf0821bc, 0xc2032fb5, 0xe132058a, 0xec390b83, 0xfb241998, 0xf62f1791, 0xd68d764d, 0xdb867844, 0xcc9b6a5f, 0xc1906456, 0xe2a14e69, 0xefaa4060, 0xf8b7527b, 0xf5bc5c72, 0xbed50605, 0xb3de080c, 0xa4c31a17, 0xa9c8141e, 0x8af93e21, 0x87f23028, 0x90ef2233, 0x9de42c3a, 0x063d96dd, 0x0b3698d4, 0x1c2b8acf, 0x112084c6, 0x3211aef9, 0x3f1aa0f0, 0x2807b2eb, 0x250cbce2, 0x6e65e695, 0x636ee89c, 0x7473fa87, 0x7978f48e, 0x5a49deb1, 0x5742d0b8, 0x405fc2a3, 0x4d54ccaa, 0xdaf741ec, 0xd7fc4fe5, 0xc0e15dfe, 0xcdea53f7, 0xeedb79c8, 0xe3d077c1, 0xf4cd65da, 0xf9c66bd3, 0xb2af31a4, 0xbfa43fad, 0xa8b92db6, 0xa5b223bf, 0x86830980, 0x8b880789, 0x9c951592, 0x919e1b9b, 0x0a47a17c, 0x074caf75, 0x1051bd6e, 0x1d5ab367, 0x3e6b9958, 0x33609751, 0x247d854a, 0x29768b43, 0x621fd134, 0x6f14df3d, 0x7809cd26, 0x7502c32f, 0x5633e910, 0x5b38e719, 0x4c25f502, 0x412efb0b, 0x618c9ad7, 0x6c8794de, 0x7b9a86c5, 0x769188cc, 0x55a0a2f3, 0x58abacfa, 0x4fb6bee1, 0x42bdb0e8, 0x09d4ea9f, 0x04dfe496, 0x13c2f68d, 0x1ec9f884, 0x3df8d2bb, 0x30f3dcb2, 0x27eecea9, 0x2ae5c0a0, 0xb13c7a47, 0xbc37744e, 0xab2a6655, 0xa621685c, 0x85104263, 0x881b4c6a, 0x9f065e71, 0x920d5078, 0xd9640a0f, 0xd46f0406, 0xc372161d, 0xce791814, 0xed48322b, 0xe0433c22, 0xf75e2e39, 0xfa552030, 0xb701ec9a, 0xba0ae293, 0xad17f088, 0xa01cfe81, 0x832dd4be, 0x8e26dab7, 0x993bc8ac, 0x9430c6a5, 0xdf599cd2, 0xd25292db, 0xc54f80c0, 0xc8448ec9, 0xeb75a4f6, 0xe67eaaff, 0xf163b8e4, 0xfc68b6ed, 0x67b10c0a, 0x6aba0203, 0x7da71018, 0x70ac1e11, 0x539d342e, 0x5e963a27, 0x498b283c, 0x44802635, 0x0fe97c42, 0x02e2724b, 0x15ff6050, 0x18f46e59, 0x3bc54466, 0x36ce4a6f, 0x21d35874, 0x2cd8567d, 0x0c7a37a1, 0x017139a8, 0x166c2bb3, 0x1b6725ba, 0x38560f85, 0x355d018c, 0x22401397, 0x2f4b1d9e, 0x642247e9, 0x692949e0, 0x7e345bfb, 0x733f55f2, 0x500e7fcd, 0x5d0571c4, 0x4a1863df, 0x47136dd6, 0xdccad731, 0xd1c1d938, 0xc6dccb23, 0xcbd7c52a, 0xe8e6ef15, 0xe5ede11c, 0xf2f0f307, 0xfffbfd0e, 0xb492a779, 0xb999a970, 0xae84bb6b, 0xa38fb562, 0x80be9f5d, 0x8db59154, 0x9aa8834f, 0x97a38d46];
  var U4 = [0x00000000, 0x090d0b0e, 0x121a161c, 0x1b171d12, 0x24342c38, 0x2d392736, 0x362e3a24, 0x3f23312a, 0x48685870, 0x4165537e, 0x5a724e6c, 0x537f4562, 0x6c5c7448, 0x65517f46, 0x7e466254, 0x774b695a, 0x90d0b0e0, 0x99ddbbee, 0x82caa6fc, 0x8bc7adf2, 0xb4e49cd8, 0xbde997d6, 0xa6fe8ac4, 0xaff381ca, 0xd8b8e890, 0xd1b5e39e, 0xcaa2fe8c, 0xc3aff582, 0xfc8cc4a8, 0xf581cfa6, 0xee96d2b4, 0xe79bd9ba, 0x3bbb7bdb, 0x32b670d5, 0x29a16dc7, 0x20ac66c9, 0x1f8f57e3, 0x16825ced, 0x0d9541ff, 0x04984af1, 0x73d323ab, 0x7ade28a5, 0x61c935b7, 0x68c43eb9, 0x57e70f93, 0x5eea049d, 0x45fd198f, 0x4cf01281, 0xab6bcb3b, 0xa266c035, 0xb971dd27, 0xb07cd629, 0x8f5fe703, 0x8652ec0d, 0x9d45f11f, 0x9448fa11, 0xe303934b, 0xea0e9845, 0xf1198557, 0xf8148e59, 0xc737bf73, 0xce3ab47d, 0xd52da96f, 0xdc20a261, 0x766df6ad, 0x7f60fda3, 0x6477e0b1, 0x6d7aebbf, 0x5259da95, 0x5b54d19b, 0x4043cc89, 0x494ec787, 0x3e05aedd, 0x3708a5d3, 0x2c1fb8c1, 0x2512b3cf, 0x1a3182e5, 0x133c89eb, 0x082b94f9, 0x01269ff7, 0xe6bd464d, 0xefb04d43, 0xf4a75051, 0xfdaa5b5f, 0xc2896a75, 0xcb84617b, 0xd0937c69, 0xd99e7767, 0xaed51e3d, 0xa7d81533, 0xbccf0821, 0xb5c2032f, 0x8ae13205, 0x83ec390b, 0x98fb2419, 0x91f62f17, 0x4dd68d76, 0x44db8678, 0x5fcc9b6a, 0x56c19064, 0x69e2a14e, 0x60efaa40, 0x7bf8b752, 0x72f5bc5c, 0x05bed506, 0x0cb3de08, 0x17a4c31a, 0x1ea9c814, 0x218af93e, 0x2887f230, 0x3390ef22, 0x3a9de42c, 0xdd063d96, 0xd40b3698, 0xcf1c2b8a, 0xc6112084, 0xf93211ae, 0xf03f1aa0, 0xeb2807b2, 0xe2250cbc, 0x956e65e6, 0x9c636ee8, 0x877473fa, 0x8e7978f4, 0xb15a49de, 0xb85742d0, 0xa3405fc2, 0xaa4d54cc, 0xecdaf741, 0xe5d7fc4f, 0xfec0e15d, 0xf7cdea53, 0xc8eedb79, 0xc1e3d077, 0xdaf4cd65, 0xd3f9c66b, 0xa4b2af31, 0xadbfa43f, 0xb6a8b92d, 0xbfa5b223, 0x80868309, 0x898b8807, 0x929c9515, 0x9b919e1b, 0x7c0a47a1, 0x75074caf, 0x6e1051bd, 0x671d5ab3, 0x583e6b99, 0x51336097, 0x4a247d85, 0x4329768b, 0x34621fd1, 0x3d6f14df, 0x267809cd, 0x2f7502c3, 0x105633e9, 0x195b38e7, 0x024c25f5, 0x0b412efb, 0xd7618c9a, 0xde6c8794, 0xc57b9a86, 0xcc769188, 0xf355a0a2, 0xfa58abac, 0xe14fb6be, 0xe842bdb0, 0x9f09d4ea, 0x9604dfe4, 0x8d13c2f6, 0x841ec9f8, 0xbb3df8d2, 0xb230f3dc, 0xa927eece, 0xa02ae5c0, 0x47b13c7a, 0x4ebc3774, 0x55ab2a66, 0x5ca62168, 0x63851042, 0x6a881b4c, 0x719f065e, 0x78920d50, 0x0fd9640a, 0x06d46f04, 0x1dc37216, 0x14ce7918, 0x2bed4832, 0x22e0433c, 0x39f75e2e, 0x30fa5520, 0x9ab701ec, 0x93ba0ae2, 0x88ad17f0, 0x81a01cfe, 0xbe832dd4, 0xb78e26da, 0xac993bc8, 0xa59430c6, 0xd2df599c, 0xdbd25292, 0xc0c54f80, 0xc9c8448e, 0xf6eb75a4, 0xffe67eaa, 0xe4f163b8, 0xedfc68b6, 0x0a67b10c, 0x036aba02, 0x187da710, 0x1170ac1e, 0x2e539d34, 0x275e963a, 0x3c498b28, 0x35448026, 0x420fe97c, 0x4b02e272, 0x5015ff60, 0x5918f46e, 0x663bc544, 0x6f36ce4a, 0x7421d358, 0x7d2cd856, 0xa10c7a37, 0xa8017139, 0xb3166c2b, 0xba1b6725, 0x8538560f, 0x8c355d01, 0x97224013, 0x9e2f4b1d, 0xe9642247, 0xe0692949, 0xfb7e345b, 0xf2733f55, 0xcd500e7f, 0xc45d0571, 0xdf4a1863, 0xd647136d, 0x31dccad7, 0x38d1c1d9, 0x23c6dccb, 0x2acbd7c5, 0x15e8e6ef, 0x1ce5ede1, 0x07f2f0f3, 0x0efffbfd, 0x79b492a7, 0x70b999a9, 0x6bae84bb, 0x62a38fb5, 0x5d80be9f, 0x548db591, 0x4f9aa883, 0x4697a38d];
  function convertToInt32(bytes) {
    var result = [];
    for (var i = 0; i < bytes.length; i += 4) {
      result.push(bytes[i] << 24 | bytes[i + 1] << 16 | bytes[i + 2] << 8 | bytes[i + 3]);
    }
    return result;
  }
  var AES = /*#__PURE__*/function () {
    function AES(key) {
      _classCallCheck(this, AES);
      _AES_key.set(this, void 0);
      _AES_Kd.set(this, void 0);
      _AES_Ke.set(this, void 0);
      if (!(this instanceof AES)) {
        throw Error('AES must be instanitated with `new`');
      }
      __classPrivateFieldSet(this, _AES_key, new Uint8Array(key), "f");
      var rounds = numberOfRounds[this.key.length];
      if (rounds == null) {
        throw new TypeError('invalid key size (must be 16, 24 or 32 bytes)');
      }
      // encryption round keys
      __classPrivateFieldSet(this, _AES_Ke, [], "f");
      // decryption round keys
      __classPrivateFieldSet(this, _AES_Kd, [], "f");
      for (var i = 0; i <= rounds; i++) {
        __classPrivateFieldGet(this, _AES_Ke, "f").push([0, 0, 0, 0]);
        __classPrivateFieldGet(this, _AES_Kd, "f").push([0, 0, 0, 0]);
      }
      var roundKeyCount = (rounds + 1) * 4;
      var KC = this.key.length / 4;
      // convert the key into ints
      var tk = convertToInt32(this.key);
      // copy values into round key arrays
      var index;
      for (var _i = 0; _i < KC; _i++) {
        index = _i >> 2;
        __classPrivateFieldGet(this, _AES_Ke, "f")[index][_i % 4] = tk[_i];
        __classPrivateFieldGet(this, _AES_Kd, "f")[rounds - index][_i % 4] = tk[_i];
      }
      // key expansion (fips-197 section 5.2)
      var rconpointer = 0;
      var t = KC,
        tt;
      while (t < roundKeyCount) {
        tt = tk[KC - 1];
        tk[0] ^= S[tt >> 16 & 0xFF] << 24 ^ S[tt >> 8 & 0xFF] << 16 ^ S[tt & 0xFF] << 8 ^ S[tt >> 24 & 0xFF] ^ rcon[rconpointer] << 24;
        rconpointer += 1;
        // key expansion (for non-256 bit)
        if (KC != 8) {
          for (var _i2 = 1; _i2 < KC; _i2++) {
            tk[_i2] ^= tk[_i2 - 1];
          }
          // key expansion for 256-bit keys is "slightly different" (fips-197)
        } else {
          for (var _i3 = 1; _i3 < KC / 2; _i3++) {
            tk[_i3] ^= tk[_i3 - 1];
          }
          tt = tk[KC / 2 - 1];
          tk[KC / 2] ^= S[tt & 0xFF] ^ S[tt >> 8 & 0xFF] << 8 ^ S[tt >> 16 & 0xFF] << 16 ^ S[tt >> 24 & 0xFF] << 24;
          for (var _i4 = KC / 2 + 1; _i4 < KC; _i4++) {
            tk[_i4] ^= tk[_i4 - 1];
          }
        }
        // copy values into round key arrays
        var _i5 = 0,
          r = void 0,
          c = void 0;
        while (_i5 < KC && t < roundKeyCount) {
          r = t >> 2;
          c = t % 4;
          __classPrivateFieldGet(this, _AES_Ke, "f")[r][c] = tk[_i5];
          __classPrivateFieldGet(this, _AES_Kd, "f")[rounds - r][c] = tk[_i5++];
          t++;
        }
      }
      // inverse-cipher-ify the decryption round key (fips-197 section 5.3)
      for (var _r = 1; _r < rounds; _r++) {
        for (var _c = 0; _c < 4; _c++) {
          tt = __classPrivateFieldGet(this, _AES_Kd, "f")[_r][_c];
          __classPrivateFieldGet(this, _AES_Kd, "f")[_r][_c] = U1[tt >> 24 & 0xFF] ^ U2[tt >> 16 & 0xFF] ^ U3[tt >> 8 & 0xFF] ^ U4[tt & 0xFF];
        }
      }
    }
    return _createClass(AES, [{
      key: "key",
      get: function get() {
        return __classPrivateFieldGet(this, _AES_key, "f").slice();
      }
    }, {
      key: "encrypt",
      value: function encrypt(plaintext) {
        if (plaintext.length != 16) {
          throw new TypeError('invalid plaintext size (must be 16 bytes)');
        }
        var rounds = __classPrivateFieldGet(this, _AES_Ke, "f").length - 1;
        var a = [0, 0, 0, 0];
        // convert plaintext to (ints ^ key)
        var t = convertToInt32(plaintext);
        for (var i = 0; i < 4; i++) {
          t[i] ^= __classPrivateFieldGet(this, _AES_Ke, "f")[0][i];
        }
        // apply round transforms
        for (var r = 1; r < rounds; r++) {
          for (var _i6 = 0; _i6 < 4; _i6++) {
            a[_i6] = T1[t[_i6] >> 24 & 0xff] ^ T2[t[(_i6 + 1) % 4] >> 16 & 0xff] ^ T3[t[(_i6 + 2) % 4] >> 8 & 0xff] ^ T4[t[(_i6 + 3) % 4] & 0xff] ^ __classPrivateFieldGet(this, _AES_Ke, "f")[r][_i6];
          }
          t = a.slice();
        }
        // the last round is special
        var result = new Uint8Array(16);
        var tt = 0;
        for (var _i7 = 0; _i7 < 4; _i7++) {
          tt = __classPrivateFieldGet(this, _AES_Ke, "f")[rounds][_i7];
          result[4 * _i7] = (S[t[_i7] >> 24 & 0xff] ^ tt >> 24) & 0xff;
          result[4 * _i7 + 1] = (S[t[(_i7 + 1) % 4] >> 16 & 0xff] ^ tt >> 16) & 0xff;
          result[4 * _i7 + 2] = (S[t[(_i7 + 2) % 4] >> 8 & 0xff] ^ tt >> 8) & 0xff;
          result[4 * _i7 + 3] = (S[t[(_i7 + 3) % 4] & 0xff] ^ tt) & 0xff;
        }
        return result;
      }
    }, {
      key: "decrypt",
      value: function decrypt(ciphertext) {
        if (ciphertext.length != 16) {
          throw new TypeError('invalid ciphertext size (must be 16 bytes)');
        }
        var rounds = __classPrivateFieldGet(this, _AES_Kd, "f").length - 1;
        var a = [0, 0, 0, 0];
        // convert plaintext to (ints ^ key)
        var t = convertToInt32(ciphertext);
        for (var i = 0; i < 4; i++) {
          t[i] ^= __classPrivateFieldGet(this, _AES_Kd, "f")[0][i];
        }
        // apply round transforms
        for (var r = 1; r < rounds; r++) {
          for (var _i8 = 0; _i8 < 4; _i8++) {
            a[_i8] = T5[t[_i8] >> 24 & 0xff] ^ T6[t[(_i8 + 3) % 4] >> 16 & 0xff] ^ T7[t[(_i8 + 2) % 4] >> 8 & 0xff] ^ T8[t[(_i8 + 1) % 4] & 0xff] ^ __classPrivateFieldGet(this, _AES_Kd, "f")[r][_i8];
          }
          t = a.slice();
        }
        // the last round is special
        var result = new Uint8Array(16);
        var tt = 0;
        for (var _i9 = 0; _i9 < 4; _i9++) {
          tt = __classPrivateFieldGet(this, _AES_Kd, "f")[rounds][_i9];
          result[4 * _i9] = (Si[t[_i9] >> 24 & 0xff] ^ tt >> 24) & 0xff;
          result[4 * _i9 + 1] = (Si[t[(_i9 + 3) % 4] >> 16 & 0xff] ^ tt >> 16) & 0xff;
          result[4 * _i9 + 2] = (Si[t[(_i9 + 2) % 4] >> 8 & 0xff] ^ tt >> 8) & 0xff;
          result[4 * _i9 + 3] = (Si[t[(_i9 + 1) % 4] & 0xff] ^ tt) & 0xff;
        }
        return result;
      }
    }]);
  }();
  aes.AES = AES;
  _AES_key = new WeakMap(), _AES_Kd = new WeakMap(), _AES_Ke = new WeakMap();
  return aes;
}

var mode = {};

var hasRequiredMode;
function requireMode() {
  if (hasRequiredMode) return mode;
  hasRequiredMode = 1;
  Object.defineProperty(mode, "__esModule", {
    value: true
  });
  mode.ModeOfOperation = void 0;
  var aes_js_1 = requireAes();
  var ModeOfOperation = /*#__PURE__*/_createClass(function ModeOfOperation(name, key, cls) {
    _classCallCheck(this, ModeOfOperation);
    if (cls && !(this instanceof cls)) {
      throw new Error("".concat(name, " must be instantiated with \"new\""));
    }
    Object.defineProperties(this, {
      aes: {
        enumerable: true,
        value: new aes_js_1.AES(key)
      },
      name: {
        enumerable: true,
        value: name
      }
    });
  });
  mode.ModeOfOperation = ModeOfOperation;
  return mode;
}

var modeCbc = {};

var hasRequiredModeCbc;
function requireModeCbc() {
  if (hasRequiredModeCbc) return modeCbc;
  hasRequiredModeCbc = 1;
  // Cipher Block Chaining
  var __classPrivateFieldSet = modeCbc && modeCbc.__classPrivateFieldSet || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet = modeCbc && modeCbc.__classPrivateFieldGet || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _CBC_iv, _CBC_lastBlock;
  Object.defineProperty(modeCbc, "__esModule", {
    value: true
  });
  modeCbc.CBC = void 0;
  var mode_js_1 = requireMode();
  var CBC = /*#__PURE__*/function (_mode_js_1$ModeOfOper) {
    function CBC(key, iv) {
      var _this;
      _classCallCheck(this, CBC);
      _this = _callSuper(this, CBC, ["ECC", key, CBC]);
      _CBC_iv.set(_this, void 0);
      _CBC_lastBlock.set(_this, void 0);
      if (iv) {
        if (iv.length % 16) {
          throw new TypeError("invalid iv size (must be 16 bytes)");
        }
        __classPrivateFieldSet(_this, _CBC_iv, new Uint8Array(iv), "f");
      } else {
        __classPrivateFieldSet(_this, _CBC_iv, new Uint8Array(16), "f");
      }
      __classPrivateFieldSet(_this, _CBC_lastBlock, _this.iv, "f");
      return _this;
    }
    _inherits(CBC, _mode_js_1$ModeOfOper);
    return _createClass(CBC, [{
      key: "iv",
      get: function get() {
        return new Uint8Array(__classPrivateFieldGet(this, _CBC_iv, "f"));
      }
    }, {
      key: "encrypt",
      value: function encrypt(plaintext) {
        if (plaintext.length % 16) {
          throw new TypeError("invalid plaintext size (must be multiple of 16 bytes)");
        }
        var ciphertext = new Uint8Array(plaintext.length);
        for (var i = 0; i < plaintext.length; i += 16) {
          for (var j = 0; j < 16; j++) {
            __classPrivateFieldGet(this, _CBC_lastBlock, "f")[j] ^= plaintext[i + j];
          }
          __classPrivateFieldSet(this, _CBC_lastBlock, this.aes.encrypt(__classPrivateFieldGet(this, _CBC_lastBlock, "f")), "f");
          ciphertext.set(__classPrivateFieldGet(this, _CBC_lastBlock, "f"), i);
        }
        return ciphertext;
      }
    }, {
      key: "decrypt",
      value: function decrypt(ciphertext) {
        if (ciphertext.length % 16) {
          throw new TypeError("invalid ciphertext size (must be multiple of 16 bytes)");
        }
        var plaintext = new Uint8Array(ciphertext.length);
        for (var i = 0; i < ciphertext.length; i += 16) {
          var block = this.aes.decrypt(ciphertext.subarray(i, i + 16));
          for (var j = 0; j < 16; j++) {
            plaintext[i + j] = block[j] ^ __classPrivateFieldGet(this, _CBC_lastBlock, "f")[j];
            __classPrivateFieldGet(this, _CBC_lastBlock, "f")[j] = ciphertext[i + j];
          }
        }
        return plaintext;
      }
    }]);
  }(mode_js_1.ModeOfOperation);
  modeCbc.CBC = CBC;
  _CBC_iv = new WeakMap(), _CBC_lastBlock = new WeakMap();
  return modeCbc;
}

var modeCfb = {};

var hasRequiredModeCfb;
function requireModeCfb() {
  if (hasRequiredModeCfb) return modeCfb;
  hasRequiredModeCfb = 1;
  // Cipher Feedback
  var __classPrivateFieldSet = modeCfb && modeCfb.__classPrivateFieldSet || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet = modeCfb && modeCfb.__classPrivateFieldGet || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _CFB_instances, _CFB_iv, _CFB_shiftRegister, _CFB_shift;
  Object.defineProperty(modeCfb, "__esModule", {
    value: true
  });
  modeCfb.CFB = void 0;
  var mode_js_1 = requireMode();
  var CFB = /*#__PURE__*/function (_mode_js_1$ModeOfOper) {
    function CFB(key, iv) {
      var _this;
      var segmentSize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 8;
      _classCallCheck(this, CFB);
      _this = _callSuper(this, CFB, ["CFB", key, CFB]);
      _CFB_instances.add(_this);
      _CFB_iv.set(_this, void 0);
      _CFB_shiftRegister.set(_this, void 0);
      // This library currently only handles byte-aligned segmentSize
      if (!Number.isInteger(segmentSize) || segmentSize % 8) {
        throw new TypeError("invalid segmentSize");
      }
      Object.defineProperties(_this, {
        segmentSize: {
          enumerable: true,
          value: segmentSize
        }
      });
      if (iv) {
        if (iv.length % 16) {
          throw new TypeError("invalid iv size (must be 16 bytes)");
        }
        __classPrivateFieldSet(_this, _CFB_iv, new Uint8Array(iv), "f");
      } else {
        __classPrivateFieldSet(_this, _CFB_iv, new Uint8Array(16), "f");
      }
      __classPrivateFieldSet(_this, _CFB_shiftRegister, _this.iv, "f");
      return _this;
    }
    _inherits(CFB, _mode_js_1$ModeOfOper);
    return _createClass(CFB, [{
      key: "iv",
      get: function get() {
        return new Uint8Array(__classPrivateFieldGet(this, _CFB_iv, "f"));
      }
    }, {
      key: "encrypt",
      value: function encrypt(plaintext) {
        if (8 * plaintext.length % this.segmentSize) {
          throw new TypeError("invalid plaintext size (must be multiple of segmentSize bytes)");
        }
        var segmentSize = this.segmentSize / 8;
        var ciphertext = new Uint8Array(plaintext);
        for (var i = 0; i < ciphertext.length; i += segmentSize) {
          var xorSegment = this.aes.encrypt(__classPrivateFieldGet(this, _CFB_shiftRegister, "f"));
          for (var j = 0; j < segmentSize; j++) {
            ciphertext[i + j] ^= xorSegment[j];
          }
          __classPrivateFieldGet(this, _CFB_instances, "m", _CFB_shift).call(this, ciphertext.subarray(i));
        }
        return ciphertext;
      }
    }, {
      key: "decrypt",
      value: function decrypt(ciphertext) {
        if (8 * ciphertext.length % this.segmentSize) {
          throw new TypeError("invalid ciphertext size (must be multiple of segmentSize bytes)");
        }
        var segmentSize = this.segmentSize / 8;
        var plaintext = new Uint8Array(ciphertext);
        for (var i = 0; i < plaintext.length; i += segmentSize) {
          var xorSegment = this.aes.encrypt(__classPrivateFieldGet(this, _CFB_shiftRegister, "f"));
          for (var j = 0; j < segmentSize; j++) {
            plaintext[i + j] ^= xorSegment[j];
          }
          __classPrivateFieldGet(this, _CFB_instances, "m", _CFB_shift).call(this, ciphertext.subarray(i));
        }
        return plaintext;
      }
    }]);
  }(mode_js_1.ModeOfOperation);
  modeCfb.CFB = CFB;
  _CFB_iv = new WeakMap(), _CFB_shiftRegister = new WeakMap(), _CFB_instances = new WeakSet(), _CFB_shift = function _CFB_shift(data) {
    var segmentSize = this.segmentSize / 8;
    // Shift the register
    __classPrivateFieldGet(this, _CFB_shiftRegister, "f").set(__classPrivateFieldGet(this, _CFB_shiftRegister, "f").subarray(segmentSize));
    __classPrivateFieldGet(this, _CFB_shiftRegister, "f").set(data.subarray(0, segmentSize), 16 - segmentSize);
  };
  return modeCfb;
}

var modeCtr = {};

var hasRequiredModeCtr;
function requireModeCtr() {
  if (hasRequiredModeCtr) return modeCtr;
  hasRequiredModeCtr = 1;
  // Counter Mode
  var __classPrivateFieldSet = modeCtr && modeCtr.__classPrivateFieldSet || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet = modeCtr && modeCtr.__classPrivateFieldGet || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _CTR_remaining, _CTR_remainingIndex, _CTR_counter;
  Object.defineProperty(modeCtr, "__esModule", {
    value: true
  });
  modeCtr.CTR = void 0;
  var mode_js_1 = requireMode();
  var CTR = /*#__PURE__*/function (_mode_js_1$ModeOfOper) {
    function CTR(key, initialValue) {
      var _this;
      _classCallCheck(this, CTR);
      _this = _callSuper(this, CTR, ["CTR", key, CTR]);
      // Remaining bytes for the one-time pad
      _CTR_remaining.set(_this, void 0);
      _CTR_remainingIndex.set(_this, void 0);
      // The current counter
      _CTR_counter.set(_this, void 0);
      __classPrivateFieldSet(_this, _CTR_counter, new Uint8Array(16), "f");
      __classPrivateFieldGet(_this, _CTR_counter, "f").fill(0);
      __classPrivateFieldSet(_this, _CTR_remaining, __classPrivateFieldGet(_this, _CTR_counter, "f"), "f"); // This will be discarded immediately
      __classPrivateFieldSet(_this, _CTR_remainingIndex, 16, "f");
      if (initialValue == null) {
        initialValue = 1;
      }
      if (typeof initialValue === "number") {
        _this.setCounterValue(initialValue);
      } else {
        _this.setCounterBytes(initialValue);
      }
      return _this;
    }
    _inherits(CTR, _mode_js_1$ModeOfOper);
    return _createClass(CTR, [{
      key: "counter",
      get: function get() {
        return new Uint8Array(__classPrivateFieldGet(this, _CTR_counter, "f"));
      }
    }, {
      key: "setCounterValue",
      value: function setCounterValue(value) {
        if (!Number.isInteger(value) || value < 0 || value > Number.MAX_SAFE_INTEGER) {
          throw new TypeError("invalid counter initial integer value");
        }
        for (var index = 15; index >= 0; --index) {
          __classPrivateFieldGet(this, _CTR_counter, "f")[index] = value % 256;
          value = Math.floor(value / 256);
        }
      }
    }, {
      key: "setCounterBytes",
      value: function setCounterBytes(value) {
        if (value.length !== 16) {
          throw new TypeError("invalid counter initial Uint8Array value length");
        }
        __classPrivateFieldGet(this, _CTR_counter, "f").set(value);
      }
    }, {
      key: "increment",
      value: function increment() {
        for (var i = 15; i >= 0; i--) {
          if (__classPrivateFieldGet(this, _CTR_counter, "f")[i] === 255) {
            __classPrivateFieldGet(this, _CTR_counter, "f")[i] = 0;
          } else {
            __classPrivateFieldGet(this, _CTR_counter, "f")[i]++;
            break;
          }
        }
      }
    }, {
      key: "encrypt",
      value: function encrypt(plaintext) {
        var _a, _b;
        var crypttext = new Uint8Array(plaintext);
        for (var i = 0; i < crypttext.length; i++) {
          if (__classPrivateFieldGet(this, _CTR_remainingIndex, "f") === 16) {
            __classPrivateFieldSet(this, _CTR_remaining, this.aes.encrypt(__classPrivateFieldGet(this, _CTR_counter, "f")), "f");
            __classPrivateFieldSet(this, _CTR_remainingIndex, 0, "f");
            this.increment();
          }
          crypttext[i] ^= __classPrivateFieldGet(this, _CTR_remaining, "f")[__classPrivateFieldSet(this, _CTR_remainingIndex, (_b = __classPrivateFieldGet(this, _CTR_remainingIndex, "f"), _a = _b++, _b), "f"), _a];
        }
        return crypttext;
      }
    }, {
      key: "decrypt",
      value: function decrypt(ciphertext) {
        return this.encrypt(ciphertext);
      }
    }]);
  }(mode_js_1.ModeOfOperation);
  modeCtr.CTR = CTR;
  _CTR_remaining = new WeakMap(), _CTR_remainingIndex = new WeakMap(), _CTR_counter = new WeakMap();
  return modeCtr;
}

var modeEcb = {};

var hasRequiredModeEcb;
function requireModeEcb() {
  if (hasRequiredModeEcb) return modeEcb;
  hasRequiredModeEcb = 1;
  // Electronic Code Book
  Object.defineProperty(modeEcb, "__esModule", {
    value: true
  });
  modeEcb.ECB = void 0;
  var mode_js_1 = requireMode();
  var ECB = /*#__PURE__*/function (_mode_js_1$ModeOfOper) {
    function ECB(key) {
      _classCallCheck(this, ECB);
      return _callSuper(this, ECB, ["ECB", key, ECB]);
    }
    _inherits(ECB, _mode_js_1$ModeOfOper);
    return _createClass(ECB, [{
      key: "encrypt",
      value: function encrypt(plaintext) {
        if (plaintext.length % 16) {
          throw new TypeError("invalid plaintext size (must be multiple of 16 bytes)");
        }
        var crypttext = new Uint8Array(plaintext.length);
        for (var i = 0; i < plaintext.length; i += 16) {
          crypttext.set(this.aes.encrypt(plaintext.subarray(i, i + 16)), i);
        }
        return crypttext;
      }
    }, {
      key: "decrypt",
      value: function decrypt(crypttext) {
        if (crypttext.length % 16) {
          throw new TypeError("invalid ciphertext size (must be multiple of 16 bytes)");
        }
        var plaintext = new Uint8Array(crypttext.length);
        for (var i = 0; i < crypttext.length; i += 16) {
          plaintext.set(this.aes.decrypt(crypttext.subarray(i, i + 16)), i);
        }
        return plaintext;
      }
    }]);
  }(mode_js_1.ModeOfOperation);
  modeEcb.ECB = ECB;
  return modeEcb;
}

var modeOfb = {};

var hasRequiredModeOfb;
function requireModeOfb() {
  if (hasRequiredModeOfb) return modeOfb;
  hasRequiredModeOfb = 1;
  // Output Feedback
  var __classPrivateFieldSet = modeOfb && modeOfb.__classPrivateFieldSet || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet = modeOfb && modeOfb.__classPrivateFieldGet || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _OFB_iv, _OFB_lastPrecipher, _OFB_lastPrecipherIndex;
  Object.defineProperty(modeOfb, "__esModule", {
    value: true
  });
  modeOfb.OFB = void 0;
  var mode_js_1 = requireMode();
  var OFB = /*#__PURE__*/function (_mode_js_1$ModeOfOper) {
    function OFB(key, iv) {
      var _this;
      _classCallCheck(this, OFB);
      _this = _callSuper(this, OFB, ["OFB", key, OFB]);
      _OFB_iv.set(_this, void 0);
      _OFB_lastPrecipher.set(_this, void 0);
      _OFB_lastPrecipherIndex.set(_this, void 0);
      if (iv) {
        if (iv.length % 16) {
          throw new TypeError("invalid iv size (must be 16 bytes)");
        }
        __classPrivateFieldSet(_this, _OFB_iv, new Uint8Array(iv), "f");
      } else {
        __classPrivateFieldSet(_this, _OFB_iv, new Uint8Array(16), "f");
      }
      __classPrivateFieldSet(_this, _OFB_lastPrecipher, _this.iv, "f");
      __classPrivateFieldSet(_this, _OFB_lastPrecipherIndex, 16, "f");
      return _this;
    }
    _inherits(OFB, _mode_js_1$ModeOfOper);
    return _createClass(OFB, [{
      key: "iv",
      get: function get() {
        return new Uint8Array(__classPrivateFieldGet(this, _OFB_iv, "f"));
      }
    }, {
      key: "encrypt",
      value: function encrypt(plaintext) {
        var _a, _b;
        if (plaintext.length % 16) {
          throw new TypeError("invalid plaintext size (must be multiple of 16 bytes)");
        }
        var ciphertext = new Uint8Array(plaintext);
        for (var i = 0; i < ciphertext.length; i++) {
          if (__classPrivateFieldGet(this, _OFB_lastPrecipherIndex, "f") === 16) {
            __classPrivateFieldSet(this, _OFB_lastPrecipher, this.aes.encrypt(__classPrivateFieldGet(this, _OFB_lastPrecipher, "f")), "f");
            __classPrivateFieldSet(this, _OFB_lastPrecipherIndex, 0, "f");
          }
          ciphertext[i] ^= __classPrivateFieldGet(this, _OFB_lastPrecipher, "f")[__classPrivateFieldSet(this, _OFB_lastPrecipherIndex, (_b = __classPrivateFieldGet(this, _OFB_lastPrecipherIndex, "f"), _a = _b++, _b), "f"), _a];
        }
        return ciphertext;
      }
    }, {
      key: "decrypt",
      value: function decrypt(ciphertext) {
        if (ciphertext.length % 16) {
          throw new TypeError("invalid ciphertext size (must be multiple of 16 bytes)");
        }
        return this.encrypt(ciphertext);
      }
    }]);
  }(mode_js_1.ModeOfOperation);
  modeOfb.OFB = OFB;
  _OFB_iv = new WeakMap(), _OFB_lastPrecipher = new WeakMap(), _OFB_lastPrecipherIndex = new WeakMap();
  return modeOfb;
}

var padding = {};

var hasRequiredPadding;
function requirePadding() {
  if (hasRequiredPadding) return padding;
  hasRequiredPadding = 1;
  Object.defineProperty(padding, "__esModule", {
    value: true
  });
  padding.pkcs7Strip = padding.pkcs7Pad = void 0;
  function pkcs7Pad(data) {
    var padder = 16 - data.length % 16;
    var result = new Uint8Array(data.length + padder);
    result.set(data);
    for (var i = data.length; i < result.length; i++) {
      result[i] = padder;
    }
    return result;
  }
  padding.pkcs7Pad = pkcs7Pad;
  function pkcs7Strip(data) {
    if (data.length < 16) {
      throw new TypeError('PKCS#7 invalid length');
    }
    var padder = data[data.length - 1];
    if (padder > 16) {
      throw new TypeError('PKCS#7 padding byte out of range');
    }
    var length = data.length - padder;
    for (var i = 0; i < padder; i++) {
      if (data[length + i] !== padder) {
        throw new TypeError('PKCS#7 invalid padding byte');
      }
    }
    return new Uint8Array(data.subarray(0, length));
  }
  padding.pkcs7Strip = pkcs7Strip;
  return padding;
}

var hasRequiredLib_commonjs;
function requireLib_commonjs() {
  if (hasRequiredLib_commonjs) return lib_commonjs;
  hasRequiredLib_commonjs = 1;
  (function (exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.pkcs7Strip = exports.pkcs7Pad = exports.OFB = exports.ECB = exports.CTR = exports.CFB = exports.CBC = exports.ModeOfOperation = exports.AES = void 0;
    var aes_js_1 = requireAes();
    Object.defineProperty(exports, "AES", {
      enumerable: true,
      get: function get() {
        return aes_js_1.AES;
      }
    });
    var mode_js_1 = requireMode();
    Object.defineProperty(exports, "ModeOfOperation", {
      enumerable: true,
      get: function get() {
        return mode_js_1.ModeOfOperation;
      }
    });
    var mode_cbc_js_1 = requireModeCbc();
    Object.defineProperty(exports, "CBC", {
      enumerable: true,
      get: function get() {
        return mode_cbc_js_1.CBC;
      }
    });
    var mode_cfb_js_1 = requireModeCfb();
    Object.defineProperty(exports, "CFB", {
      enumerable: true,
      get: function get() {
        return mode_cfb_js_1.CFB;
      }
    });
    var mode_ctr_js_1 = requireModeCtr();
    Object.defineProperty(exports, "CTR", {
      enumerable: true,
      get: function get() {
        return mode_ctr_js_1.CTR;
      }
    });
    var mode_ecb_js_1 = requireModeEcb();
    Object.defineProperty(exports, "ECB", {
      enumerable: true,
      get: function get() {
        return mode_ecb_js_1.ECB;
      }
    });
    var mode_ofb_js_1 = requireModeOfb();
    Object.defineProperty(exports, "OFB", {
      enumerable: true,
      get: function get() {
        return mode_ofb_js_1.OFB;
      }
    });
    var padding_js_1 = requirePadding();
    Object.defineProperty(exports, "pkcs7Pad", {
      enumerable: true,
      get: function get() {
        return padding_js_1.pkcs7Pad;
      }
    });
    Object.defineProperty(exports, "pkcs7Strip", {
      enumerable: true,
      get: function get() {
        return padding_js_1.pkcs7Strip;
      }
    });
  })(lib_commonjs);
  return lib_commonjs;
}

var utils = {};

var hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils) return utils;
  hasRequiredUtils = 1;
  /**
   *  @_ignore
   */
  Object.defineProperty(utils, "__esModule", {
    value: true
  });
  utils.spelunk = utils.getPassword = utils.zpad = utils.looseArrayify = void 0;
  var index_js_1 = /*@__PURE__*/requireUtils$3();
  function looseArrayify(hexString) {
    if (typeof hexString === "string" && !hexString.startsWith("0x")) {
      hexString = "0x" + hexString;
    }
    return (0, index_js_1.getBytesCopy)(hexString);
  }
  utils.looseArrayify = looseArrayify;
  function zpad(value, length) {
    value = String(value);
    while (value.length < length) {
      value = '0' + value;
    }
    return value;
  }
  utils.zpad = zpad;
  function getPassword(password) {
    if (typeof password === 'string') {
      return (0, index_js_1.toUtf8Bytes)(password, "NFKC");
    }
    return (0, index_js_1.getBytesCopy)(password);
  }
  utils.getPassword = getPassword;
  function spelunk(object, _path) {
    var match = _path.match(/^([a-z0-9$_.-]*)(:([a-z]+))?(!)?$/i);
    (0, index_js_1.assertArgument)(match != null, "invalid path", "path", _path);
    var path = match[1];
    var type = match[3];
    var reqd = match[4] === "!";
    var cur = object;
    var _iterator = _createForOfIteratorHelper(path.toLowerCase().split('.')),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var comp = _step.value;
        // Search for a child object with a case-insensitive matching key
        if (Array.isArray(cur)) {
          if (!comp.match(/^[0-9]+$/)) {
            break;
          }
          cur = cur[parseInt(comp)];
        } else if (_typeof(cur) === "object") {
          var found = null;
          for (var key in cur) {
            if (key.toLowerCase() === comp) {
              found = cur[key];
              break;
            }
          }
          cur = found;
        } else {
          cur = null;
        }
        if (cur == null) {
          break;
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    (0, index_js_1.assertArgument)(!reqd || cur != null, "missing required value", "path", path);
    if (type && cur != null) {
      if (type === "int") {
        if (typeof cur === "string" && cur.match(/^-?[0-9]+$/)) {
          return parseInt(cur);
        } else if (Number.isSafeInteger(cur)) {
          return cur;
        }
      }
      if (type === "number") {
        if (typeof cur === "string" && cur.match(/^-?[0-9.]*$/)) {
          return parseFloat(cur);
        }
      }
      if (type === "data") {
        if (typeof cur === "string") {
          return looseArrayify(cur);
        }
      }
      if (type === "array" && Array.isArray(cur)) {
        return cur;
      }
      if (type === _typeof(cur)) {
        return cur;
      }
      (0, index_js_1.assertArgument)(false, "wrong type found for ".concat(type, " "), "path", path);
    }
    return cur;
  }
  utils.spelunk = spelunk;
  /*
  export function follow(object: any, path: string): null | string {
      let currentChild = object;
  	    for (const comp of path.toLowerCase().split('/')) {
  	        // Search for a child object with a case-insensitive matching key
          let matchingChild = null;
          for (const key in currentChild) {
               if (key.toLowerCase() === comp) {
                   matchingChild = currentChild[key];
                   break;
               }
          }
  	        if (matchingChild === null) { return null; }
  	        currentChild = matchingChild;
      }
  	    return currentChild;
  }
  	// "path/to/something:type!"
  export function followRequired(data: any, path: string): string {
      const value = follow(data, path);
      if (value != null) { return value; }
      return logger.throwArgumentError("invalid value", `data:${ path }`,
      JSON.stringify(data));
  }
  */
  // See: https://www.ietf.org/rfc/rfc4122.txt (Section 4.4)
  /*
  export function uuidV4(randomBytes: BytesLike): string {
      const bytes = getBytes(randomBytes, "randomBytes");
  	    // Section: 4.1.3:
      // - time_hi_and_version[12:16] = 0b0100
      bytes[6] = (bytes[6] & 0x0f) | 0x40;
  	    // Section 4.4
      // - clock_seq_hi_and_reserved[6] = 0b0
      // - clock_seq_hi_and_reserved[7] = 0b1
      bytes[8] = (bytes[8] & 0x3f) | 0x80;
  	    const value = hexlify(bytes);
  	    return [
         value.substring(2, 10),
         value.substring(10, 14),
         value.substring(14, 18),
         value.substring(18, 22),
         value.substring(22, 34),
      ].join("-");
  }
  */

  return utils;
}

var hasRequiredJsonKeystore;
function requireJsonKeystore() {
  if (hasRequiredJsonKeystore) return jsonKeystore;
  hasRequiredJsonKeystore = 1;
  /**
   *  The JSON Wallet formats allow a simple way to store the private
   *  keys needed in Ethereum along with related information and allows
   *  for extensible forms of encryption.
   *
   *  These utilities facilitate decrypting and encrypting the most common
   *  JSON Wallet formats.
   *
   *  @_subsection: api/wallet:JSON Wallets  [json-wallets]
   */
  Object.defineProperty(jsonKeystore, "__esModule", {
    value: true
  });
  jsonKeystore.encryptKeystoreJson = jsonKeystore.encryptKeystoreJsonSync = jsonKeystore.decryptKeystoreJson = jsonKeystore.decryptKeystoreJsonSync = jsonKeystore.isKeystoreJson = void 0;
  var aes_js_1 = /*@__PURE__*/requireLib_commonjs();
  var index_js_1 = /*@__PURE__*/requireAddress$2();
  var index_js_2 = /*@__PURE__*/requireCrypto();
  var index_js_3 = /*@__PURE__*/requireTransaction();
  var index_js_4 = /*@__PURE__*/requireUtils$3();
  var utils_js_1 = /*@__PURE__*/requireUtils();
  var _version_js_1 = /*@__PURE__*/require_version();
  var defaultPath = "m/44'/60'/0'/0/0";
  /**
   *  Returns true if %%json%% is a valid JSON Keystore Wallet.
   */
  function isKeystoreJson(json) {
    try {
      var data = JSON.parse(json);
      var version = data.version != null ? parseInt(data.version) : 0;
      if (version === 3) {
        return true;
      }
    } catch (error) {}
    return false;
  }
  jsonKeystore.isKeystoreJson = isKeystoreJson;
  function decrypt(data, key, ciphertext) {
    var cipher = (0, utils_js_1.spelunk)(data, "crypto.cipher:string");
    if (cipher === "aes-128-ctr") {
      var iv = (0, utils_js_1.spelunk)(data, "crypto.cipherparams.iv:data!");
      var aesCtr = new aes_js_1.CTR(key, iv);
      return (0, index_js_4.hexlify)(aesCtr.decrypt(ciphertext));
    }
    (0, index_js_4.assert)(false, "unsupported cipher", "UNSUPPORTED_OPERATION", {
      operation: "decrypt"
    });
  }
  function getAccount(data, _key) {
    var key = (0, index_js_4.getBytes)(_key);
    var ciphertext = (0, utils_js_1.spelunk)(data, "crypto.ciphertext:data!");
    var computedMAC = (0, index_js_4.hexlify)((0, index_js_2.keccak256)((0, index_js_4.concat)([key.slice(16, 32), ciphertext]))).substring(2);
    (0, index_js_4.assertArgument)(computedMAC === (0, utils_js_1.spelunk)(data, "crypto.mac:string!").toLowerCase(), "incorrect password", "password", "[ REDACTED ]");
    var privateKey = decrypt(data, key.slice(0, 16), ciphertext);
    var address = (0, index_js_3.computeAddress)(privateKey);
    if (data.address) {
      var check = data.address.toLowerCase();
      if (!check.startsWith("0x")) {
        check = "0x" + check;
      }
      (0, index_js_4.assertArgument)((0, index_js_1.getAddress)(check) === address, "keystore address/privateKey mismatch", "address", data.address);
    }
    var account = {
      address: address,
      privateKey: privateKey
    };
    // Version 0.1 x-ethers metadata must contain an encrypted mnemonic phrase
    var version = (0, utils_js_1.spelunk)(data, "x-ethers.version:string");
    if (version === "0.1") {
      var mnemonicKey = key.slice(32, 64);
      var mnemonicCiphertext = (0, utils_js_1.spelunk)(data, "x-ethers.mnemonicCiphertext:data!");
      var mnemonicIv = (0, utils_js_1.spelunk)(data, "x-ethers.mnemonicCounter:data!");
      var mnemonicAesCtr = new aes_js_1.CTR(mnemonicKey, mnemonicIv);
      account.mnemonic = {
        path: (0, utils_js_1.spelunk)(data, "x-ethers.path:string") || defaultPath,
        locale: (0, utils_js_1.spelunk)(data, "x-ethers.locale:string") || "en",
        entropy: (0, index_js_4.hexlify)((0, index_js_4.getBytes)(mnemonicAesCtr.decrypt(mnemonicCiphertext)))
      };
    }
    return account;
  }
  function getDecryptKdfParams(data) {
    var kdf = (0, utils_js_1.spelunk)(data, "crypto.kdf:string");
    if (kdf && typeof kdf === "string") {
      if (kdf.toLowerCase() === "scrypt") {
        var salt = (0, utils_js_1.spelunk)(data, "crypto.kdfparams.salt:data!");
        var N = (0, utils_js_1.spelunk)(data, "crypto.kdfparams.n:int!");
        var r = (0, utils_js_1.spelunk)(data, "crypto.kdfparams.r:int!");
        var p = (0, utils_js_1.spelunk)(data, "crypto.kdfparams.p:int!");
        // Make sure N is a power of 2
        (0, index_js_4.assertArgument)(N > 0 && (N & N - 1) === 0, "invalid kdf.N", "kdf.N", N);
        (0, index_js_4.assertArgument)(r > 0 && p > 0, "invalid kdf", "kdf", kdf);
        var dkLen = (0, utils_js_1.spelunk)(data, "crypto.kdfparams.dklen:int!");
        (0, index_js_4.assertArgument)(dkLen === 32, "invalid kdf.dklen", "kdf.dflen", dkLen);
        return {
          name: "scrypt",
          salt: salt,
          N: N,
          r: r,
          p: p,
          dkLen: 64
        };
      } else if (kdf.toLowerCase() === "pbkdf2") {
        var _salt = (0, utils_js_1.spelunk)(data, "crypto.kdfparams.salt:data!");
        var prf = (0, utils_js_1.spelunk)(data, "crypto.kdfparams.prf:string!");
        var algorithm = prf.split("-").pop();
        (0, index_js_4.assertArgument)(algorithm === "sha256" || algorithm === "sha512", "invalid kdf.pdf", "kdf.pdf", prf);
        var count = (0, utils_js_1.spelunk)(data, "crypto.kdfparams.c:int!");
        var _dkLen = (0, utils_js_1.spelunk)(data, "crypto.kdfparams.dklen:int!");
        (0, index_js_4.assertArgument)(_dkLen === 32, "invalid kdf.dklen", "kdf.dklen", _dkLen);
        return {
          name: "pbkdf2",
          salt: _salt,
          count: count,
          dkLen: _dkLen,
          algorithm: algorithm
        };
      }
    }
    (0, index_js_4.assertArgument)(false, "unsupported key-derivation function", "kdf", kdf);
  }
  /**
   *  Returns the account details for the JSON Keystore Wallet %%json%%
   *  using %%password%%.
   *
   *  It is preferred to use the [async version](decryptKeystoreJson)
   *  instead, which allows a [[ProgressCallback]] to keep the user informed
   *  as to the decryption status.
   *
   *  This method will block the event loop (freezing all UI) until decryption
   *  is complete, which can take quite some time, depending on the wallet
   *  paramters and platform.
   */
  function decryptKeystoreJsonSync(json, _password) {
    var data = JSON.parse(json);
    var password = (0, utils_js_1.getPassword)(_password);
    var params = getDecryptKdfParams(data);
    if (params.name === "pbkdf2") {
      var _salt2 = params.salt,
        count = params.count,
        _dkLen2 = params.dkLen,
        algorithm = params.algorithm;
      var _key2 = (0, index_js_2.pbkdf2)(password, _salt2, count, _dkLen2, algorithm);
      return getAccount(data, _key2);
    }
    (0, index_js_4.assert)(params.name === "scrypt", "cannot be reached", "UNKNOWN_ERROR", {
      params: params
    });
    var salt = params.salt,
      N = params.N,
      r = params.r,
      p = params.p,
      dkLen = params.dkLen;
    var key = (0, index_js_2.scryptSync)(password, salt, N, r, p, dkLen);
    return getAccount(data, key);
  }
  jsonKeystore.decryptKeystoreJsonSync = decryptKeystoreJsonSync;
  function stall(duration) {
    return new Promise(function (resolve) {
      setTimeout(function () {
        resolve();
      }, duration);
    });
  }
  /**
   *  Resolves to the decrypted JSON Keystore Wallet %%json%% using the
   *  %%password%%.
   *
   *  If provided, %%progress%% will be called periodically during the
   *  decrpytion to provide feedback, and if the function returns
   *  ``false`` will halt decryption.
   *
   *  The %%progressCallback%% will **always** receive ``0`` before
   *  decryption begins and ``1`` when complete.
   */
  function decryptKeystoreJson(_x, _x2, _x3) {
    return _decryptKeystoreJson.apply(this, arguments);
  }
  function _decryptKeystoreJson() {
    _decryptKeystoreJson = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(json, _password, progress) {
      var data, password, params, _salt3, count, _dkLen3, algorithm, _key3, salt, N, r, p, dkLen, key;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            data = JSON.parse(json);
            password = (0, utils_js_1.getPassword)(_password);
            params = getDecryptKdfParams(data);
            if (!(params.name === "pbkdf2")) {
              _context.next = 15;
              break;
            }
            if (!progress) {
              _context.next = 8;
              break;
            }
            progress(0);
            _context.next = 8;
            return stall(0);
          case 8:
            _salt3 = params.salt, count = params.count, _dkLen3 = params.dkLen, algorithm = params.algorithm;
            _key3 = (0, index_js_2.pbkdf2)(password, _salt3, count, _dkLen3, algorithm);
            if (!progress) {
              _context.next = 14;
              break;
            }
            progress(1);
            _context.next = 14;
            return stall(0);
          case 14:
            return _context.abrupt("return", getAccount(data, _key3));
          case 15:
            (0, index_js_4.assert)(params.name === "scrypt", "cannot be reached", "UNKNOWN_ERROR", {
              params: params
            });
            salt = params.salt, N = params.N, r = params.r, p = params.p, dkLen = params.dkLen;
            _context.next = 19;
            return (0, index_js_2.scrypt)(password, salt, N, r, p, dkLen, progress);
          case 19:
            key = _context.sent;
            return _context.abrupt("return", getAccount(data, key));
          case 21:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    return _decryptKeystoreJson.apply(this, arguments);
  }
  jsonKeystore.decryptKeystoreJson = decryptKeystoreJson;
  function getEncryptKdfParams(options) {
    // Check/generate the salt
    var salt = options.salt != null ? (0, index_js_4.getBytes)(options.salt, "options.salt") : (0, index_js_2.randomBytes)(32);
    // Override the scrypt password-based key derivation function parameters
    var N = 1 << 17,
      r = 8,
      p = 1;
    if (options.scrypt) {
      if (options.scrypt.N) {
        N = options.scrypt.N;
      }
      if (options.scrypt.r) {
        r = options.scrypt.r;
      }
      if (options.scrypt.p) {
        p = options.scrypt.p;
      }
    }
    (0, index_js_4.assertArgument)(typeof N === "number" && N > 0 && Number.isSafeInteger(N) && (BigInt(N) & BigInt(N - 1)) === BigInt(0), "invalid scrypt N parameter", "options.N", N);
    (0, index_js_4.assertArgument)(typeof r === "number" && r > 0 && Number.isSafeInteger(r), "invalid scrypt r parameter", "options.r", r);
    (0, index_js_4.assertArgument)(typeof p === "number" && p > 0 && Number.isSafeInteger(p), "invalid scrypt p parameter", "options.p", p);
    return {
      name: "scrypt",
      dkLen: 32,
      salt: salt,
      N: N,
      r: r,
      p: p
    };
  }
  function _encryptKeystore(key, kdf, account, options) {
    var privateKey = (0, index_js_4.getBytes)(account.privateKey, "privateKey");
    // Override initialization vector
    var iv = options.iv != null ? (0, index_js_4.getBytes)(options.iv, "options.iv") : (0, index_js_2.randomBytes)(16);
    (0, index_js_4.assertArgument)(iv.length === 16, "invalid options.iv length", "options.iv", options.iv);
    // Override the uuid
    var uuidRandom = options.uuid != null ? (0, index_js_4.getBytes)(options.uuid, "options.uuid") : (0, index_js_2.randomBytes)(16);
    (0, index_js_4.assertArgument)(uuidRandom.length === 16, "invalid options.uuid length", "options.uuid", options.iv);
    // This will be used to encrypt the wallet (as per Web3 secret storage)
    // - 32 bytes   As normal for the Web3 secret storage (derivedKey, macPrefix)
    // - 32 bytes   AES key to encrypt mnemonic with (required here to be Ethers Wallet)
    var derivedKey = key.slice(0, 16);
    var macPrefix = key.slice(16, 32);
    // Encrypt the private key
    var aesCtr = new aes_js_1.CTR(derivedKey, iv);
    var ciphertext = (0, index_js_4.getBytes)(aesCtr.encrypt(privateKey));
    // Compute the message authentication code, used to check the password
    var mac = (0, index_js_2.keccak256)((0, index_js_4.concat)([macPrefix, ciphertext]));
    // See: https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition
    var data = {
      address: account.address.substring(2).toLowerCase(),
      id: (0, index_js_4.uuidV4)(uuidRandom),
      version: 3,
      Crypto: {
        cipher: "aes-128-ctr",
        cipherparams: {
          iv: (0, index_js_4.hexlify)(iv).substring(2)
        },
        ciphertext: (0, index_js_4.hexlify)(ciphertext).substring(2),
        kdf: "scrypt",
        kdfparams: {
          salt: (0, index_js_4.hexlify)(kdf.salt).substring(2),
          n: kdf.N,
          dklen: 32,
          p: kdf.p,
          r: kdf.r
        },
        mac: mac.substring(2)
      }
    };
    // If we have a mnemonic, encrypt it into the JSON wallet
    if (account.mnemonic) {
      var client = options.client != null ? options.client : "ethers/".concat(_version_js_1.version);
      var path = account.mnemonic.path || defaultPath;
      var locale = account.mnemonic.locale || "en";
      var mnemonicKey = key.slice(32, 64);
      var entropy = (0, index_js_4.getBytes)(account.mnemonic.entropy, "account.mnemonic.entropy");
      var mnemonicIv = (0, index_js_2.randomBytes)(16);
      var mnemonicAesCtr = new aes_js_1.CTR(mnemonicKey, mnemonicIv);
      var mnemonicCiphertext = (0, index_js_4.getBytes)(mnemonicAesCtr.encrypt(entropy));
      var now = new Date();
      var timestamp = now.getUTCFullYear() + "-" + (0, utils_js_1.zpad)(now.getUTCMonth() + 1, 2) + "-" + (0, utils_js_1.zpad)(now.getUTCDate(), 2) + "T" + (0, utils_js_1.zpad)(now.getUTCHours(), 2) + "-" + (0, utils_js_1.zpad)(now.getUTCMinutes(), 2) + "-" + (0, utils_js_1.zpad)(now.getUTCSeconds(), 2) + ".0Z";
      var gethFilename = "UTC--" + timestamp + "--" + data.address;
      data["x-ethers"] = {
        client: client,
        gethFilename: gethFilename,
        path: path,
        locale: locale,
        mnemonicCounter: (0, index_js_4.hexlify)(mnemonicIv).substring(2),
        mnemonicCiphertext: (0, index_js_4.hexlify)(mnemonicCiphertext).substring(2),
        version: "0.1"
      };
    }
    return JSON.stringify(data);
  }
  /**
   *  Return the JSON Keystore Wallet for %%account%% encrypted with
   *  %%password%%.
   *
   *  The %%options%% can be used to tune the password-based key
   *  derivation function parameters, explicitly set the random values
   *  used. Any provided [[ProgressCallback]] is ignord.
   */
  function encryptKeystoreJsonSync(account, password, options) {
    if (options == null) {
      options = {};
    }
    var passwordBytes = (0, utils_js_1.getPassword)(password);
    var kdf = getEncryptKdfParams(options);
    var key = (0, index_js_2.scryptSync)(passwordBytes, kdf.salt, kdf.N, kdf.r, kdf.p, 64);
    return _encryptKeystore((0, index_js_4.getBytes)(key), kdf, account, options);
  }
  jsonKeystore.encryptKeystoreJsonSync = encryptKeystoreJsonSync;
  /**
   *  Resolved to the JSON Keystore Wallet for %%account%% encrypted
   *  with %%password%%.
   *
   *  The %%options%% can be used to tune the password-based key
   *  derivation function parameters, explicitly set the random values
   *  used and provide a [[ProgressCallback]] to receive periodic updates
   *  on the completion status..
   */
  function encryptKeystoreJson(_x4, _x5, _x6) {
    return _encryptKeystoreJson.apply(this, arguments);
  }
  function _encryptKeystoreJson() {
    _encryptKeystoreJson = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(account, password, options) {
      var passwordBytes, kdf, key;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            if (options == null) {
              options = {};
            }
            passwordBytes = (0, utils_js_1.getPassword)(password);
            kdf = getEncryptKdfParams(options);
            _context2.next = 5;
            return (0, index_js_2.scrypt)(passwordBytes, kdf.salt, kdf.N, kdf.r, kdf.p, 64, options.progressCallback);
          case 5:
            key = _context2.sent;
            return _context2.abrupt("return", _encryptKeystore((0, index_js_4.getBytes)(key), kdf, account, options));
          case 7:
          case "end":
            return _context2.stop();
        }
      }, _callee2);
    }));
    return _encryptKeystoreJson.apply(this, arguments);
  }
  jsonKeystore.encryptKeystoreJson = encryptKeystoreJson;
  return jsonKeystore;
}

var hasRequiredHdwallet;
function requireHdwallet() {
  if (hasRequiredHdwallet) return hdwallet;
  hasRequiredHdwallet = 1;
  (function (exports, _HDNodeWallet) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getIndexedAccountPath = exports.getAccountPath = exports.HDNodeVoidWallet = exports.HDNodeWallet = exports.defaultPath = void 0;
    /**
     *  Explain HD Wallets..
     *
     *  @_subsection: api/wallet:HD Wallets  [hd-wallets]
     */
    var index_js_1 = /*@__PURE__*/requireCrypto();
    var index_js_2 = /*@__PURE__*/requireProviders();
    var index_js_3 = /*@__PURE__*/requireTransaction();
    var index_js_4 = /*@__PURE__*/requireUtils$3();
    var lang_en_js_1 = /*@__PURE__*/requireLangEn();
    var base_wallet_js_1 = /*@__PURE__*/requireBaseWallet();
    var mnemonic_js_1 = /*@__PURE__*/requireMnemonic();
    var json_keystore_js_1 = /*@__PURE__*/requireJsonKeystore();
    /**
     *  The default derivation path for Ethereum HD Nodes. (i.e. ``"m/44'/60'/0'/0/0"``)
     */
    exports.defaultPath = "m/44'/60'/0'/0/0";
    // "Bitcoin seed"
    var MasterSecret = new Uint8Array([66, 105, 116, 99, 111, 105, 110, 32, 115, 101, 101, 100]);
    var HardenedBit = 0x80000000;
    var N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
    var Nibbles = "0123456789abcdef";
    function zpad(value, length) {
      var result = "";
      while (value) {
        result = Nibbles[value % 16] + result;
        value = Math.trunc(value / 16);
      }
      while (result.length < length * 2) {
        result = "0" + result;
      }
      return "0x" + result;
    }
    function encodeBase58Check(_value) {
      var value = (0, index_js_4.getBytes)(_value);
      var check = (0, index_js_4.dataSlice)((0, index_js_1.sha256)((0, index_js_1.sha256)(value)), 0, 4);
      var bytes = (0, index_js_4.concat)([value, check]);
      return (0, index_js_4.encodeBase58)(bytes);
    }
    var _guard = {};
    function ser_I(index, chainCode, publicKey, privateKey) {
      var data = new Uint8Array(37);
      if (index & HardenedBit) {
        (0, index_js_4.assert)(privateKey != null, "cannot derive child of neutered node", "UNSUPPORTED_OPERATION", {
          operation: "deriveChild"
        });
        // Data = 0x00 || ser_256(k_par)
        data.set((0, index_js_4.getBytes)(privateKey), 1);
      } else {
        // Data = ser_p(point(k_par))
        data.set((0, index_js_4.getBytes)(publicKey));
      }
      // Data += ser_32(i)
      for (var i = 24; i >= 0; i -= 8) {
        data[33 + (i >> 3)] = index >> 24 - i & 0xff;
      }
      var I = (0, index_js_4.getBytes)((0, index_js_1.computeHmac)("sha512", chainCode, data));
      return {
        IL: I.slice(0, 32),
        IR: I.slice(32)
      };
    }
    function _derivePath(node, path) {
      var components = path.split("/");
      (0, index_js_4.assertArgument)(components.length > 0, "invalid path", "path", path);
      if (components[0] === "m") {
        (0, index_js_4.assertArgument)(node.depth === 0, "cannot derive root path (i.e. path starting with \"m/\") for a node at non-zero depth ".concat(node.depth), "path", path);
        components.shift();
      }
      var result = node;
      for (var i = 0; i < components.length; i++) {
        var component = components[i];
        if (component.match(/^[0-9]+'$/)) {
          var index = parseInt(component.substring(0, component.length - 1));
          (0, index_js_4.assertArgument)(index < HardenedBit, "invalid path index", "path[".concat(i, "]"), component);
          result = result.deriveChild(HardenedBit + index);
        } else if (component.match(/^[0-9]+$/)) {
          var _index2 = parseInt(component);
          (0, index_js_4.assertArgument)(_index2 < HardenedBit, "invalid path index", "path[".concat(i, "]"), component);
          result = result.deriveChild(_index2);
        } else {
          (0, index_js_4.assertArgument)(false, "invalid path component", "path[".concat(i, "]"), component);
        }
      }
      return result;
    }
    /**
     *  An **HDNodeWallet** is a [[Signer]] backed by the private key derived
     *  from an HD Node using the [[link-bip-32]] stantard.
     *
     *  An HD Node forms a hierarchal structure with each HD Node having a
     *  private key and the ability to derive child HD Nodes, defined by
     *  a path indicating the index of each child.
     */
    var _HDNodeWallet_brand = /*#__PURE__*/new WeakSet();
    var HDNodeWallet = /*#__PURE__*/function (_base_wallet_js_1$Bas) {
      /**
       *  @private
       */
      function HDNodeWallet(guard, signingKey, parentFingerprint, chainCode, path, index, depth, mnemonic, provider) {
        var _this;
        _classCallCheck(this, HDNodeWallet);
        _this = _callSuper(this, HDNodeWallet, [signingKey, provider]);
        _classPrivateMethodInitSpec(_this, _HDNodeWallet_brand);
        /**
         *  The compressed public key.
         */
        _defineProperty(_this, "publicKey", void 0);
        /**
         *  The fingerprint.
         *
         *  A fingerprint allows quick qay to detect parent and child nodes,
         *  but developers should be prepared to deal with collisions as it
         *  is only 4 bytes.
         */
        _defineProperty(_this, "fingerprint", void 0);
        /**
         *  The parent fingerprint.
         */
        _defineProperty(_this, "parentFingerprint", void 0);
        /**
         *  The mnemonic used to create this HD Node, if available.
         *
         *  Sources such as extended keys do not encode the mnemonic, in
         *  which case this will be ``null``.
         */
        _defineProperty(_this, "mnemonic", void 0);
        /**
         *  The chaincode, which is effectively a public key used
         *  to derive children.
         */
        _defineProperty(_this, "chainCode", void 0);
        /**
         *  The derivation path of this wallet.
         *
         *  Since extended keys do not provide full path details, this
         *  may be ``null``, if instantiated from a source that does not
         *  encode it.
         */
        _defineProperty(_this, "path", void 0);
        /**
         *  The child index of this wallet. Values over ``2 *\* 31`` indicate
         *  the node is hardened.
         */
        _defineProperty(_this, "index", void 0);
        /**
         *  The depth of this wallet, which is the number of components
         *  in its path.
         */
        _defineProperty(_this, "depth", void 0);
        (0, index_js_4.assertPrivate)(guard, _guard, "HDNodeWallet");
        (0, index_js_4.defineProperties)(_this, {
          publicKey: signingKey.compressedPublicKey
        });
        var fingerprint = (0, index_js_4.dataSlice)((0, index_js_1.ripemd160)((0, index_js_1.sha256)(_this.publicKey)), 0, 4);
        (0, index_js_4.defineProperties)(_this, {
          parentFingerprint: parentFingerprint,
          fingerprint: fingerprint,
          chainCode: chainCode,
          path: path,
          index: index,
          depth: depth
        });
        (0, index_js_4.defineProperties)(_this, {
          mnemonic: mnemonic
        });
        return _this;
      }
      _inherits(HDNodeWallet, _base_wallet_js_1$Bas);
      return _createClass(HDNodeWallet, [{
        key: "connect",
        value: function connect(provider) {
          return new HDNodeWallet(_guard, this.signingKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, this.mnemonic, provider);
        }
      }, {
        key: "encrypt",
        value: (
        /**
         *  Resolves to a [JSON Keystore Wallet](json-wallets) encrypted with
         *  %%password%%.
         *
         *  If %%progressCallback%% is specified, it will receive periodic
         *  updates as the encryption process progreses.
         */
        function () {
          var _encrypt = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(password, progressCallback) {
            return _regeneratorRuntime().wrap(function _callee$(_context) {
              while (1) switch (_context.prev = _context.next) {
                case 0:
                  _context.next = 2;
                  return (0, json_keystore_js_1.encryptKeystoreJson)(_assertClassBrand(_HDNodeWallet_brand, this, _account).call(this), password, {
                    progressCallback: progressCallback
                  });
                case 2:
                  return _context.abrupt("return", _context.sent);
                case 3:
                case "end":
                  return _context.stop();
              }
            }, _callee, this);
          }));
          function encrypt(_x, _x2) {
            return _encrypt.apply(this, arguments);
          }
          return encrypt;
        }()
        /**
         *  Returns a [JSON Keystore Wallet](json-wallets) encryped with
         *  %%password%%.
         *
         *  It is preferred to use the [async version](encrypt) instead,
         *  which allows a [[ProgressCallback]] to keep the user informed.
         *
         *  This method will block the event loop (freezing all UI) until
         *  it is complete, which may be a non-trivial duration.
         */
        )
      }, {
        key: "encryptSync",
        value: function encryptSync(password) {
          return (0, json_keystore_js_1.encryptKeystoreJsonSync)(_assertClassBrand(_HDNodeWallet_brand, this, _account).call(this), password);
        }
        /**
         *  The extended key.
         *
         *  This key will begin with the prefix ``xpriv`` and can be used to
         *  reconstruct this HD Node to derive its children.
         */
      }, {
        key: "extendedKey",
        get: function get() {
          // We only support the mainnet values for now, but if anyone needs
          // testnet values, let me know. I believe current sentiment is that
          // we should always use mainnet, and use BIP-44 to derive the network
          //   - Mainnet: public=0x0488B21E, private=0x0488ADE4
          //   - Testnet: public=0x043587CF, private=0x04358394
          (0, index_js_4.assert)(this.depth < 256, "Depth too deep", "UNSUPPORTED_OPERATION", {
            operation: "extendedKey"
          });
          return encodeBase58Check((0, index_js_4.concat)(["0x0488ADE4", zpad(this.depth, 1), this.parentFingerprint, zpad(this.index, 4), this.chainCode, (0, index_js_4.concat)(["0x00", this.privateKey])]));
        }
        /**
         *  Returns true if this wallet has a path, providing a Type Guard
         *  that the path is non-null.
         */
      }, {
        key: "hasPath",
        value: function hasPath() {
          return this.path != null;
        }
        /**
         *  Returns a neutered HD Node, which removes the private details
         *  of an HD Node.
         *
         *  A neutered node has no private key, but can be used to derive
         *  child addresses and other public data about the HD Node.
         */
      }, {
        key: "neuter",
        value: function neuter() {
          return new HDNodeVoidWallet(_guard, this.address, this.publicKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, this.provider);
        }
        /**
         *  Return the child for %%index%%.
         */
      }, {
        key: "deriveChild",
        value: function deriveChild(_index) {
          var index = (0, index_js_4.getNumber)(_index, "index");
          (0, index_js_4.assertArgument)(index <= 0xffffffff, "invalid index", "index", index);
          // Base path
          var path = this.path;
          if (path) {
            path += "/" + (index & ~HardenedBit);
            if (index & HardenedBit) {
              path += "'";
            }
          }
          var _ser_I = ser_I(index, this.chainCode, this.publicKey, this.privateKey),
            IR = _ser_I.IR,
            IL = _ser_I.IL;
          var ki = new index_js_1.SigningKey((0, index_js_4.toBeHex)(((0, index_js_4.toBigInt)(IL) + BigInt(this.privateKey)) % N, 32));
          return new HDNodeWallet(_guard, ki, this.fingerprint, (0, index_js_4.hexlify)(IR), path, index, this.depth + 1, this.mnemonic, this.provider);
        }
        /**
         *  Return the HDNode for %%path%% from this node.
         */
      }, {
        key: "derivePath",
        value: function derivePath(path) {
          return _derivePath(this, path);
        }
      }], [{
        key: "fromExtendedKey",
        value:
        /**
         *  Creates a new HD Node from %%extendedKey%%.
         *
         *  If the %%extendedKey%% will either have a prefix or ``xpub`` or
         *  ``xpriv``, returning a neutered HD Node ([[HDNodeVoidWallet]])
         *  or full HD Node ([[HDNodeWallet) respectively.
         */
        function fromExtendedKey(extendedKey) {
          var bytes = (0, index_js_4.toBeArray)((0, index_js_4.decodeBase58)(extendedKey)); // @TODO: redact
          (0, index_js_4.assertArgument)(bytes.length === 82 || encodeBase58Check(bytes.slice(0, 78)) === extendedKey, "invalid extended key", "extendedKey", "[ REDACTED ]");
          var depth = bytes[4];
          var parentFingerprint = (0, index_js_4.hexlify)(bytes.slice(5, 9));
          var index = parseInt((0, index_js_4.hexlify)(bytes.slice(9, 13)).substring(2), 16);
          var chainCode = (0, index_js_4.hexlify)(bytes.slice(13, 45));
          var key = bytes.slice(45, 78);
          switch ((0, index_js_4.hexlify)(bytes.slice(0, 4))) {
            // Public Key
            case "0x0488b21e":
            case "0x043587cf":
              {
                var publicKey = (0, index_js_4.hexlify)(key);
                return new HDNodeVoidWallet(_guard, (0, index_js_3.computeAddress)(publicKey), publicKey, parentFingerprint, chainCode, null, index, depth, null);
              }
            // Private Key
            case "0x0488ade4":
            case "0x04358394 ":
              if (key[0] !== 0) {
                break;
              }
              return new HDNodeWallet(_guard, new index_js_1.SigningKey(key.slice(1)), parentFingerprint, chainCode, null, index, depth, null, null);
          }
          (0, index_js_4.assertArgument)(false, "invalid extended key prefix", "extendedKey", "[ REDACTED ]");
        }
        /**
         *  Creates a new random HDNode.
         */
      }, {
        key: "createRandom",
        value: function createRandom(password, path, wordlist) {
          if (password == null) {
            password = "";
          }
          if (path == null) {
            path = exports.defaultPath;
          }
          if (wordlist == null) {
            wordlist = lang_en_js_1.LangEn.wordlist();
          }
          var mnemonic = mnemonic_js_1.Mnemonic.fromEntropy((0, index_js_1.randomBytes)(16), password, wordlist);
          return _fromSeed.call(HDNodeWallet, mnemonic.computeSeed(), mnemonic).derivePath(path);
        }
        /**
         *  Create an HD Node from %%mnemonic%%.
         */
      }, {
        key: "fromMnemonic",
        value: function fromMnemonic(mnemonic, path) {
          if (!path) {
            path = exports.defaultPath;
          }
          return _fromSeed.call(HDNodeWallet, mnemonic.computeSeed(), mnemonic).derivePath(path);
        }
        /**
         *  Creates an HD Node from a mnemonic %%phrase%%.
         */
      }, {
        key: "fromPhrase",
        value: function fromPhrase(phrase, password, path, wordlist) {
          if (password == null) {
            password = "";
          }
          if (path == null) {
            path = exports.defaultPath;
          }
          if (wordlist == null) {
            wordlist = lang_en_js_1.LangEn.wordlist();
          }
          var mnemonic = mnemonic_js_1.Mnemonic.fromPhrase(phrase, password, wordlist);
          return _fromSeed.call(HDNodeWallet, mnemonic.computeSeed(), mnemonic).derivePath(path);
        }
        /**
         *  Creates an HD Node from a %%seed%%.
         */
      }, {
        key: "fromSeed",
        value: function fromSeed(seed) {
          return _fromSeed.call(HDNodeWallet, seed, null);
        }
      }]);
    }(base_wallet_js_1.BaseWallet);
    _HDNodeWallet = HDNodeWallet;
    function _account() {
      var account = {
        address: this.address,
        privateKey: this.privateKey
      };
      var m = this.mnemonic;
      if (this.path && m && m.wordlist.locale === "en" && m.password === "") {
        account.mnemonic = {
          path: this.path,
          locale: "en",
          entropy: m.entropy
        };
      }
      return account;
    }
    function _fromSeed(_seed, mnemonic) {
      (0, index_js_4.assertArgument)((0, index_js_4.isBytesLike)(_seed), "invalid seed", "seed", "[REDACTED]");
      var seed = (0, index_js_4.getBytes)(_seed, "seed");
      (0, index_js_4.assertArgument)(seed.length >= 16 && seed.length <= 64, "invalid seed", "seed", "[REDACTED]");
      var I = (0, index_js_4.getBytes)((0, index_js_1.computeHmac)("sha512", MasterSecret, seed));
      var signingKey = new index_js_1.SigningKey((0, index_js_4.hexlify)(I.slice(0, 32)));
      return new _HDNodeWallet(_guard, signingKey, "0x00000000", (0, index_js_4.hexlify)(I.slice(32)), "m", 0, 0, mnemonic, null);
    }
    exports.HDNodeWallet = HDNodeWallet;
    /**
     *  A **HDNodeVoidWallet** cannot sign, but provides access to
     *  the children nodes of a [[link-bip-32]] HD wallet addresses.
     *
     *  The can be created by using an extended ``xpub`` key to
     *  [[HDNodeWallet_fromExtendedKey]] or by
     *  [nuetering](HDNodeWallet-neuter) a [[HDNodeWallet]].
     */
    var HDNodeVoidWallet = /*#__PURE__*/function (_index_js_2$VoidSigne) {
      /**
       *  @private
       */
      function HDNodeVoidWallet(guard, address, publicKey, parentFingerprint, chainCode, path, index, depth, provider) {
        var _this2;
        _classCallCheck(this, HDNodeVoidWallet);
        _this2 = _callSuper(this, HDNodeVoidWallet, [address, provider]);
        /**
         *  The compressed public key.
         */
        _defineProperty(_this2, "publicKey", void 0);
        /**
         *  The fingerprint.
         *
         *  A fingerprint allows quick qay to detect parent and child nodes,
         *  but developers should be prepared to deal with collisions as it
         *  is only 4 bytes.
         */
        _defineProperty(_this2, "fingerprint", void 0);
        /**
         *  The parent node fingerprint.
         */
        _defineProperty(_this2, "parentFingerprint", void 0);
        /**
         *  The chaincode, which is effectively a public key used
         *  to derive children.
         */
        _defineProperty(_this2, "chainCode", void 0);
        /**
         *  The derivation path of this wallet.
         *
         *  Since extended keys do not provider full path details, this
         *  may be ``null``, if instantiated from a source that does not
         *  enocde it.
         */
        _defineProperty(_this2, "path", void 0);
        /**
         *  The child index of this wallet. Values over ``2 *\* 31`` indicate
         *  the node is hardened.
         */
        _defineProperty(_this2, "index", void 0);
        /**
         *  The depth of this wallet, which is the number of components
         *  in its path.
         */
        _defineProperty(_this2, "depth", void 0);
        (0, index_js_4.assertPrivate)(guard, _guard, "HDNodeVoidWallet");
        (0, index_js_4.defineProperties)(_this2, {
          publicKey: publicKey
        });
        var fingerprint = (0, index_js_4.dataSlice)((0, index_js_1.ripemd160)((0, index_js_1.sha256)(publicKey)), 0, 4);
        (0, index_js_4.defineProperties)(_this2, {
          publicKey: publicKey,
          fingerprint: fingerprint,
          parentFingerprint: parentFingerprint,
          chainCode: chainCode,
          path: path,
          index: index,
          depth: depth
        });
        return _this2;
      }
      _inherits(HDNodeVoidWallet, _index_js_2$VoidSigne);
      return _createClass(HDNodeVoidWallet, [{
        key: "connect",
        value: function connect(provider) {
          return new HDNodeVoidWallet(_guard, this.address, this.publicKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, provider);
        }
        /**
         *  The extended key.
         *
         *  This key will begin with the prefix ``xpub`` and can be used to
         *  reconstruct this neutered key to derive its children addresses.
         */
      }, {
        key: "extendedKey",
        get: function get() {
          // We only support the mainnet values for now, but if anyone needs
          // testnet values, let me know. I believe current sentiment is that
          // we should always use mainnet, and use BIP-44 to derive the network
          //   - Mainnet: public=0x0488B21E, private=0x0488ADE4
          //   - Testnet: public=0x043587CF, private=0x04358394
          (0, index_js_4.assert)(this.depth < 256, "Depth too deep", "UNSUPPORTED_OPERATION", {
            operation: "extendedKey"
          });
          return encodeBase58Check((0, index_js_4.concat)(["0x0488B21E", zpad(this.depth, 1), this.parentFingerprint, zpad(this.index, 4), this.chainCode, this.publicKey]));
        }
        /**
         *  Returns true if this wallet has a path, providing a Type Guard
         *  that the path is non-null.
         */
      }, {
        key: "hasPath",
        value: function hasPath() {
          return this.path != null;
        }
        /**
         *  Return the child for %%index%%.
         */
      }, {
        key: "deriveChild",
        value: function deriveChild(_index) {
          var index = (0, index_js_4.getNumber)(_index, "index");
          (0, index_js_4.assertArgument)(index <= 0xffffffff, "invalid index", "index", index);
          // Base path
          var path = this.path;
          if (path) {
            path += "/" + (index & ~HardenedBit);
            if (index & HardenedBit) {
              path += "'";
            }
          }
          var _ser_I2 = ser_I(index, this.chainCode, this.publicKey, null),
            IR = _ser_I2.IR,
            IL = _ser_I2.IL;
          var Ki = index_js_1.SigningKey.addPoints(IL, this.publicKey, true);
          var address = (0, index_js_3.computeAddress)(Ki);
          return new HDNodeVoidWallet(_guard, address, Ki, this.fingerprint, (0, index_js_4.hexlify)(IR), path, index, this.depth + 1, this.provider);
        }
        /**
         *  Return the signer for %%path%% from this node.
         */
      }, {
        key: "derivePath",
        value: function derivePath(path) {
          return _derivePath(this, path);
        }
      }]);
    }(index_js_2.VoidSigner);
    exports.HDNodeVoidWallet = HDNodeVoidWallet;
    /*
    export class HDNodeWalletManager {
        #root: HDNodeWallet;
    	    constructor(phrase: string, password?: null | string, path?: null | string, locale?: null | Wordlist) {
            if (password == null) { password = ""; }
            if (path == null) { path = "m/44'/60'/0'/0"; }
            if (locale == null) { locale = LangEn.wordlist(); }
            this.#root = HDNodeWallet.fromPhrase(phrase, password, path, locale);
        }
    	    getSigner(index?: number): HDNodeWallet {
            return this.#root.deriveChild((index == null) ? 0: index);
        }
    }
    */
    /**
     *  Returns the [[link-bip-32]] path for the account at %%index%%.
     *
     *  This is the pattern used by wallets like Ledger.
     *
     *  There is also an [alternate pattern](getIndexedAccountPath) used by
     *  some software.
     */
    function getAccountPath(_index) {
      var index = (0, index_js_4.getNumber)(_index, "index");
      (0, index_js_4.assertArgument)(index >= 0 && index < HardenedBit, "invalid account index", "index", index);
      return "m/44'/60'/".concat(index, "'/0/0");
    }
    exports.getAccountPath = getAccountPath;
    /**
     *  Returns the path using an alternative pattern for deriving accounts,
     *  at %%index%%.
     *
     *  This derivation path uses the //index// component rather than the
     *  //account// component to derive sequential accounts.
     *
     *  This is the pattern used by wallets like MetaMask.
     */
    function getIndexedAccountPath(_index) {
      var index = (0, index_js_4.getNumber)(_index, "index");
      (0, index_js_4.assertArgument)(index >= 0 && index < HardenedBit, "invalid account index", "index", index);
      return "m/44'/60'/0'/0/".concat(index);
    }
    exports.getIndexedAccountPath = getIndexedAccountPath;
  })(hdwallet);
  return hdwallet;
}

var jsonCrowdsale = {};

var hasRequiredJsonCrowdsale;
function requireJsonCrowdsale() {
  if (hasRequiredJsonCrowdsale) return jsonCrowdsale;
  hasRequiredJsonCrowdsale = 1;
  /**
   *  @_subsection: api/wallet:JSON Wallets  [json-wallets]
   */
  Object.defineProperty(jsonCrowdsale, "__esModule", {
    value: true
  });
  jsonCrowdsale.decryptCrowdsaleJson = jsonCrowdsale.isCrowdsaleJson = void 0;
  var aes_js_1 = /*@__PURE__*/requireLib_commonjs();
  var index_js_1 = /*@__PURE__*/requireAddress$2();
  var index_js_2 = /*@__PURE__*/requireCrypto();
  var index_js_3 = /*@__PURE__*/requireHash();
  var index_js_4 = /*@__PURE__*/requireUtils$3();
  var utils_js_1 = /*@__PURE__*/requireUtils();
  /**
   *  Returns true if %%json%% is a valid JSON Crowdsale wallet.
   */
  function isCrowdsaleJson(json) {
    try {
      var data = JSON.parse(json);
      if (data.encseed) {
        return true;
      }
    } catch (error) {}
    return false;
  }
  jsonCrowdsale.isCrowdsaleJson = isCrowdsaleJson;
  // See: https://github.com/ethereum/pyethsaletool
  /**
   *  Before Ethereum launched, it was necessary to create a wallet
   *  format for backers to use, which would be used to receive ether
   *  as a reward for contributing to the project.
   *
   *  The [[link-crowdsale]] format is now obsolete, but it is still
   *  useful to support and the additional code is fairly trivial as
   *  all the primitives required are used through core portions of
   *  the library.
   */
  function decryptCrowdsaleJson(json, _password) {
    var data = JSON.parse(json);
    var password = (0, utils_js_1.getPassword)(_password);
    // Ethereum Address
    var address = (0, index_js_1.getAddress)((0, utils_js_1.spelunk)(data, "ethaddr:string!"));
    // Encrypted Seed
    var encseed = (0, utils_js_1.looseArrayify)((0, utils_js_1.spelunk)(data, "encseed:string!"));
    (0, index_js_4.assertArgument)(encseed && encseed.length % 16 === 0, "invalid encseed", "json", json);
    var key = (0, index_js_4.getBytes)((0, index_js_2.pbkdf2)(password, password, 2000, 32, "sha256")).slice(0, 16);
    var iv = encseed.slice(0, 16);
    var encryptedSeed = encseed.slice(16);
    // Decrypt the seed
    var aesCbc = new aes_js_1.CBC(key, iv);
    var seed = (0, aes_js_1.pkcs7Strip)((0, index_js_4.getBytes)(aesCbc.decrypt(encryptedSeed)));
    // This wallet format is weird... Convert the binary encoded hex to a string.
    var seedHex = "";
    for (var i = 0; i < seed.length; i++) {
      seedHex += String.fromCharCode(seed[i]);
    }
    return {
      address: address,
      privateKey: (0, index_js_3.id)(seedHex)
    };
  }
  jsonCrowdsale.decryptCrowdsaleJson = decryptCrowdsaleJson;
  return jsonCrowdsale;
}

var wallet = {};

var hasRequiredWallet$1;
function requireWallet$1() {
  var _Wallet;
  if (hasRequiredWallet$1) return wallet;
  hasRequiredWallet$1 = 1;
  Object.defineProperty(wallet, "__esModule", {
    value: true
  });
  wallet.Wallet = void 0;
  var index_js_1 = /*@__PURE__*/requireCrypto();
  var index_js_2 = /*@__PURE__*/requireUtils$3();
  var base_wallet_js_1 = /*@__PURE__*/requireBaseWallet();
  var hdwallet_js_1 = /*@__PURE__*/requireHdwallet();
  var json_crowdsale_js_1 = /*@__PURE__*/requireJsonCrowdsale();
  var json_keystore_js_1 = /*@__PURE__*/requireJsonKeystore();
  var mnemonic_js_1 = /*@__PURE__*/requireMnemonic();
  function stall(duration) {
    return new Promise(function (resolve) {
      setTimeout(function () {
        resolve();
      }, duration);
    });
  }
  /**
   *  A **Wallet** manages a single private key which is used to sign
   *  transactions, messages and other common payloads.
   *
   *  This class is generally the main entry point for developers
   *  that wish to use a private key directly, as it can create
   *  instances from a large variety of common sources, including
   *  raw private key, [[link-bip-39]] mnemonics and encrypte JSON
   *  wallets.
   */
  var Wallet = /*#__PURE__*/function (_base_wallet_js_1$Bas) {
    /**
     *  Create a new wallet for the private %%key%%, optionally connected
     *  to %%provider%%.
     */
    function Wallet(key, provider) {
      _classCallCheck(this, Wallet);
      if (typeof key === "string" && !key.startsWith("0x")) {
        key = "0x" + key;
      }
      var signingKey = typeof key === "string" ? new index_js_1.SigningKey(key) : key;
      return _callSuper(this, Wallet, [signingKey, provider]);
    }
    _inherits(Wallet, _base_wallet_js_1$Bas);
    return _createClass(Wallet, [{
      key: "connect",
      value: function connect(provider) {
        return new Wallet(this.signingKey, provider);
      }
      /**
       *  Resolves to a [JSON Keystore Wallet](json-wallets) encrypted with
       *  %%password%%.
       *
       *  If %%progressCallback%% is specified, it will receive periodic
       *  updates as the encryption process progreses.
       */
    }, {
      key: "encrypt",
      value: (function () {
        var _encrypt = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(password, progressCallback) {
          var account;
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                account = {
                  address: this.address,
                  privateKey: this.privateKey
                };
                _context.next = 3;
                return (0, json_keystore_js_1.encryptKeystoreJson)(account, password, {
                  progressCallback: progressCallback
                });
              case 3:
                return _context.abrupt("return", _context.sent);
              case 4:
              case "end":
                return _context.stop();
            }
          }, _callee, this);
        }));
        function encrypt(_x, _x2) {
          return _encrypt.apply(this, arguments);
        }
        return encrypt;
      }()
      /**
       *  Returns a [JSON Keystore Wallet](json-wallets) encryped with
       *  %%password%%.
       *
       *  It is preferred to use the [async version](encrypt) instead,
       *  which allows a [[ProgressCallback]] to keep the user informed.
       *
       *  This method will block the event loop (freezing all UI) until
       *  it is complete, which may be a non-trivial duration.
       */
      )
    }, {
      key: "encryptSync",
      value: function encryptSync(password) {
        var account = {
          address: this.address,
          privateKey: this.privateKey
        };
        return (0, json_keystore_js_1.encryptKeystoreJsonSync)(account, password);
      }
    }], [{
      key: "fromEncryptedJson",
      value: (
      /**
       *  Creates (asynchronously) a **Wallet** by decrypting the %%json%%
       *  with %%password%%.
       *
       *  If %%progress%% is provided, it is called periodically during
       *  decryption so that any UI can be updated.
       */
      function () {
        var _fromEncryptedJson = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(json, password, progress) {
          var account;
          return _regeneratorRuntime().wrap(function _callee2$(_context2) {
            while (1) switch (_context2.prev = _context2.next) {
              case 0:
                account = null;
                if (!(0, json_keystore_js_1.isKeystoreJson)(json)) {
                  _context2.next = 7;
                  break;
                }
                _context2.next = 4;
                return (0, json_keystore_js_1.decryptKeystoreJson)(json, password, progress);
              case 4:
                account = _context2.sent;
                _context2.next = 17;
                break;
              case 7:
                if (!(0, json_crowdsale_js_1.isCrowdsaleJson)(json)) {
                  _context2.next = 17;
                  break;
                }
                if (!progress) {
                  _context2.next = 12;
                  break;
                }
                progress(0);
                _context2.next = 12;
                return stall(0);
              case 12:
                account = (0, json_crowdsale_js_1.decryptCrowdsaleJson)(json, password);
                if (!progress) {
                  _context2.next = 17;
                  break;
                }
                progress(1);
                _context2.next = 17;
                return stall(0);
              case 17:
                return _context2.abrupt("return", _fromAccount.call(Wallet, account));
              case 18:
              case "end":
                return _context2.stop();
            }
          }, _callee2);
        }));
        function fromEncryptedJson(_x3, _x4, _x5) {
          return _fromEncryptedJson.apply(this, arguments);
        }
        return fromEncryptedJson;
      }()
      /**
       *  Creates a **Wallet** by decrypting the %%json%% with %%password%%.
       *
       *  The [[fromEncryptedJson]] method is preferred, as this method
       *  will lock up and freeze the UI during decryption, which may take
       *  some time.
       */
      )
    }, {
      key: "fromEncryptedJsonSync",
      value: function fromEncryptedJsonSync(json, password) {
        var account = null;
        if ((0, json_keystore_js_1.isKeystoreJson)(json)) {
          account = (0, json_keystore_js_1.decryptKeystoreJsonSync)(json, password);
        } else if ((0, json_crowdsale_js_1.isCrowdsaleJson)(json)) {
          account = (0, json_crowdsale_js_1.decryptCrowdsaleJson)(json, password);
        } else {
          (0, index_js_2.assertArgument)(false, "invalid JSON wallet", "json", "[ REDACTED ]");
        }
        return _fromAccount.call(Wallet, account);
      }
      /**
       *  Creates a new random [[HDNodeWallet]] using the available
       *  [cryptographic random source](randomBytes).
       *
       *  If there is no crytographic random source, this will throw.
       */
    }, {
      key: "createRandom",
      value: function createRandom(provider) {
        var wallet = hdwallet_js_1.HDNodeWallet.createRandom();
        if (provider) {
          return wallet.connect(provider);
        }
        return wallet;
      }
      /**
       *  Creates a [[HDNodeWallet]] for %%phrase%%.
       */
    }, {
      key: "fromPhrase",
      value: function fromPhrase(phrase, provider) {
        var wallet = hdwallet_js_1.HDNodeWallet.fromPhrase(phrase);
        if (provider) {
          return wallet.connect(provider);
        }
        return wallet;
      }
    }]);
  }(base_wallet_js_1.BaseWallet);
  _Wallet = Wallet;
  function _fromAccount(account) {
    (0, index_js_2.assertArgument)(account, "invalid JSON wallet", "json", "[ REDACTED ]");
    if ("mnemonic" in account && account.mnemonic && account.mnemonic.locale === "en") {
      var mnemonic = mnemonic_js_1.Mnemonic.fromEntropy(account.mnemonic.entropy);
      var _wallet = hdwallet_js_1.HDNodeWallet.fromMnemonic(mnemonic, account.mnemonic.path);
      if (_wallet.address === account.address && _wallet.privateKey === account.privateKey) {
        return _wallet;
      }
      console.log("WARNING: JSON mismatch address/privateKey != mnemonic; fallback onto private key");
    }
    var wallet = new _Wallet(account.privateKey);
    (0, index_js_2.assertArgument)(wallet.address === account.address, "address/privateKey mismatch", "json", "[ REDACTED ]");
    return wallet;
  }
  wallet.Wallet = Wallet;
  return wallet;
}

var hasRequiredWallet;
function requireWallet() {
  if (hasRequiredWallet) return wallet$1;
  hasRequiredWallet = 1;
  (function (exports) {

    /**
     *  When interacting with Ethereum, it is necessary to use a private
     *  key authenticate actions by signing a payload.
     *
     *  Wallets are the simplest way to expose the concept of an
     *  //Externally Owner Account// (EOA) as it wraps a private key
     *  and supports high-level methods to sign common types of interaction
     *  and send transactions.
     *
     *  The class most developers will want to use is [[Wallet]], which
     *  can load a private key directly or from any common wallet format.
     *
     *  The [[HDNodeWallet]] can be used when it is necessary to access
     *  low-level details of how an HD wallets are derived, exported
     *  or imported.
     *
     *  @_section: api/wallet:Wallets  [about-wallets]
     */
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Wallet = exports.Mnemonic = exports.encryptKeystoreJsonSync = exports.encryptKeystoreJson = exports.decryptKeystoreJson = exports.decryptKeystoreJsonSync = exports.isKeystoreJson = exports.decryptCrowdsaleJson = exports.isCrowdsaleJson = exports.HDNodeVoidWallet = exports.HDNodeWallet = exports.getIndexedAccountPath = exports.getAccountPath = exports.defaultPath = exports.BaseWallet = void 0;
    var base_wallet_js_1 = /*@__PURE__*/requireBaseWallet();
    Object.defineProperty(exports, "BaseWallet", {
      enumerable: true,
      get: function get() {
        return base_wallet_js_1.BaseWallet;
      }
    });
    var hdwallet_js_1 = /*@__PURE__*/requireHdwallet();
    Object.defineProperty(exports, "defaultPath", {
      enumerable: true,
      get: function get() {
        return hdwallet_js_1.defaultPath;
      }
    });
    Object.defineProperty(exports, "getAccountPath", {
      enumerable: true,
      get: function get() {
        return hdwallet_js_1.getAccountPath;
      }
    });
    Object.defineProperty(exports, "getIndexedAccountPath", {
      enumerable: true,
      get: function get() {
        return hdwallet_js_1.getIndexedAccountPath;
      }
    });
    Object.defineProperty(exports, "HDNodeWallet", {
      enumerable: true,
      get: function get() {
        return hdwallet_js_1.HDNodeWallet;
      }
    });
    Object.defineProperty(exports, "HDNodeVoidWallet", {
      enumerable: true,
      get: function get() {
        return hdwallet_js_1.HDNodeVoidWallet;
      }
    });
    var json_crowdsale_js_1 = /*@__PURE__*/requireJsonCrowdsale();
    Object.defineProperty(exports, "isCrowdsaleJson", {
      enumerable: true,
      get: function get() {
        return json_crowdsale_js_1.isCrowdsaleJson;
      }
    });
    Object.defineProperty(exports, "decryptCrowdsaleJson", {
      enumerable: true,
      get: function get() {
        return json_crowdsale_js_1.decryptCrowdsaleJson;
      }
    });
    var json_keystore_js_1 = /*@__PURE__*/requireJsonKeystore();
    Object.defineProperty(exports, "isKeystoreJson", {
      enumerable: true,
      get: function get() {
        return json_keystore_js_1.isKeystoreJson;
      }
    });
    Object.defineProperty(exports, "decryptKeystoreJsonSync", {
      enumerable: true,
      get: function get() {
        return json_keystore_js_1.decryptKeystoreJsonSync;
      }
    });
    Object.defineProperty(exports, "decryptKeystoreJson", {
      enumerable: true,
      get: function get() {
        return json_keystore_js_1.decryptKeystoreJson;
      }
    });
    Object.defineProperty(exports, "encryptKeystoreJson", {
      enumerable: true,
      get: function get() {
        return json_keystore_js_1.encryptKeystoreJson;
      }
    });
    Object.defineProperty(exports, "encryptKeystoreJsonSync", {
      enumerable: true,
      get: function get() {
        return json_keystore_js_1.encryptKeystoreJsonSync;
      }
    });
    var mnemonic_js_1 = /*@__PURE__*/requireMnemonic();
    Object.defineProperty(exports, "Mnemonic", {
      enumerable: true,
      get: function get() {
        return mnemonic_js_1.Mnemonic;
      }
    });
    var wallet_js_1 = /*@__PURE__*/requireWallet$1();
    Object.defineProperty(exports, "Wallet", {
      enumerable: true,
      get: function get() {
        return wallet_js_1.Wallet;
      }
    });
  })(wallet$1);
  return wallet$1;
}

var wordlists$1 = {};

var wordlistOwla = {};

var decodeOwla = {};

var bitReader = {};

var hasRequiredBitReader;
function requireBitReader() {
  if (hasRequiredBitReader) return bitReader;
  hasRequiredBitReader = 1;
  Object.defineProperty(bitReader, "__esModule", {
    value: true
  });
  bitReader.decodeBits = void 0;
  var Base64 = ")!@#$%^&*(ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_";
  /**
   *  @_ignore
   */
  function decodeBits(width, data) {
    var maxValue = (1 << width) - 1;
    var result = [];
    var accum = 0,
      bits = 0,
      flood = 0;
    for (var i = 0; i < data.length; i++) {
      // Accumulate 6 bits of data
      accum = accum << 6 | Base64.indexOf(data[i]);
      bits += 6;
      // While we have enough for a word...
      while (bits >= width) {
        // ...read the word
        var value = accum >> bits - width;
        accum &= (1 << bits - width) - 1;
        bits -= width;
        // A value of 0 indicates we exceeded maxValue, it
        // floods over into the next value
        if (value === 0) {
          flood += maxValue;
        } else {
          result.push(value + flood);
          flood = 0;
        }
      }
    }
    return result;
  }
  bitReader.decodeBits = decodeBits;
  return bitReader;
}

var hasRequiredDecodeOwla;
function requireDecodeOwla() {
  if (hasRequiredDecodeOwla) return decodeOwla;
  hasRequiredDecodeOwla = 1;
  Object.defineProperty(decodeOwla, "__esModule", {
    value: true
  });
  decodeOwla.decodeOwlA = void 0;
  var index_js_1 = /*@__PURE__*/requireUtils$3();
  var bit_reader_js_1 = /*@__PURE__*/requireBitReader();
  var decode_owl_js_1 = /*@__PURE__*/requireDecodeOwl();
  /**
   *  @_ignore
   */
  function decodeOwlA(data, accents) {
    var words = (0, decode_owl_js_1.decodeOwl)(data).join(",");
    // Inject the accents
    accents.split(/,/g).forEach(function (accent) {
      var match = accent.match(/^([a-z]*)([0-9]+)([0-9])(.*)$/);
      (0, index_js_1.assertArgument)(match !== null, "internal error parsing accents", "accents", accents);
      var posOffset = 0;
      var positions = (0, bit_reader_js_1.decodeBits)(parseInt(match[3]), match[4]);
      var charCode = parseInt(match[2]);
      var regex = new RegExp("([".concat(match[1], "])"), "g");
      words = words.replace(regex, function (all, letter) {
        var rem = --positions[posOffset];
        if (rem === 0) {
          letter = String.fromCharCode(letter.charCodeAt(0), charCode);
          posOffset++;
        }
        return letter;
      });
    });
    return words.split(",");
  }
  decodeOwla.decodeOwlA = decodeOwlA;
  return decodeOwla;
}

var hasRequiredWordlistOwla;
function requireWordlistOwla() {
  if (hasRequiredWordlistOwla) return wordlistOwla;
  hasRequiredWordlistOwla = 1;
  Object.defineProperty(wordlistOwla, "__esModule", {
    value: true
  });
  wordlistOwla.WordlistOwlA = void 0;
  var wordlist_owl_js_1 = /*@__PURE__*/requireWordlistOwl();
  var decode_owla_js_1 = /*@__PURE__*/requireDecodeOwla();
  /**
   *  An OWL-A format Wordlist extends the OWL format to add an
   *  overlay onto an OWL format Wordlist to support diacritic
   *  marks.
   *
   *  This class is generally not useful to most developers as
   *  it is used mainly internally to keep Wordlists for languages
   *  based on latin-1 small.
   *
   *  If necessary, there are tools within the ``generation/`` folder
   *  to create the necessary data.
   */
  var _accent = /*#__PURE__*/new WeakMap();
  var WordlistOwlA = /*#__PURE__*/function (_wordlist_owl_js_1$Wo) {
    /**
     *  Creates a new Wordlist for %%locale%% using the OWLA %%data%%
     *  and %%accent%% data and validated against the %%checksum%%.
     */
    function WordlistOwlA(locale, data, accent, checksum) {
      var _this;
      _classCallCheck(this, WordlistOwlA);
      _this = _callSuper(this, WordlistOwlA, [locale, data, checksum]);
      _classPrivateFieldInitSpec(_this, _accent, void 0);
      _classPrivateFieldSet2(_accent, _this, accent);
      return _this;
    }
    /**
     *  The OWLA-encoded accent data.
     */
    _inherits(WordlistOwlA, _wordlist_owl_js_1$Wo);
    return _createClass(WordlistOwlA, [{
      key: "_accent",
      get: function get() {
        return _classPrivateFieldGet2(_accent, this);
      }
      /**
       *  Decode all the words for the wordlist.
       */
    }, {
      key: "_decodeWords",
      value: function _decodeWords() {
        return (0, decode_owla_js_1.decodeOwlA)(this._data, this._accent);
      }
    }]);
  }(wordlist_owl_js_1.WordlistOwl);
  wordlistOwla.WordlistOwlA = WordlistOwlA;
  return wordlistOwla;
}

var wordlists = {};

var langCz = {};

var hasRequiredLangCz;
function requireLangCz() {
  if (hasRequiredLangCz) return langCz;
  hasRequiredLangCz = 1;
  Object.defineProperty(langCz, "__esModule", {
    value: true
  });
  langCz.LangCz = void 0;
  var wordlist_owl_js_1 = /*@__PURE__*/requireWordlistOwl();
  var words = "0itatkastcenaovo$taouleraeki&chor*teci%enbalodaeladet'!Chn=0Di#%E%^1Resa2Rese3CeT'#0EjKohol0Pu)%0A&sDul#Ekdo)Ke)Ti#Ul|3}aOgan%0FaltI$@tPi,%TmaTronom0LasL{i#Ol0Tobus4Yl:B#}<CilCul#D!_Ge)GrHnoKterieLa^L{#LkonLon-LvanLzaMbusNkom!R[rR{RmanRokoRvaTer#TohVl&Zal#Zili#Zu#3D&RanSe^StieTonZin#ZmocZ)k3CyklD]Ft-KinyLan%Og,fO]gTvaZon2AhobytAt*/E/aEdu+EskIk!Iz&Ok|Oud Ud2B-BrDl.D~H!(JkotJ|K<ysLe$R>R'?TaUb_U/!U^U+Ur!Xer2A^v#Ambo,An#AtrEp)Ike)KoLohOnzOskevUn{#Usin#Z^Zy2Bl.Bn|})D _D#D'aF{Jar(Kv?LdokLvaN^NkrRzaTikVolZola3D+tL.T'#0Ukot:PartRev&3DrDu+J/JnLaLerLkemLn?N.Nn(N'#NtrumNz<StopisT#2AlupaAp`]Ar aA)E/t!EmieI/otIrurgL`Le[Lub M_Mu,ObotO/olOd[O+,Om=Op Oro[OvRapotRl RtRupTiv(Ud.Utn!V!Vil#V(Y[Y$!Yt 0Bu+Gare)H_&HlaNkotRkusSter&Ta%TrusZin>Z(2O&2KolivUv!4It_N(0Dn(Ke)KrPot0Ak~AlIkRkot2Kli$a:L-oRe[T_Tum1E,1B!a}'#Cib_Fic Fla%KlKr{Mokr!PreseRbyS#T-tiv3Kob,zKt|O^P]mSkSp+jV`]Vo/2AhaOuhoUhopis1Es0BroByt-C@t}ut DnesH+dHo^H,JemJn?Kl`KolaKt<Kum@tLarLevaL.MaM.ntMluv M'Nut P`PisPln PosudPr'odPu$ Raz R(RtSahSl'St!-SudSy)TazT-Tk~Uf!Utn!Voz%Z`uZn!Z<%2Aho)AkAm!ikAv>AzeDolObn(OgerieOzdSn(T Z(2B@}'noD-HaH'#S SnoT(0Oj?Or>2Nam :9O]gOnomie0EktronIpsa0AilIseO%P!ie2Izo^O/aOpejOs2EjEn%K<)Kymo0Ike)0F<ie0Olu%1Eku%KurzePed?P]zeP<tT,kt:C#Jf#Kul)N!ikN)zieRmacieV< Zo+3De,%J{onN#3Al#Gu,ntLozofLtrNan%N)Xa%0Ord1An_IrtOtila2NdSf<T[lT#Ton2Ak%Es#On)2KarNk%3Zi#:LejeRant3N{i#O]g3Lot.2Azu,Ejt2LemLfi$aTi#2AfAmofonAnu+EpIlOgOtes#2Ma:D?DrLaL@#N[NopisRfaRpu&V,n3Bk(J#lJnoJtmanK)rLmaM!omR>R&S]Zky3St<ik2Ad'#AsivkyAvaEd!EnO^v>OhOup(T!Ub.U/o)0AtO)Yz0IsOjivoOut0Bl.Boj}DinyDl!Dno)D|Jn(KejLin#L#LubMo+N [No,%RalR^RizontRkoRliv>RmonRn.RoskopR$voSpo^St.T'(U[UfUp!Us#V<2Ad[An?Av(Az^Bo+kD.D]D(N-Ob#Oma^OtOu^Oz@St#Ub(Yz!2B@(B~D[KotMrS aSto)0Ozd2Bn(D,ntGie&M&Sterik:2Yl#3Ned2O&0Uze0Un a0F-%Fla%KasoOva%Sp-%Tern{Vali^Ve$<Zer%3Onie:Blko})Ho^Kmi+K(L'>N)rRmarkRoSanSnoT#V<Zyk3Din>D+Dn!_HlanKotL@L oMn(NomP?S{erV Zd>Zero3NakNdyNo/Sk,Sto)Trn?Zva3En|1Gurt5R):Bar{B_Bin{}&D{Did]HanJakJu)KaoKtusLam aLhotyLibrLn(Me,MkolivM&Ni[lNoeNt<Pal.P_aP olaP#P+Po)PrPu$aPy[,Ram_Rot#RtonSaTa]gTed,U%UzaVa+cZaj#Ze)Ziv(2EkolivEsi0Dlub@MpRami#3No2A%kAdivoAmApotAsi#AunEcEn[Ep!Es~IdImaIs&Ob*kO#nOpaOubUb'&Us!Uzk(0EnIt!Otr0IhaOt0Al?Ber>B#BlihaBylaC*rH=J@>KosKtejlLapsLe^LizeLoMandoMe)MikMn!aMo,MpasMun aN!N%ptNd?N>NfeseNgresN.NkursN)ktNzervaPan>PieP~Pr'#Rb_R-t<Rmid]RoptevRpusRu&RytoRz{S!>St#T_T+)T*lUk!Up_&Us-Uz]VbojZaZ<oh2Ab?A/Aj.Al|AsopisAv!aEd EjcarEs[Eve)Ik{ItikIzeKav>Me+cMivoOcanOkOni#Op OupaOv#T-Uh`]Up?Ut(Vin#Y/+Yp)Y$alYt2Dlan#FrJn(KlaLaj^Li/L#Lom{Ltu,NaPodivuRtRz<Til0Al aAsin#E$<2No]gS_.Ta,T?T#T'>V`]:B,d<})nDn(IkKom>M_aMpaN'#S?SoStu,Tin#V.3B#CkdyD@Dn?D'#Dv.G@^GieG,%H%Hk(H~KtvarNo/odNtil#P@#Pid]T`]T>TmoTokruhVhartV a%Vobok3B,}ot#DojedDsk(H'.Jav>L-M{#NieN#No+umStop`T.T|5Bi$aDivodGi#GopedKal aK{Mc|P!aPu/RdSosTrU^lUhU#Usk!V>3Tiv(1Cer&CiferMpSkSt,%0I%2RaRi#S.:DamD]Gi$rHagonJ{-J _J< aKakK'?Kr_aL[L.L|Lv?Min#Nd+NkoRn(SakrSkotSopu$T?Tri#Tur aZan>ZivoZl Zur#2Lo[0}anikD a%D'.LasaL*nNtol#TlaTo^TrZe,3G,%H~Hu+K.KrofonL@>Lim{rL(Mi#Nc'&Ni[rNom{Nul(S#StrX|2Ad(HaH'.OkS!Uv 1I/Ohem0BilCn(D_#Dl [HylaKroL-ulaM@t#Nar/aNoklN$rumNt|NzunSazSkytStTiva%T<#Ty#U/aUdr(Zai#Z-Zol2Am<Av@>KevTvolaZ{Zut(0T _1DrcF]nL!MieN?S{Ta%ZeumZi#nt3Sliv>0Da:B*r!}yt!Da%Dbyt-DhozDobroDpisHlasHn!Hodi+H,d Iv aJedn*Ji$oJm=K]n Kon>Krm LevoMaz!Mluv Nom{rOkoOpakO$roP`!PevnoPln P~Pos+dPr(oRod RubyRy/]S` S-!S+poSt!TolikV@-Vr/Vzd<yZv!3Be}!CkyDa+koDb!DuhGa%H{Ho^J@JprveKlidLib(Mil(MocO/o)On#PokojR(RvSmyslS*l`Tv<UronV.Zvyk+3Co)JakKamKdyKlKte,kTro5C+hHav?M.%RaR-S _Sn(UzeVinyVo)Zd,5DaD+G{T Tn(Trie3Mfa:0AlArv AvaDivEcEhn!Ejm=Ez aHajo[Iln?Jasn J-tK]p La$L-Li[LohaLu^NosOh! Oj-OutRaz>R&Ru[RysSahSluhaS)r!UvVazVin VodVyk+Yv!_Z<0AsElEn Hl` Ho)H,&It~0BojByt}odCiz Ebr!Esl!Evzd!EzvaH`%Hod J{JinudKazK*p LivLu#Ml#Oln(P`PisPl=P<Pu$ Pyk!Raz#S*d StupSunTokTudVahaVe)Vol!V,%tZ&k1I&Sajd1LasNiskoRa^Roz Ryz-2ApEn?Li#NoOuzl OvyRasaResRs-RuhUpantUr#Us 0Ejn.Iz|0AkE+)Ez L`.L*v!LuvaYl0Ehdy1Ak|As-E,%I%Il(Is|O,Oz?RavduRoti1B al}e$rGieL?LojT_0A^}~I#IvoLavaLep Ln L' N'aO[Ol Pa+cT@T,haTu^Ty/Voj 0Epl IskOpRh!Rl(RokRubyV<1A~ArEsLivn O%1Id1Do[:}!_Ci@tD*/H<-KtLan^L>LivoLu[Mf+tMls-N@#Ni#N&N|N$voNtof+Pri#Rke)RodieR)Ru#Ry[Se#Siv aSt_#T@tTro&V*kZnehtZ*r-3C#DagogJs-K]LotonNal)Ndr-NzeRiskopRoStr(Tar^T?Tro+jVn.Xeso3Ani$aHaJav?K+KnikL.Ln(Lul#Nze)Pe)S!_Sto+Tev&Vn?V'ar2A%n)Ak!Am@Ane)A$i#At Avid]AzE/Em@oEn)EsEtivoEv_Iv!N NoO/aOd.Om[OutUkYn2Bav Byt}odC Ctiv>D!D%n Deps!Dh+dDiv Dkl`Dman DnikDo[Dpo,D,zD$!aDvodDzimEzieHan#Hnut#H'<HromaHybIn)Ji$#Jm=Kaz K+sKojKrokKu)KynLedneLib-Lk~LohaLynomMaluMi~Ml#MocM$aMys+tNe/!N<#Nur(P`!P_Pis-Pla/Pros Ps!PudR`%R%RodRu/aRyvS` SedSilaSkokSlan>S*d SpoluS)vaSud-SypTahT#nT+skTom-T,vaTupaTvo,U#zUtoUzdroVahaVidlaVlakVozVr/V$!VykVzde/Zd,vZem-Zn!-Z<Zv!2Ac|Ah<yAkti#A+sAot>Ap<-AseAv^IncipKnoObud O%ntoOdejOfeseOh,Oj-tO]m Omi+Onik!Op`OrokOs[OtonOut-OvazS#v#St@Udk(UtV-Voh<y0An>OvodTruh0Actvo0Ber)}DlKav>Kl.Kr+LtMpaNcP@SaSin#St.T|Ty#3Rami^SkT_::C-}otDia%Dn?DonFtGbyKe)K'.M@oMp*/NdeRa/R aS'&StrTo+$Zan%Zid]3Ag|Ak%CeptDakt<Fer@tF+xJnokKlamaK<dKrutKt<Pu)%VizeVmaVolverZerva3Sk|Ziko5Boti#Dokm@H'#K+KokoMan{oP'odPu/aRejsSolStl.Tmi$rTopedTun^Ub@#U/oUpU,V.Vn?Zb<Z/odZd!Zezn!Zhod%Zin#ZjezdZ#zZ]haZmarZp`Zru/ZsahZtokZumZvod5Bri#}`]Kav?Kopis3BaBol'}l(D]P`]T.Z(:Di$aH!KoM>Mizd!Mo)N #Rdin#San#T_ Z[Z@?0Or0H|1B,n#CeseD`]Dim@tD]Hn!Jm=Ke,K)Kun^KvojeM@oNoRvisS` Sho,SkokSl!St,SuvSyp!T[T.Tk!T~Trv!VerZ&m2O^R~0FonLn?R#Rot-RupTua%1AfandrAliskoAnz@AutEptikIcaL`[L@?LoLuzO[O#nOroRip)RzUp.V(Vr&0Abi#Adid]An.A$Avn(Ed|Ep>EvaEz.IbI&Izn?OnOup-OvoU/UhaUn%Up#Za0A,gdE)&Il$voL*vaOgR`RkRt#Ut-Ysl0AdAhaOb0Bo)}aD'#KolP#TvaUbojUc Ud%UhlasUl`Um,kUp,vaUsedUtokUvis{0Al'&As _IsLavOd-Oj@>OluOnz<Orn(Ou$aR/aU$ 1An^AzD%NaN>Ovn!P@StUb1An?Ar(aAti#Av[EhnoEz#OdolaO+kOpaOrnoOup!Ra/ResRh~RomRu&Ud&Upn?VolYk0Bj-tBtropy}arD(KnoNd!N=Rik!aR'.0AhAl$voEtrAt[Az-Is+It-Obo^Odid]Or#Rab2Kav#KotN-N'>P!Pk(R'(S_T(:B+t#Bu+H*nJemnoJfunJgaJ Jn(Kti#Mh+MponNc|N>NkerPe)V@.Z!_3}ni#HdyKut.LefonMno)Nd@%Ni$aN<P])P&PrveRapieRmos#Xtil3}oSkopisTu+k1Ad+cAn.0Ap#Esk!UkotUpa0El1A+)Pin#PolRzoUhaU+c2Ad?Akt<AmpAsaAverzaEf E$Ez<Hav.Hl.O/uOj?Os#Ou[P%P _Pk(Ub>U/l Uhl?UsV!2DyH~H(Nd,Ri$aR&jZemsko0ArohOr[Rd(Rz2GrKev:0Oh(OzeR!R*s-RusYt'&0HoTiv(0Iv 3R` 1Edn!I$ M=0Az!_Lidn Lon Otv Roj 0I%I)Ov 0Yv`]0Av If<maIk~1Ad~L!n Ly~Out!Rav 1AnAz 0Ed~Il|Mrt N`n N=Oud Tl!Tr~0Ah|K!Lum O~Op@>R*s 1Al Oln Oz'#3D,v ElEn.L.N!:GonL/aL*nNaN^lNil#RanRhanyR|1ElkuHod0Ova0DroGe)%J%Lbl*dL{rhL _LmocLry[Nk'Ran^RzeS_#SkrzeSn?SpoduS)Ter.Ver#3B,%}rDeoh,D.D+LaN?S{Tal aZeZ #0Ezd0L`Us0Aj#AkAs>EvoHk(IvN'#Oup!1Uc|Uk0DaDiv(Doz&kD$voJ@skyJ&JskoLantL[L LnoSk'#Zid]Z'&0Ravo1Ab>A%tAhA)Ba}o+kH!StvaTu+0Ad T*p Tup0Ip4Bav Br!}|D!D,Fot H+d!H~Hod H,d Hub Jasn J{Jm=K]p Kon!L-!Maz!Mez Miz{Mys+tNe/!Nik!Nut P`!Pl! P,v Pu$ Raz R'n!Rv!Sl' SokoS)v Su~Syp!Tas Tes!Tr! Vi~Vol!Vrh_Zdob Zn!0AduBud }op D<Du/Dy/!E$upH+demKazLyk!NikOr-P*,TahT-::993Lofon::Br!Byd+t}|DarmoDus F*k!Hlt Hod H,^Hy~J!>J{Ji$ K+p!K*p Lep Mez Mot!Mys+tNe/!Nik!Pl! Poj Ps!Raz S)v Su~Taj Temn Tk~Ujm=Val Ve+tVin Vol!Vrt!Zvon 0Av RusuUd|Yt-1A+#ArmaAtn(IvoOb RojVihYm`]0L@.ManM.Pt!Z`uZdola2At Lt~Lubo#Ot' Ru[0MaMn?0Emn 0Lam!Oum!R!#Umav#0AtoEh#O[OmO$Ozvyk0Ap|ArAt-IjeIz{Ocn Odr!Rzl.Ut|0AkAl(Am@!Ovu0B,z Tav Ub-Ufa+0Lod Omal RavaR( Rud#Rvu1A^An C`]N (NoOv&Y/l Zav(1I/aR! 0B'.Br0Ed~EnkuEs_aOnR!Uk'odYk";
  var checksum = "0x25f44555f4af25b51a711136e1c7d6e50ce9f8917d39d6b1f076b2bb4d2fac1a";
  var _wordlist = null;
  /**
   *  The [[link-bip39-cz]] for [mnemonic phrases](link-bip-39).
   *
   *  @_docloc: api/wordlists
   */
  var LangCz = /*#__PURE__*/function (_wordlist_owl_js_1$Wo) {
    /**
     *  Creates a new instance of the Czech language Wordlist.
     *
     *  Using the constructor should be unnecessary, instead use the
     *  [[wordlist]] singleton method.
     *
     *  @_ignore:
     */
    function LangCz() {
      _classCallCheck(this, LangCz);
      return _callSuper(this, LangCz, ["cz", words, checksum]);
    }
    /**
     *  Returns a singleton instance of a ``LangCz``, creating it
     *  if this is the first time being called.
     */
    _inherits(LangCz, _wordlist_owl_js_1$Wo);
    return _createClass(LangCz, null, [{
      key: "wordlist",
      value: function wordlist() {
        if (_wordlist == null) {
          _wordlist = new LangCz();
        }
        return _wordlist;
      }
    }]);
  }(wordlist_owl_js_1.WordlistOwl);
  langCz.LangCz = LangCz;
  return langCz;
}

var langEs = {};

var hasRequiredLangEs;
function requireLangEs() {
  if (hasRequiredLangEs) return langEs;
  hasRequiredLangEs = 1;
  Object.defineProperty(langEs, "__esModule", {
    value: true
  });
  langEs.LangEs = void 0;
  var wordlist_owla_js_1 = /*@__PURE__*/requireWordlistOwla();
  var words = "0arertoiotadonoaRteirroenaNonaLsolocoiliaralaorrenadaChoN$n0A>Dom,EjaI!#Oga&O'Or#RazoR*Ue=U<0Ab Adem@Ce<C~Ei)ElgaEn#Ept I&L  NeOg!O<TivoToTrizTu Ud*U!&Us 0Ic#Mit*Opt Or'Ua`Ul#0Reo0Ect Ic~In Irm 0IlIt On@Os#Ot Reg R$UaU&U?aUja0OgoOr+0ReSl 0Ed_zE'Us)1Ac[nAmb_ArmaBaBumCaldeDeaEg_Ej Er%E%F?!GaGo&nIa&I,#Iv$MaMejaMib T TezaTivoToTu[Um'Z 0AbleAn)Apo]ArgoAs B Bi#E'IgoIs%dOrP oPl$0|oC@'C]D D,Em@Gu=Il=ImoIsOt T,aTiguoTojoUalUl Unc$Ad*EjoO1Ag A[#Eti#IoLic O&Or)OyoR,d!Rob Ues%U+1A&A`ArBit+BolBus#|ivoCoD!D?]DuoEaI&IesM.i-esOmaPaP.Reg=RozRugaTeTis%0AA&Al#C,<Egur EoE<rI,#I=Ist*NoOmb+P!oT?]T+Tu#Um*Un#0AjoAqueArEn#EoI>Le%OmoRa!RozUn0DazD$GeLaM,#S,)T^0AlAnceA+EEl]`E`EstruzI.I<2ErU{U'0Af[nArO)Uc Uf_Ul:BaB^|eH@IleJ Lanz/c.LdeMbuN>Nd-oRb(>RnizR+Scu]S#nSu[Tal]T!@T*Tu%UlZ 3BeBid/=S SoSt@3|oEnNgo2An>OqueUsa2ABi`BoCaCi`DaDegaIn//!oLsaMb-{dNi#N}saiRdeRr SqueTeTinVe{Zal2AvoAzoEchaEveIl=In>IsaOcaOmaOnceO)UjaUs>U#2CeoCleE'EyFan{F.HoIt_L#Rbuj(l(+Sc TacaZ.:Bal=BezaBi`B[CaoDav!D,aErFeI{ImanJaJ.LLam Lc$L&Li{dLleLm/^LvoMaMb$Mel=Mi'Mp}c!Nd?Nel-gu+Nic-#N-.ObaOsPazPi%nPo)Pt Puch((b.RcelRe%Rg(i'RneRpe%R+R%SaS>S!oSpaS#rT^ceT_U{lUsaZo3Bol]D!D+Ld/eb_Lo<Lu]M,#Niz-t+Rc(&Rez(oRr R)zaSpedT+2AcalAle>AmpuAnc]ApaAr]I>Is)IvoOqueOzaUle%Up 0Cl.EgoE=EnEr#F[G +M->NeN%P_sR>Rue]SneTaU{d2Am^AnA+AseAveI,)ImaInica2B_Cc~|i'Ci`CoDigoDoF_G!He)JinJoL/ch/eg$Lg Lin/l LmoLum`Mba)M!Mi{Mo&Mpr-deNej}g-oc!Nsej}t PaPi(az.Rba%RchoR&nR.(r!S!SmosS%2AneoAt!E Ec!Ei&EmaIaIm,Ip%IsisOmoOnicaOque%U&Uz2Ad+Ar#At+BoBr*| aEl=En#Er{Es%EvaId Lebr/p/#Mb_Mpl*N-e%O%P.Pul( R$<R<RvaTis:M-z(R&T?3B!B?Ca{C*DoF,saFin*J LfinLga&Li#M^-<N%lP^)RechoR+%Sayu'SeoSf?eSnu&Sti'Sv$TalleT,!U{3AAb=AdemaAman)A`Ar$BujoCt En)E%EzFic?G'Lem/u*N!oRec#Rig*S>Se'Sf[zVaVi'5BleCeL^Ming}N Ra&Rm*R<SSis2Ag.Oga2|aDaE=E'LceOQueR Rez(o:0A'R$0H OUa&r0AdIc~Ific$I#rUc 1Ec#Icaz3EEmp=1Efan)Eg*Em,#Ev IpseI)Ix*Og$Ud*0Bu&It*Oc~Pa)Pe'PleoP_sa0A'C go|ufeC@EmigoE+Fa&F!moGa'Igm/aceOrmeRe&SayoS, T!oTr VaseV$1Oca0Uipo0Izo0Ca]C,aCol Crib*Cu&Enc@F!aFu!zoPa{PejoP@PosaPumaQuiT TeTi=Tufa0ApaEr'Ic-@1Ad*Alu En#It 1Ac#Am,Ce<CusaEn#Ig*Il$Ist*I#P!#Plic P.!T_mo:BricaBu]|a{C?C#rE`J/d/=L<Lt MaM?@Mo<Ra.Rmaci(olRsaSeTigaU`V^X3Br!o|/izORi(ozRt?Rv^Stin3AbleAnzaArB[Cc~|aDeoEb_ElE[Es%Gu[J JoL/e)L@lLt+NNc-g*Ni#Rma2A>Au%EchaOrO%U*UjoU^2B@CaGa%G.L$Lle#N&Rm(+Rtun(z SaTo2Aca<Ag?AnjaAseAudeE*E'EsaIoI#U%2EgoEn)ErzaGaM Nc~Nd(g.R@S?TbolTu+:Ce]FasI%JoL/!i/=Mb- Nch}g-<RajeRzaSoli`St ToV?an3Me=M*NN!}$N)Ran$R,)Rm,S#3Gan)M`s$R Ro2Aci OboOr@2LLfoLo<LpeM(&R?([TaTeoZ 2A{Afi>A'AsaAtisAveIe%Il=IpeIsI#O<rUaUe<UmoUpo2An)ApoArd@Er[IaI'I.I<It [Sa'St :B!B?Bl C!|aD/l Mac(i`ZZa`3B?]B[|oLa&L$Mbr(*Rma'RoeRv*3E=Er+Ga&Gi,eJoM'S#r@5Ci>G Gu!aJaMb_Ng}^Nr((mig('St?Yo5E>ElgaEr%E<EvoI{IrMa'Me&M?deM}d*RacanR#:1O'0EalIomaO=2Lesi/uUal4EgalUs~0Ag,AnIt P P!$P.!Pul<0CapazDiceEr)FielF^meG,$Ic$M,<MuneNa#Sec#S%n)T!esTimoTu*Ut?Vi!'3AIsOn@0L/o):BaliB.M.RabeRdinR[U]Zmin3FeRinga3Ne)5R`d(obaV,Ya5ErgaEvesEzGa&rGoGue)Ic$N>Ngl-$Nt Pit!R S#V,?Zg :7Lo5A]:B$C$C[DoD+nG #GrimaGu`I>M!Mi`Mp --ch-gos%NzaPizRgoRvaStimaTaTexT*U_lV Zo3AlCc~|eC#rErG~Gumb_Ja'Ngu-#NaOnOp &S~TalT[VeY,{3B!%dB+C^D!Di EnzoGaG!oMaMi)M.Mp$NceN&Ne-go)N}t!`Qui&SoS%T!aT$T+2AgaAmaAn#AveEg En Ev Or Ov!Uv@2BoC~CoCu[GicaG+MbrizM}jaTe5|aC*G J}-esPaSt+ToZ:Ce%|oD!aD_Du+Est+F@G@GoIzL{dLe%Ll/oMaMboMutN>N&Nej Ng-iquiNj N}<N%Na`PaQuin(R>Re(f?Rg,Ri&RmolR+nR)sRzoSaSc aSivoT T!@TizTrizXimoY^Z^ca3|aDal]D$Du]J?]J^L,/.M^i-^NsajeN)NuRca&R,gueRi#SS.TaT!To&T+Zc]3E&ElEmb+G/Lag+Lit Ll.M}-!}im}u#OpeR SaS!@S?SmoTadTo5|?aC~DaDe=HoJ LdeL!Li'M,#Mi- c-ed-j-#NoRad(d!Re'R*R+Rs(%lScaStr TivoV!V?Zo5|oD EbleE]Er)Est[G_J!L/e%L%N&Nec(alRoScu=SeoSgoSicaS=:C C~D IpeRanj(izRr SalTalTivoTu[lUseaValVeVi{d3C$Ct G Goc$G+OnRv$ToUt+V V!a3|oDoEb]E#NezNoTi&Vel5Bleza|eMin(i(m()TaTic@Va#Ve]V$5BeCaCleoD?=DoE[EveEzLoM!oTr@:Sis0E<IspoJe#R(!oS!v T,!V$0AA<Ea'H,%HoIoReTavoTub_Ul#Up Urr*0I IoIsea0S)0EnsaEr%Ic$Rec!0Ro1DoR0O1AEa{Fa#IvoLaMoOrVi&0Bligo0DaZa1A>C~E[In On!T TicaUes#1Ac~A&rAlBi%CaD,EjaGa'G@Gul=I,)Ig,Il]OQues%Uga0Ad@Cu+Ez'OT[0O'Ro1EjaU=1I&Ige'0En)0O':C#D_El]Gi`GoIsJ oLabr/>Le%Li&Lm/om/p NNalNi>Nt!-ue=PaPelP?]Que)R Rcel(edR*RoRpa&RqueR[foR)S SeoS~SoS%TaT$Tr@UsaU%VoYa<3A#nCa&C!a|oDalD*G IneL L{'Le/ig+LlejoLoLuc--s N.OnOrPi'Que'R(ch(d!Rez(f?Ri>Rl(mi<R+Rs.aSaScaSimoS%`Ta=T+leoZZu`3C |.EEd[Er`EzaJam/ Lo#Mi,%N}#rNz-aOjoP(a%S Sci`SoS%T.Zca2AcaAnA%AyaAzaEi#E'OmoUmaU[l2B_CoD!D$EmaEs@E%L,Lici/=LvoMa{Me=MoMp-!Rc~R%lSa{Se!SibleS)T,c@T+Zo2A&E>zEgun%Em$EnsaE<Ev$ImoIncipeIs~Iv OaOb Oce<Oduc#OezaOfe<rOg[maOleOmesaOn#Op$OximoUeba2Bli>|!oD^Eb=Er%Es#Lg/*Lm.LpoL<M-#NalNoPaP?(e:99Ed EjaEm Er!E<Ie#ImicaInceIt :Ba'B@BoC~DicalIzMaMp-ch}goPazPi&P#SgoSpaToYoZaZ.3Acc~Ali{dBa'Bo)Ca!Ce%|azoCog!C_oC#Cur<DD.&Duc*FlejoF^maF[nFug$Ga=G*G]G_<H,I'IrJ/a#LevoLieveLle'LojM Med$M}>rNd*N%P #Pet*Po<Pt?SSca)Si`Spe#S#Sum,T*oT^'T[#Un*VesVis%YZ 3CoEgoEn{EsgoFaGi&G^Nc.N.OQuezaSaTmoToZo5BleCeCi D DeoD?]ErJizoJoM!oMp!NN>N{PaP!oSaScaSt+T 5BiB^DoE{G*I&In/e%LoMboM^Ptu[TaTi`:Ba&B!B$BleC GazG[&L/&L!oL*Lm.L.Ls/#LudLv Mb-c~Ndi-e Ng_Ni{dN}#PoQueRdin()nSt_TanU`Xof.3Cc~CoC_#C%DGu*IsL=LvaMa`M?l-d-<rNalN^P  P@Qui(RieRm.Rv*S,%S~TaT,%V!oXoX#3D[Es%E)G=G'Lab/b L,c$L]Mbo=M$R,aS)maT$Tu 5B_C$D$LLap/{&Le{dLi&Lt Luc~Mbr-de}i&No+NrisaPaPl P^)R&Rp_s()oS)nTa'5AveB*Ce<D^Eg[E=E'Er)Fr*Je#L%nM P! Pl*P.!P_moRR>Re'Rg*S#T?:Ba>BiqueB]BuCoC#JoL L>L,#Ll/.Ma'Mb^Ng}quePaPe)P@P.Qu?l(deRe(if(je%RotR+R%TuajeU+ZaZ.3At+|oC]CnicaJa&J!Ji&L/efo'MaM^Mp=NazNd!N!NisN<Ori(api(>Rmi'Rnur(+rSisSo+StigoT!aX#Z3B$Bu+nEmpoEn{Er[E<G_J!/deMb_Mi&M}%OPi>PoR(.TanT!eTu=Za5Al]B?=C Ci'DoG/&M N}#P PeQueRaxR!oRm,%RneoRoRpe&R_R<RtugaSS>S!Xi>2AbajoAc#rA!Afi>AgoAjeAmoAnceA#AumaAz EbolEguaEin%EnEp EsIbuIgoIpaIs)IunfoOfeoOmpaOn>OpaO)OzoU>Ue'Ufa2B!@BoEr#MbaM^NelNic(bin(ismoR'T^:0Ic 9C!a0B[l0I{dIrIv!<OT A3Ba'BeG,)Na0ArU $0IlOp@1A:CaC$Cu`G GoI`J?l/eLi&LleL^Lvu]Mp*oR(i R.So3Ci'C#rHicu=In)JezL/!oLozN-c!Nd-e'Ng N*N%NusRRa'RboRdeRed(j(<Rt!3AAjeBr C$CtimaDaDeoDr$EjoErnesG^LLl-ag_N}e&OlinRalRgoRtudS^Sp!aS%Tami`U&VazV!oV*Vo5LcanLum,Lv!RazT ToZ5E=Lg :::C!Te3GuaM('So9DoGaGur:F*}jaPa#Rza93N(+5MoR&";
  var accents = "aeiou7695@@BZWWavwUJkO@Y-Kn))YEGq#E@O)cI@#ZkMHv$e*))M!!)D**$GW!oKm*Acoh^k&It-pi^SYW)$^n!G)bO!Wkzam(jS#X)Og*^l^RW!bQ#QygBKXfzE))hti!Qm)Cng%%c)mJiI*HJWbmYniCLwNdYyY%WKO^bnT$PuGOr!IvHu&G(GKbtBuhiW&!eO@XMeoYQeCa#!MrTJCq!OW&CHG(WCcW%%)$rfrIegu$)w!G)JGmWWw)MnD%SXXWIT^LWAZuVWB^W)eTL^x&$WGHW(nKWEMA)#$F$x$Waekqs,n7715)W*HM-$WAcCiu(a))VCZ)GG%(*CWWdW%$D!UCO$M";
  var checksum = "0xf74fb7092aeacdfbf8959557de22098da512207fb9f109cb526994938cf40300";
  var _wordlist = null;
  /**
   *  The [[link-bip39-es]] for [mnemonic phrases](link-bip-39).
   *
   *  @_docloc: api/wordlists
   */
  var LangEs = /*#__PURE__*/function (_wordlist_owla_js_1$W) {
    /**
     *  Creates a new instance of the Spanish language Wordlist.
     *
     *  This should be unnecessary most of the time as the exported
     *  [[langEs]] should suffice.
     *
     *  @_ignore:
     */
    function LangEs() {
      _classCallCheck(this, LangEs);
      return _callSuper(this, LangEs, ["es", words, accents, checksum]);
    }
    /**
     *  Returns a singleton instance of a ``LangEs``, creating it
     *  if this is the first time being called.
     */
    _inherits(LangEs, _wordlist_owla_js_1$W);
    return _createClass(LangEs, null, [{
      key: "wordlist",
      value: function wordlist() {
        if (_wordlist == null) {
          _wordlist = new LangEs();
        }
        return _wordlist;
      }
    }]);
  }(wordlist_owla_js_1.WordlistOwlA);
  langEs.LangEs = LangEs;
  return langEs;
}

var langFr = {};

var hasRequiredLangFr;
function requireLangFr() {
  if (hasRequiredLangFr) return langFr;
  hasRequiredLangFr = 1;
  Object.defineProperty(langFr, "__esModule", {
    value: true
  });
  langFr.LangFr = void 0;
  var wordlist_owla_js_1 = /*@__PURE__*/requireWordlistOwla();
  var words = "0erreleontiteurinueiriet cegeanseali medenel q)eniluxaus ch0Ais}And$Diqu E`#Ol*Ord Ou%rOy RasifReuv Ri,Rog RuptS_-SoluS'@UsifYss=0A@m+AjouAr+nCab]Cep,Clam Cola@Cro~eCu}ErbeHatHe,Idu]I Omp&Qu *R$y?Te'TifT)l0Ep&EquatHesifJec%fJug Mett!M* Op,Or Ouc*Res<RoitUl&V be0R R$ef0Fai!Fec,Fi~eF!{Fub]0Ac Enc I#I,Raf Reab#Ru?1D Gu`#L>Mab#S/-0Ou,Us,1Arm Chim+Er&Geb!G)I_ I?ntLeg Lia.Lou Lum O'd*PagaTes<Veo#0A&'BiguB!Enag Ertu?Id$Ir=Orc O'Ovib#Phib+P#'Us/t0Aly<Apho!Ar~+Atom+C+nE/%rG#Gois<Gu#{Im=Nex N$-N)lOd(Om=+Ony?Orm=T_[Tido&X+{1Ai}Eri%fL/*Olog+Pa!`Pe]Por,Puy 0UariumUeduc0Bit!Bus&De'Doi<G_tLequ(Matu!Me?ntMoi!Mu!P_,Ra~ Riv Ro}S_icT +lTic#0PectPh=&P* S|tS v*S+t&Soc>S' TicotT!Tu-0El>O?RiumRo-Ta^T_%fT* Trap 0Ba(eB .Da-Dib#G' Ro!Tom[Tru~e0A]Anc Ari-En*Er<Eug#Ia&'I@I$I}O(eOu R`1I=Io?:D.Fou Ga.G)t&Igna@L/c Lc$Le(eLisa.Mb(Ncai!Nda.Nl+)Nn>eNqu>Rb>R`R$R^Rra.Ss(S%$Ta`#Te|T,+Udr>Vard 3Let&L>Lo&Nefi-R-|Rg Rl(eRmudaSa-Sog[Ta`Ur!3B $Cyc#Du#JouL/L(g)LlardNai!Olog+Ops+OtypeScuitS$Sto'iTu?Zar!2AfardAg)An~*Ess/tInd OndOqu Ous$2BardB(eI!I}Li@Nb$Nd*Nhe'Nif>NusRdu!R[T&Uc#Ue{Ug+Ul$Uqu(Ur<Usso#U%^Xe'2An~eAs>AveEbisE~eEuva.Ico]Iga@Ill/tIo~eI^O~u!Od Onz Ous<Oye'U?Us^Ut=Uy/t2Ff#Iss$L#%nRe|R(S% T( To*Vab#Vet&:B/$B(eChet&De|D!Fe(eIllouIss$Lcu]Lep(Lib!Lm Lomn+Lvai!Mara@M aMi$Mpag[N=Net$N$N%[NularPab#Por=Pri-Psu#P,Pu~eRab(eRb$eRes}RibouRna.Rot&R!|Rt$Sca@S>S^Ssu!U}U%$V=>V [Viar3D`#Intu!Les&Llu#Ndr>Ns' Ntr=Rc#Rebr=Ri<Rn Rve|S}2Agr(Ai<A#'Amb!An-Apit!Arb$As<'At$Auss$Av* Emi<En`#Equ>Er~ Ev=I_Iff!Ign$Im eIotLoru!OcolatOis*O<O)t&Ro?U&0Ga!Gog[M_,NemaNtr Rcu]R R^T [Toy_Tr$V`2A*$A?'Aqu As<Av>I_tIgn ImatIva.O~eOna.Opor&2B=tBraCas<Co% D Dif>Ff!Gn Hesi$Iff Inc L eLibriLl(eLma,L$elMbatMed+Mm/@MpactNc tNdui!Nf>N.]Nno,Ns$[NtactNvexePa(P+Ra`Rbe|Rda.Rni~eRpusR!ctR&.Smi^Stu?T$U@Upu!Ura.U&|Uvr*Yo&2AbeA(&Ava&Ay$Eatu!Edi,E?{Eu}Evet&Ib]I Ist=I,eOi!Oqu Ota#Uci=UelYp,2Bi^E`l*Il]eIs(eIv!Lm( L%v Mu]Pi@Ra%fR<'3Anu!C#L(d!Ni^:Ign M>Ng N<'Uph(3Batt!Bi,Bord Brid But/tC= Cemb!Ch* Cid Clar Cor Cri!Cup]Da#Duc%fEs<F_sifFi]Fray Gag Givr Glu%rGraf Jeun Li-Log M/d Me' Mol*Ni~ Nou N&l#Nud PartP_}Pha}Plac Po}R/g Rob Sast!S-n&S tSign Sobe*Ss( Str>Ta~ Tes,To' T!s<V/c V_*V( Vo*3Ab#Alog)Am/tC,Ff  G  Git=G[Lu M/~eM(u Oxy@Rec%fRig Scu,Spo}Ssip St/-V %rVi}5Ci#C&'G?IgtMa(eMici#Mp,Na&'Nj$Nn Pam(eRto*Ru!Sa.Se'Ss>Ta%$U/>Ub#U-'U,Y_2Ag$Ap Es}Ibb]Oitu!2P +P#xeRab#Rc*3Nas%e:0Lou*0Ar,HarpeHel#La* Lip<Lo!Lu<O#Onom+Or-Ou,Ra}Rem Riva(RouU?U!u`0If>Uqu 1Fac Fec%fFig+FortFray Fusi$0Ali}Ar 2Ec,1Abor Arg*Ectr$Eg/tEph/tEveIgib#I%s?O.Ucid Ud 0B=]Bell*Bry$Er|@Issi$M_ O%$Ouvo*P e'Ploy Por,Pri<Ulsi$0Cadr Ch eClaveCo~eDigu Dos}DroitDui!Erg+F/-F m Fou*Gag G(Glob Ig?Jamb JeuLev NemiNuye{Ri~*Roba.Seig[Tas}T_d!T>To' Trav Um  Vah*Viab#Voy Zy?0L+n0Aiss*Arg[At/tAu#Ic +I@m+I Ilog)I[Iso@ItapheO^ReuveRouv Uis/t0U !Uipe0Ig Osi$Re'Up%$0C=>Pad$Pe-P+g#Po*PritQuiv Say S_-S+uSor Ti?TomacTra@0Ag eA]An~eA%^E(d!Endo*Er[lH/olHi^Hn+Ir Off Oi#Onn/tO'd*R/.RoitU@0Phor+0Alu Asi$Enta`I@n-I,Olu%fOqu 1ActAg  Auc Cel]Cit/tClusifCu<Ecu,Emp#Erc H= Hor,I.n-I]Is,O%^Ped>Plor Po}Prim QuisT_sifTrai!Ul,:B#Bu#{Cet&Ci#Ctu!Ibl*Lai<Me{M`#R-'RfeluR(eRou~eSc( T=Tig)Uc$U%fVe'Vori3Bri#C$d D  L(M?M'Ndo*Od=Rm Ro-Rve'S%v=U`#Ut!Vr>3AscoCe]C%fDe#Gu!Latu!Leta.L>eL#ulLm LouLtr N/c N*O#R?Ssu!X 2A* Am?As^At&'E|E~eE'Exi$Oc$O!Uctu Ui@Uvi=2L+Nd +Ngib#Nta(eRc Rg $Rmu]Rtu[Ssi#Ud!Ug eU`]Ulu!Urmi2Agi#Ai<An~*App Aye'Ega&E( El$Em*E[s+E!Iab#Ic%$Iss$Ivo#OidOma.Ont=Ot,Uit2Gi%fI&Re'R+{R%fSi$T':Gn Lax+L +Mbad R/%rRd+nRn*Rrig)Zel#Z$3AntLa%[Lu#Ndar?N =N+NouN%lOlog+O?t!R/iumR?St)lY}3B>C]RafeV!2A-AiveIs}ObeOi!Or+{2Lfe'M?Nf]R.R`#Udr$Uff!UlotUp`#Urm/dUt&2Ad)lAffi%A(eAndApp(AtuitAv*EnatIffu!Il]Imp Ogn Ond Ot&OupeUg U% Uy e2EpardErr>I@Im|veIta!Sta%f3Mnas&Rostat:Bitu@Cho*L&Me|NgarN[t$RicotRm$+Rp$Sard3LiumMato?RbeRiss$Rm(eR$Si,U!{3B n BouLar/tStoi!V 5MardMma.Mo.[N['Nor N&{R@Riz$Rlo.Rm$eRrib#U#{Us<5BlotI#{Ma(Mb#Mi@Mo'R]3Dro?lG+[M[Pno<:2Yl#2Nor U/e4Lici&Lusi$0A.Bib I,M_<Mobi#Muab#PactP i=Plor Po}Prim Pu,0Carn C_d+Ci@ntCl( Colo!Dex Di-Duc%fEditEp%eExactF(iFlig Form Fusi$G  H= Hib Jec,Ju!No-ntOcu]Ond Scri!Sec&Sig[Soli&Sp* S%nctSul,TactT_<Ti?Trig)Tui%fU%#Vasi$V_,Vi,Voqu 3Oni^Rad>ReelRi,0O]2Oi!Res<:GuarIll*MbeNv>Rd(Ug U[Velot3Tab#T$UdiU[s<9Ind!N~ Ng]Ue'UissifUrn=Vi=Y|Ye{5Bi]Ge?ntNiorP$Ris&S%-Te{V_i#:Yak7M$oOs^:BelBi=Bo' C  Cto<Gu[I[Is}I% Mbe|Mel#MpeN-'Nga.N,[P(R.'R?Ur>VaboVo*3Ctu!G=G Gu?SsiveTt!V>Xi^Zard3As<B  B!C_-Cor[E.Ev!Gatu!Go,G)M Mi&M$a@Mpi@Neai!NgotOn-|Qui@S>eS,ThiumTi.Ttor=V!'5Gi^Inta(Is*MbricT +U UrdUt!UveY=5B+Ci@Cra%fE'Gub!Is/tM>eNai!NdiR$T,X){:Ch(eGas(G_taGi^Ig!Ill$In%_Ir+Is$Jor Lax Lefi-Lhe'Li-L#t&MmouthNda,Niab#Nqu/tN&|N)lRath$Rb!R~/dRdiRi%?R^'Rr$R&]Scot&SsifT +lT>eTra^Udi!Ussa@UveXim=3Ch/tC$nuDa`#Dec(Di,Du<Il#'L/.Lod+Mb!Moi!Nac N Nh*Ns$.NtorRc!diRi&R#Ssag Su!T=Teo!Tho@T>Ub#3Au]CrobeEt&Gn$Gr L+uLli$Mi^N-N =Nim=Nor Nu&Rac#Roi,Ssi#X&5Bi#D [El#{Ndi=Ni&'Nna+Not$eNst!Ntag[Nu?ntQ)'R-|Rsu!R% Te'TifU~eUf#Ul(Uss$Ut$Uv/t5L%p#Ni%$Ra`#Re[Rmu!Sc#SeumSic+nTa%$T T)l3Ria@R%l#S,eThi^:Ge'PpeRquoisRr Ta%$Ti$Tu!Ufra.U%^Vi!3Bu#{CtarFas&Ga%$Glig Goc>I.Rve{Ttoy Ur$eUtr$Veu3CheCkelTra&Ve|5B#CifCt'[Ir-'I<t&Ma@Mb!{Mm Rma%fTab#Tif>Toi!Urr*Uve|Va&'Vemb!Vi-5A.Anc I!Isib#M oP%=Q)Tri%f:0E*Jec%fLig Sc'S v Stac#T_*T' 0Casi$Cup E/Tob!Troy Tup]Ulai!0E'Or/t1F_}Fic>Fr*0Ive1Se|S`l$2Fac%fIv>0Bra.Ett!0Ct){Du]E!{Iri^1A#A^Er Ini$PortunPrim T Ti^1A.{An.Bi&D$n E`#G/eG)`Ifi-Ne?ntQ)T+0C`]Mo<Satu!0Ar+0Rag/Rs$T`Trag Vra.0A%$1Y@Y.[1O[:Isib#La-Lma!sLo'@Lp Na~eNdaNgol(Niqu N[|NoramaNt=$PayeP>Po,PyrusRadoxeR-l#Res<Rfum R]Ro#Rra(R<m Rtag Ru!Rv_*Ssi$S&^T [lT+n-Tr$V`l$Voi}Y Ysa.3Ig[Int!La.Lic/L#Lou<Lu~eNdu#Netr Nib#NsifN'+Pi&PlumRdrixRfor Rio@Rmu,Rp#xeRs`R&S Ta#TitTr*Up#2Ara$Ob+O^Ot$Ra<Ysi^0AnoCt'=E-Er!Euv!Lo&N-|Pet&Qu Rog)Sc(eSt$Vo,XelZza2AcardAf$dAis*An A^Astr$A&|E' ExusIa.OmbOng U+Uma.2Chet&Es+E&In&Ir>Iss$Iv!Lai!Lic>L#nLyg$eMma@Mp>Nct)lNd  NeyR%^Si%$S<d Stu!Tag Te|Ti$U-Ula(Um$Urp!Uss(Uvo*2A*+A%^Ec+{Edi!EfixeElu@EnomE<n-E&x&Evo*Imi%fIn-Is$Iv Ob#?O-d Odi.Of$dOg!sO+Oje,Olog)O?n Op!Osp eO&g O)s<Ov beU@n-U[|0Y~o<1BlicC $I}LpeLsarNai<Ni%fPit!Rif>Zz#3Rami@:99AsarE!l#Es%$Ietu@It,O%_t:C(eC$,D+{G$d(I@'Is(L_%rLl$.Mas}Pi@Sa.Tis}Vag V(Y$n 3Ac%fAg*Ali}Anim Cevo*Ci,Clam Col,Cru,Cu]Cyc]Dig Dou,Fai!F#xeForm Fra(Fu.G=+nGi$Gla.Gul>I, Je,Jou La%fLev L+fMar^Me@Mi<M$,Mpl*Mu NardNfortNif]N$c Ntr NvoiPl>Por,Pri<P%#Qu(S veS(e{Soud!SpectS,SultatTabl*T_*Ticu#Tomb Trac Uni$Uss*V/~eViv!Vol&Vulsif3Ches<De|E'Gi@Go]Nc Pos,Sib#S^T)lV=V>e5Che{M/-Mp!N-Nd(Se|S>Ta%fTorTu#U.U`#U#|U%[Y|?5B/BisCheEl#G){In Is<|S S%^3Th?:B]Bo,B!Co~eFariGes<Is*La@LiveL$Lu MediNc%$Ngl>Rcas?Rd(eT' Ug!nuUm$U,Uva.V/tV$n 1AlpelAnda#E]atEnarioEpt!HemaI_-Ind O!Ru%nUlp,1An-Cab#Ch Cou C!,Da%fDui!Ig['Jo'Lec%fMa(eMb]M_-M(=Na&'Nsib#N&n-Par Q)n-Re(R.ntR+{Rru!RumRvi-Sa?V*Vra.Xtup#3D =Ec#Eg Ff]G#Gn=L_-LiciumMp#Nc eNist!Ph$RopSmi^Tu 1I 3Ci=C#DiumIg[{LdatLe`Litu@Lub#Mb!M?`Mno]N@N.'N[t&No!Rc>R%rS+T%<Uc+{Udu!Uff#U#v UpapeUr-U%r Uv_*0Ac+{A%=Eci=H eIr=3Ab#A%$ErnumImulusIpu]RictUd+{Upe'Ylis&0Bli?BstratB%lBv_*C-sC!FfixeGg  Ive'Lfa&P bePpl>Rfa-Rica&R?n Rpri<Rs|tRv+Spect3LlabeMbo#Metr+Nap<NtaxeS&?:BacBl>C%#Il]L_tLism/L$n Mbo'Mi}Ngib#PisQu( Rd RifR%[S<TamiToua.UpeU!|X 3Mo(Mpo!lNa`#Nd!Ne'N*Nsi$Rm( R[Rrib#T(eX&2E?Eor+Erap+Orax0BiaE@Mi@Reli!Ro*SsuT/eT!Tub 5Bogg/L /tMa&Ni^N[|P$y?R~eRd!Rna@Rp`#R!ntR<Rt)TemU~ Urna.Us}X(e2Ac%$AficAgi^Ah*A(An~ Ava`Ef#Emp EsorEu`Ia.Ibun=Ico,Ilog+IompheIp]It' Ivi=Omb$eOncOpic=Oupe|2I#LipeMul&N[lRb(eTe'Toy Y|3Mp/Ph$Pi^R/:0Ues^9Ti?Tras$1Ani?If>I$I^Itai!Iv s3AniumBa(Tic/t0A.I[UelU!0I#Op+:Car?Cc(Gab$dG)Ill/tInc!Is<|Lab#Li<Ll$LveMpi!N`#Pe'R>Se{Ss=S&3C&'Det&Get=Hicu#InardLo-Nd!diN  Ng Ni?{Ntou<Rdu!R(Rn*RrouR}RtuSt$T /Tus&X/tX 3AducAn@Ctoi!D/.DeoG[t&G)'La(Lla.Naig!Ol$P eRe?ntRtuo<RusSa.Se'Si$S^{S)lT=Tes<Tico#Tr(eVa-Vipa!5Ca%$Gu I#Is(Itu!La`#Lc/L%g Lu?Ra-R&xT Ulo*Ya.Yel#:G$:3N$:Cht:3B!NithS&9Olog+";
  var accents = "e7693&)U*o&)Ry^)*)W))))#X^))))@@)#Wf)m%)#!))AG)&IIAQIIIBIIHJNAgBIILIDJGo)))HIQIIIIA(IGgJHH(BIIxX#)Ou)@*IAAPIIIJHQJ)&QIQPYI(HYAQC%)!))QHJJ@)#)^f*^AXCJ))$%CP))%&m)u)@e^A#G#))W@!(IKK%!(I%))O@QA))@GG#e))))WHJIWh))my@IIBT^)!)HAYGETHI*))!QnUDG)))nBoKAC*HwyQh))$&)G&)UGO)G)))(BX#v**)%O,e7686)I))@)&)gdMP()))ud)p#L))I^FIHYdWG))D@DFV)QA)o%MyTh%*)Z)%)n(XANc^R)YS";
  var checksum = "0x51deb7ae009149dc61a6bd18a918eb7ac78d2775726c68e598b92d002519b045";
  var _wordlist = null;
  /**
   *  The [[link-bip39-fr]] for [mnemonic phrases](link-bip-39).
   *
   *  @_docloc: api/wordlists
   */
  var LangFr = /*#__PURE__*/function (_wordlist_owla_js_1$W) {
    /**
     *  Creates a new instance of the French language Wordlist.
     *
     *  This should be unnecessary most of the time as the exported
     *  [[langFr]] should suffice.
     *
     *  @_ignore:
     */
    function LangFr() {
      _classCallCheck(this, LangFr);
      return _callSuper(this, LangFr, ["fr", words, accents, checksum]);
    }
    /**
     *  Returns a singleton instance of a ``LangFr``, creating it
     *  if this is the first time being called.
     */
    _inherits(LangFr, _wordlist_owla_js_1$W);
    return _createClass(LangFr, null, [{
      key: "wordlist",
      value: function wordlist() {
        if (_wordlist == null) {
          _wordlist = new LangFr();
        }
        return _wordlist;
      }
    }]);
  }(wordlist_owla_js_1.WordlistOwlA);
  langFr.LangFr = LangFr;
  return langFr;
}

var langJa = {};

var hasRequiredLangJa;
function requireLangJa() {
  if (hasRequiredLangJa) return langJa;
  hasRequiredLangJa = 1;
  Object.defineProperty(langJa, "__esModule", {
    value: true
  });
  langJa.LangJa = void 0;
  var index_js_1 = /*@__PURE__*/requireHash();
  var index_js_2 = /*@__PURE__*/requireUtils$3();
  var wordlist_js_1 = /*@__PURE__*/requireWordlist();
  var data = [
  // 4-kana words
  "AQRASRAGBAGUAIRAHBAghAURAdBAdcAnoAMEAFBAFCBKFBQRBSFBCXBCDBCHBGFBEQBpBBpQBIkBHNBeOBgFBVCBhBBhNBmOBmRBiHBiFBUFBZDBvFBsXBkFBlcBjYBwDBMBBTBBTRBWBBWXXaQXaRXQWXSRXCFXYBXpHXOQXHRXhRXuRXmXXbRXlXXwDXTRXrCXWQXWGaBWaKcaYgasFadQalmaMBacAKaRKKBKKXKKjKQRKDRKCYKCRKIDKeVKHcKlXKjHKrYNAHNBWNaRNKcNIBNIONmXNsXNdXNnBNMBNRBNrXNWDNWMNFOQABQAHQBrQXBQXFQaRQKXQKDQKOQKFQNBQNDQQgQCXQCDQGBQGDQGdQYXQpBQpQQpHQLXQHuQgBQhBQhCQuFQmXQiDQUFQZDQsFQdRQkHQbRQlOQlmQPDQjDQwXQMBQMDQcFQTBQTHQrDDXQDNFDGBDGQDGRDpFDhFDmXDZXDbRDMYDRdDTRDrXSAhSBCSBrSGQSEQSHBSVRShYShkSyQSuFSiBSdcSoESocSlmSMBSFBSFKSFNSFdSFcCByCaRCKcCSBCSRCCrCGbCEHCYXCpBCpQCIBCIHCeNCgBCgFCVECVcCmkCmwCZXCZFCdRClOClmClFCjDCjdCnXCwBCwXCcRCFQCFjGXhGNhGDEGDMGCDGCHGIFGgBGVXGVEGVRGmXGsXGdYGoSGbRGnXGwXGwDGWRGFNGFLGFOGFdGFkEABEBDEBFEXOEaBEKSENBENDEYXEIgEIkEgBEgQEgHEhFEudEuFEiBEiHEiFEZDEvBEsXEsFEdXEdREkFEbBEbRElFEPCEfkEFNYAEYAhYBNYQdYDXYSRYCEYYoYgQYgRYuRYmCYZTYdBYbEYlXYjQYRbYWRpKXpQopQnpSFpCXpIBpISphNpdBpdRpbRpcZpFBpFNpFDpFopFrLADLBuLXQLXcLaFLCXLEhLpBLpFLHXLeVLhILdHLdRLoDLbRLrXIABIBQIBCIBsIBoIBMIBRIXaIaRIKYIKRINBINuICDIGBIIDIIkIgRIxFIyQIiHIdRIbYIbRIlHIwRIMYIcRIRVITRIFBIFNIFQOABOAFOBQOaFONBONMOQFOSFOCDOGBOEQOpBOLXOIBOIFOgQOgFOyQOycOmXOsXOdIOkHOMEOMkOWWHBNHXNHXWHNXHDuHDRHSuHSRHHoHhkHmRHdRHkQHlcHlRHwBHWcgAEgAggAkgBNgBQgBEgXOgYcgLXgHjgyQgiBgsFgdagMYgWSgFQgFEVBTVXEVKBVKNVKDVKYVKRVNBVNYVDBVDxVSBVSRVCjVGNVLXVIFVhBVhcVsXVdRVbRVlRhBYhKYhDYhGShxWhmNhdahdkhbRhjohMXhTRxAXxXSxKBxNBxEQxeNxeQxhXxsFxdbxlHxjcxFBxFNxFQxFOxFoyNYyYoybcyMYuBQuBRuBruDMuCouHBudQukkuoBulVuMXuFEmCYmCRmpRmeDmiMmjdmTFmFQiADiBOiaRiKRiNBiNRiSFiGkiGFiERipRiLFiIFihYibHijBijEiMXiWBiFBiFCUBQUXFUaRUNDUNcUNRUNFUDBUSHUCDUGBUGFUEqULNULoUIRUeEUeYUgBUhFUuRUiFUsXUdFUkHUbBUjSUjYUwXUMDUcHURdUTBUrBUrXUrQZAFZXZZaRZKFZNBZQFZCXZGBZYdZpBZLDZIFZHXZHNZeQZVRZVFZmXZiBZvFZdFZkFZbHZbFZwXZcCZcRZRBvBQvBGvBLvBWvCovMYsAFsBDsaRsKFsNFsDrsSHsSFsCXsCRsEBsEHsEfspBsLBsLDsIgsIRseGsbRsFBsFQsFSdNBdSRdCVdGHdYDdHcdVbdySduDdsXdlRdwXdWYdWcdWRkBMkXOkaRkNIkNFkSFkCFkYBkpRkeNkgBkhVkmXksFklVkMBkWDkFNoBNoaQoaFoNBoNXoNaoNEoSRoEroYXoYCoYbopRopFomXojkowXorFbBEbEIbdBbjYlaRlDElMXlFDjKjjSRjGBjYBjYkjpRjLXjIBjOFjeVjbRjwBnXQnSHnpFnLXnINnMBnTRwXBwXNwXYwNFwQFwSBwGFwLXwLDweNwgBwuHwjDwnXMBXMpFMIBMeNMTHcaQcNBcDHcSFcCXcpBcLXcLDcgFcuFcnXcwXccDcTQcrFTQErXNrCHrpFrgFrbFrTHrFcWNYWNbWEHWMXWTR",
  // 5-kana words
  "ABGHABIJAEAVAYJQALZJAIaRAHNXAHdcAHbRAZJMAZJRAZTRAdVJAklmAbcNAjdRAMnRAMWYAWpRAWgRAFgBAFhBAFdcBNJBBNJDBQKBBQhcBQlmBDEJBYJkBYJTBpNBBpJFBIJBBIJDBIcABOKXBOEJBOVJBOiJBOZJBepBBeLXBeIFBegBBgGJBVJXBuocBiJRBUJQBlXVBlITBwNFBMYVBcqXBTlmBWNFBWiJBWnRBFGHBFwXXKGJXNJBXNZJXDTTXSHSXSVRXSlHXCJDXGQJXEhXXYQJXYbRXOfXXeNcXVJFXhQJXhEJXdTRXjdXXMhBXcQTXRGBXTEBXTnQXFCXXFOFXFgFaBaFaBNJaBCJaBpBaBwXaNJKaNJDaQIBaDpRaEPDaHMFamDJalEJaMZJaFaFaFNBaFQJaFLDaFVHKBCYKBEBKBHDKXaFKXGdKXEJKXpHKXIBKXZDKXwXKKwLKNacKNYJKNJoKNWcKDGdKDTRKChXKGaRKGhBKGbRKEBTKEaRKEPTKLMDKLWRKOHDKVJcKdBcKlIBKlOPKFSBKFEPKFpFNBNJNJBQNBGHNBEPNBHXNBgFNBVXNBZDNBsXNBwXNNaRNNJDNNJENNJkNDCJNDVDNGJRNJiDNZJNNsCJNJFNNFSBNFCXNFEPNFLXNFIFQJBFQCaRQJEQQLJDQLJFQIaRQOqXQHaFQHHQQVJXQVJDQhNJQmEIQZJFQsJXQJrFQWbRDJABDBYJDXNFDXCXDXLXDXZDDXsJDQqXDSJFDJCXDEPkDEqXDYmQDpSJDOCkDOGQDHEIDVJDDuDuDWEBDJFgSBNDSBSFSBGHSBIBSBTQSKVYSJQNSJQiSJCXSEqXSJYVSIiJSOMYSHAHSHaQSeCFSepQSegBSHdHSHrFShSJSJuHSJUFSkNRSrSrSWEBSFaHSJFQSFCXSFGDSFYXSFODSFgBSFVXSFhBSFxFSFkFSFbBSFMFCADdCJXBCXaFCXKFCXNFCXCXCXGBCXEJCXYBCXLDCXIBCXOPCXHXCXgBCXhBCXiBCXlDCXcHCJNBCJNFCDCJCDGBCDVXCDhBCDiDCDJdCCmNCpJFCIaRCOqXCHCHCHZJCViJCuCuCmddCJiFCdNBCdHhClEJCnUJCreSCWlgCWTRCFBFCFNBCFYBCFVFCFhFCFdSCFTBCFWDGBNBGBQFGJBCGBEqGBpBGBgQGNBEGNJYGNkOGNJRGDUFGJpQGHaBGJeNGJeEGVBlGVKjGiJDGvJHGsVJGkEBGMIJGWjNGFBFGFCXGFGBGFYXGFpBGFMFEASJEAWpEJNFECJVEIXSEIQJEOqXEOcFEeNcEHEJEHlFEJgFEhlmEmDJEmZJEiMBEUqXEoSREPBFEPXFEPKFEPSFEPEFEPpFEPLXEPIBEJPdEPcFEPTBEJnXEqlHEMpREFCXEFODEFcFYASJYJAFYBaBYBVXYXpFYDhBYCJBYJGFYYbRYeNcYJeVYiIJYZJcYvJgYvJRYJsXYsJFYMYMYreVpBNHpBEJpBwXpQxFpYEJpeNDpJeDpeSFpeCHpHUJpHbBpHcHpmUJpiiJpUJrpsJuplITpFaBpFQqpFGBpFEfpFYBpFpBpFLJpFIDpFgBpFVXpFyQpFuFpFlFpFjDpFnXpFwXpJFMpFTBLXCJLXEFLXhFLXUJLXbFLalmLNJBLSJQLCLCLGJBLLDJLHaFLeNFLeSHLeCXLepFLhaRLZsJLsJDLsJrLocaLlLlLMdbLFNBLFSBLFEHLFkFIBBFIBXFIBaQIBKXIBSFIBpHIBLXIBgBIBhBIBuHIBmXIBiFIBZXIBvFIBbFIBjQIBwXIBWFIKTRIQUJIDGFICjQIYSRIINXIJeCIVaRImEkIZJFIvJRIsJXIdCJIJoRIbBQIjYBIcqXITFVIreVIFKFIFSFIFCJIFGFIFLDIFIBIJFOIFgBIFVXIJFhIFxFIFmXIFdHIFbBIJFrIJFWOBGBOQfXOOKjOUqXOfXBOqXEOcqXORVJOFIBOFlDHBIOHXiFHNTRHCJXHIaRHHJDHHEJHVbRHZJYHbIBHRsJHRkDHWlmgBKFgBSBgBCDgBGHgBpBgBIBgBVJgBuBgBvFgKDTgQVXgDUJgGSJgOqXgmUMgZIJgTUJgWIEgFBFgFNBgFDJgFSFgFGBgFYXgJFOgFgQgFVXgFhBgFbHgJFWVJABVQKcVDgFVOfXVeDFVhaRVmGdViJYVMaRVFNHhBNDhBCXhBEqhBpFhBLXhNJBhSJRheVXhhKEhxlmhZIJhdBQhkIJhbMNhMUJhMZJxNJgxQUJxDEkxDdFxSJRxplmxeSBxeCXxeGFxeYXxepQxegBxWVcxFEQxFLXxFIBxFgBxFxDxFZtxFdcxFbBxFwXyDJXyDlcuASJuDJpuDIBuCpJuGSJuIJFueEFuZIJusJXudWEuoIBuWGJuFBcuFKEuFNFuFQFuFDJuFGJuFVJuFUtuFdHuFTBmBYJmNJYmQhkmLJDmLJomIdXmiJYmvJRmsJRmklmmMBymMuCmclmmcnQiJABiJBNiJBDiBSFiBCJiBEFiBYBiBpFiBLXiBTHiJNciDEfiCZJiECJiJEqiOkHiHKFieNDiHJQieQcieDHieSFieCXieGFieEFieIHiegFihUJixNoioNXiFaBiFKFiFNDiFEPiFYXitFOitFHiFgBiFVEiFmXiFitiFbBiFMFiFrFUCXQUIoQUIJcUHQJUeCEUHwXUUJDUUqXUdWcUcqXUrnQUFNDUFSHUFCFUFEfUFLXUtFOZBXOZXSBZXpFZXVXZEQJZEJkZpDJZOqXZeNHZeCDZUqXZFBQZFEHZFLXvBAFvBKFvBCXvBEPvBpHvBIDvBgFvBuHvQNJvFNFvFGBvFIBvJFcsXCDsXLXsXsXsXlFsXcHsQqXsJQFsEqXseIFsFEHsFjDdBxOdNpRdNJRdEJbdpJRdhZJdnSJdrjNdFNJdFQHdFhNkNJDkYaRkHNRkHSRkVbRkuMRkjSJkcqDoSJFoEiJoYZJoOfXohEBoMGQocqXbBAFbBXFbBaFbBNDbBGBbBLXbBTBbBWDbGJYbIJHbFQqbFpQlDgQlOrFlVJRjGEBjZJRnXvJnXbBnEfHnOPDngJRnxfXnUJWwXEJwNpJwDpBwEfXwrEBMDCJMDGHMDIJMLJDcQGDcQpHcqXccqNFcqCXcFCJRBSBRBGBRBEJRBpQTBNFTBQJTBpBTBVXTFABTFSBTFCFTFGBTFMDrXCJrXLDrDNJrEfHrFQJrFitWNjdWNTR",
  // 6-kana words
  "AKLJMANOPFASNJIAEJWXAYJNRAIIbRAIcdaAeEfDAgidRAdjNYAMYEJAMIbRAFNJBAFpJFBBIJYBDZJFBSiJhBGdEBBEJfXBEJqXBEJWRBpaUJBLXrXBIYJMBOcfXBeEfFBestXBjNJRBcDJOBFEqXXNvJRXDMBhXCJNYXOAWpXONJWXHDEBXeIaRXhYJDXZJSJXMDJOXcASJXFVJXaBQqXaBZJFasXdQaFSJQaFEfXaFpJHaFOqXKBNSRKXvJBKQJhXKEJQJKEJGFKINJBKIJjNKgJNSKVElmKVhEBKiJGFKlBgJKjnUJKwsJYKMFIJKFNJDKFIJFKFOfXNJBSFNJBCXNBpJFNJBvQNJBMBNJLJXNJOqXNJeCXNJeGFNdsJCNbTKFNwXUJQNFEPQDiJcQDMSJQSFpBQGMQJQJeOcQyCJEQUJEBQJFBrQFEJqDXDJFDJXpBDJXIMDGiJhDIJGRDJeYcDHrDJDVXgFDkAWpDkIgRDjDEqDMvJRDJFNFDJFIBSKclmSJQOFSJQVHSJQjDSJGJBSJGJFSECJoSHEJqSJHTBSJVJDSViJYSZJNBSJsJDSFSJFSFEfXSJFLXCBUJVCJXSBCJXpBCXVJXCJXsXCJXdFCJNJHCLIJgCHiJFCVNJMChCJhCUHEJCsJTRCJdYcCoQJCCFEfXCFIJgCFUJxCFstFGJBaQGJBIDGQJqXGYJNRGJHKFGeQqDGHEJFGJeLXGHIiJGHdBlGUJEBGkIJTGFQPDGJFEqEAGegEJIJBEJVJXEhQJTEiJNcEJZJFEJoEqEjDEqEPDsXEPGJBEPOqXEPeQFEfDiDEJfEFEfepQEfMiJEqXNBEqDIDEqeSFEqVJXEMvJRYXNJDYXEJHYKVJcYYJEBYJeEcYJUqXYFpJFYFstXpAZJMpBSJFpNBNFpeQPDpHLJDpHIJFpHgJFpeitFpHZJFpJFADpFSJFpJFCJpFOqXpFitBpJFZJLXIJFLIJgRLVNJWLVHJMLwNpJLFGJBLFLJDLFOqXLJFUJIBDJXIBGJBIJBYQIJBIBIBOqXIBcqDIEGJFILNJTIIJEBIOiJhIJeNBIJeIBIhiJIIWoTRIJFAHIJFpBIJFuHIFUtFIJFTHOSBYJOEcqXOHEJqOvBpFOkVJrObBVJOncqDOcNJkHhNJRHuHJuHdMhBgBUqXgBsJXgONJBgHNJDgHHJQgJeitgHsJXgJyNagyDJBgZJDrgsVJQgkEJNgkjSJgJFAHgFCJDgFZtMVJXNFVXQfXVJXDJVXoQJVQVJQVDEfXVDvJHVEqNFVeQfXVHpJFVHxfXVVJSRVVmaRVlIJOhCXVJhHjYkhxCJVhWVUJhWiJcxBNJIxeEqDxfXBFxcFEPxFSJFxFYJXyBDQJydaUJyFOPDuYCJYuLvJRuHLJXuZJLDuFOPDuFZJHuFcqXmKHJdmCQJcmOsVJiJAGFitLCFieOfXiestXiZJMEikNJQirXzFiFQqXiFIJFiFZJFiFvtFUHpJFUteIcUteOcUVCJkUhdHcUbEJEUJqXQUMNJhURjYkUFitFZDGJHZJIxDZJVJXZJFDJZJFpQvBNJBvBSJFvJxBrseQqDsVFVJdFLJDkEJNBkmNJYkFLJDoQJOPoGsJRoEAHBoEJfFbBQqDbBZJHbFVJXlFIJBjYIrXjeitcjjCEBjWMNBwXQfXwXOaFwDsJXwCJTRwrCZJMDNJQcDDJFcqDOPRYiJFTBsJXTQIJBTFEfXTFLJDrXEJFrEJXMrFZJFWEJdEWYTlm",
  // 7-kana words
  "ABCDEFACNJTRAMBDJdAcNJVXBLNJEBXSIdWRXErNJkXYDJMBXZJCJaXMNJaYKKVJKcKDEJqXKDcNJhKVJrNYKbgJVXKFVJSBNBYBwDNJeQfXNJeEqXNhGJWENJFiJRQlIJbEQJfXxDQqXcfXQFNDEJQFwXUJDYcnUJDJIBgQDIUJTRDJFEqDSJQSJFSJQIJFSOPeZtSJFZJHCJXQfXCTDEqFGJBSJFGJBOfXGJBcqXGJHNJDGJRLiJEJfXEqEJFEJPEFpBEJYJBZJFYBwXUJYiJMEBYJZJyTYTONJXpQMFXFpeGIDdpJFstXpJFcPDLBVSJRLHQJqXLJFZJFIJBNJDIJBUqXIBkFDJIJEJPTIYJGWRIJeQPDIJeEfHIJFsJXOqGDSFHXEJqXgJCsJCgGQJqXgdQYJEgFMFNBgJFcqDVJwXUJVJFZJchIgJCCxOEJqXxOwXUJyDJBVRuscisciJBiJBieUtqXiJFDJkiFsJXQUGEZJcUJFsJXZtXIrXZDZJDrZJFNJDZJFstXvJFQqXvJFCJEsJXQJqkhkNGBbDJdTRbYJMEBlDwXUJMEFiJFcfXNJDRcNJWMTBLJXC",
  // 8-kana words
  "BraFUtHBFSJFdbNBLJXVJQoYJNEBSJBEJfHSJHwXUJCJdAZJMGjaFVJXEJPNJBlEJfFiJFpFbFEJqIJBVJCrIBdHiJhOPFChvJVJZJNJWxGFNIFLueIBQJqUHEJfUFstOZJDrlXEASJRlXVJXSFwVJNJWD",
  // 9-kana words
  "QJEJNNJDQJEJIBSFQJEJxegBQJEJfHEPSJBmXEJFSJCDEJqXLXNJFQqXIcQsFNJFIFEJqXUJgFsJXIJBUJEJfHNFvJxEqXNJnXUJFQqD",
  // 10-kana words
  "IJBEJqXZJ"];
  // Maps each character into its kana value (the index)
  var mapping = "~~AzB~X~a~KN~Q~D~S~C~G~E~Y~p~L~I~O~eH~g~V~hxyumi~~U~~Z~~v~~s~~dkoblPjfnqwMcRTr~W~~~F~~~~~Jt";
  var _wordlist = null;
  function hex(word) {
    return (0, index_js_2.hexlify)((0, index_js_2.toUtf8Bytes)(word));
  }
  var KiYoKu = "0xe3818de38284e3818f";
  var KyoKu = "0xe3818de38283e3818f";
  function toString(data) {
    return (0, index_js_2.toUtf8String)(new Uint8Array(data));
  }
  function loadWords() {
    if (_wordlist !== null) {
      return _wordlist;
    }
    var wordlist = [];
    // Transforms for normalizing (sort is a not quite UTF-8)
    var transform = {};
    // Delete the diacritic marks
    transform[toString([227, 130, 154])] = false;
    transform[toString([227, 130, 153])] = false;
    // Some simple transforms that sort out most of the order
    transform[toString([227, 130, 133])] = toString([227, 130, 134]);
    transform[toString([227, 129, 163])] = toString([227, 129, 164]);
    transform[toString([227, 130, 131])] = toString([227, 130, 132]);
    transform[toString([227, 130, 135])] = toString([227, 130, 136]);
    // Normalize words using the transform
    function normalize(word) {
      var result = "";
      for (var i = 0; i < word.length; i++) {
        var kana = word[i];
        var target = transform[kana];
        if (target === false) {
          continue;
        }
        if (target) {
          kana = target;
        }
        result += kana;
      }
      return result;
    }
    // Sort how the Japanese list is sorted
    function sortJapanese(a, b) {
      a = normalize(a);
      b = normalize(b);
      if (a < b) {
        return -1;
      }
      if (a > b) {
        return 1;
      }
      return 0;
    }
    // Load all the words
    for (var length = 3; length <= 9; length++) {
      var d = data[length - 3];
      for (var offset = 0; offset < d.length; offset += length) {
        var word = [];
        for (var i = 0; i < length; i++) {
          var k = mapping.indexOf(d[offset + i]);
          word.push(227);
          word.push(k & 0x40 ? 130 : 129);
          word.push((k & 0x3f) + 128);
        }
        wordlist.push(toString(word));
      }
    }
    wordlist.sort(sortJapanese);
    // For some reason kyoku and kiyoku are flipped in node (!!).
    // The order SHOULD be:
    //   - kyoku
    //   - kiyoku
    // This should ignore "if", but that doesn't work here??
    /* c8 ignore start */
    if (hex(wordlist[442]) === KiYoKu && hex(wordlist[443]) === KyoKu) {
      var tmp = wordlist[442];
      wordlist[442] = wordlist[443];
      wordlist[443] = tmp;
    }
    /* c8 ignore stop */
    // Verify the computed list matches the official list
    /* istanbul ignore if */
    var checksum = (0, index_js_1.id)(wordlist.join("\n") + "\n");
    /* c8 ignore start */
    if (checksum !== "0xcb36b09e6baa935787fd762ce65e80b0c6a8dabdfbc3a7f86ac0e2c4fd111600") {
      throw new Error("BIP39 Wordlist for ja (Japanese) FAILED");
    }
    /* c8 ignore stop */
    _wordlist = wordlist;
    return wordlist;
  }
  var _wordlist2 = null;
  /**
   *  The [[link-bip39-ja]] for [mnemonic phrases](link-bip-39).
   *
   *  @_docloc: api/wordlists
   */
  var LangJa = /*#__PURE__*/function (_wordlist_js_1$Wordli) {
    /**
     *  Creates a new instance of the Japanese language Wordlist.
     *
     *  This should be unnecessary most of the time as the exported
     *  [[langJa]] should suffice.
     *
     *  @_ignore:
     */
    function LangJa() {
      _classCallCheck(this, LangJa);
      return _callSuper(this, LangJa, ["ja"]);
    }
    _inherits(LangJa, _wordlist_js_1$Wordli);
    return _createClass(LangJa, [{
      key: "getWord",
      value: function getWord(index) {
        var words = loadWords();
        (0, index_js_2.assertArgument)(index >= 0 && index < words.length, "invalid word index: ".concat(index), "index", index);
        return words[index];
      }
    }, {
      key: "getWordIndex",
      value: function getWordIndex(word) {
        return loadWords().indexOf(word);
      }
    }, {
      key: "split",
      value: function split(phrase) {
        //logger.assertNormalize();
        return phrase.split(/(?:\u3000| )+/g);
      }
    }, {
      key: "join",
      value: function join(words) {
        return words.join("\u3000");
      }
      /**
       *  Returns a singleton instance of a ``LangJa``, creating it
       *  if this is the first time being called.
       */
    }], [{
      key: "wordlist",
      value: function wordlist() {
        if (_wordlist2 == null) {
          _wordlist2 = new LangJa();
        }
        return _wordlist2;
      }
    }]);
  }(wordlist_js_1.Wordlist);
  langJa.LangJa = LangJa;
  return langJa;
}

var langKo = {};

var hasRequiredLangKo;
function requireLangKo() {
  if (hasRequiredLangKo) return langKo;
  hasRequiredLangKo = 1;
  Object.defineProperty(langKo, "__esModule", {
    value: true
  });
  langKo.LangKo = void 0;
  var index_js_1 = /*@__PURE__*/requireHash();
  var index_js_2 = /*@__PURE__*/requireUtils$3();
  var wordlist_js_1 = /*@__PURE__*/requireWordlist();
  var data = ["OYAa", "ATAZoATBl3ATCTrATCl8ATDloATGg3ATHT8ATJT8ATJl3ATLlvATLn4ATMT8ATMX8ATMboATMgoAToLbAToMTATrHgATvHnAT3AnAT3JbAT3MTAT8DbAT8JTAT8LmAT8MYAT8MbAT#LnAUHT8AUHZvAUJXrAUJX8AULnrAXJnvAXLUoAXLgvAXMn6AXRg3AXrMbAX3JTAX3QbAYLn3AZLgvAZrSUAZvAcAZ8AaAZ8AbAZ8AnAZ8HnAZ8LgAZ8MYAZ8MgAZ8OnAaAboAaDTrAaFTrAaJTrAaJboAaLVoAaMXvAaOl8AaSeoAbAUoAbAg8AbAl4AbGnrAbMT8AbMXrAbMn4AbQb8AbSV8AbvRlAb8AUAb8AnAb8HgAb8JTAb8NTAb8RbAcGboAcLnvAcMT8AcMX8AcSToAcrAaAcrFnAc8AbAc8MgAfGgrAfHboAfJnvAfLV8AfLkoAfMT8AfMnoAfQb8AfScrAfSgrAgAZ8AgFl3AgGX8AgHZvAgHgrAgJXoAgJX8AgJboAgLZoAgLn4AgOX8AgoATAgoAnAgoCUAgoJgAgoLXAgoMYAgoSeAgrDUAgrJTAhrFnAhrLjAhrQgAjAgoAjJnrAkMX8AkOnoAlCTvAlCV8AlClvAlFg4AlFl6AlFn3AloSnAlrAXAlrAfAlrFUAlrFbAlrGgAlrOXAlvKnAlvMTAl3AbAl3MnAnATrAnAcrAnCZ3AnCl8AnDg8AnFboAnFl3AnHX4AnHbrAnHgrAnIl3AnJgvAnLXoAnLX4AnLbrAnLgrAnLhrAnMXoAnMgrAnOn3AnSbrAnSeoAnvLnAn3OnCTGgvCTSlvCTvAUCTvKnCTvNTCT3CZCT3GUCT3MTCT8HnCUCZrCULf8CULnvCU3HnCU3JUCY6NUCbDb8CbFZoCbLnrCboOTCboScCbrFnCbvLnCb8AgCb8HgCb$LnCkLfoClBn3CloDUDTHT8DTLl3DTSU8DTrAaDTrLXDTrLjDTrOYDTrOgDTvFXDTvFnDT3HUDT3LfDUCT9DUDT4DUFVoDUFV8DUFkoDUGgrDUJnrDULl8DUMT8DUMXrDUMX4DUMg8DUOUoDUOgvDUOg8DUSToDUSZ8DbDXoDbDgoDbGT8DbJn3DbLg3DbLn4DbMXrDbMg8DbOToDboJXGTClvGTDT8GTFZrGTLVoGTLlvGTLl3GTMg8GTOTvGTSlrGToCUGTrDgGTrJYGTrScGTtLnGTvAnGTvQgGUCZrGUDTvGUFZoGUHXrGULnvGUMT8GUoMgGXoLnGXrMXGXrMnGXvFnGYLnvGZOnvGZvOnGZ8LaGZ8LmGbAl3GbDYvGbDlrGbHX3GbJl4GbLV8GbLn3GbMn4GboJTGboRfGbvFUGb3GUGb4JnGgDX3GgFl$GgJlrGgLX6GgLZoGgLf8GgOXoGgrAgGgrJXGgrMYGgrScGgvATGgvOYGnAgoGnJgvGnLZoGnLg3GnLnrGnQn8GnSbrGnrMgHTClvHTDToHTFT3HTQT8HToJTHToJgHTrDUHTrMnHTvFYHTvRfHT8MnHT8SUHUAZ8HUBb4HUDTvHUoMYHXFl6HXJX6HXQlrHXrAUHXrMnHXrSbHXvFYHXvKXHX3LjHX3MeHYvQlHZrScHZvDbHbAcrHbFT3HbFl3HbJT8HbLTrHbMT8HbMXrHbMbrHbQb8HbSX3HboDbHboJTHbrFUHbrHgHbrJTHb8JTHb8MnHb8QgHgAlrHgDT3HgGgrHgHgrHgJTrHgJT8HgLX@HgLnrHgMT8HgMX8HgMboHgOnrHgQToHgRg3HgoHgHgrCbHgrFnHgrLVHgvAcHgvAfHnAloHnCTrHnCnvHnGTrHnGZ8HnGnvHnJT8HnLf8HnLkvHnMg8HnRTrITvFUITvFnJTAXrJTCV8JTFT3JTFT8JTFn4JTGgvJTHT8JTJT8JTJXvJTJl3JTJnvJTLX4JTLf8JTLhvJTMT8JTMXrJTMnrJTObrJTQT8JTSlvJT8DUJT8FkJT8MTJT8OXJT8OgJT8QUJT8RfJUHZoJXFT4JXFlrJXGZ8JXGnrJXLV8JXLgvJXMXoJXMX3JXNboJXPlvJXoJTJXoLkJXrAXJXrHUJXrJgJXvJTJXvOnJX4KnJYAl3JYJT8JYLhvJYQToJYrQXJY6NUJbAl3JbCZrJbDloJbGT8JbGgrJbJXvJbJboJbLf8JbLhrJbLl3JbMnvJbRg8JbSZ8JboDbJbrCZJbrSUJb3KnJb8LnJfRn8JgAXrJgCZrJgDTrJgGZrJgGZ8JgHToJgJT8JgJXoJgJgvJgLX4JgLZ3JgLZ8JgLn4JgMgrJgMn4JgOgvJgPX6JgRnvJgSToJgoCZJgoJbJgoMYJgrJXJgrJgJgrLjJg6MTJlCn3JlGgvJlJl8Jl4AnJl8FnJl8HgJnAToJnATrJnAbvJnDUoJnGnrJnJXrJnJXvJnLhvJnLnrJnLnvJnMToJnMT8JnMXvJnMX3JnMg8JnMlrJnMn4JnOX8JnST4JnSX3JnoAgJnoAnJnoJTJnoObJnrAbJnrAkJnrHnJnrJTJnrJYJnrOYJnrScJnvCUJnvFaJnvJgJnvJnJnvOYJnvQUJnvRUJn3FnJn3JTKnFl3KnLT6LTDlvLTMnoLTOn3LTRl3LTSb4LTSlrLToAnLToJgLTrAULTrAcLTrCULTrHgLTrMgLT3JnLULnrLUMX8LUoJgLVATrLVDTrLVLb8LVoJgLV8MgLV8RTLXDg3LXFlrLXrCnLXrLXLX3GTLX4GgLX4OYLZAXrLZAcrLZAgrLZAhrLZDXyLZDlrLZFbrLZFl3LZJX6LZJX8LZLc8LZLnrLZSU8LZoJTLZoJnLZrAgLZrAnLZrJYLZrLULZrMgLZrSkLZvAnLZvGULZvJeLZvOTLZ3FZLZ4JXLZ8STLZ8ScLaAT3LaAl3LaHT8LaJTrLaJT8LaJXrLaJgvLaJl4LaLVoLaMXrLaMXvLaMX8LbClvLbFToLbHlrLbJn4LbLZ3LbLhvLbMXrLbMnoLbvSULcLnrLc8HnLc8MTLdrMnLeAgoLeOgvLeOn3LfAl3LfLnvLfMl3LfOX8Lf8AnLf8JXLf8LXLgJTrLgJXrLgJl8LgMX8LgRZrLhCToLhrAbLhrFULhrJXLhvJYLjHTrLjHX4LjJX8LjLhrLjSX3LjSZ4LkFX4LkGZ8LkGgvLkJTrLkMXoLkSToLkSU8LkSZ8LkoOYLl3FfLl3MgLmAZrLmCbrLmGgrLmHboLmJnoLmJn3LmLfoLmLhrLmSToLnAX6LnAb6LnCZ3LnCb3LnDTvLnDb8LnFl3LnGnrLnHZvLnHgvLnITvLnJT8LnJX8LnJlvLnLf8LnLg6LnLhvLnLnoLnMXrLnMg8LnQlvLnSbrLnrAgLnrAnLnrDbLnrFkLnrJdLnrMULnrOYLnrSTLnvAnLnvDULnvHgLnvOYLnvOnLn3GgLn4DULn4JTLn4JnMTAZoMTAloMTDb8MTFT8MTJnoMTJnrMTLZrMTLhrMTLkvMTMX8MTRTrMToATMTrDnMTrOnMT3JnMT4MnMT8FUMT8FaMT8FlMT8GTMT8GbMT8GnMT8HnMT8JTMT8JbMT8OTMUCl8MUJTrMUJU8MUMX8MURTrMUSToMXAX6MXAb6MXCZoMXFXrMXHXrMXLgvMXOgoMXrAUMXrAnMXrHgMXrJYMXrJnMXrMTMXrMgMXrOYMXrSZMXrSgMXvDUMXvOTMX3JgMX3OTMX4JnMX8DbMX8FnMX8HbMX8HgMX8HnMX8LbMX8MnMX8OnMYAb8MYGboMYHTvMYHX4MYLTrMYLnvMYMToMYOgvMYRg3MYSTrMbAToMbAXrMbAl3MbAn8MbGZ8MbJT8MbJXrMbMXvMbMX8MbMnoMbrMUMb8AfMb8FbMb8FkMcJXoMeLnrMgFl3MgGTvMgGXoMgGgrMgGnrMgHT8MgHZrMgJnoMgLnrMgLnvMgMT8MgQUoMgrHnMgvAnMg8HgMg8JYMg8LfMloJnMl8ATMl8AXMl8JYMnAToMnAT4MnAZ8MnAl3MnAl4MnCl8MnHT8MnHg8MnJnoMnLZoMnLhrMnMXoMnMX3MnMnrMnOgvMnrFbMnrFfMnrFnMnrNTMnvJXNTMl8OTCT3OTFV8OTFn3OTHZvOTJXrOTOl3OT3ATOT3JUOT3LZOT3LeOT3MbOT8ATOT8AbOT8AgOT8MbOUCXvOUMX3OXHXvOXLl3OXrMUOXvDbOX6NUOX8JbOYFZoOYLbrOYLkoOYMg8OYSX3ObHTrObHT4ObJgrObLhrObMX3ObOX8Ob8FnOeAlrOeJT8OeJXrOeJnrOeLToOeMb8OgJXoOgLXoOgMnrOgOXrOgOloOgoAgOgoJbOgoMYOgoSTOg8AbOjLX4OjMnoOjSV8OnLVoOnrAgOn3DUPXQlrPXvFXPbvFTPdAT3PlFn3PnvFbQTLn4QToAgQToMTQULV8QURg8QUoJnQXCXvQbFbrQb8AaQb8AcQb8FbQb8MYQb8ScQeAlrQeLhrQjAn3QlFXoQloJgQloSnRTLnvRTrGURTrJTRUJZrRUoJlRUrQnRZrLmRZrMnRZrSnRZ8ATRZ8JbRZ8ScRbMT8RbST3RfGZrRfMX8RfMgrRfSZrRnAbrRnGT8RnvJgRnvLfRnvMTRn8AaSTClvSTJgrSTOXrSTRg3STRnvSToAcSToAfSToAnSToHnSToLjSToMTSTrAaSTrEUST3BYST8AgST8LmSUAZvSUAgrSUDT4SUDT8SUGgvSUJXoSUJXvSULTrSU8JTSU8LjSV8AnSV8JgSXFToSXLf8SYvAnSZrDUSZrMUSZrMnSZ8HgSZ8JTSZ8JgSZ8MYSZ8QUSaQUoSbCT3SbHToSbQYvSbSl4SboJnSbvFbSb8HbSb8JgSb8OTScGZrScHgrScJTvScMT8ScSToScoHbScrMTScvAnSeAZrSeAcrSeHboSeJUoSeLhrSeMT8SeMXrSe6JgSgHTrSkJnoSkLnvSk8CUSlFl3SlrSnSl8GnSmAboSmGT8SmJU8", "ATLnDlATrAZoATrJX4ATrMT8ATrMX4ATrRTrATvDl8ATvJUoATvMl8AT3AToAT3MX8AT8CT3AT8DT8AT8HZrAT8HgoAUAgFnAUCTFnAXoMX8AXrAT8AXrGgvAXrJXvAXrOgoAXvLl3AZvAgoAZvFbrAZvJXoAZvJl8AZvJn3AZvMX8AZvSbrAZ8FZoAZ8LZ8AZ8MU8AZ8OTvAZ8SV8AZ8SX3AbAgFZAboJnoAbvGboAb8ATrAb8AZoAb8AgrAb8Al4Ab8Db8Ab8JnoAb8LX4Ab8LZrAb8LhrAb8MT8Ab8OUoAb8Qb8Ab8ST8AcrAUoAcrAc8AcrCZ3AcrFT3AcrFZrAcrJl4AcrJn3AcrMX3AcrOTvAc8AZ8Ac8MT8AfAcJXAgoFn4AgoGgvAgoGnrAgoLc8AgoMXoAgrLnrAkrSZ8AlFXCTAloHboAlrHbrAlrLhrAlrLkoAl3CZrAl3LUoAl3LZrAnrAl4AnrMT8An3HT4BT3IToBX4MnvBb!Ln$CTGXMnCToLZ4CTrHT8CT3JTrCT3RZrCT#GTvCU6GgvCU8Db8CU8GZrCU8HT8CboLl3CbrGgrCbrMU8Cb8DT3Cb8GnrCb8LX4Cb8MT8Cb8ObrCgrGgvCgrKX4Cl8FZoDTrAbvDTrDboDTrGT6DTrJgrDTrMX3DTrRZrDTrRg8DTvAVvDTvFZoDT3DT8DT3Ln3DT4HZrDT4MT8DT8AlrDT8MT8DUAkGbDUDbJnDYLnQlDbDUOYDbMTAnDbMXSnDboAT3DboFn4DboLnvDj6JTrGTCgFTGTGgFnGTJTMnGTLnPlGToJT8GTrCT3GTrLVoGTrLnvGTrMX3GTrMboGTvKl3GZClFnGZrDT3GZ8DTrGZ8FZ8GZ8MXvGZ8On8GZ8ST3GbCnQXGbMbFnGboFboGboJg3GboMXoGb3JTvGb3JboGb3Mn6Gb3Qb8GgDXLjGgMnAUGgrDloGgrHX4GgrSToGgvAXrGgvAZvGgvFbrGgvLl3GgvMnvGnDnLXGnrATrGnrMboGnuLl3HTATMnHTAgCnHTCTCTHTrGTvHTrHTvHTrJX8HTrLl8HTrMT8HTrMgoHTrOTrHTuOn3HTvAZrHTvDTvHTvGboHTvJU8HTvLl3HTvMXrHTvQb4HT4GT6HT4JT8HT4Jb#HT8Al3HT8GZrHT8GgrHT8HX4HT8Jb8HT8JnoHT8LTrHT8LgvHT8SToHT8SV8HUoJUoHUoJX8HUoLnrHXrLZoHXvAl3HX3LnrHX4FkvHX4LhrHX4MXoHX4OnoHZrAZ8HZrDb8HZrGZ8HZrJnrHZvGZ8HZvLnvHZ8JnvHZ8LhrHbCXJlHbMTAnHboJl4HbpLl3HbrJX8HbrLnrHbrMnvHbvRYrHgoSTrHgrFV8HgrGZ8HgrJXoHgrRnvHgvBb!HgvGTrHgvHX4HgvHn!HgvLTrHgvSU8HnDnLbHnFbJbHnvDn8Hn6GgvHn!BTvJTCTLnJTQgFnJTrAnvJTrLX4JTrOUoJTvFn3JTvLnrJTvNToJT3AgoJT3Jn4JT3LhvJT3ObrJT8AcrJT8Al3JT8JT8JT8JnoJT8LX4JT8LnrJT8MX3JT8Rg3JT8Sc8JUoBTvJU8AToJU8GZ8JU8GgvJU8JTrJU8JXrJU8JnrJU8LnvJU8ScvJXHnJlJXrGgvJXrJU8JXrLhrJXrMT8JXrMXrJXrQUoJXvCTvJXvGZ8JXvGgrJXvQT8JX8Ab8JX8DT8JX8GZ8JX8HZvJX8LnrJX8MT8JX8MXoJX8MnvJX8ST3JYGnCTJbAkGbJbCTAnJbLTAcJboDT3JboLb6JbrAnvJbrCn3JbrDl8JbrGboJbrIZoJbrJnvJbrMnvJbrQb4Jb8RZrJeAbAnJgJnFbJgScAnJgrATrJgvHZ8JgvMn4JlJlFbJlLiQXJlLjOnJlRbOlJlvNXoJlvRl3Jl4AcrJl8AUoJl8MnrJnFnMlJnHgGbJnoDT8JnoFV8JnoGgvJnoIT8JnoQToJnoRg3JnrCZ3JnrGgrJnrHTvJnrLf8JnrOX8JnvAT3JnvFZoJnvGT8JnvJl4JnvMT8JnvMX8JnvOXrJnvPX6JnvSX3JnvSZrJn3MT8Jn3MX8Jn3RTrLTATKnLTJnLTLTMXKnLTRTQlLToGb8LTrAZ8LTrCZ8LTrDb8LTrHT8LT3PX6LT4FZoLT$CTvLT$GgrLUvHX3LVoATrLVoAgoLVoJboLVoMX3LVoRg3LV8CZ3LV8FZoLV8GTvLXrDXoLXrFbrLXvAgvLXvFlrLXvLl3LXvRn6LX4Mb8LX8GT8LYCXMnLYrMnrLZoSTvLZrAZvLZrAloLZrFToLZrJXvLZrJboLZrJl4LZrLnrLZrMT8LZrOgvLZrRnvLZrST4LZvMX8LZvSlvLZ8AgoLZ8CT3LZ8JT8LZ8LV8LZ8LZoLZ8Lg8LZ8SV8LZ8SbrLZ$HT8LZ$Mn4La6CTvLbFbMnLbRYFTLbSnFZLboJT8LbrAT9LbrGb3LbrQb8LcrJX8LcrMXrLerHTvLerJbrLerNboLgrDb8LgrGZ8LgrHTrLgrMXrLgrSU8LgvJTrLgvLl3Lg6Ll3LhrLnrLhrMT8LhvAl4LiLnQXLkoAgrLkoJT8LkoJn4LlrSU8Ll3FZoLl3HTrLl3JX8Ll3JnoLl3LToLmLeFbLnDUFbLnLVAnLnrATrLnrAZoLnrAb8LnrAlrLnrGgvLnrJU8LnrLZrLnrLhrLnrMb8LnrOXrLnrSZ8LnvAb4LnvDTrLnvDl8LnvHTrLnvHbrLnvJT8LnvJU8LnvJbrLnvLhvLnvMX8LnvMb8LnvNnoLnvSU8Ln3Al3Ln4FZoLn4GT6Ln4JgvLn4LhrLn4MT8Ln4SToMToCZrMToJX8MToLX4MToLf8MToRg3MTrEloMTvGb6MT3BTrMT3Lb6MT8AcrMT8AgrMT8GZrMT8JnoMT8LnrMT8MX3MUOUAnMXAbFnMXoAloMXoJX8MXoLf8MXoLl8MXrAb8MXrDTvMXrGT8MXrGgrMXrHTrMXrLf8MXrMU8MXrOXvMXrQb8MXvGT8MXvHTrMXvLVoMX3AX3MX3Jn3MX3LhrMX3MX3MX4AlrMX4OboMX8GTvMX8GZrMX8GgrMX8JT8MX8JX8MX8LhrMX8MT8MYDUFbMYMgDbMbGnFfMbvLX4MbvLl3Mb8Mb8Mb8ST4MgGXCnMg8ATrMg8AgoMg8CZrMg8DTrMg8DboMg8HTrMg8JgrMg8LT8MloJXoMl8AhrMl8JT8MnLgAUMnoJXrMnoLX4MnoLhrMnoMT8MnrAl4MnrDb8MnrOTvMnrOgvMnrQb8MnrSU8MnvGgrMnvHZ8Mn3MToMn4DTrMn4LTrMn4Mg8NnBXAnOTFTFnOToAToOTrGgvOTrJX8OT3JXoOT6MTrOT8GgrOT8HTpOT8MToOUoHT8OUoJT8OUoLn3OXrAgoOXrDg8OXrMT8OXvSToOX6CTvOX8CZrOX8OgrOb6HgvOb8AToOb8MT8OcvLZ8OgvAlrOgvHTvOgvJTrOgvJnrOgvLZrOgvLn4OgvMT8OgvRTrOg8AZoOg8DbvOnrOXoOnvJn4OnvLhvOnvRTrOn3GgoOn3JnvOn6JbvOn8OTrPTGYFTPbBnFnPbGnDnPgDYQTPlrAnvPlrETvPlrLnvPlrMXvPlvFX4QTMTAnQTrJU8QYCnJlQYJlQlQbGTQbQb8JnrQb8LZoQb8LnvQb8MT8Qb8Ml8Qb8ST4QloAl4QloHZvQloJX8QloMn8QnJZOlRTrAZvRTrDTrRTvJn4RTvLhvRT4Jb8RZrAZrRZ8AkrRZ8JU8RZ8LV8RZ8LnvRbJlQXRg3GboRg3MnvRg8AZ8Rg8JboRg8Jl4RnLTCbRnvFl3RnvQb8SToAl4SToCZrSToFZoSToHXrSToJU8SToJgvSToJl4SToLhrSToMX3STrAlvSTrCT9STrCgrSTrGgrSTrHXrSTrHboSTrJnoSTrNboSTvLnrST4AZoST8Ab8ST8JT8SUoJn3SU6HZ#SU6JTvSU8Db8SU8HboSU8LgrSV8JT8SZrAcrSZrAl3SZrJT8SZrJnvSZrMT8SZvLUoSZ4FZoSZ8JnoSZ8RZrScoLnrScoMT8ScoMX8ScrAT4ScrAZ8ScrLZ8ScrLkvScvDb8ScvLf8ScvNToSgrFZrShvKnrSloHUoSloLnrSlrMXoSl8HgrSmrJUoSn3BX6", "ATFlOn3ATLgrDYAT4MTAnAT8LTMnAYJnRTrAbGgJnrAbLV8LnAbvNTAnAeFbLg3AgOYMXoAlQbFboAnDboAfAnJgoJTBToDgAnBUJbAl3BboDUAnCTDlvLnCTFTrSnCYoQTLnDTwAbAnDUDTrSnDUHgHgrDX8LXFnDbJXAcrETvLTLnGTFTQbrGTMnGToGT3DUFbGUJlPX3GbQg8LnGboJbFnGb3GgAYGgAg8ScGgMbAXrGgvAbAnGnJTLnvGnvATFgHTDT6ATHTrDlJnHYLnMn8HZrSbJTHZ8LTFnHbFTJUoHgSeMT8HgrLjAnHgvAbAnHlFUrDlHnDgvAnHnHTFT3HnQTGnrJTAaMXvJTGbCn3JTOgrAnJXvAXMnJbMg8SnJbMnRg3Jb8LTMnJnAl3OnJnGYrQlJnJlQY3LTDlCn3LTJjLg3LTLgvFXLTMg3GTLV8HUOgLXFZLg3LXNXrMnLX8QXFnLX9AlMYLYLXPXrLZAbJU8LZDUJU8LZMXrSnLZ$AgFnLaPXrDULbFYrMnLbMn8LXLboJgJgLeFbLg3LgLZrSnLgOYAgoLhrRnJlLkCTrSnLkOnLhrLnFX%AYLnFZoJXLnHTvJbLnLloAbMTATLf8MTHgJn3MTMXrAXMT3MTFnMUITvFnMXFX%AYMXMXvFbMXrFTDbMYAcMX3MbLf8SnMb8JbFnMgMXrMTMgvAXFnMgvGgCmMnAloSnMnFnJTrOXvMXSnOX8HTMnObJT8ScObLZFl3ObMXCZoPTLgrQXPUFnoQXPU3RXJlPX3RkQXPbrJXQlPlrJbFnQUAhrDbQXGnCXvQYLnHlvQbLfLnvRTOgvJbRXJYrQlRYLnrQlRbLnrQlRlFT8JlRlFnrQXSTClCn3STHTrAnSTLZQlrSTMnGTrSToHgGbSTrGTDnSTvGXCnST3HgFbSU3HXAXSbAnJn3SbFT8LnScLfLnv", "AT3JgJX8AT8FZoSnAT8JgFV8AT8LhrDbAZ8JT8DbAb8GgLhrAb8SkLnvAe8MT8SnAlMYJXLVAl3GYDTvAl3LfLnvBUDTvLl3CTOn3HTrCT3DUGgrCU8MT8AbCbFTrJUoCgrDb8MTDTLV8JX8DTLnLXQlDT8LZrSnDUQb8FZ8DUST4JnvDb8ScOUoDj6GbJl4GTLfCYMlGToAXvFnGboAXvLnGgAcrJn3GgvFnSToGnLf8JnvGn#HTDToHTLnFXJlHTvATFToHTvHTDToHTvMTAgoHT3STClvHT4AlFl6HT8HTDToHUoDgJTrHUoScMX3HbRZrMXoHboJg8LTHgDb8JTrHgMToLf8HgvLnLnoHnHn3HT4Hn6MgvAnJTJU8ScvJT3AaQT8JT8HTrAnJXrRg8AnJbAloMXoJbrATFToJbvMnoSnJgDb6GgvJgDb8MXoJgSX3JU8JguATFToJlPYLnQlJlQkDnLbJlQlFYJlJl8Lf8OTJnCTFnLbJnLTHXMnJnLXGXCnJnoFfRg3JnrMYRg3Jn3HgFl3KT8Dg8LnLTRlFnPTLTvPbLbvLVoSbrCZLXMY6HT3LXNU7DlrLXNXDTATLX8DX8LnLZDb8JU8LZMnoLhrLZSToJU8LZrLaLnrLZvJn3SnLZ8LhrSnLaJnoMT8LbFlrHTvLbrFTLnrLbvATLlvLb6OTFn3LcLnJZOlLeAT6Mn4LeJT3ObrLg6LXFlrLhrJg8LnLhvDlPX4LhvLfLnvLj6JTFT3LnFbrMXoLnQluCTvLnrQXCY6LnvLfLnvLnvMgLnvLnvSeLf8MTMbrJn3MT3JgST3MT8AnATrMT8LULnrMUMToCZrMUScvLf8MXoDT8SnMX6ATFToMX8AXMT8MX8FkMT8MX8HTrDUMX8ScoSnMYJT6CTvMgAcrMXoMg8SToAfMlvAXLg3MnFl3AnvOT3AnFl3OUoATHT8OU3RnLXrOXrOXrSnObPbvFn6Og8HgrSnOg8OX8DbPTvAgoJgPU3RYLnrPXrDnJZrPb8CTGgvPlrLTDlvPlvFUJnoQUvFXrQlQeMnoAl3QlrQlrSnRTFTrJUoSTDlLiLXSTFg6HT3STJgoMn4STrFTJTrSTrLZFl3ST4FnMXoSUrDlHUoScvHTvSnSfLkvMXo", "AUoAcrMXoAZ8HboAg8AbOg6ATFgAg8AloMXoAl3AT8JTrAl8MX8MXoCT3SToJU8Cl8Db8MXoDT8HgrATrDboOT8MXoGTOTrATMnGT8LhrAZ8GnvFnGnQXHToGgvAcrHTvAXvLl3HbrAZoMXoHgBlFXLg3HgMnFXrSnHgrSb8JUoHn6HT8LgvITvATrJUoJUoLZrRnvJU8HT8Jb8JXvFX8QT8JXvLToJTrJYrQnGnQXJgrJnoATrJnoJU8ScvJnvMnvMXoLTCTLgrJXLTJlRTvQlLbRnJlQYvLbrMb8LnvLbvFn3RnoLdCVSTGZrLeSTvGXCnLg3MnoLn3MToLlrETvMT8SToAl3MbrDU6GTvMb8LX4LhrPlrLXGXCnSToLf8Rg3STrDb8LTrSTvLTHXMnSb3RYLnMnSgOg6ATFg", "HUDlGnrQXrJTrHgLnrAcJYMb8DULc8LTvFgGnCk3Mg8JbAnLX4QYvFYHnMXrRUoJnGnvFnRlvFTJlQnoSTrBXHXrLYSUJgLfoMT8Se8DTrHbDb", "AbDl8SToJU8An3RbAb8ST8DUSTrGnrAgoLbFU6Db8LTrMg8AaHT8Jb8ObDl8SToJU8Pb3RlvFYoJl"];
  var codes = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*";
  function getHangul(code) {
    if (code >= 40) {
      code = code + 168 - 40;
    } else if (code >= 19) {
      code = code + 97 - 19;
    }
    return (0, index_js_2.toUtf8String)(new Uint8Array([225, (code >> 6) + 132, (code & 0x3f) + 128]));
  }
  var _wordlist = null;
  function loadWords() {
    if (_wordlist != null) {
      return _wordlist;
    }
    var wordlist = [];
    data.forEach(function (data, length) {
      length += 4;
      for (var i = 0; i < data.length; i += length) {
        var word = "";
        for (var j = 0; j < length; j++) {
          word += getHangul(codes.indexOf(data[i + j]));
        }
        wordlist.push(word);
      }
    });
    wordlist.sort();
    // Verify the computed list matches the official list
    /* istanbul ignore if */
    var checksum = (0, index_js_1.id)(wordlist.join("\n") + "\n");
    /* c8 ignore start */
    if (checksum !== "0xf9eddeace9c5d3da9c93cf7d3cd38f6a13ed3affb933259ae865714e8a3ae71a") {
      throw new Error("BIP39 Wordlist for ko (Korean) FAILED");
    }
    /* c8 ignore stop */
    _wordlist = wordlist;
    return wordlist;
  }
  var _wordlist2 = null;
  /**
   *  The [[link-bip39-ko]] for [mnemonic phrases](link-bip-39).
   *
   *  @_docloc: api/wordlists
   */
  var LangKo = /*#__PURE__*/function (_wordlist_js_1$Wordli) {
    /**
     *  Creates a new instance of the Korean language Wordlist.
     *
     *  This should be unnecessary most of the time as the exported
     *  [[langKo]] should suffice.
     *
     *  @_ignore:
     */
    function LangKo() {
      _classCallCheck(this, LangKo);
      return _callSuper(this, LangKo, ["ko"]);
    }
    _inherits(LangKo, _wordlist_js_1$Wordli);
    return _createClass(LangKo, [{
      key: "getWord",
      value: function getWord(index) {
        var words = loadWords();
        (0, index_js_2.assertArgument)(index >= 0 && index < words.length, "invalid word index: ".concat(index), "index", index);
        return words[index];
      }
    }, {
      key: "getWordIndex",
      value: function getWordIndex(word) {
        return loadWords().indexOf(word);
      }
      /**
       *  Returns a singleton instance of a ``LangKo``, creating it
       *  if this is the first time being called.
       */
    }], [{
      key: "wordlist",
      value: function wordlist() {
        if (_wordlist2 == null) {
          _wordlist2 = new LangKo();
        }
        return _wordlist2;
      }
    }]);
  }(wordlist_js_1.Wordlist);
  langKo.LangKo = LangKo;
  return langKo;
}

var langIt = {};

var hasRequiredLangIt;
function requireLangIt() {
  if (hasRequiredLangIt) return langIt;
  hasRequiredLangIt = 1;
  Object.defineProperty(langIt, "__esModule", {
    value: true
  });
  langIt.LangIt = void 0;
  var wordlist_owl_js_1 = /*@__PURE__*/requireWordlistOwl();
  var words = "0torea noica!iosorolotaleratelanena%oiadoencotivomai t ca%a0A]Bagl'Bin#E.Is(Oli!Rasi_Rog#0Cade!C[$Cus#E <Hil,I@QuaReRil>Roba+U 0Ag'Deb{DomeEgu#Eri!IpeOtt&Ul&1Fabi,Fe|Fis(F-n Oris`O(R~$0AveEn.E_,Ganc'I!It&OnismoR>*Rume Uzzo4AbardaA Bat)Ber#BoBumeCeCol>E|<FaGeb-Ian.IbiIm[ Lag#Leg)Lie_Lo@/Lusi_Me$Oge$Pa}Pest!Ta,=Ter$T%c'T)veUn$Veo*Z&0Alga`Ani+A!=B{Br#EbaEr~E^s+I]Mas(M[daMir&Mon{O!P'Pli&U, 0A}r@Ag-feAlis+Arch?At-CaCel/Co-D&D!aEl*Ge*Gol&Gus I`Neg&Nid#NoNunc'OnimoT%ipoZi1At>Ertu-OdePari!Pe^ Pogg'P)@Pun Ri,1Ab~AchideAgos+Ald~Anc'Atu-AzzoBit)Chiv'D{Eni,G[ Gi<Gu IaMon?NeseRed#RingaRos S[>SoTef%eZil*0Ciu|Col EpsiEtt>Fal I$O/Pir#P)Sagg'SeSolu Sur@TaT[u T%eT-|0Av>EismoOm>O$TesaTiv&Tor$Tr{Tua,0Sil'Str?Tis+To$moTun$0Anz#E!V[i!Vi(Volge!3Io<O ZimoZur):Be,C}$Ci$CoDessaDi/+Gn#I+L]<L@Le=L/+Lza$Mbi$Ndi!RaondaRba)R}R{$RlumeRoc]Sil>S(Tos+Ttu U,VaVosa3C]FfaLg'LvaNdaNe_,Nig$Nzi=ReRli=Ta3Bi+CiDo<Fi@GaLanc?MboNo]*O*goPedePol&Rban.R-S]|Ses S$n$Son.SturiZzar)2An@At+2Ll{Nif>R@S]Tan>T^$Zzo*2Acc'AdipoA`An}Avu-E.l/Eve|EzzaIgl?Il/n.Ind&Oc]*O@Onzi=Ul*U$2Bbo<CaDi$Ffo<IoLboO$R*<R-s}S(/S+:De|Du]La`)L]*LesseLib)LmoLor?MbusaMe-+M%?Mmi$Mo/Mpa,NapaNde/NeNi$No|N^=PacePel*P{*Pogi)Ppe)P-Psu/RapaceR}ssaR@Ris`Rova=R!|R li=Sacc'S}+Ser`SoS(<S.l*Sua,Tas+Te=T-meU Vil*3Dibi,D-+Fa*Leb!Llul&NaNo<N.simoRam~Rc&R RumeRvel*So?SpoTo2E/Ia)Ic}Iede!Ime-I=IrurgoI+r-0AoClismoFr&G$Lind)O|*R}R)siTr>T+di$UffoVet+Vi,2Ass>In~O)2C]Dar@D%eE!n.G$meLl&Lm#Lo!Lpo(L^v#LzaMaMe+M`n@Mo@Mpu.rMu<Nci(Ndur!Nfer`Ngel&NiugeN<s(Nosce!NsumoN^nuoNveg$Per P'<Pp?Pr~poRazzaRda+R%#Rn%eRol/RpoR!@Rs?R.seSm>S+n.Ttu-V#2A.!Avat+E#Ede!Emo(Esci+E+Ice I=,IsiIt>OceO=}Os++Uc?,Us}2Ci!Cu*Gi$Ll#Po/R#!R(!R_Sci$S de:DoI$L`+Meri$Nie/N$(Nz&T#Van^Vve)3Bu|C[n'Ci(Cli$Col*C! D%#Fin{FormeG$Leg&Lfi$Lir'L+M[zaNot#Nt)Pos{Rapa+Riv&RogaScri|Ser Sider'Sume!Tersi_Vo 3Amet)Cemb!Ed)Fe(Ffu(Geri!Gi+,Luv'Nam>N=nziPin P*`Po*Rad&ReRo|RupoSag'Sc! Sf&Sge*Spos S+nzaSu`$ToVa$Vel Vide!Vor#5B*<C[.Ga=,G`LceM#M[~Min&N@*NoRmi!TeT !Vu Zzi=2AgoUi@2Bb'Bit&Ca,NaOmoPl%eRatu):0A$0Ces(CoLissiO$m?0E-I]/I,I r?Uc&2Emon?LiOismoReg'4Abor#Argi!Egan.Enc#E|Ev&F>I}MoSaU(0An#B,`Es(I)O^_Oz'<Pir>U*0Dem>Du)Erg?FasiO.}Tr&Zi`1A^.I*goI(d'O},Pu!0U#!0Ar'BaBo(EdeEmi+Ige!Met>OeOsi_Ran.0Ago$AmeAnimeAudi!CaEmp'Erc{Ib{Ig[.Is.!I OfagoOrt#O(Pan(P!s(S[zaSoTe(Tim&Ton?T)(Ult&0Il>N>Rus]To0ClideoRopa0A(Id[zaIt#Olu Viva:Bbr~Cc[daChi)L]Migl?Na,Nfa-NgoN+s`ReRfal/Ri$(R`]Sc?S (Sul*T%&ToVo*(3Bb!Co/DeG#LpaLt)Mmi=Nde!Nome$Rm[ R)R^,Ssu-S^_T+U@3AbaDuc?FaGur#LoNanzaNest-Ni!O!S},S>Ume2A]<Am[]EboEm`Ori@U[.Uo)2B>Cacc?Co(Der#Gl'La+Lc*!Lgo!Nd[.Net>N?N+=Rb{Rchet+Res+Rm~R='RoR.zzaRz&Sf#S(2A}s(A=Assi$A.l*Eccet+E=+Es]IgoOlli$OndeUga,Ut+2Ci/+Cs?Gg[.Lmi<L_Man.Me|Mo(NeNz'<O]RboRgo<Ro!SoTi,:Bb?$FfeLa.oLli=LoppoMbe)M`Ranz?RboRofa$Rzo<S@|Sol'Str>T Ud'ZeboZzel/3CoLa^=L(Mel*Mm#NeN{!N='No^poRgo2Epar@Iacc'Isa0Al*LdaNep)Oc&Oiel*Or$OveR#Ro<T++Udiz'Ur#Us 2Obu*U^<1Omo0BbaLfM{Mmo<Nf'N=Ver$2Aci,A@Af>AmmoAndeAtt&A_(Az?E}EggeIfo<Ig'InzaOt+Uppo2Adag$A'An Ard&FoId&::0Ern#0O=0Ent>Ill'O*RaR>Roge$2Ie<Na)Nor#4A!Le(Log>Lude!0Bal*Bevu Boc]Bu Ma<Mer(Mol#Pac]Pe PiegoPor P)n+0Al&Arc&At^_Can C[d'Chi$Cisi_Clu(Cont)C)c'CuboDagi<D?Do,Ed{Fat^Fil&Fli|Gagg'Geg$G,seGor@G)s(Nes]O@!Oltr&Ond#Sa$Se|SiemeSonn?Suli=Tas#Te)To=]Tu{Umidi!Vali@VeceV{1Erbo,Not>O.siP~1IdeLandaOn>Rig#Ror&0Ol#O poTer>Titu Tr%e0Al?Er&:::Bb)Birin C}Cer#Cri`Cu=D@veGoMpoNcet+N.r=R@(RgaRingeSt-T[zaTi$TtugaVag=Vo)3Ga,Gge)MboN.zzaNzaO<P!Si_Ss#S T.-,VaVig#3Be)DoEv{L/Matu-Mit&Mpi@Ne&NguaQui@RaR~S}TeTig'V!a5CandaDeG~Mb&Nd-Nge_QuaceR[zoToT.r?5CeCid#Ma}Mi$(NgoPoPpo*SingaS(T :Cab)Cchi=Ce)Cin#Da`G>Gl?G<.G)Iol~LafedeLg-@Lin.(Lsa$L Lumo!NaNc?N@r/Ngi&Nifes N=)Nov-NsardaN^deNubr'PpaR#=Rci!Ret+RmoRsup'Sche-Ssa?S^$Te-s(Tr>/T <Tu)Zur}3And)C}n>Ce=.DesimoDit&GaLassaLisLod?NingeNoN(/Rcur'R[daR*Schi$SeSse!S *Tal*To@T.!3Agol&CaCel'Che,C)boDol*E,Gl'!La$Li.MosaNe-,NiNo!Ri$R^l*Sce/SsivaS Sur&TezzaTig&T-T.n.4Emon>0Del*Dif~Du*Ga$G'LeLos(Nas.)N]Ndi=Ne+r'Ni,No $N(<Nt#Nvi(RaRde!Rs%#St)Tiv#TosegaT V[zaVim[ Zzo5C}CosaFfaGhe|G='La|Li<l*L^p*Mm?N Ove!Ra,SaS]*S~Te_,To:BabboF+Nomet)Rci(R%eRr#Sce!Str&Tu-,Ut~Vigl'3Bu*saC)siGa^_Goz'Mme$Ofi+Re|R_Ssu$Ttu$Ut-,VeV)t>3Cch?NfaTi@5Bi,Ci_DoMeMi=Rd>R`,RvegeseSt-$T&Tiz?Ttur$Vel/5C,oL/Me)O_Tri!Vo/Z?,:Si0Bedi!BligoElis]L'O*So, 0Cas'<Ch'Cid[.Cor!!Cult&RaUl#0Ier$Or&1Fer+Fri!Fusc#0Ge|GiNu$4AndeseFa|I#IvaOg-m`T!0Agg'Bel>B-EgaIss'<0Do(E!IceNi_)O!_,Ta1Er#In'<Pos 1A]*AfoDi<Ecchi$Ef%eFa$Gan>Igi<Izzon.MaMegg'Na^_O*g'R[@Ribi,T[s?T~Za+Zo0A!Cur&MosiPeda,Pi.SaSid&Ta]*Te0I.ReTago$TimoTob!1A,EstI$Ipa)Oc{UnqueVi&3Io:Cche|CeCif>Del/D)<EseGaGi=Lazzi=Les&Lli@LoLudeN@)N<l*O*O=zzoPr~Rabo/Rcel/Re!Rgo*RiRl#Ro/R^!Rv[zaRz?,Ssi_St%}Tac}To*g?TtumeVo<3Cc#Dal&Do=,Gg'Lo(N&Nd%eNi(/Nnu Nomb-Ns&N /PePi+Rbe<R]r(R@n#Rfor&Rgame=R'@Rmes(R$Rp,s(Rsua(Rtug'Rva(S#!Sis+SoS^fe)Ta*T^<Tu/n.Zzo3Ace!An+At^$Cci$CozzaEgaEt-Ffe)G?`Gol'G)LaLife)L*/Lo+Mpan.Ne+N=No*Ogg?OmboRamideRet>Ri.RolisiTo<Zz>2AceboAn&As`A+$E=r'2ChezzaDe)(DismoEs?Ggi&L[+Ligo$Ll%eLmoni.Lpet+L(Lt)=Lve!M%eMo@)N.Po*(Rfi@Ro(Rpo-R!R++SaSi^_Sses(Stul#Tass'Te!2AnzoAssiAt~Eclu(Ed~Efis(Egi#Elie_Eme!E$t&Epar#Es[zaE.s Eval(I`IncipeIv#Ob,`Ocu-Odur!OfumoOge|OlungaOmessaO$meOpos+O)gaO.(OvaUd[.Ug=Ur{0Iche1Bbl>D~Gil#G$LceL{Lsan.Nt&PazzoPil/Ro:99Ad)Al]saAsiE!/O+:C]l D@pp'D~,Dun#Ff~GazzoG'<G$Mar)MingoMoNdag'N l&P#Pi=Pp!(Satu-Schi#S[.Sseg=St!l*TaVvedu 3A,Cepi!Cin Clu+Cond{Cupe)Dd{Dime!Gal#Gist)Go/G!s(Laz'<M&Mo N=Pl~Prime!Put&SaSid[.Spon(S+u)TeTi=Tor~T^f~Voc#3Assun Badi!Bel,B!zzoCar~C]Ceve!C%l#Cor@C!du D>*Dur!Fas&F,s(For`Fug'G&Gett#Ghel*Lass#Lev#Ma<!MbalzoMed'Morch'Nasci+N})NforzoN$_Nom#Nsav{N c]Nunc?Nv[i!Par#Petu Pie$Port&P!saPuli!Sa+Sch'ServaSibi,SoSpe|S )Sult#S_l Tar@Teg$Tm>T)_Un'<VaVer(Vinci+Vol Zo`5BaBot>Bus Cc?CoDagg'De!D{!G{Ll'Mant>Mpe!Nz'Sol&SpoTan.Ton@Tu/Vesc'5BizzoBr~GaLli$Mi<Mo)(O*PeSs&St>:B#Bbi&Bot#Go`Las(Ldatu-Lgem`Liv&Lmo<Lo<Lt&Lu L_Pe!Pi@Por{Race$R}smoR S((Telli.Ti-Tol*Tur$Va=V'Zi#0Adigl'AlzoAnc#Ar-At.!Av&End&Irci&Locc#Occi#Rin&Ruffo<Uff&0Ab)(Ad[zaA/Ambi&Anda*Apo/Ar(A.n&Av#El En>Ett)HedaHie=IarpaI[zaInde!IppoI)ppoI_*Ler&Odel/Olp{Ompar Onfor Opri!Or+Os(<OzzeseRibaRoll&Ru^n'Uder?Ul !Uo/U)Us&0Ebit&Ogan&0C}tu-Con@Da$Gg'/G=l#G!g#Gu{Lci#Let^_L/Lvagg'Mafo)Mbr&MeMin#Mp!N(N^!Pol Qu[zaRa+Rb#Re$R'Rp[.R-gl'Rvi!S^=To/T^`=0Ace*Ald&Am#Arzo(At%#E-IdaIl#IngeOc#Oder&OgoOl^!Orz#Ra|Rutt#Ugg{Um&U(0Abel*Arb#Onfi&Orb'Rass#Uar@1Bi*C]meEr-G/G$!L[z'L/baMbo*Mpat>Mul#Nfon?Ngo*Nist)NoN.siNu(idePar'S`S ,Tu#2It+Ogatu-Ove$0Arr{Emor#En^ E-l@IlzoOnt&Ott#Uss#0Elli!Erv#O@0BbalzoBr'C]r(C?,Da,Ffi|G$Ld#L[<Li@L/zzoLoLubi,Lv[.Mat>M`NdaNe|Nnife)Pi!Ppe(P-Rge!Rpas(Rri(R(R.gg'R_l#Spi)S+T^,0AdaAl/Arge!A /Av[ Azzo/EcieEdi!Eg<!E/tu-E-nzaEs(!Ett-,Ezz#IaIgo*(Ill#I$(I-,L[di@Or^_O(RangaRec&Ron#RuzzoUn^$0Uil*0Ad%&O l#1Abi,Ac]AffaAgn&Amp#Ant'Arnu Ase-Atu E*EppaErzoI,|I`IrpeIva,Izzo(On#Or>RappoReg#Ridu*Rozz&Ru|Ucc&UfoUp[@0B[t)C](Do!Gger{GoL+$On&PerboPpor Rgel#R)g#Ssur)Tu-0Ag&EdeseEgl'El&Enu Ez?IluppoIs+Izze-Ol+Uot&:Bac]Bul#Cci&Citur$LeLis`$Mpo<Nni$RaRdi_Rg#RiffaRp&R+rugaS Tt>Ver=Vo/+Zza3CaCn>Lefo$Me-r'MpoMu N@<Ne)Ns'<N+]*O!`RmeR-zzoRze|SiSser#St#T)T ?3F&Gel/Mb)N P>Pog-foRagg'RoTan'To*Tuban.Z'Zzo<5Cc&L,r&L Mbo/MoNfoNsil/Paz'Po*g?PpaRbaRn&R)<R -S}$Ssi!S+tu-Ta$2Aboc]AcheaAfi/Aged?Alc'Amon Ans{Apa$Ar!As*]Att#AveEcc?Emol'Espo*Ibu Iche]Ifogl'Il*InceaIoIs.zzaItur#Ivel/OmbaO$OppoO|/Ov&Ucc#2Batu-Ff#Lipa$Mul Nis?Rb&Rchi$TaTe/:0Ic#0Cel*Ci(!0I!I^_1FaF%'0Ua,4IsseTim#0A$I,Orismo0Ci<|Ge!Ghe!seI]r$If%#I($I+r'Te0Vo0Upa1Aga$G[zaLo0AnzaA C{Ig$*U-'0Ensi,IlizzoOp?:Can.Ccin#Gabon@Gli#LangaLgoL>L,t+Lo)(Lut&L_/Mpa+Ng&N{(NoN+gg'Nve-Po!Ra$Rc#R?n.S}3Det+DovaDu Ge+,I]*Lc)Li=Llu LoceN#Ndemm?N RaceRba,Rgog=Rif~RoRru}Rt~,Sc~Ssil*S+,Te-$Tri=Tus 3Andan.B-n.C[daChingoCi=nzaDim&Gil?G< Go!LeL/$MiniNc{!O/Pe-Rgo/Ro*goRu,n S](S'<SpoSsu Su-TaTel*T^`VandaVi@Zi&5CeGaLa^,Le!LpeRagi<5L}$::::Mpog=N=Pp#T.-Vor-3Fi)Lan.LoNze)Rbi$3Be|N]R]<T 5L/T>5Cche)Fo*LuPpa";
  var checksum = "0x5c1362d88fd4cf614a96f3234941d29f7d37c08c5292fde03bf62c2db6ff7620";
  var _wordlist = null;
  /**
   *  The [[link-bip39-it]] for [mnemonic phrases](link-bip-39).
   *
   *  @_docloc: api/wordlists
   */
  var LangIt = /*#__PURE__*/function (_wordlist_owl_js_1$Wo) {
    /**
     *  Creates a new instance of the Italian language Wordlist.
     *
     *  This should be unnecessary most of the time as the exported
     *  [[langIt]] should suffice.
     *
     *  @_ignore:
     */
    function LangIt() {
      _classCallCheck(this, LangIt);
      return _callSuper(this, LangIt, ["it", words, checksum]);
    }
    /**
     *  Returns a singleton instance of a ``LangIt``, creating it
     *  if this is the first time being called.
     */
    _inherits(LangIt, _wordlist_owl_js_1$Wo);
    return _createClass(LangIt, null, [{
      key: "wordlist",
      value: function wordlist() {
        if (_wordlist == null) {
          _wordlist = new LangIt();
        }
        return _wordlist;
      }
    }]);
  }(wordlist_owl_js_1.WordlistOwl);
  langIt.LangIt = LangIt;
  return langIt;
}

var langPt = {};

var hasRequiredLangPt;
function requireLangPt() {
  if (hasRequiredLangPt) return langPt;
  hasRequiredLangPt = 1;
  Object.defineProperty(langPt, "__esModule", {
    value: true
  });
  langPt.LangPt = void 0;
  var wordlist_owl_js_1 = /*@__PURE__*/requireWordlistOwl();
  var words = "0arad!ototealirertainrasoent hoandoaR#riareha!aroele'oronul0Aca%AixoAl A%rDuz'El]Er$IsmoO$ R<g(Revi Rig Rup$S*$Solu$Sur=Ut[0Ab#Alm Amp Anh A,Ei.El( En ErvoEss E$naHa.IdezImaI}#Irr Lam LiveOlhidaOmod Opl Ord Um~ Us?0Ap.EgaEnt_Ep$Equ Er-%EsivoEusI<%ItivoJetivoJun$M' Or Qu''UboV(,Vog#0R}ave0As.Er'EtivoIn?Iv` Li$Lu-%R}.0Ach Arr As&/Enci Iliz Io)It#O+R! Res%Rup U d Ul]2O`h Ud Us.1AmedaArmeAstr Av<caB(gueB*oCat+De@EcrimEgr@Er.FaceF*e%GumHeioI Ica%I- Inh Ivi Mof^Oc Pis%T( TitudeUc* Ug UnoUsivoVo0Aci A=rA[loAss BasBi-%EixaEniz I=Is$,Iz!eOl?On$ O_,Ost+P  Pli Pola0Ag+maAlis Arqu@A$m@DaimeElExoG~ Im JoOm&@Ot#Sio,T(i|Uid!eUnci Zol1Ag?Alp Anh#EgoEli=Ert^Es Eti%I$Lau,Lic^OioOn.Os)R-dizRov 0Uec(0AmeAn]A+C^D-%E@Ej Eni$Es)Gilo,GolaMaQuivoRai&Reba%Risc Rob>um S-&T(i&TigoVo[=0F&.Il#P' S?S* So&/Sun$Tr&0Ac#Adu+Al/A[f E End(Er_EuIng'Ir?IvoOl{oRac Revi=RizU&Um0Di$rM-.R>o+TismoT|@Tu 0Ali An%Ar@Ent&Es,I?Is Ul,1Ila1Ar E=Ei%Ulejo:B BosaC&]uCh `C@GagemI<oIl I}e)Ir_Ixis)J~ Le@LizaLsaN&Nd{aN/N'Nque%Ra$Rb#R}es>+c>~/Se#S)n%Ta)Te=rTidaTomTuc Unil]3B(IjoIr^IsebolLd!eLezaLgaLisc Ndi$Ng&aNz(RimbauRl*d>_Sou_XigaZ(_3CoCu=En&Foc&Furc G|naLhe%Mest[Mo$rOlog@OmboOsf(aPol Rr-$Scoi$Sne$SpoSsex$TolaZ _2Ind#OcoOque 2A$BagemC#CejoChec]Ico.L^LetimL]LoMb{oNdeNecoNi)Rb~h>d>e&R+c]V*oXe?2AncoAsaAvezaEuIgaIl/Inc OaOchu+Onze O$Uxo2C]DismoF LeRacoScaS$Z*a:B<aB`oBideBoBri$CauCet^C/r_CiqueDast_De#Fez&IaqueIp'aIxo%J#JuLafrioLc~ Ld{aLibr Lm<%Lo)M^Mbis)MisaMomilaMp<]Mufl Navi&Nc` Ne)NguruN/$Nive%NoaNs#N.Nu=Pac/P`aP* Po.Pric/Pt?PuzRacolRb}oRde&Rec>imb Rn{oRpe%R['>)zRv&/SacoScaSeb[S%loS~oT a)Tiv UleUs?U%l V&oV(na3BolaDil]G}]Lebr L~ Nou+N,N%ioRc Rr#R%'oRvejaTimV^2Aco)Al{aAm#Ap^ArmeAticeAveEfeEg^E'oEqueIco%If[In`oOc&/Ov(UmboU.Uva0CatrizCl}eD!eD['aEn%G<aM-$N$Nz><d>cui$Rurg@T 2A[zaE_Ic OneUbe2A=Ag'Ba@B($rBr C^El/Ent_E,Gum`oIb'IfaIo%L L{aLh(Lid'Lme@L}oLunaM<=Mb* M-.MitivaMov(MplexoMumNc]N=rNec.Nfu,Ng` Nhec(Njug Nsum'Nt+$Nvi%Op( P{oPi?PoQue%lRagemRdi&Rne)R}h>p|&R[ioR%joRuj>voSs-oS%laT}e%U_UveVilZ*]2A%+AvoEcheE=rEmeErEspoI^Im*&Io~oIseItic Os)UaUz{o2B<oEcaId#JoLat+Lm* Lp Ltu+Mpr'Nh#Pi=RativoRr&Rs R$Sp'S% T`o:MascoT 3Ba%rBi.BocheB~h C&queCim&CliveCo%C[.D&Dic#Duz'FesaFum G`oG+uGus.It#Ix La$rLeg#L*e L}gaM<daMit'Moli=Ntis)P-#Pil PoisP[ssaPur Riv>+m SafioSbo.Sc<,S-/Sfi#Sgas%Sigu&SlizeSmam SovaSpesaS)queSvi T&h T-$rT} Tri$UsaV(Vi=Vot#Z-a3Ag+maAle$Da)Fu,Gi.Lat#Lu-%M*u'Nast@Nh{oOceseRe$Sc[)Sf ceSp oSque%Ssip S)n%T?UrnoV(,Vi,rV~g Z(5Br?L|i=M?M*#NativoNz`>m-%Rs&SagemUr#U$r2EnagemIbleOg @2El EndeE$PloQues><%Vi=,:1Lod'O Olog@0Ific It&Uc#1Ei$Etiv 3E.1Ab| Eg(Ei$rEncoEv?Im* Ogi 0B goBol#Br~/Buti=EndaErg'Is,rPat@P-/P*#Polg P[goPurr Ul?0CaixeC-#Ch-%C}t_Deus Doss Faix Fei%FimGaj#G-/Glob Gom#G+x Gu@Jo La.Qu<$Raiz Rol#Rug SaioSe^S*oSop#T<$Te#Tid!eT|.Tr^T~/V(g Vi#Volv(XameX($Xof[Xu$1Id(me0Uip 0E$Gui=Ra)VaVil]0B<j B`$CamaColaCri)Cu)F*geFol F[g Fum#GrimaM&%P<$P`/PigaP}jaP[i)Pum Qu(daTacaT{aTic Tof#T[laTu=Vazi 0AnolIque)0F|i>opeu0Acu Ap| AsivoEntu&Id-%Olu'1Ag(oAl Am* A$Aus$Ces,Ci.Clam Ecu.EmploIb'Ig-%On( P<d'P`'P' Pl< Pos$P[s,P~s T(noT*$T+$:Bric B~o,Ce)Ci&DaDigaIxaL L)Mili Nd<goNf +N$cheRd#R`oR*h>of>p>tu+T@T|V|i)X*aZ-da3Ch#Ijo^I+n%L*oM**oNdaNoR>i#RrugemRv(S%j T&Ud&3ApoB_seC Ch{oGur#L{aL/LmeLtr RmezaSg^Ssu+TaV`aX?Xo2AcidezAm*goAn`aEch^O+Utu Uxo2C&C*/Foc GoGue%IceLg#Lhe$Rj Rmig>noR%ScoSsa2Aga)AldaAngoAscoA%rnoE'aEn%E.IezaI,Itu+On]Ustr U%'a2G'L<oLigemNd NgoNilR?Rio,Tebol:B i$B*e%DoIa$IolaIvo)LegaL/L*]Loc]Nh RagemRfoRg&oRimpoRoup>+faSodu$S$TaTil/Ve)Z`a3L#Le@LoM^M(Mi=N(o,NgivaNi&NomaN_Ologi>?Rm* S,S$r3Nas)Nc<aNg#Raf>*o2Aci&IcoseOb&Orio,2ElaIabaLfeLpe Rdu+Rje)R_S$,T{aV(n 2AcejoAdu&Afi%Al]AmpoAn^Atui$Ave$AxaEgoElh EveIloIs&/I.@Os,O%scoUd#Unhi=U)2AcheA+niAx*imEr[ I Inc/Is#LaLo,Ru:Bi.Rm}@S%V(3C.eRd Res@Si.3A$B(n D+.EnaNoPismoPnosePo%ca5JeLofo%MemNes$Nr#Rm}&Sped 5M|#:Te2E@O,2N|#RejaU<a4E,HaUdi=Um* Ustr 0AgemEd@$En,ErsivoIn-%It?Ort&Pac$Ped'Pl<%P|Pr-saPuneUniz 0Al?Ap$AtivoC-,Ch Cid'Clu'Col|Deci,D'e$Du$rEficazEr-%F<tilFes.F*i$Flam F|m&F+$rG('Ibi=Ici&ImigoJe.Oc-%O=_Ov?OxQuie$Scri$Se$Sist'Spe$rSt& S~$Tac$Tegr&Tim Toc#TrigaVa,rV(noVic$Voc 0Gur%2Ani<oOniz Re&Rit#0CaEn$Ol#Qu{o0Ali<o:N{oNg^N)R ac>dimR_SmimToV&iZida3Jum9An*]Elh^G?I>n&Rr Vem5BaDeuDocaIzLg?L/R#Ris)RoS)::B edaB|&C[C)n%Dril/G )GoaJeMb(M-.M* MpejoNchePid P,R<j>{>gu+S<]St_T(&Ti=V<daVou+Vr?X<%Z(3Ald!eB[G#G-d Gis)IgoIlo Itu+Mb[%MeNh?Ntil]OaSmaS%TivoT['oV VezaVi.3B(&Bi=D( G G{oMi.Mo{oMp?NdaNe N]gemQuidezS)gemSu+T|&V_XaX{a5C?Cu$rJis)MboNaNgeNt+RdeT#T(@Ucu+UsaUv 5ArCidezC_Ne)St[T?Va:CacoCe%Ch#CioD{aDr*]Gna)G[zaI|IsL<d_L]Lo%LucoMiloMo{oMu%N^Nc]Nda$NequimN/,Niv`aNobr NsaN%rNuse Pe#Qu* Rc?Resi>fimRgemR*/Rmi)Ro$RquiseR[coR%loRujoSco%Sm|+SsagemStig Tag&T(noT*&Tu.Xil 3D&]DidaDusaGaf}eIgaL<c@L/rMb_M|i&N*oNosNsagemNt&Rec(Rg~/S^Scl SmoSqui)St[T!eTeo_T+gemX(Xic<o3C_G&]Gr Lag[L- Lh M#N( N/caNist_N|@OloR<%RtiloStur 5Cid!eD(noD~ EdaErIn/I)Ldu+LezaL/L*e%LuscoN)n]Quec><goRcegoR=moR-aSaicoSque%S.daT`TimToTriz5DaI$La)Lh(L.Ndi&Ni=R&h>c/Sc~ SeuSic&:Ci}&D?JaMo_R*>r#Sc(TivaTu[zaV&]Veg Vio3Bl*aB~o,GativaGoci Gri$Rvo,TaUr&VascaVo{o3N N/TidezV` 5B[zaI%IvaMe M*&Rdes%R% T Tici TurnoV`oVil/Vo5Bl#DezM(&Pci&Tr'Vem:0Cec#Edec(JetivoRig#Scu_S%t+T(Tur 0Id-%Io,Orr(Ulis)Up#2Eg<%EnsivaEr-daIc*aUsc#0Iva4Ar@Eo,H Iv{a0B_Ele%Is,It'0D~#E_,Tem1Ci}&Er?On-%OrtunoOs$1ArBi.DemD*&F<a$GasmoG~/I-t&IgemIun=LaTo=xoV&/0Cil S^SoT-.0Imismo0S!@T}oTub_Vi=0El]Ul 1Id Ig- :Ca$Ci-%Co%Ctu D @Dr*/G GodeIn`Ir IsagemLav+Lest+Lhe)Li$Lm^Lpi.Nc^N`aNfle$NquecaN)n&PagaioP`^P'oRaf*>ci&Rd&RedeRtidaSmoSs#S%lTam T-%T* T_noUl^Us 3C~i D& Dest[D@t+D+G^I$r&IxeLeLic<oNcaNdur N{aN]scoNs?N%Rceb(Rfei$Rgun)Ri$Rmit'Rn>plexoRsi<>%nceRucaSc#SquisaS,aTisc 3AdaC#Ed!eGm-$Last+Lh#Lo.M-)Nc`NguimN]No%N.On{oPocaQue%R<h>esRue)Sc S$laT<gaVe%2An)Aque)At*aEbeuUmagemUvi&1Eu0DaE'aEtisaLeg^Lici Lu-%Lvil/M MbaNd( N.@P~o,R)Ssu'St&TeUp U,Vo 2A@Anc]A$AxeEceEd?Efei$Emi Ens Ep  Esil]E%x$Ev-'Ez Ima)IncesaIsmaIv#Oces,Odu$Ofe)Oibi=Oje$Ome%rOpag OsaO%$rOv?2Blic DimL Lm} Ls{aNh&N'PiloRezaX?:99Ad+Ant@Ar$AseEbr EdaEijoEn%Eri=Im}oInaIosque:B<^BiscoCh Ci} Di&I In]IoIvaJ^L#M&Ng(Nhu+P!u+P`PidezPosaQue%Rid!eS<%Scun/Sg Sp?S%'aSur Taz<aTo{a3AlezaAnim Av(Baix B`deBol C#C-%CheioCiboC|d Cru.Cu DeDim'D}daDuzidaEnvioF* Flet'Fog F[scoFugi G&@GimeG+In#I$rJei.LativoM?M-=M|,Nov#P oP`'Ple$Pol/P[saPudi Qu((S-]Sfri Sga.Sid'Solv(Spei$SsacaS)n%Sum'T&/T(T' Tom^T+.V` Vi,rVol)3Ac/CaGidezGo_,M NgueS^ScoS}/5B&oChe=D^DeioDov@E=rLe)M<oNc S#S{aS$TaT{oT*aT~ UcoUpaXo5B_Gi=Go,IvoMoPest[S,:B|Ci ColaCud'DioF'aGaGr^Ib_L^L{oLg#LivaLpic Lsic]L.Lv?Mb Mu+iN Nf}aNgueNid!ePa$Rd>g-$Rje)Tur Ud!eXof}eZ}&3C C~ DaD-$Di#Do,Du$rGm-$G[=Gun=IvaLe$LvagemM<&M-%N?N/rNsu&Nt#P #Rei>*g>+RvoTemb_T|3GiloLhue)Lic}eMetr@Mpat@M~ N&Nc(oNg~ NopseN$ni>-eRiTu#5B(<oB+C|_G_JaLdaLetr L%'oMbrioNa)Nd Neg Nh?NoP+noQue%Rr'R%ioSsegoTaqueT(r V#Z*/5Aviz BidaBm(,B,loBt+'Ca)Ces,CoDes%FixoG?G('Jei$Lfa$M'OrP(i|Plic Pos$Prim'Rd*>fis)Rp[s>[&Rt'Sp'oS%n$:B`aBle%Bu^C/G `aLh(LoLvezM</Mb|imMpaNg-%N$P Pioc>dioRef>j>+xaTuagemUr*oXativoXis)3Atr&C(Ci=Cl#Dio,IaIm Lef}eLh#Mp(oN-%N,rN.Rm&RnoRr-oSeSou+St#ToXtu+Xugo3A+G`aJoloMbr MidezNgi=N%'oRagemT~ 5Al]C]L( LiceM^Mil/N`Ntu+Pe%R>ci=RneioRqueRr!>$S.UcaUp{aX*a2Ab&/Acej Adu$rAfeg Aje$AmaAnc ApoAs{oAt?Av E*oEm(Epid EvoIagemIboIcicloId-%Ilog@Ind!eIploItur Iunf&Oc Ombe)OvaUnfoUque2B~ C<oDoLipaPiRboRm>quesaT` T|i&:7V 3Bigo0HaId!eIf|me3Olog@SoTigaUbu0A=InaUfru':C*aDi G o,I=,LaL-%Lid!eLo[sN)gemQu{oR<d>e)Rr(Sc~ Sil]S,u+Z Zio3A=D Ge.Ic~ L{oLhiceLu=Nce=rNdav&N( Nt[Rb&Rd!eRe?Rg}h>m`/RnizRs R%n%SpaSti=T|i&3Adu$AgemAj Atu+Br?D{aDr @ElaGaG-%Gi G| L ejoNcoNhe)NilOle)R!>tudeSi.S$Tr&V{oZ*/5A=rArG&L<%LeibolL)gemLumo,Nt!e5L$Vuz`a::D[zRope3QueRe.Rife3Ng ::Ng#Rp 3BuL?9Mb Olog@5Mbi=";
  var checksum = "0x2219000926df7b50d8aa0a3d495826b988287df4657fbd100e6fe596c8f737ac";
  var _wordlist = null;
  /**
   *  The [[link-bip39-pt]] for [mnemonic phrases](link-bip-39).
   *
   *  @_docloc: api/wordlists
   */
  var LangPt = /*#__PURE__*/function (_wordlist_owl_js_1$Wo) {
    /**
     *  Creates a new instance of the Portuguese language Wordlist.
     *
     *  This should be unnecessary most of the time as the exported
     *  [[langPt]] should suffice.
     *
     *  @_ignore:
     */
    function LangPt() {
      _classCallCheck(this, LangPt);
      return _callSuper(this, LangPt, ["pt", words, checksum]);
    }
    /**
     *  Returns a singleton instance of a ``LangPt``, creating it
     *  if this is the first time being called.
     */
    _inherits(LangPt, _wordlist_owl_js_1$Wo);
    return _createClass(LangPt, null, [{
      key: "wordlist",
      value: function wordlist() {
        if (_wordlist == null) {
          _wordlist = new LangPt();
        }
        return _wordlist;
      }
    }]);
  }(wordlist_owl_js_1.WordlistOwl);
  langPt.LangPt = LangPt;
  return langPt;
}

var langZh = {};

var hasRequiredLangZh;
function requireLangZh() {
  if (hasRequiredLangZh) return langZh;
  hasRequiredLangZh = 1;
  Object.defineProperty(langZh, "__esModule", {
    value: true
  });
  langZh.LangZh = void 0;
  var index_js_1 = /*@__PURE__*/requireHash();
  var index_js_2 = /*@__PURE__*/requireUtils$3();
  var wordlist_js_1 = /*@__PURE__*/requireWordlist();
  var data = "}aE#4A=Yv&co#4N#6G=cJ&SM#66|/Z#4t&kn~46#4K~4q%b9=IR#7l,mB#7W_X2*dl}Uo~7s}Uf&Iw#9c&cw~6O&H6&wx&IG%v5=IQ~8a&Pv#47$PR&50%Ko&QM&3l#5f,D9#4L|/H&tQ;v0~6n]nN<di,AM=W5%QO&ka&ua,hM^tm=zV=JA=wR&+X]7P&NB#4J#5L|/b[dA}tJ<Do&6m&u2[U1&Kb.HM&mC=w0&MW<rY,Hq#6M}QG,13&wP}Jp]Ow%ue&Kg<HP<D9~4k~9T&I2_c6$9T#9/[C5~7O~4a=cs&O7=KK=An&l9$6U$8A&uD&QI|/Y&bg}Ux&F2#6b}E2&JN&kW&kp=U/&bb=Xl<Cj}k+~5J#6L&5z&9i}b4&Fo,ho(X0_g3~4O$Fz&QE<HN=Ww]6/%GF-Vw=tj&/D&PN#9g=YO}cL&Of&PI~5I&Ip=vU=IW#9G;0o-wU}ss&QR<BT&R9=tk$PY_dh&Pq-yh]7T,nj.Xu=EP&76=cI&Fs*Xg}z7$Gb&+I=DF,AF=cA}rL#7j=Dz&3y<Aa$52=PQ}b0(iY$Fa}oL&xV#6U=ec=WZ,xh%RY<dp#9N&Fl&44=WH*A7=sh&TB&8P=07;u+&PK}uh}J5#72)V/=xC,AB$k0&f6;1E|+5=1B,3v]6n&wR%b+&xx]7f=Ol}fl;+D^wG]7E;nB;uh^Ir&l5=JL,nS=cf=g5;u6|/Q$Gc=MH%Hg#5d%M6^86=U+$Gz,l/,ir^5y&Ba&/F-IY&FI&be%IZ#77&PW_Nu$kE(Yf&NX]7Z,Jy&FJ(Xo&Nz#/d=y7&MX<Ag}Z+;nE]Dt(iG#4D=13&Pj~4c%v8&Zo%OL&/X#4W<HR&ie~6J_1O(Y2=y5=Ad*cv_eB#6k&PX:BU#7A;uk&Ft&Fx_dD=U2;vB=U5=4F}+O&GN.HH:9s=b0%NV(jO&IH=JT}Z9=VZ<Af,Kx^4m&uJ%c6,6r;9m#+L}cf%Kh&F3~4H=vP}bu,Hz|++,1w]nv}k6;uu$jw*Kl*WX&uM[x7&Fr[m7$NO&QN]hu=JN}nR^8g#/h(ps|KC;vd}xz=V0}p6&FD$G1#7K<bG_4p~8g&cf;u4=tl}+k%5/}fz;uw<cA=u1}gU}VM=LJ=eX&+L&Pr#4U}p2:nC,2K]7H:jF&9x}uX#9O=MB<fz~8X~5m&4D&kN&u5%E/(h7(ZF&VG<de(qM|/e-Wt=3x(a+,/R]f/&ND$Ro&nU}0g=KA%kH&NK$Ke<dS}cB&IX~5g$TN]6m=Uv,Is&Py=Ef%Kz#+/%bi&+A<F4$OG&4C&FL#9V<Zk=2I_eE&6c]nw&kq$HG}y+&A8$P3}OH=XP]70%IS(AJ_gH%GZ&tY&AZ=vb~6y&/r=VI=Wv<Zi=fl=xf&eL}c8}OL=MJ=g8$F7=YT}9u=0+^xC}JH&nL^N0~4T]K2,Cy%OC#6s;vG(AC^xe^cG&MF}Br#9P;wD-7h$O/&xA}Fn^PC]6i]7G&8V$Qs;vl(TB~73~4l<mW&6V=2y&uY&+3)aP}XF;LP&kx$wU=t7;uy<FN&lz)7E=Oo*Y+;wI}9q}le;J6&Ri&4t&Qr#8B=cb&vG=J5|Ql(h5<Yy~4+}QD,Lx=wn%K/&RK=dO&Pw,Q9=co%4u;9u}g0@6a^4I%b0=zo|/c&tX=dQ=OS#+b=yz_AB&wB&Pm=W9$HP_gR=62=AO=ti=hI,oA&jr&dH=tm&b6$P2(x8=zi;nG~7F;05]0n[Ix&3m}rg=Xp=cd&uz]7t;97=cN;vV<jf&FF&F1=6Q&Ik*Kk&P4,2z=fQ]7D&3u,H0=d/}Uw<ZN<7R}Kv;0f$H7,MD]7n$F0#88~9Z%da=by;+T#/u=VF&fO&kr^kf<AB]sU,I5$Ng&Pz;0i&QD&vM=Yl:BM;nJ_xJ]U7&Kf&30,3f|Z9*dC)je_jA&Q4&Kp$NH(Yz#6S&Id%Ib=KX,AD=KV%dP}tW&Pk^+E_Ni=cq,3R}VZ(Si=b+}rv;0j}rZ]uA,/w(Sx&Jv$w9&4d&wE,NJ$Gy=J/]Ls#7k<ZQ<Y/&uj]Ov$PM;v3,2F&+u:up=On&3e,Jv;90=J+&Qm]6q}bK#+d~8Y(h2]hA;99&AS=I/}qB&dQ}yJ-VM}Vl&ui,iB&G3|Dc]7d=eQ%dX%JC_1L~4d^NP;vJ&/1)ZI#7N]9X[bQ&PL=0L(UZ,Lm&kc&IR}n7(iR<AQ<dg=33=vN}ft}au]7I,Ba=x9=dR~6R&Tq=Xi,3d$Nr&Bc}DI&ku&vf]Dn,/F&iD,Ll&Nw=0y&I7=Ls=/A&tU=Qe}Ua&uk&+F=g4=gh=Vj#+1&Qn}Uy*44#5F,Pc&Rz*Xn=oh=5W;0n_Nf(iE<Y7=vr=Zu]oz#5Z%mI=kN=Bv_Jp(T2;vt_Ml<FS&uI=L/&6P]64$M7}86<bo%QX(SI%IY&VK=Al&Ux;vv;ut*E/%uh<ZE|O3,M2(yc]yu=Wk&tp:Ex}hr,Cl&WE)+Z=8U}I2_4Q,hA_si=iw=OM=tM=yZ%Ia=U7;wT}b+;uo=Za}yS!5x}HD}fb#5O_dA;Nv%uB(yB;01(Sf}Fk;v7}Pt#8v<mZ#7L,/r&Pl~4w&f5=Ph$Fw_LF&8m,bL=yJ&BH}p/*Jn}tU~5Q;wB(h6]Df]8p^+B;E4&Wc=d+;Ea&bw$8C&FN,DM=Yf}mP~5w=fT#6V=mC=Fi=AV}jB&AN}lW}aH#/D)dZ;hl;vE}/7,CJ;31&w8,hj%u9_Js=jJ&4M~8k=TN&eC}nL&uc-wi&lX}dj=Mv=e2#6u=cr$uq$6G]8W}Jb:nm=Yg<b3(UA;vX&6n&xF=KT,jC,De&R8&oY=Zv&oB]7/=Z2&Oa}bf,hh(4h^tZ&72&Nx;D2&xL~5h~40)ZG)h+=OJ&RA]Bv$yB=Oq=df,AQ%Jn}OJ;11,3z&Tl&tj;v+^Hv,Dh(id=s+]7N&N3)9Q~8f,S4=uW=w4&uX,LX&3d]CJ&yp&8x<b2_do&lP=y/<cy_dG=Oi=7R(VH(lt_1T,Iq_AA;12^6T%k6#8K[B1{oO<AU[Bt;1b$9S&Ps<8T=St{bY,jB(Zp&63&Uv$9V,PM]6v&Af}zW[bW_oq}sm}nB&Kq&gC&ff_eq_2m&5F&TI}rf}Gf;Zr_z9;ER&jk}iz_sn<BN~+n&vo=Vi%97|ZR=Wc,WE&6t]6z%85(ly#84=KY)6m_5/=aX,N3}Tm&he&6K]tR_B2-I3;u/&hU&lH<AP=iB&IA=XL;/5&Nh=wv<BH#79=vS=zl<AA=0X_RG}Bw&9p$NW,AX&kP_Lp&/Z(Tc]Mu}hs#6I}5B&cI<bq&H9#6m=K9}vH(Y1(Y0#4B&w6,/9&gG<bE,/O=zb}I4_l8<B/;wL%Qo<HO[Mq=XX}0v&BP&F4(mG}0i}nm,EC=9u{I3,xG&/9=JY*DK&hR)BX=EI=cx=b/{6k}yX%A+&wa}Xb=la;wi^lL;0t}jo&Qb=xg=XB}iO<qo{bR=NV&8f=a0&Jy;0v=uK)HK;vN#6h&jB(h/%ud&NI%wY.X7=Pt}Cu-uL&Gs_hl%mH,tm]78=Lb^Q0#7Y=1u<Bt&+Q=Co_RH,w3;1e}ux<aU;ui}U3&Q5%bt]63&UQ|0l&uL}O7&3o,AV&dm|Nj(Xt*5+(Uu&Hh(p7(UF=VR=Bp^Jl&Hd[ix)9/=Iq]C8<67]66}mB%6f}bb}JI]8T$HA}db=YM&pa=2J}tS&Y0=PS&y4=cX$6E,hX,XP&nR;04,FQ&l0&Vm_Dv#5Y~8Z=Bi%MA]6x=JO:+p,Az&9q,Hj~6/}SD=K1:EJ}nA;Qo#/E]9R,Ie&6X%W3]61&v4=xX_MC=0q;06(Xq=fs}IG}Dv=0l}o7$iZ;9v&LH&DP-7a&OY,SZ,Kz,Cv&dh=fx|Nh,F/~7q=XF&w+;9n&Gw;0h}Z7<7O&JK(S7&LS<AD<ac=wo<Dt&zw%4B=4v#8P;9o~6p*vV=Tm,Or&I6=1q}nY=P0=gq&Bl&Uu,Ch%yb}UY=zh}dh}rl(T4_xk(YA#8R*xH,IN}Jn]7V}C4&Ty}j3]7p=cL=3h&wW%Qv<Z3=f0&RI&+S(ic_zq}oN&/Y=z1;Td=LW=0e=OI(Vc,+b^ju(UL;0r:Za%8v=Rp=zw&58&73&wK}qX]6y&8E)a2}WR=wP^ur&nQ<cH}Re=Aq&wk}Q0&+q=PP,Gc|/d^k5,Fw]8Y}Pg]p3=ju=ed}r5_yf&Cs]7z$/G<Cm&Jp&54_1G_gP_Ll}JZ;0u]k8_7k(Sg]65{9i=LN&Sx&WK,iW&fD&Lk{9a}Em-9c#8N&io=sy]8d&nT&IK(lx#7/$lW(Td<s8~49,3o<7Y=MW(T+_Jr&Wd,iL}Ct=xh&5V;v4&8n%Kx=iF&l2_0B{B+,If(J0,Lv;u8=Kx-vB=HC&vS=Z6&fU&vE^xK;3D=4h=MR#45:Jw;0d}iw=LU}I5=I0]gB*im,K9}GU,1k_4U&Tt=Vs(iX&lU(TF#7y,ZO}oA&m5#5P}PN}Uz=hM<B1&FB<aG,e6~7T<tP(UQ_ZT=wu&F8)aQ]iN,1r_Lo&/g:CD}84{J1_Ki&Na&3n$jz&FE=dc;uv;va}in}ll=fv(h1&3h}fp=Cy}BM(+E~8m}lo%v7=hC(T6$cj=BQ=Bw(DR,2j=Ks,NS|F+;00=fU=70}Mb(YU;+G&m7&hr=Sk%Co]t+(X5_Jw}0r}gC(AS-IP&QK<Z2#8Q$WC]WX}T2&pG_Ka,HC=R4&/N;Z+;ch(C7,D4$3p_Mk&B2$8D=n9%Ky#5z(CT&QJ#7B]DC]gW}nf~5M;Iw#80}Tc_1F#4Z-aC}Hl=ph=fz,/3=aW}JM}nn;DG;vm}wn,4P}T3;wx&RG$u+}zK=0b;+J_Ek{re<aZ=AS}yY#5D]7q,Cp}xN=VP*2C}GZ}aG~+m_Cs=OY#6r]6g<GS}LC(UB=3A=Bo}Jy<c4}Is;1P<AG}Op<Z1}ld}nS=1Z,yM&95&98=CJ(4t:2L$Hk=Zo}Vc;+I}np&N1}9y=iv}CO*7p=jL)px]tb^zh&GS&Vl%v/;vR=14=zJ&49|/f]hF}WG;03=8P}o/&Gg&rp;DB,Kv}Ji&Pb;aA^ll(4j%yt}+K$Ht#4y&hY]7Y<F1,eN}bG(Uh%6Z]t5%G7;+F_RE;it}tL=LS&Da=Xx(S+(4f=8G=yI}cJ}WP=37=jS}pX}hd)fp<A8=Jt~+o$HJ=M6}iX=g9}CS=dv=Cj(mP%Kd,xq|+9&LD(4/=Xm&QP=Lc}LX&fL;+K=Op(lu=Qs.qC:+e&L+=Jj#8w;SL]7S(b+#4I=c1&nG_Lf&uH;+R)ZV<bV%B/,TE&0H&Jq&Ah%OF&Ss(p2,Wv&I3=Wl}Vq;1L&lJ#9b_1H=8r=b8=JH(SZ=hD=J2#7U,/U#/X~6P,FU<eL=jx,mG=hG=CE&PU=Se(qX&LY=X6=y4&tk&QQ&tf=4g&xI}W+&mZ=Dc#7w}Lg;DA;wQ_Kb(cJ=hR%yX&Yb,hw{bX_4X;EP;1W_2M}Uc=b5(YF,CM&Tp^OJ{DD]6s=vF=Yo~8q}XH}Fu%P5(SJ=Qt;MO]s8<F3&B3&8T(Ul-BS*dw&dR<87}/8]62$PZ]Lx<Au}9Q]7c=ja=KR,Go,Us&v6(qk}pG&G2=ev^GM%w4&H4]7F&dv]J6}Ew:9w=sj-ZL}Ym$+h(Ut(Um~4n=Xs(U7%eE=Qc_JR<CA#6t<Fv|/I,IS,EG<F2(Xy$/n<Fa(h9}+9_2o&N4#7X<Zq|+f_Dp=dt&na,Ca=NJ)jY=8C=YG=s6&Q+<DO}D3=xB&R1(lw;Qn<bF(Cu|/B}HV=SS&n7,10&u0]Dm%A6^4Q=WR(TD=Xo<GH,Rj(l8)bP&n/=LM&CF,F5&ml=PJ;0k=LG=tq,Rh,D6@4i=1p&+9=YC%er_Mh;nI;0q=Fw]80=xq=FM$Gv;v6&nc;wK%H2&Kj;vs,AA=YP,66}bI(qR~5U=6q~4b$Ni=K5.X3$So&Iu(p+]8G=Cf=RY(TS_O3(iH&57=fE=Dg_Do#9z#7H;FK{qd_2k%JR}en&gh_z8;Rx}9p<cN_Ne,DO;LN_7o~/p=NF=5Y}gN<ce<C1,QE]Wv=3u<BC}GK]yq}DY&u/_hj=II(pz&rC,jV&+Z}ut=NQ;Cg-SR_ZS,+o=u/;Oy_RK_QF(Fx&xP}Wr&TA,Uh&g1=yr{ax[VF$Pg(YB;Ox=Vy;+W(Sp}XV%dd&33(l/]l4#4Y}OE=6c=bw(A7&9t%wd&N/&mo,JH&Qe)fm=Ao}fu=tH";
  var deltaData = "FAZDC6BALcLZCA+GBARCW8wNCcDDZ8LVFBOqqDUiou+M42TFAyERXFb7EjhP+vmBFpFrUpfDV2F7eB+eCltCHJFWLFCED+pWTojEIHFXc3aFn4F68zqjEuKidS1QBVPDEhE7NA4mhMF7oThD49ot3FgtzHFCK0acW1x8DH1EmLoIlrWFBLE+y5+NA3Cx65wJHTaEZVaK1mWAmPGxgYCdxwOjTDIt/faOEhTl1vqNsKtJCOhJWuio2g07KLZEQsFBUpNtwEByBgxFslFheFbiEPvi61msDvApxCzB6rBCzox7joYA5UdDc+Cb4FSgIabpXFAj3bjkmFAxCZE+mD/SFf/0ELecYCt3nLoxC6WEZf2tKDB4oZvrEmqFkKk7BwILA7gtYBpsTq//D4jD0F0wEB9pyQ1BD5Ba0oYHDI+sbDFhvrHXdDHfgFEIJLi5r8qercNFBgFLC4bo5ERJtamWBDFy73KCEb6M8VpmEt330ygCTK58EIIFkYgF84gtGA9Uyh3m68iVrFbWFbcbqiCYHZ9J1jeRPbL8yswhMiDbhEhdNoSwFbZrLT740ABEqgCkO8J1BLd1VhKKR4sD1yUo0z+FF59Mvg71CFbyEhbHSFBKEIKyoQNgQppq9T0KAqePu0ZFGrXOHdKJqkoTFhYvpDNyuuznrN84thJbsCoO6Cu6Xlvntvy0QYuAExQEYtTUBf3CoCqwgGFZ4u1HJFzDVwEy3cjcpV4QvsPaBC3rCGyCF23o4K3pp2gberGgFEJEHo4nHICtyKH2ZqyxhN05KBBJIQlKh/Oujv/DH32VrlqFdIFC7Fz9Ct4kaqFME0UETLprnN9kfy+kFmtQBB0+5CFu0N9Ij8l/VvJDh2oq3hT6EzjTHKFN7ZjZwoTsAZ4Exsko6Fpa6WC+sduz8jyrLpegTv2h1EBeYpLpm2czQW0KoCcS0bCVXCmuWJDBjN1nQNLdF58SFJ0h7i3pC3oEOKy/FjBklL70XvBEEIWp2yZ04xObzAWDDJG7f+DbqBEA7LyiR95j7MDVdDViz2RE5vWlBMv5e4+VfhP3aXNPhvLSynb9O2x4uFBV+3jqu6d5pCG28/sETByvmu/+IJ0L3wb4rj9DNOLBF6XPIODr4L19U9RRofAG6Nxydi8Bki8BhGJbBAJKzbJxkZSlF9Q2Cu8oKqggB9hBArwLLqEBWEtFowy8XK8bEyw9snT+BeyFk1ZCSrdmgfEwFePTgCjELBEnIbjaDDPJm36rG9pztcEzT8dGk23SBhXBB1H4z+OWze0ooFzz8pDBYFvp9j9tvFByf9y4EFdVnz026CGR5qMr7fxMHN8UUdlyJAzlTBDRC28k+L4FB8078ljyD91tUj1ocnTs8vdEf7znbzm+GIjEZnoZE5rnLL700Xc7yHfz05nWxy03vBB9YGHYOWxgMQGBCR24CVYNE1hpfKxN0zKnfJDmmMgMmBWqNbjfSyFCBWSCGCgR8yFXiHyEj+VtD1FB3FpC1zI0kFbzifiKTLm9yq5zFmur+q8FHqjoOBWsBPiDbnCC2ErunV6cJ6TygXFYHYp7MKN9RUlSIS8/xBAGYLzeqUnBF4QbsTuUkUqGs6CaiDWKWjQK9EJkjpkTmNCPYXL";
  var _wordlist = {
    zh_cn: null,
    zh_tw: null
  };
  var Checks = {
    zh_cn: "0x17bcc4d8547e5a7135e365d1ab443aaae95e76d8230c2782c67305d4f21497a1",
    zh_tw: "0x51e720e90c7b87bec1d70eb6e74a21a449bd3ec9c020b01d3a40ed991b60ce5d"
  };
  var codes = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  var style = "~!@#$%^&*_-=[]{}|;:,.()<>?";
  function loadWords(locale) {
    if (_wordlist[locale] != null) {
      return _wordlist[locale];
    }
    var wordlist = [];
    var deltaOffset = 0;
    for (var i = 0; i < 2048; i++) {
      var s = style.indexOf(data[i * 3]);
      var bytes = [228 + (s >> 2), 128 + codes.indexOf(data[i * 3 + 1]), 128 + codes.indexOf(data[i * 3 + 2])];
      if (locale === "zh_tw") {
        var common = s % 4;
        for (var _i = common; _i < 3; _i++) {
          bytes[_i] = codes.indexOf(deltaData[deltaOffset++]) + (_i == 0 ? 228 : 128);
        }
      }
      wordlist.push((0, index_js_2.toUtf8String)(new Uint8Array(bytes)));
    }
    // Verify the computed list matches the official list
    var checksum = (0, index_js_1.id)(wordlist.join("\n") + "\n");
    /* c8 ignore start */
    if (checksum !== Checks[locale]) {
      throw new Error("BIP39 Wordlist for ".concat(locale, " (Chinese) FAILED"));
    }
    /* c8 ignore stop */
    _wordlist[locale] = wordlist;
    return wordlist;
  }
  var wordlists = {};
  /**
   *  The [[link-bip39-zh_cn]] and [[link-bip39-zh_tw]] for
   *  [mnemonic phrases](link-bip-39).
   *
   *  @_docloc: api/wordlists
   */
  var LangZh = /*#__PURE__*/function (_wordlist_js_1$Wordli) {
    /**
     *  Creates a new instance of the Chinese language Wordlist for
     *  the %%dialect%%, either ``"cn"`` or ``"tw"`` for simplified
     *  or traditional, respectively.
     *
     *  This should be unnecessary most of the time as the exported
     *  [[langZhCn]] and [[langZhTw]] should suffice.
     *
     *  @_ignore:
     */
    function LangZh(dialect) {
      _classCallCheck(this, LangZh);
      return _callSuper(this, LangZh, ["zh_" + dialect]);
    }
    _inherits(LangZh, _wordlist_js_1$Wordli);
    return _createClass(LangZh, [{
      key: "getWord",
      value: function getWord(index) {
        var words = loadWords(this.locale);
        (0, index_js_2.assertArgument)(index >= 0 && index < words.length, "invalid word index: ".concat(index), "index", index);
        return words[index];
      }
    }, {
      key: "getWordIndex",
      value: function getWordIndex(word) {
        return loadWords(this.locale).indexOf(word);
      }
    }, {
      key: "split",
      value: function split(phrase) {
        phrase = phrase.replace(/(?:\u3000| )+/g, "");
        return phrase.split("");
      }
      /**
       *  Returns a singleton instance of a ``LangZh`` for %%dialect%%,
       *  creating it if this is the first time being called.
       *
       *  Use the %%dialect%% ``"cn"`` or ``"tw"`` for simplified or
       *  traditional, respectively.
       */
    }], [{
      key: "wordlist",
      value: function wordlist(dialect) {
        if (wordlists[dialect] == null) {
          wordlists[dialect] = new LangZh(dialect);
        }
        return wordlists[dialect];
      }
    }]);
  }(wordlist_js_1.Wordlist);
  langZh.LangZh = LangZh;
  return langZh;
}

var hasRequiredWordlists$1;
function requireWordlists$1() {
  if (hasRequiredWordlists$1) return wordlists;
  hasRequiredWordlists$1 = 1;
  Object.defineProperty(wordlists, "__esModule", {
    value: true
  });
  wordlists.wordlists = void 0;
  var lang_cz_js_1 = /*@__PURE__*/requireLangCz();
  var lang_en_js_1 = /*@__PURE__*/requireLangEn();
  var lang_es_js_1 = /*@__PURE__*/requireLangEs();
  var lang_fr_js_1 = /*@__PURE__*/requireLangFr();
  var lang_ja_js_1 = /*@__PURE__*/requireLangJa();
  var lang_ko_js_1 = /*@__PURE__*/requireLangKo();
  var lang_it_js_1 = /*@__PURE__*/requireLangIt();
  var lang_pt_js_1 = /*@__PURE__*/requireLangPt();
  var lang_zh_js_1 = /*@__PURE__*/requireLangZh();
  /**
   *  The available Wordlists by their
   *  [ISO 639-1 Language Code](link-wiki-iso639).
   *
   *  (**i.e.** [cz](LangCz), [en](LangEn), [es](LangEs), [fr](LangFr),
   *  [ja](LangJa), [ko](LangKo), [it](LangIt), [pt](LangPt),
   *  [zh_cn](LangZh), [zh_tw](LangZh))
   *
   *  The dist files (in the ``/dist`` folder) have had all languages
   *  except English stripped out, which reduces the library size by
   *  about 80kb. If required, they are available by importing the
   *  included ``wordlists-extra.min.js`` file.
   */
  wordlists.wordlists = {
    cz: lang_cz_js_1.LangCz.wordlist(),
    en: lang_en_js_1.LangEn.wordlist(),
    es: lang_es_js_1.LangEs.wordlist(),
    fr: lang_fr_js_1.LangFr.wordlist(),
    it: lang_it_js_1.LangIt.wordlist(),
    pt: lang_pt_js_1.LangPt.wordlist(),
    ja: lang_ja_js_1.LangJa.wordlist(),
    ko: lang_ko_js_1.LangKo.wordlist(),
    zh_cn: lang_zh_js_1.LangZh.wordlist("cn"),
    zh_tw: lang_zh_js_1.LangZh.wordlist("tw")
  };
  return wordlists;
}

var hasRequiredWordlists;
function requireWordlists() {
  if (hasRequiredWordlists) return wordlists$1;
  hasRequiredWordlists = 1;
  (function (exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.wordlists = exports.WordlistOwlA = exports.WordlistOwl = exports.LangEn = exports.Wordlist = void 0;
    /**
     *  A Wordlist is a set of 2048 words used to encode private keys
     *  (or other binary data) that is easier for humans to write down,
     *  transcribe and dictate.
     *
     *  The [[link-bip-39]] standard includes several checksum bits,
     *  depending on the size of the mnemonic phrase.
     *
     *  A mnemonic phrase may be 12, 15, 18, 21 or 24 words long. For
     *  most purposes 12 word mnemonics should be used, as including
     *  additional words increases the difficulty and potential for
     *  mistakes and does not offer any effective improvement on security.
     *
     *  There are a variety of [[link-bip39-wordlists]] for different
     *  languages, but for maximal compatibility, the
     *  [English Wordlist](LangEn) is recommended.
     *
     *  @_section: api/wordlists:Wordlists [about-wordlists]
     */
    var wordlist_js_1 = /*@__PURE__*/requireWordlist();
    Object.defineProperty(exports, "Wordlist", {
      enumerable: true,
      get: function get() {
        return wordlist_js_1.Wordlist;
      }
    });
    var lang_en_js_1 = /*@__PURE__*/requireLangEn();
    Object.defineProperty(exports, "LangEn", {
      enumerable: true,
      get: function get() {
        return lang_en_js_1.LangEn;
      }
    });
    var wordlist_owl_js_1 = /*@__PURE__*/requireWordlistOwl();
    Object.defineProperty(exports, "WordlistOwl", {
      enumerable: true,
      get: function get() {
        return wordlist_owl_js_1.WordlistOwl;
      }
    });
    var wordlist_owla_js_1 = /*@__PURE__*/requireWordlistOwla();
    Object.defineProperty(exports, "WordlistOwlA", {
      enumerable: true,
      get: function get() {
        return wordlist_owla_js_1.WordlistOwlA;
      }
    });
    var wordlists_js_1 = /*@__PURE__*/requireWordlists$1();
    Object.defineProperty(exports, "wordlists", {
      enumerable: true,
      get: function get() {
        return wordlists_js_1.wordlists;
      }
    });
  })(wordlists$1);
  return wordlists$1;
}

var hasRequiredEthers;
function requireEthers() {
  if (hasRequiredEthers) return ethers;
  hasRequiredEthers = 1;
  (function (exports) {

    /////////////////////////////
    //
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ripemd160 = exports.keccak256 = exports.randomBytes = exports.computeHmac = exports.UndecodedEventLog = exports.EventLog = exports.ContractUnknownEventPayload = exports.ContractTransactionResponse = exports.ContractTransactionReceipt = exports.ContractEventPayload = exports.ContractFactory = exports.Contract = exports.BaseContract = exports.MessagePrefix = exports.EtherSymbol = exports.ZeroHash = exports.N = exports.MaxInt256 = exports.MinInt256 = exports.MaxUint256 = exports.WeiPerEther = exports.ZeroAddress = exports.resolveAddress = exports.isAddress = exports.isAddressable = exports.getCreate2Address = exports.getCreateAddress = exports.getIcapAddress = exports.getAddress = exports.Typed = exports.TransactionDescription = exports.Result = exports.LogDescription = exports.Interface = exports.Indexed = exports.ErrorDescription = exports.checkResultErrors = exports.StructFragment = exports.ParamType = exports.NamedFragment = exports.FunctionFragment = exports.FallbackFragment = exports.Fragment = exports.EventFragment = exports.ErrorFragment = exports.ConstructorFragment = exports.AbiCoder = exports.encodeBytes32String = exports.decodeBytes32String = exports.version = void 0;
    exports.EnsPlugin = exports.Network = exports.EnsResolver = exports.WebSocketProvider = exports.SocketProvider = exports.IpcSocketProvider = exports.QuickNodeProvider = exports.PocketProvider = exports.InfuraWebSocketProvider = exports.InfuraProvider = exports.EtherscanProvider = exports.CloudflareProvider = exports.ChainstackProvider = exports.AnkrProvider = exports.AlchemyProvider = exports.BrowserProvider = exports.JsonRpcSigner = exports.JsonRpcProvider = exports.JsonRpcApiProvider = exports.FallbackProvider = exports.AbstractProvider = exports.VoidSigner = exports.NonceManager = exports.AbstractSigner = exports.TransactionResponse = exports.TransactionReceipt = exports.Log = exports.FeeData = exports.Block = exports.getDefaultProvider = exports.verifyTypedData = exports.TypedDataEncoder = exports.solidityPackedSha256 = exports.solidityPackedKeccak256 = exports.solidityPacked = exports.verifyMessage = exports.hashMessage = exports.dnsEncode = exports.namehash = exports.isValidName = exports.ensNormalize = exports.id = exports.SigningKey = exports.Signature = exports.lock = exports.scryptSync = exports.scrypt = exports.pbkdf2 = exports.sha512 = exports.sha256 = void 0;
    exports.getUint = exports.getNumber = exports.getBigInt = exports.FixedNumber = exports.FetchCancelSignal = exports.FetchResponse = exports.FetchRequest = exports.EventPayload = exports.isError = exports.isCallException = exports.makeError = exports.assertPrivate = exports.assertNormalize = exports.assertArgumentCount = exports.assertArgument = exports.assert = exports.resolveProperties = exports.defineProperties = exports.zeroPadValue = exports.zeroPadBytes = exports.stripZerosLeft = exports.isBytesLike = exports.isHexString = exports.hexlify = exports.getBytesCopy = exports.getBytes = exports.dataSlice = exports.dataLength = exports.concat = exports.encodeBase64 = exports.decodeBase64 = exports.encodeBase58 = exports.decodeBase58 = exports.Transaction = exports.recoverAddress = exports.computeAddress = exports.accessListify = exports.showThrottleMessage = exports.copyRequest = exports.UnmanagedSubscriber = exports.SocketSubscriber = exports.SocketPendingSubscriber = exports.SocketEventSubscriber = exports.SocketBlockSubscriber = exports.MulticoinProviderPlugin = exports.NetworkPlugin = exports.GasCostPlugin = exports.FetchUrlFeeDataNetworkPlugin = exports.FeeDataNetworkPlugin = exports.EtherscanPlugin = void 0;
    exports.wordlists = exports.WordlistOwlA = exports.WordlistOwl = exports.LangEn = exports.Wordlist = exports.encryptKeystoreJsonSync = exports.encryptKeystoreJson = exports.decryptKeystoreJson = exports.decryptKeystoreJsonSync = exports.decryptCrowdsaleJson = exports.isKeystoreJson = exports.isCrowdsaleJson = exports.getIndexedAccountPath = exports.getAccountPath = exports.defaultPath = exports.Wallet = exports.HDNodeVoidWallet = exports.HDNodeWallet = exports.BaseWallet = exports.Mnemonic = exports.uuidV4 = exports.encodeRlp = exports.decodeRlp = exports.Utf8ErrorFuncs = exports.toUtf8String = exports.toUtf8CodePoints = exports.toUtf8Bytes = exports.parseUnits = exports.formatUnits = exports.parseEther = exports.formatEther = exports.mask = exports.toTwos = exports.fromTwos = exports.toQuantity = exports.toNumber = exports.toBeHex = exports.toBigInt = exports.toBeArray = void 0;
    var _version_js_1 = /*@__PURE__*/require_version();
    Object.defineProperty(exports, "version", {
      enumerable: true,
      get: function get() {
        return _version_js_1.version;
      }
    });
    var index_js_1 = /*@__PURE__*/requireAbi();
    Object.defineProperty(exports, "decodeBytes32String", {
      enumerable: true,
      get: function get() {
        return index_js_1.decodeBytes32String;
      }
    });
    Object.defineProperty(exports, "encodeBytes32String", {
      enumerable: true,
      get: function get() {
        return index_js_1.encodeBytes32String;
      }
    });
    Object.defineProperty(exports, "AbiCoder", {
      enumerable: true,
      get: function get() {
        return index_js_1.AbiCoder;
      }
    });
    Object.defineProperty(exports, "ConstructorFragment", {
      enumerable: true,
      get: function get() {
        return index_js_1.ConstructorFragment;
      }
    });
    Object.defineProperty(exports, "ErrorFragment", {
      enumerable: true,
      get: function get() {
        return index_js_1.ErrorFragment;
      }
    });
    Object.defineProperty(exports, "EventFragment", {
      enumerable: true,
      get: function get() {
        return index_js_1.EventFragment;
      }
    });
    Object.defineProperty(exports, "Fragment", {
      enumerable: true,
      get: function get() {
        return index_js_1.Fragment;
      }
    });
    Object.defineProperty(exports, "FallbackFragment", {
      enumerable: true,
      get: function get() {
        return index_js_1.FallbackFragment;
      }
    });
    Object.defineProperty(exports, "FunctionFragment", {
      enumerable: true,
      get: function get() {
        return index_js_1.FunctionFragment;
      }
    });
    Object.defineProperty(exports, "NamedFragment", {
      enumerable: true,
      get: function get() {
        return index_js_1.NamedFragment;
      }
    });
    Object.defineProperty(exports, "ParamType", {
      enumerable: true,
      get: function get() {
        return index_js_1.ParamType;
      }
    });
    Object.defineProperty(exports, "StructFragment", {
      enumerable: true,
      get: function get() {
        return index_js_1.StructFragment;
      }
    });
    Object.defineProperty(exports, "checkResultErrors", {
      enumerable: true,
      get: function get() {
        return index_js_1.checkResultErrors;
      }
    });
    Object.defineProperty(exports, "ErrorDescription", {
      enumerable: true,
      get: function get() {
        return index_js_1.ErrorDescription;
      }
    });
    Object.defineProperty(exports, "Indexed", {
      enumerable: true,
      get: function get() {
        return index_js_1.Indexed;
      }
    });
    Object.defineProperty(exports, "Interface", {
      enumerable: true,
      get: function get() {
        return index_js_1.Interface;
      }
    });
    Object.defineProperty(exports, "LogDescription", {
      enumerable: true,
      get: function get() {
        return index_js_1.LogDescription;
      }
    });
    Object.defineProperty(exports, "Result", {
      enumerable: true,
      get: function get() {
        return index_js_1.Result;
      }
    });
    Object.defineProperty(exports, "TransactionDescription", {
      enumerable: true,
      get: function get() {
        return index_js_1.TransactionDescription;
      }
    });
    Object.defineProperty(exports, "Typed", {
      enumerable: true,
      get: function get() {
        return index_js_1.Typed;
      }
    });
    var index_js_2 = /*@__PURE__*/requireAddress$2();
    Object.defineProperty(exports, "getAddress", {
      enumerable: true,
      get: function get() {
        return index_js_2.getAddress;
      }
    });
    Object.defineProperty(exports, "getIcapAddress", {
      enumerable: true,
      get: function get() {
        return index_js_2.getIcapAddress;
      }
    });
    Object.defineProperty(exports, "getCreateAddress", {
      enumerable: true,
      get: function get() {
        return index_js_2.getCreateAddress;
      }
    });
    Object.defineProperty(exports, "getCreate2Address", {
      enumerable: true,
      get: function get() {
        return index_js_2.getCreate2Address;
      }
    });
    Object.defineProperty(exports, "isAddressable", {
      enumerable: true,
      get: function get() {
        return index_js_2.isAddressable;
      }
    });
    Object.defineProperty(exports, "isAddress", {
      enumerable: true,
      get: function get() {
        return index_js_2.isAddress;
      }
    });
    Object.defineProperty(exports, "resolveAddress", {
      enumerable: true,
      get: function get() {
        return index_js_2.resolveAddress;
      }
    });
    var index_js_3 = /*@__PURE__*/requireConstants$1();
    Object.defineProperty(exports, "ZeroAddress", {
      enumerable: true,
      get: function get() {
        return index_js_3.ZeroAddress;
      }
    });
    Object.defineProperty(exports, "WeiPerEther", {
      enumerable: true,
      get: function get() {
        return index_js_3.WeiPerEther;
      }
    });
    Object.defineProperty(exports, "MaxUint256", {
      enumerable: true,
      get: function get() {
        return index_js_3.MaxUint256;
      }
    });
    Object.defineProperty(exports, "MinInt256", {
      enumerable: true,
      get: function get() {
        return index_js_3.MinInt256;
      }
    });
    Object.defineProperty(exports, "MaxInt256", {
      enumerable: true,
      get: function get() {
        return index_js_3.MaxInt256;
      }
    });
    Object.defineProperty(exports, "N", {
      enumerable: true,
      get: function get() {
        return index_js_3.N;
      }
    });
    Object.defineProperty(exports, "ZeroHash", {
      enumerable: true,
      get: function get() {
        return index_js_3.ZeroHash;
      }
    });
    Object.defineProperty(exports, "EtherSymbol", {
      enumerable: true,
      get: function get() {
        return index_js_3.EtherSymbol;
      }
    });
    Object.defineProperty(exports, "MessagePrefix", {
      enumerable: true,
      get: function get() {
        return index_js_3.MessagePrefix;
      }
    });
    var index_js_4 = /*@__PURE__*/requireContract();
    Object.defineProperty(exports, "BaseContract", {
      enumerable: true,
      get: function get() {
        return index_js_4.BaseContract;
      }
    });
    Object.defineProperty(exports, "Contract", {
      enumerable: true,
      get: function get() {
        return index_js_4.Contract;
      }
    });
    Object.defineProperty(exports, "ContractFactory", {
      enumerable: true,
      get: function get() {
        return index_js_4.ContractFactory;
      }
    });
    Object.defineProperty(exports, "ContractEventPayload", {
      enumerable: true,
      get: function get() {
        return index_js_4.ContractEventPayload;
      }
    });
    Object.defineProperty(exports, "ContractTransactionReceipt", {
      enumerable: true,
      get: function get() {
        return index_js_4.ContractTransactionReceipt;
      }
    });
    Object.defineProperty(exports, "ContractTransactionResponse", {
      enumerable: true,
      get: function get() {
        return index_js_4.ContractTransactionResponse;
      }
    });
    Object.defineProperty(exports, "ContractUnknownEventPayload", {
      enumerable: true,
      get: function get() {
        return index_js_4.ContractUnknownEventPayload;
      }
    });
    Object.defineProperty(exports, "EventLog", {
      enumerable: true,
      get: function get() {
        return index_js_4.EventLog;
      }
    });
    Object.defineProperty(exports, "UndecodedEventLog", {
      enumerable: true,
      get: function get() {
        return index_js_4.UndecodedEventLog;
      }
    });
    var index_js_5 = /*@__PURE__*/requireCrypto();
    Object.defineProperty(exports, "computeHmac", {
      enumerable: true,
      get: function get() {
        return index_js_5.computeHmac;
      }
    });
    Object.defineProperty(exports, "randomBytes", {
      enumerable: true,
      get: function get() {
        return index_js_5.randomBytes;
      }
    });
    Object.defineProperty(exports, "keccak256", {
      enumerable: true,
      get: function get() {
        return index_js_5.keccak256;
      }
    });
    Object.defineProperty(exports, "ripemd160", {
      enumerable: true,
      get: function get() {
        return index_js_5.ripemd160;
      }
    });
    Object.defineProperty(exports, "sha256", {
      enumerable: true,
      get: function get() {
        return index_js_5.sha256;
      }
    });
    Object.defineProperty(exports, "sha512", {
      enumerable: true,
      get: function get() {
        return index_js_5.sha512;
      }
    });
    Object.defineProperty(exports, "pbkdf2", {
      enumerable: true,
      get: function get() {
        return index_js_5.pbkdf2;
      }
    });
    Object.defineProperty(exports, "scrypt", {
      enumerable: true,
      get: function get() {
        return index_js_5.scrypt;
      }
    });
    Object.defineProperty(exports, "scryptSync", {
      enumerable: true,
      get: function get() {
        return index_js_5.scryptSync;
      }
    });
    Object.defineProperty(exports, "lock", {
      enumerable: true,
      get: function get() {
        return index_js_5.lock;
      }
    });
    Object.defineProperty(exports, "Signature", {
      enumerable: true,
      get: function get() {
        return index_js_5.Signature;
      }
    });
    Object.defineProperty(exports, "SigningKey", {
      enumerable: true,
      get: function get() {
        return index_js_5.SigningKey;
      }
    });
    var index_js_6 = /*@__PURE__*/requireHash();
    Object.defineProperty(exports, "id", {
      enumerable: true,
      get: function get() {
        return index_js_6.id;
      }
    });
    Object.defineProperty(exports, "ensNormalize", {
      enumerable: true,
      get: function get() {
        return index_js_6.ensNormalize;
      }
    });
    Object.defineProperty(exports, "isValidName", {
      enumerable: true,
      get: function get() {
        return index_js_6.isValidName;
      }
    });
    Object.defineProperty(exports, "namehash", {
      enumerable: true,
      get: function get() {
        return index_js_6.namehash;
      }
    });
    Object.defineProperty(exports, "dnsEncode", {
      enumerable: true,
      get: function get() {
        return index_js_6.dnsEncode;
      }
    });
    Object.defineProperty(exports, "hashMessage", {
      enumerable: true,
      get: function get() {
        return index_js_6.hashMessage;
      }
    });
    Object.defineProperty(exports, "verifyMessage", {
      enumerable: true,
      get: function get() {
        return index_js_6.verifyMessage;
      }
    });
    Object.defineProperty(exports, "solidityPacked", {
      enumerable: true,
      get: function get() {
        return index_js_6.solidityPacked;
      }
    });
    Object.defineProperty(exports, "solidityPackedKeccak256", {
      enumerable: true,
      get: function get() {
        return index_js_6.solidityPackedKeccak256;
      }
    });
    Object.defineProperty(exports, "solidityPackedSha256", {
      enumerable: true,
      get: function get() {
        return index_js_6.solidityPackedSha256;
      }
    });
    Object.defineProperty(exports, "TypedDataEncoder", {
      enumerable: true,
      get: function get() {
        return index_js_6.TypedDataEncoder;
      }
    });
    Object.defineProperty(exports, "verifyTypedData", {
      enumerable: true,
      get: function get() {
        return index_js_6.verifyTypedData;
      }
    });
    var index_js_7 = /*@__PURE__*/requireProviders();
    Object.defineProperty(exports, "getDefaultProvider", {
      enumerable: true,
      get: function get() {
        return index_js_7.getDefaultProvider;
      }
    });
    Object.defineProperty(exports, "Block", {
      enumerable: true,
      get: function get() {
        return index_js_7.Block;
      }
    });
    Object.defineProperty(exports, "FeeData", {
      enumerable: true,
      get: function get() {
        return index_js_7.FeeData;
      }
    });
    Object.defineProperty(exports, "Log", {
      enumerable: true,
      get: function get() {
        return index_js_7.Log;
      }
    });
    Object.defineProperty(exports, "TransactionReceipt", {
      enumerable: true,
      get: function get() {
        return index_js_7.TransactionReceipt;
      }
    });
    Object.defineProperty(exports, "TransactionResponse", {
      enumerable: true,
      get: function get() {
        return index_js_7.TransactionResponse;
      }
    });
    Object.defineProperty(exports, "AbstractSigner", {
      enumerable: true,
      get: function get() {
        return index_js_7.AbstractSigner;
      }
    });
    Object.defineProperty(exports, "NonceManager", {
      enumerable: true,
      get: function get() {
        return index_js_7.NonceManager;
      }
    });
    Object.defineProperty(exports, "VoidSigner", {
      enumerable: true,
      get: function get() {
        return index_js_7.VoidSigner;
      }
    });
    Object.defineProperty(exports, "AbstractProvider", {
      enumerable: true,
      get: function get() {
        return index_js_7.AbstractProvider;
      }
    });
    Object.defineProperty(exports, "FallbackProvider", {
      enumerable: true,
      get: function get() {
        return index_js_7.FallbackProvider;
      }
    });
    Object.defineProperty(exports, "JsonRpcApiProvider", {
      enumerable: true,
      get: function get() {
        return index_js_7.JsonRpcApiProvider;
      }
    });
    Object.defineProperty(exports, "JsonRpcProvider", {
      enumerable: true,
      get: function get() {
        return index_js_7.JsonRpcProvider;
      }
    });
    Object.defineProperty(exports, "JsonRpcSigner", {
      enumerable: true,
      get: function get() {
        return index_js_7.JsonRpcSigner;
      }
    });
    Object.defineProperty(exports, "BrowserProvider", {
      enumerable: true,
      get: function get() {
        return index_js_7.BrowserProvider;
      }
    });
    Object.defineProperty(exports, "AlchemyProvider", {
      enumerable: true,
      get: function get() {
        return index_js_7.AlchemyProvider;
      }
    });
    Object.defineProperty(exports, "AnkrProvider", {
      enumerable: true,
      get: function get() {
        return index_js_7.AnkrProvider;
      }
    });
    Object.defineProperty(exports, "ChainstackProvider", {
      enumerable: true,
      get: function get() {
        return index_js_7.ChainstackProvider;
      }
    });
    Object.defineProperty(exports, "CloudflareProvider", {
      enumerable: true,
      get: function get() {
        return index_js_7.CloudflareProvider;
      }
    });
    Object.defineProperty(exports, "EtherscanProvider", {
      enumerable: true,
      get: function get() {
        return index_js_7.EtherscanProvider;
      }
    });
    Object.defineProperty(exports, "InfuraProvider", {
      enumerable: true,
      get: function get() {
        return index_js_7.InfuraProvider;
      }
    });
    Object.defineProperty(exports, "InfuraWebSocketProvider", {
      enumerable: true,
      get: function get() {
        return index_js_7.InfuraWebSocketProvider;
      }
    });
    Object.defineProperty(exports, "PocketProvider", {
      enumerable: true,
      get: function get() {
        return index_js_7.PocketProvider;
      }
    });
    Object.defineProperty(exports, "QuickNodeProvider", {
      enumerable: true,
      get: function get() {
        return index_js_7.QuickNodeProvider;
      }
    });
    Object.defineProperty(exports, "IpcSocketProvider", {
      enumerable: true,
      get: function get() {
        return index_js_7.IpcSocketProvider;
      }
    });
    Object.defineProperty(exports, "SocketProvider", {
      enumerable: true,
      get: function get() {
        return index_js_7.SocketProvider;
      }
    });
    Object.defineProperty(exports, "WebSocketProvider", {
      enumerable: true,
      get: function get() {
        return index_js_7.WebSocketProvider;
      }
    });
    Object.defineProperty(exports, "EnsResolver", {
      enumerable: true,
      get: function get() {
        return index_js_7.EnsResolver;
      }
    });
    Object.defineProperty(exports, "Network", {
      enumerable: true,
      get: function get() {
        return index_js_7.Network;
      }
    });
    Object.defineProperty(exports, "EnsPlugin", {
      enumerable: true,
      get: function get() {
        return index_js_7.EnsPlugin;
      }
    });
    Object.defineProperty(exports, "EtherscanPlugin", {
      enumerable: true,
      get: function get() {
        return index_js_7.EtherscanPlugin;
      }
    });
    Object.defineProperty(exports, "FeeDataNetworkPlugin", {
      enumerable: true,
      get: function get() {
        return index_js_7.FeeDataNetworkPlugin;
      }
    });
    Object.defineProperty(exports, "FetchUrlFeeDataNetworkPlugin", {
      enumerable: true,
      get: function get() {
        return index_js_7.FetchUrlFeeDataNetworkPlugin;
      }
    });
    Object.defineProperty(exports, "GasCostPlugin", {
      enumerable: true,
      get: function get() {
        return index_js_7.GasCostPlugin;
      }
    });
    Object.defineProperty(exports, "NetworkPlugin", {
      enumerable: true,
      get: function get() {
        return index_js_7.NetworkPlugin;
      }
    });
    Object.defineProperty(exports, "MulticoinProviderPlugin", {
      enumerable: true,
      get: function get() {
        return index_js_7.MulticoinProviderPlugin;
      }
    });
    Object.defineProperty(exports, "SocketBlockSubscriber", {
      enumerable: true,
      get: function get() {
        return index_js_7.SocketBlockSubscriber;
      }
    });
    Object.defineProperty(exports, "SocketEventSubscriber", {
      enumerable: true,
      get: function get() {
        return index_js_7.SocketEventSubscriber;
      }
    });
    Object.defineProperty(exports, "SocketPendingSubscriber", {
      enumerable: true,
      get: function get() {
        return index_js_7.SocketPendingSubscriber;
      }
    });
    Object.defineProperty(exports, "SocketSubscriber", {
      enumerable: true,
      get: function get() {
        return index_js_7.SocketSubscriber;
      }
    });
    Object.defineProperty(exports, "UnmanagedSubscriber", {
      enumerable: true,
      get: function get() {
        return index_js_7.UnmanagedSubscriber;
      }
    });
    Object.defineProperty(exports, "copyRequest", {
      enumerable: true,
      get: function get() {
        return index_js_7.copyRequest;
      }
    });
    Object.defineProperty(exports, "showThrottleMessage", {
      enumerable: true,
      get: function get() {
        return index_js_7.showThrottleMessage;
      }
    });
    var index_js_8 = /*@__PURE__*/requireTransaction();
    Object.defineProperty(exports, "accessListify", {
      enumerable: true,
      get: function get() {
        return index_js_8.accessListify;
      }
    });
    Object.defineProperty(exports, "computeAddress", {
      enumerable: true,
      get: function get() {
        return index_js_8.computeAddress;
      }
    });
    Object.defineProperty(exports, "recoverAddress", {
      enumerable: true,
      get: function get() {
        return index_js_8.recoverAddress;
      }
    });
    Object.defineProperty(exports, "Transaction", {
      enumerable: true,
      get: function get() {
        return index_js_8.Transaction;
      }
    });
    var index_js_9 = /*@__PURE__*/requireUtils$3();
    Object.defineProperty(exports, "decodeBase58", {
      enumerable: true,
      get: function get() {
        return index_js_9.decodeBase58;
      }
    });
    Object.defineProperty(exports, "encodeBase58", {
      enumerable: true,
      get: function get() {
        return index_js_9.encodeBase58;
      }
    });
    Object.defineProperty(exports, "decodeBase64", {
      enumerable: true,
      get: function get() {
        return index_js_9.decodeBase64;
      }
    });
    Object.defineProperty(exports, "encodeBase64", {
      enumerable: true,
      get: function get() {
        return index_js_9.encodeBase64;
      }
    });
    Object.defineProperty(exports, "concat", {
      enumerable: true,
      get: function get() {
        return index_js_9.concat;
      }
    });
    Object.defineProperty(exports, "dataLength", {
      enumerable: true,
      get: function get() {
        return index_js_9.dataLength;
      }
    });
    Object.defineProperty(exports, "dataSlice", {
      enumerable: true,
      get: function get() {
        return index_js_9.dataSlice;
      }
    });
    Object.defineProperty(exports, "getBytes", {
      enumerable: true,
      get: function get() {
        return index_js_9.getBytes;
      }
    });
    Object.defineProperty(exports, "getBytesCopy", {
      enumerable: true,
      get: function get() {
        return index_js_9.getBytesCopy;
      }
    });
    Object.defineProperty(exports, "hexlify", {
      enumerable: true,
      get: function get() {
        return index_js_9.hexlify;
      }
    });
    Object.defineProperty(exports, "isHexString", {
      enumerable: true,
      get: function get() {
        return index_js_9.isHexString;
      }
    });
    Object.defineProperty(exports, "isBytesLike", {
      enumerable: true,
      get: function get() {
        return index_js_9.isBytesLike;
      }
    });
    Object.defineProperty(exports, "stripZerosLeft", {
      enumerable: true,
      get: function get() {
        return index_js_9.stripZerosLeft;
      }
    });
    Object.defineProperty(exports, "zeroPadBytes", {
      enumerable: true,
      get: function get() {
        return index_js_9.zeroPadBytes;
      }
    });
    Object.defineProperty(exports, "zeroPadValue", {
      enumerable: true,
      get: function get() {
        return index_js_9.zeroPadValue;
      }
    });
    Object.defineProperty(exports, "defineProperties", {
      enumerable: true,
      get: function get() {
        return index_js_9.defineProperties;
      }
    });
    Object.defineProperty(exports, "resolveProperties", {
      enumerable: true,
      get: function get() {
        return index_js_9.resolveProperties;
      }
    });
    Object.defineProperty(exports, "assert", {
      enumerable: true,
      get: function get() {
        return index_js_9.assert;
      }
    });
    Object.defineProperty(exports, "assertArgument", {
      enumerable: true,
      get: function get() {
        return index_js_9.assertArgument;
      }
    });
    Object.defineProperty(exports, "assertArgumentCount", {
      enumerable: true,
      get: function get() {
        return index_js_9.assertArgumentCount;
      }
    });
    Object.defineProperty(exports, "assertNormalize", {
      enumerable: true,
      get: function get() {
        return index_js_9.assertNormalize;
      }
    });
    Object.defineProperty(exports, "assertPrivate", {
      enumerable: true,
      get: function get() {
        return index_js_9.assertPrivate;
      }
    });
    Object.defineProperty(exports, "makeError", {
      enumerable: true,
      get: function get() {
        return index_js_9.makeError;
      }
    });
    Object.defineProperty(exports, "isCallException", {
      enumerable: true,
      get: function get() {
        return index_js_9.isCallException;
      }
    });
    Object.defineProperty(exports, "isError", {
      enumerable: true,
      get: function get() {
        return index_js_9.isError;
      }
    });
    Object.defineProperty(exports, "EventPayload", {
      enumerable: true,
      get: function get() {
        return index_js_9.EventPayload;
      }
    });
    Object.defineProperty(exports, "FetchRequest", {
      enumerable: true,
      get: function get() {
        return index_js_9.FetchRequest;
      }
    });
    Object.defineProperty(exports, "FetchResponse", {
      enumerable: true,
      get: function get() {
        return index_js_9.FetchResponse;
      }
    });
    Object.defineProperty(exports, "FetchCancelSignal", {
      enumerable: true,
      get: function get() {
        return index_js_9.FetchCancelSignal;
      }
    });
    Object.defineProperty(exports, "FixedNumber", {
      enumerable: true,
      get: function get() {
        return index_js_9.FixedNumber;
      }
    });
    Object.defineProperty(exports, "getBigInt", {
      enumerable: true,
      get: function get() {
        return index_js_9.getBigInt;
      }
    });
    Object.defineProperty(exports, "getNumber", {
      enumerable: true,
      get: function get() {
        return index_js_9.getNumber;
      }
    });
    Object.defineProperty(exports, "getUint", {
      enumerable: true,
      get: function get() {
        return index_js_9.getUint;
      }
    });
    Object.defineProperty(exports, "toBeArray", {
      enumerable: true,
      get: function get() {
        return index_js_9.toBeArray;
      }
    });
    Object.defineProperty(exports, "toBigInt", {
      enumerable: true,
      get: function get() {
        return index_js_9.toBigInt;
      }
    });
    Object.defineProperty(exports, "toBeHex", {
      enumerable: true,
      get: function get() {
        return index_js_9.toBeHex;
      }
    });
    Object.defineProperty(exports, "toNumber", {
      enumerable: true,
      get: function get() {
        return index_js_9.toNumber;
      }
    });
    Object.defineProperty(exports, "toQuantity", {
      enumerable: true,
      get: function get() {
        return index_js_9.toQuantity;
      }
    });
    Object.defineProperty(exports, "fromTwos", {
      enumerable: true,
      get: function get() {
        return index_js_9.fromTwos;
      }
    });
    Object.defineProperty(exports, "toTwos", {
      enumerable: true,
      get: function get() {
        return index_js_9.toTwos;
      }
    });
    Object.defineProperty(exports, "mask", {
      enumerable: true,
      get: function get() {
        return index_js_9.mask;
      }
    });
    Object.defineProperty(exports, "formatEther", {
      enumerable: true,
      get: function get() {
        return index_js_9.formatEther;
      }
    });
    Object.defineProperty(exports, "parseEther", {
      enumerable: true,
      get: function get() {
        return index_js_9.parseEther;
      }
    });
    Object.defineProperty(exports, "formatUnits", {
      enumerable: true,
      get: function get() {
        return index_js_9.formatUnits;
      }
    });
    Object.defineProperty(exports, "parseUnits", {
      enumerable: true,
      get: function get() {
        return index_js_9.parseUnits;
      }
    });
    Object.defineProperty(exports, "toUtf8Bytes", {
      enumerable: true,
      get: function get() {
        return index_js_9.toUtf8Bytes;
      }
    });
    Object.defineProperty(exports, "toUtf8CodePoints", {
      enumerable: true,
      get: function get() {
        return index_js_9.toUtf8CodePoints;
      }
    });
    Object.defineProperty(exports, "toUtf8String", {
      enumerable: true,
      get: function get() {
        return index_js_9.toUtf8String;
      }
    });
    Object.defineProperty(exports, "Utf8ErrorFuncs", {
      enumerable: true,
      get: function get() {
        return index_js_9.Utf8ErrorFuncs;
      }
    });
    Object.defineProperty(exports, "decodeRlp", {
      enumerable: true,
      get: function get() {
        return index_js_9.decodeRlp;
      }
    });
    Object.defineProperty(exports, "encodeRlp", {
      enumerable: true,
      get: function get() {
        return index_js_9.encodeRlp;
      }
    });
    Object.defineProperty(exports, "uuidV4", {
      enumerable: true,
      get: function get() {
        return index_js_9.uuidV4;
      }
    });
    var index_js_10 = /*@__PURE__*/requireWallet();
    Object.defineProperty(exports, "Mnemonic", {
      enumerable: true,
      get: function get() {
        return index_js_10.Mnemonic;
      }
    });
    Object.defineProperty(exports, "BaseWallet", {
      enumerable: true,
      get: function get() {
        return index_js_10.BaseWallet;
      }
    });
    Object.defineProperty(exports, "HDNodeWallet", {
      enumerable: true,
      get: function get() {
        return index_js_10.HDNodeWallet;
      }
    });
    Object.defineProperty(exports, "HDNodeVoidWallet", {
      enumerable: true,
      get: function get() {
        return index_js_10.HDNodeVoidWallet;
      }
    });
    Object.defineProperty(exports, "Wallet", {
      enumerable: true,
      get: function get() {
        return index_js_10.Wallet;
      }
    });
    Object.defineProperty(exports, "defaultPath", {
      enumerable: true,
      get: function get() {
        return index_js_10.defaultPath;
      }
    });
    Object.defineProperty(exports, "getAccountPath", {
      enumerable: true,
      get: function get() {
        return index_js_10.getAccountPath;
      }
    });
    Object.defineProperty(exports, "getIndexedAccountPath", {
      enumerable: true,
      get: function get() {
        return index_js_10.getIndexedAccountPath;
      }
    });
    Object.defineProperty(exports, "isCrowdsaleJson", {
      enumerable: true,
      get: function get() {
        return index_js_10.isCrowdsaleJson;
      }
    });
    Object.defineProperty(exports, "isKeystoreJson", {
      enumerable: true,
      get: function get() {
        return index_js_10.isKeystoreJson;
      }
    });
    Object.defineProperty(exports, "decryptCrowdsaleJson", {
      enumerable: true,
      get: function get() {
        return index_js_10.decryptCrowdsaleJson;
      }
    });
    Object.defineProperty(exports, "decryptKeystoreJsonSync", {
      enumerable: true,
      get: function get() {
        return index_js_10.decryptKeystoreJsonSync;
      }
    });
    Object.defineProperty(exports, "decryptKeystoreJson", {
      enumerable: true,
      get: function get() {
        return index_js_10.decryptKeystoreJson;
      }
    });
    Object.defineProperty(exports, "encryptKeystoreJson", {
      enumerable: true,
      get: function get() {
        return index_js_10.encryptKeystoreJson;
      }
    });
    Object.defineProperty(exports, "encryptKeystoreJsonSync", {
      enumerable: true,
      get: function get() {
        return index_js_10.encryptKeystoreJsonSync;
      }
    });
    var index_js_11 = /*@__PURE__*/requireWordlists();
    Object.defineProperty(exports, "Wordlist", {
      enumerable: true,
      get: function get() {
        return index_js_11.Wordlist;
      }
    });
    Object.defineProperty(exports, "LangEn", {
      enumerable: true,
      get: function get() {
        return index_js_11.LangEn;
      }
    });
    Object.defineProperty(exports, "WordlistOwl", {
      enumerable: true,
      get: function get() {
        return index_js_11.WordlistOwl;
      }
    });
    Object.defineProperty(exports, "WordlistOwlA", {
      enumerable: true,
      get: function get() {
        return index_js_11.WordlistOwlA;
      }
    });
    Object.defineProperty(exports, "wordlists", {
      enumerable: true,
      get: function get() {
        return index_js_11.wordlists;
      }
    });
    // dummy change; to pick-up ws security issue changes
  })(ethers);
  return ethers;
}

var ethersExports = /*@__PURE__*/ requireEthers();

var validate$1 = {};

var regex = {};

var hasRequiredRegex;
function requireRegex() {
  if (hasRequiredRegex) return regex;
  hasRequiredRegex = 1;
  Object.defineProperty(regex, "__esModule", {
    value: true
  });
  regex["default"] = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;
  return regex;
}

var hasRequiredValidate;
function requireValidate() {
  if (hasRequiredValidate) return validate$1;
  hasRequiredValidate = 1;
  Object.defineProperty(validate$1, "__esModule", {
    value: true
  });
  var regex_js_1 = requireRegex();
  function validate(uuid) {
    return typeof uuid === 'string' && regex_js_1["default"].test(uuid);
  }
  validate$1["default"] = validate;
  return validate$1;
}

var validateExports = requireValidate();
var validate = /*@__PURE__*/getDefaultExportFromCjs(validateExports);

var baseUrl = process.env.TOURNAMENT_API_URL;
function getDynamicEnv(key) {
  return process.env[key] || "";
}
var getClientCredentials = function getClientCredentials(gameName) {
  var clientId = getDynamicEnv("".concat(gameName, "_CLIENT_ID"));
  var clientSecret = getDynamicEnv("".concat(gameName, "_CLIENT_SECRET"));
  if (clientId === "" || clientSecret === "") {
    throw new Error("Client credentials invalid");
  }
  return {
    clientId: clientId,
    clientSecret: clientSecret
  };
};
var generateRequestParams = function generateRequestParams(gameName, params) {
  var _a = getClientCredentials(gameName),
    clientId = _a.clientId,
    clientSecret = _a.clientSecret;
  var nonce = new Date().getTime();
  params.nonce = nonce;
  params.clientId = clientId;
  var paramKeys = Object.keys(params);
  paramKeys.sort(function (firstEl, secondEl) {
    return firstEl.localeCompare(secondEl);
  });
  var tmpStr = "";
  paramKeys.forEach(function (paramKey) {
    if (Object.prototype.hasOwnProperty.call(params, paramKey)) {
      var value = _typeof(params[paramKey]) === "object" ? JSON.stringify(params[paramKey]) : params[paramKey];
      tmpStr += "".concat(paramKey, "=").concat(value);
    }
  });
  var hash = createHmac("sha512", clientSecret);
  hash.update(tmpStr);
  params.clientAccessToken = hash.digest("hex");
  return params;
};
function rpcStartTournament(ctx, logger, nk, payload) {
  try {
    var _a = JSON.parse(payload),
      gameName = _a.gameName,
      playerId = _a.playerId,
      tournamentId = _a.tournamentId,
      token = _a.token,
      walletAddress = _a.walletAddress,
      playerIp = _a.playerIp;
    if (!validate(playerId)) {
      throw new Error("Invalid player ID: " + playerId);
    }
    if (!validate(tournamentId)) {
      throw new Error("Invalid tournament ID: " + tournamentId);
    }
    if (!token) {
      throw new Error("Invalid token: " + token);
    }
    if (walletAddress && walletAddress !== "") {
      if (!ethersExports.isAddress(walletAddress)) {
        throw new Error("Invalid wallet address: " + walletAddress);
      }
    }
    walletAddress = walletAddress || "";
    playerIp = ctx.clientIp || "";
    var body = generateRequestParams(gameName, {
      playerId: playerId,
      tournamentId: tournamentId,
      token: token,
      walletAddress: walletAddress
    });
    var apiUrl = "".concat(baseUrl, "/tournament-round/").concat(tournamentId, "/start");
    var options = {
      headers: {
        "Content-Type": "application/json",
        "x-arcadia-player-ip": playerIp
      },
      body: JSON.stringify(body)
    };
    nk.httpRequest(apiUrl, "post", options.headers, options.body);
    return JSON.stringify({
      code: 200,
      message: "OK"
    });
  } catch (error) {
    throw new Error((error === null || error === void 0 ? void 0 : error.message) || "Something went wrong");
  }
}
function rpcEndTournament(ctx, logger, nk, payload) {
  try {
    var _a = JSON.parse(payload),
      gameName = _a.gameName,
      playerId = _a.playerId,
      tournamentId = _a.tournamentId,
      token = _a.token,
      score = _a.score,
      otherPlayerScores = _a.otherPlayerScores;
    if (!validate(playerId)) {
      throw new Error("Invalid player ID: " + playerId);
    }
    if (!validate(tournamentId)) {
      throw new Error("Invalid t tournament ID: " + tournamentId);
    }
    if (!token) {
      throw new Error("Invalid token: " + token);
    }
    if (typeof score !== "number" || score < 0) {
      throw new Error("Invalid score: " + score);
    }
    otherPlayerScores.forEach(function (scores) {
      if (typeof scores.score !== "number" || scores.score < 0) {
        throw new Error("Invalid score: " + scores.score);
      }
      if (!ethersExports.isAddress(scores.walletAddress)) {
        throw new Error("Invalid wallet address: " + scores.walletAddress);
      }
    });
    var data = {
      playerId: playerId,
      tournamentId: tournamentId,
      score: score,
      token: token
    };
    if (otherPlayerScores.length > 0) {
      data["otherPlayerScores"] = otherPlayerScores;
    }
    var body = generateRequestParams(gameName, data);
    var apiUrl = "".concat(baseUrl, "/tournament-round/").concat(tournamentId, "/end");
    var options = {
      method: 'post',
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify(body)
    };
    nk.httpRequest(apiUrl, "post", options.headers, options.body);
    return JSON.stringify({
      code: 200,
      message: "OK"
    });
  } catch (error) {
    throw new Error((error === null || error === void 0 ? void 0 : error.message) || "Something went wrong");
  }
}

function rpcReward(context, logger, nk, payload) {
  if (!context.userId) {
    throw Error('No user ID in context');
  }
  var objectId = {
    collection: 'reward',
    key: 'daily',
    userId: context.userId
  };
  var objects;
  try {
    objects = nk.storageRead([objectId]);
  } catch (error) {
    logger.error('storageRead error: %s', error);
    throw error;
  }
  var dailyReward = {
    lastClaimUnix: 0
  };
  objects.forEach(function (object) {
    if (object.key == 'daily') {
      dailyReward = object.value;
    }
  });
  var resp = {
    coinsReceived: 0
  };
  var d = new Date();
  d.setHours(0, 0, 0, 0);
  if (dailyReward.lastClaimUnix < msecToSec(d.getTime())) {
    resp.coinsReceived = 500;
    var changeset = {
      coins: resp.coinsReceived
    };
    try {
      nk.walletUpdate(context.userId, changeset, {}, false);
    } catch (error) {
      logger.error('walletUpdate error: %q', error);
      throw error;
    }
    var notification = {
      code: 1001,
      content: changeset,
      persistent: true,
      subject: "You've received your daily reward!",
      userId: context.userId
    };
    try {
      nk.notificationsSend([notification]);
    } catch (error) {
      logger.error('notificationsSend error: %q', error);
      throw error;
    }
    dailyReward.lastClaimUnix = msecToSec(Date.now());
    var write = {
      collection: 'reward',
      key: 'daily',
      permissionRead: 1,
      permissionWrite: 0,
      value: dailyReward,
      userId: context.userId
    };
    if (objects.length > 0) {
      write.version = objects[0].version;
    }
    try {
      nk.storageWrite([write]);
    } catch (error) {
      logger.error('storageWrite error: %q', error);
      throw error;
    }
  }
  var result = JSON.stringify(resp);
  logger.debug('rpcReward resp: %q', result);
  return result;
}
function msecToSec(n) {
  return Math.floor(n / 1000);
}

function rpcHealthcheck(ctx, logger, nk, payload) {
  logger.info("Healthcheck request received");
  return JSON.stringify({
    success: true
  });
}

var Mark;
(function (Mark) {
  Mark[Mark["UNDEFINED"] = 0] = "UNDEFINED";
  Mark[Mark["X"] = 1] = "X";
  Mark[Mark["O"] = 2] = "O";
})(Mark || (Mark = {}));
var OpCode;
(function (OpCode) {
  OpCode[OpCode["START"] = 1] = "START";
  OpCode[OpCode["UPDATE"] = 2] = "UPDATE";
  OpCode[OpCode["DONE"] = 3] = "DONE";
  OpCode[OpCode["MOVE"] = 4] = "MOVE";
  OpCode[OpCode["REJECTED"] = 5] = "REJECTED";
  OpCode[OpCode["OPPONENT_LEFT"] = 6] = "OPPONENT_LEFT";
  OpCode[OpCode["INVITE_AI"] = 7] = "INVITE_AI";
})(OpCode || (OpCode = {}));

var aiUserId = "ai-user-id";
var tfServingAddress = "http://tf:8501/v1/models/ttt:predict";
var aiPresence = {
  userId: aiUserId,
  sessionId: "",
  username: aiUserId,
  node: ""
};
function aiMessage(code, data) {
  return {
    sender: aiPresence,
    persistence: true,
    status: "",
    opCode: code,
    data: data,
    reliable: true,
    receiveTimeMs: Date.now()
  };
}
function aiTurn(state, logger, nk) {
  var aiCell = [1, 0];
  var playerCell = [0, 1];
  var undefCell = [0, 0];
  var b = [[undefCell, undefCell, undefCell], [undefCell, undefCell, undefCell], [undefCell, undefCell, undefCell]];
  state.board.forEach(function (mark, idx) {
    var rowIdx = Math.floor(idx / 3);
    var cellIdx = idx % 3;
    if (mark === state.marks[aiUserId]) b[rowIdx][cellIdx] = aiCell;else if (mark === null || mark === Mark.UNDEFINED) b[rowIdx][cellIdx] = undefCell;else b[rowIdx][cellIdx] = playerCell;
  });
  var headers = {
    'Accept': 'application/json'
  };
  var resp = nk.httpRequest(tfServingAddress, 'post', headers, JSON.stringify({
    instances: [b]
  }));
  var body = JSON.parse(resp.body);
  var predictions = [];
  try {
    predictions = body.predictions[0];
  } catch (error) {
    logger.error("received unexpected TF response: %v: %v", error, body);
    return;
  }
  var maxVal = -Infinity;
  var aiMovePos = -1;
  predictions.forEach(function (val, idx) {
    if (val > maxVal) {
      maxVal = val;
      aiMovePos = idx;
    }
  });
  if (aiMovePos > -1) {
    var move = nk.stringToBinary(JSON.stringify({
      position: aiMovePos
    }));
    state.aiMessage = aiMessage(OpCode.MOVE, move);
  }
}

var moduleName = "tic-tac-toe_js";
var tickRate = 5;
var maxEmptySec = 30;
var delaybetweenGamesSec = 5;
var turnTimeFastSec = 10;
var turnTimeNormalSec = 20;
var winningPositions = [[0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6], [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6]];
var matchInit = function matchInit(ctx, logger, nk, params) {
  var fast = !!params['fast'];
  var ai = !!params['ai'];
  var label = {
    open: 1,
    fast: 0
  };
  if (fast) {
    label.fast = 1;
  }
  var state = {
    label: label,
    emptyTicks: 0,
    presences: {},
    joinsInProgress: 0,
    playing: false,
    board: [],
    marks: {},
    mark: Mark.UNDEFINED,
    deadlineRemainingTicks: 0,
    winner: null,
    winnerPositions: null,
    nextGameRemainingTicks: 0,
    ai: ai,
    aiMessage: null
  };
  if (ai) {
    state.presences[aiUserId] = aiPresence;
  }
  return {
    state: state,
    tickRate: tickRate,
    label: JSON.stringify(label)
  };
};
var matchJoinAttempt = function matchJoinAttempt(ctx, logger, nk, dispatcher, tick, state, presence, metadata) {
  if (presence.userId in state.presences) {
    if (state.presences[presence.userId] === null) {
      state.joinsInProgress++;
      return {
        state: state,
        accept: false
      };
    } else {
      return {
        state: state,
        accept: false,
        rejectMessage: 'already joined'
      };
    }
  }
  if (connectedPlayers(state) + state.joinsInProgress >= 2) {
    return {
      state: state,
      accept: false,
      rejectMessage: 'match full'
    };
  }
  state.joinsInProgress++;
  return {
    state: state,
    accept: true
  };
};
var matchJoin = function matchJoin(ctx, logger, nk, dispatcher, tick, state, presences) {
  var t = msecToSec(Date.now());
  for (var _i = 0, presences_1 = presences; _i < presences_1.length; _i++) {
    var presence = presences_1[_i];
    state.emptyTicks = 0;
    state.presences[presence.userId] = presence;
    state.joinsInProgress--;
    if (state.playing) {
      var update = {
        board: state.board,
        mark: state.mark,
        deadline: t + Math.floor(state.deadlineRemainingTicks / tickRate)
      };
      dispatcher.broadcastMessage(OpCode.UPDATE, JSON.stringify(update));
    } else if (state.board.length !== 0 && Object.keys(state.marks).length !== 0 && state.marks[presence.userId]) {
      logger.debug('player %s rejoined game', presence.userId);
      var done = {
        board: state.board,
        winner: state.winner,
        winnerPositions: state.winnerPositions,
        nextGameStart: t + Math.floor(state.nextGameRemainingTicks / tickRate)
      };
      dispatcher.broadcastMessage(OpCode.DONE, JSON.stringify(done));
    }
  }
  if (Object.keys(state.presences).length >= 2 && state.label.open != 0) {
    state.label.open = 0;
    var labelJSON = JSON.stringify(state.label);
    dispatcher.matchLabelUpdate(labelJSON);
  }
  return {
    state: state
  };
};
var matchLeave = function matchLeave(ctx, logger, nk, dispatcher, tick, state, presences) {
  for (var _i = 0, presences_2 = presences; _i < presences_2.length; _i++) {
    var presence = presences_2[_i];
    logger.info("Player: %s left match: %s.", presence.userId, ctx.matchId);
    state.presences[presence.userId] = null;
  }
  var humanPlayersRemaining = [];
  Object.keys(state.presences).forEach(function (userId) {
    if (userId !== aiUserId && state.presences[userId] !== null) humanPlayersRemaining.push(state.presences[userId]);
  });
  if (humanPlayersRemaining.length === 1) {
    dispatcher.broadcastMessage(OpCode.OPPONENT_LEFT, null, humanPlayersRemaining, null, true);
  } else if (state.ai && humanPlayersRemaining.length === 0) {
    delete state.presences[aiUserId];
    state.ai = false;
  }
  return {
    state: state
  };
};
var matchLoop = function matchLoop(ctx, logger, nk, dispatcher, tick, state, messages) {
  var _a;
  if (connectedPlayers(state) + state.joinsInProgress === 0) {
    state.emptyTicks++;
    if (state.emptyTicks >= maxEmptySec * tickRate) {
      logger.info('closing idle match');
      return null;
    }
  }
  var t = msecToSec(Date.now());
  if (!state.playing) {
    for (var userID in state.presences) {
      if (state.presences[userID] === null) {
        delete state.presences[userID];
      }
    }
    if (Object.keys(state.presences).length < 2 && state.label.open != 1) {
      state.label.open = 1;
      var labelJSON = JSON.stringify(state.label);
      dispatcher.matchLabelUpdate(labelJSON);
    }
    if (Object.keys(state.presences).length < 2) {
      return {
        state: state
      };
    }
    if (state.nextGameRemainingTicks > 0) {
      state.nextGameRemainingTicks--;
      return {
        state: state
      };
    }
    state.playing = true;
    state.board = new Array(9);
    state.marks = {};
    var marks_1 = [Mark.X, Mark.O];
    Object.keys(state.presences).forEach(function (userId) {
      var _a;
      if (state.ai) {
        if (userId === aiUserId) {
          state.marks[userId] = Mark.O;
        } else {
          state.marks[userId] = Mark.X;
        }
      } else {
        state.marks[userId] = (_a = marks_1.shift()) !== null && _a !== void 0 ? _a : null;
      }
    });
    state.mark = Mark.X;
    state.winner = Mark.UNDEFINED;
    state.winnerPositions = null;
    state.deadlineRemainingTicks = calculateDeadlineTicks(state.label);
    state.nextGameRemainingTicks = 0;
    var msg = {
      board: state.board,
      marks: state.marks,
      mark: state.mark,
      deadline: t + Math.floor(state.deadlineRemainingTicks / tickRate)
    };
    dispatcher.broadcastMessage(OpCode.START, JSON.stringify(msg));
    return {
      state: state
    };
  }
  if (state.aiMessage !== null) {
    messages.push(state.aiMessage);
    state.aiMessage = null;
  }
  var _loop_1 = function _loop_1(message) {
    switch (message.opCode) {
      case OpCode.MOVE:
        logger.debug('Received move message from user: %v', state.marks);
        var mark = (_a = state.marks[message.sender.userId]) !== null && _a !== void 0 ? _a : null;
        var sender = message.sender.userId == aiUserId ? null : [message.sender];
        if (mark === null || state.mark != mark) {
          dispatcher.broadcastMessage(OpCode.REJECTED, null, sender);
          return "continue";
        }
        var msg = {};
        try {
          msg = JSON.parse(nk.binaryToString(message.data));
        } catch (error) {
          dispatcher.broadcastMessage(OpCode.REJECTED, null, sender);
          logger.debug('Bad data received: %v', error);
          return "continue";
        }
        if (state.board[msg.position]) {
          dispatcher.broadcastMessage(OpCode.REJECTED, null, sender);
          return "continue";
        }
        state.board[msg.position] = mark;
        state.mark = mark === Mark.O ? Mark.X : Mark.O;
        state.deadlineRemainingTicks = calculateDeadlineTicks(state.label);
        var _b = winCheck(state.board, mark),
          winner = _b[0],
          winningPos = _b[1];
        if (winner) {
          state.winner = mark;
          state.winnerPositions = winningPos;
          state.playing = false;
          state.deadlineRemainingTicks = 0;
          state.nextGameRemainingTicks = delaybetweenGamesSec * tickRate;
        }
        var tie = state.board.every(function (v) {
          return v !== null;
        });
        if (tie) {
          state.playing = false;
          state.deadlineRemainingTicks = 0;
          state.nextGameRemainingTicks = delaybetweenGamesSec * tickRate;
        }
        var opCode = void 0;
        var outgoingMsg = void 0;
        if (state.playing) {
          opCode = OpCode.UPDATE;
          var msg_1 = {
            board: state.board,
            mark: state.mark,
            deadline: t + Math.floor(state.deadlineRemainingTicks / tickRate)
          };
          outgoingMsg = msg_1;
        } else {
          opCode = OpCode.DONE;
          var msg_2 = {
            board: state.board,
            winner: state.winner,
            winnerPositions: state.winnerPositions,
            nextGameStart: t + Math.floor(state.nextGameRemainingTicks / tickRate)
          };
          outgoingMsg = msg_2;
          var walletUpdates = [];
          for (var userId in state.marks) {
            if (userId === 'ai-user-id') {
              continue;
            }
            if (state.marks[userId] === state.winner) {
              walletUpdates.push({
                userId: userId,
                changeset: {
                  wins: 1,
                  plays: 1
                },
                metadata: {
                  gameid: ctx.matchId
                }
              });
            } else {
              walletUpdates.push({
                userId: userId,
                changeset: {
                  plays: 1
                },
                metadata: {
                  gameid: ctx.matchId
                }
              });
            }
          }
          nk.walletsUpdate(walletUpdates, true);
        }
        dispatcher.broadcastMessage(opCode, JSON.stringify(outgoingMsg));
        break;
      case OpCode.INVITE_AI:
        if (state.ai) {
          logger.error('AI player is already playing');
          return "continue";
        }
        var activePlayers_1 = [];
        Object.keys(state.presences).forEach(function (userId) {
          var p = state.presences[userId];
          if (p === null) {
            delete state.presences[userId];
          } else {
            activePlayers_1.push(p);
          }
        });
        logger.debug('active users: %d', activePlayers_1.length);
        if (activePlayers_1.length != 1) {
          logger.error('one active player is required to enable AI mode');
          return "continue";
        }
        state.ai = true;
        state.presences[aiUserId] = aiPresence;
        if (state.marks[activePlayers_1[0].userId] == Mark.O) {
          state.marks[aiUserId] = Mark.X;
        } else {
          state.marks[aiUserId] = Mark.O;
        }
        logger.info('AI player joined match');
        break;
      default:
        dispatcher.broadcastMessage(OpCode.REJECTED, null, [message.sender]);
        logger.error('Unexpected opcode received: %d', message.opCode);
    }
  };
  for (var _i = 0, messages_1 = messages; _i < messages_1.length; _i++) {
    var message = messages_1[_i];
    _loop_1(message);
  }
  if (state.playing) {
    state.deadlineRemainingTicks--;
    if (state.deadlineRemainingTicks <= 0) {
      state.playing = false;
      state.winner = state.mark === Mark.O ? Mark.X : Mark.O;
      state.deadlineRemainingTicks = 0;
      state.nextGameRemainingTicks = delaybetweenGamesSec * tickRate;
      var msg = {
        board: state.board,
        winner: state.winner,
        nextGameStart: t + Math.floor(state.nextGameRemainingTicks / tickRate),
        winnerPositions: null
      };
      dispatcher.broadcastMessage(OpCode.DONE, JSON.stringify(msg));
    }
  }
  if (state.ai && state.mark === state.marks[aiUserId]) {
    aiTurn(state, logger, nk);
  }
  return {
    state: state
  };
};
var matchTerminate = function matchTerminate(ctx, logger, nk, dispatcher, tick, state, graceSeconds) {
  return {
    state: state
  };
};
var matchSignal = function matchSignal(ctx, logger, nk, dispatcher, tick, state) {
  return {
    state: state
  };
};
function calculateDeadlineTicks(l) {
  if (l.fast === 1) {
    return turnTimeFastSec * tickRate;
  } else {
    return turnTimeNormalSec * tickRate;
  }
}
function winCheck(board, mark) {
  for (var _i = 0, winningPositions_1 = winningPositions; _i < winningPositions_1.length; _i++) {
    var wp = winningPositions_1[_i];
    if (board[wp[0]] === mark && board[wp[1]] === mark && board[wp[2]] === mark) {
      return [true, wp];
    }
  }
  return [false, null];
}
function connectedPlayers(s) {
  var count = 0;
  for (var _i = 0, _a = Object.keys(s.presences); _i < _a.length; _i++) {
    var p = _a[_i];
    if (s.presences[p] !== null) {
      count++;
    }
  }
  return count;
}

var rpcFindMatch = function rpcFindMatch(ctx, logger, nk, payload) {
  if (!ctx.userId) {
    throw Error('No user ID in context');
  }
  if (!payload) {
    throw Error('Expects payload.');
  }
  var request = {};
  try {
    request = JSON.parse(payload);
  } catch (error) {
    logger.error('Error parsing json message: %q', error);
    throw error;
  }
  if (request.ai) {
    var matchId = nk.matchCreate(moduleName, {
      fast: request.fast,
      ai: true
    });
    var res_1 = {
      matchIds: [matchId]
    };
    return JSON.stringify(res_1);
  }
  var matches;
  try {
    var query = "+label.open:1 +label.fast:".concat(request.fast ? 1 : 0);
    matches = nk.matchList(10, true, null, null, 1, query);
  } catch (error) {
    logger.error('Error listing matches: %v', error);
    throw error;
  }
  var matchIds = [];
  if (matches.length > 0) {
    matchIds = matches.map(function (m) {
      return m.matchId;
    });
  } else {
    try {
      matchIds.push(nk.matchCreate(moduleName, {
        fast: request.fast
      }));
    } catch (error) {
      logger.error('Error creating match: %v', error);
      throw error;
    }
  }
  var res = {
    matchIds: matchIds
  };
  return JSON.stringify(res);
};

var rpcIdRewards = 'rewards_js';
var rpcIdFindMatch = 'find_match_js';
var rpcIdAwardCoins = 'awardCoins';
var LEADERBOARD_ID = "radar";
var startTournament = "startTournament";
var endTournament = "endTournament";
function createLeaderboard(nk, id) {
  var authoritative = false;
  var sort = "descending";
  var operator = "best";
  var reset = '*/1 * * * *';
  var metadata = {
    weatherConditions: 'rain'
  };
  try {
    nk.leaderboardCreate(id, authoritative, sort, operator, reset, metadata);
  } catch (error) {}
}
var leaderboardReset = function leaderboardReset(ctx, logger, nk, leaderboard, reset) {
  if (leaderboard.id != LEADERBOARD_ID) {
    return;
  }
  var result = nk.leaderboardRecordsList(leaderboard.id, [], 3, undefined, reset);
  var walletUpdates = [];
  if (result && result.records) {
    result.records.forEach(function (r) {
      var reward = 100;
      walletUpdates.push({
        userId: r.ownerId,
        changeset: {
          coins: reward
        },
        metadata: {}
      });
    });
  }
  nk.walletsUpdate(walletUpdates, true);
};
function rpcCreateTournament(ctx, logger, nk, id) {
  createLeaderboard(nk, id);
  logger.info("leaderboard " + id + " created");
  return JSON.stringify({
    success: true
  });
}
function sendTokens(receivingWallet, tokensClaimed, nk, logger) {
  var data = {
    "walletAddresses": [receivingWallet],
    "amounts": [tokensClaimed]
  };
  var apiUrl = 'http://demo.cosmiclabs.org:3000/api/tokens/distribute';
  var apiKey = "f3d37ce6-3766-4027-a388-1090f512f601";
  var options = {
    method: 'post',
    headers: {
      'Content-Type': 'application/json',
      'api-key': apiKey
    },
    body: JSON.stringify(data)
  };
  var response = nk.httpRequest(apiUrl, "post", options.headers, options.body);
  if (response.code > 299) {
    logger.error('Error distributing tokens: ' + response.body);
    return null;
  } else {
    logger.info('Tokens distributed successfully: ' + response.body);
    var body = JSON.parse(response.body);
    var transactionUrl = body.transactionUrl;
    return transactionUrl;
  }
}
function rpcAwardCoins(ctx, logger, nk, data) {
  if (ctx.userId) {
    var account = nk.accountGetId(ctx.userId);
    var wallet = account.wallet;
    if (wallet.wins || wallet.plays) {
      var wins = Number(wallet.wins);
      var plays = Number(wallet.plays);
      var tokensClaimed = wins * 0.1 + plays * 0.02;
      var receivingWallet = JSON.parse(data).data;
      var url = sendTokens(receivingWallet, tokensClaimed, nk, logger);
      return JSON.stringify({
        success: true,
        tokensClaimed: tokensClaimed,
        url: url
      });
    }
  }
  return JSON.stringify({
    success: false
  });
}
function InitModule(ctx, logger, nk, initializer) {
  initializer.registerRpc(rpcIdRewards, rpcReward);
  initializer.registerRpc(rpcIdFindMatch, rpcFindMatch);
  initializer.registerMatch(moduleName, {
    matchInit: matchInit,
    matchJoinAttempt: matchJoinAttempt,
    matchJoin: matchJoin,
    matchLeave: matchLeave,
    matchLoop: matchLoop,
    matchTerminate: matchTerminate,
    matchSignal: matchSignal
  });
  createLeaderboard(nk, LEADERBOARD_ID);
  initializer.registerRpc("healthcheck", rpcHealthcheck);
  initializer.registerRpc("createTournament", rpcCreateTournament);
  initializer.registerLeaderboardReset(leaderboardReset);
  initializer.registerRpc(rpcIdAwardCoins, rpcAwardCoins);
  initializer.registerRpc(startTournament, rpcStartTournament);
  initializer.registerRpc(endTournament, rpcEndTournament);
  logger.info('JavaScript logic loaded.');
}
!InitModule && InitModule.bind(null);
